<html><head><meta charset="utf-8"/><title>无穷小演算</title><link href="styles.css" rel="stylesheet"/></head><body><h1>无穷小演算</h1><p>无穷小演算是微分和积分演算的另一个名字, 不过说到底, 我是怎么也学不会微积分.</p><h2>第一章 求上界, 求下界</h2><h2>第二章 方程的根的逼近</h2><h3>1. 问题的地位</h3><h3>2. 试位法</h3><p>本节假定函数<math><mi>f</mi></math>在某个区间<math><mrow><mo stretchy="false">[</mo><mrow><mi>a</mi><mo>,</mo><mi>b</mi></mrow><mo stretchy="false">]</mo></mrow></math>上定义, 具有连续的二阶导数, <math><msup><mi>f</mi><mo>&prime;</mo></msup></math>在该区间上恒不为零 (由于连续性, 其符号不变), 并且<math><mrow><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&it;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&lt;</mo><mn>0</mn></mrow></math>. 设<math><msub><mi>&xi;</mi><mn>0</mn></msub></math>是<math><mi>f</mi></math>在区间上唯一的那个根, 而<math><mi>&xi;</mi></math>是将函数的两端连起来的直线 (也就是一次插值) 与横轴的交点. 若将<math><mi>&xi;</mi></math>当作<math><msub><mi>&xi;</mi><mn>0</mn></msub></math>的近似值, 那么我们的问题是考虑误差<math><mrow><mo stretchy="false">|</mo><mrow><mi>&xi;</mi><mo>&minus;</mo><msub><mi>&xi;</mi><mn>0</mn></msub></mrow><mo stretchy="false">|</mo></mrow></math>的上界.</p><div class="lemma"><b>引理.</b> 设<math><mi>J</mi></math>是<math><mi>&Ropf;</mi></math>的一个区间, <math><mi>f</mi></math>是<math><mi>J</mi></math>上两次连续可导 [注记: 其实两次连续可导的意思就是连续可导且导函数连续可导] 的函数, <math><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></math>是<math><mi>J</mi></math>上不同的两点, <math><mi>L</mi></math>是在点<math><msub><mi>x</mi><mn>0</mn></msub></math>和<math><msub><mi>x</mi><mn>1</mn></msub></math>处取与<math><mi>f</mi></math>相同的值的一次多项式:<math display="block"><mrow><mrow><mi>L</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mfrac><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>z</mi><mo>&minus;</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&minus;</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>z</mi><mo>&minus;</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>&minus;</mo><msub><mi>x</mi><mn>0</mn></msub></mrow></mfrac></mrow><mtext>;</mtext></math>那么在含有<math><mrow><mi>x</mi><mo>,</mo><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></math>的最小区间上, 存在(与<math><mi>x</mi></math>有关的)一个点<math><mi>&zeta;</mi></math>满足<math display="block"><mrow><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&minus;</mo><mrow><mi>L</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>&it;</mo><mrow><msup><mi>f</mi><mo>&Prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&zeta;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>.</mtext></math></div><div class="proof"><b>证明.</b> 显然仅考虑<math><mrow><mi>x</mi><mo>&ne;</mo><msub><mi>x</mi><mn>0</mn></msub></mrow></math>且<math><mrow><mi>x</mi><mo>&ne;</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></math>的情况即可, 设<math><mi>J</mi></math>上函数<math display="block"><mrow><mrow><mi>u</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&minus;</mo><mrow><mi>L</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&minus;</mo><mrow><mi>c</mi><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>z</mi><mo>&minus;</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>z</mi><mo>&minus;</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>其中常数<math><mi>c</mi></math>由<math><mrow><mrow><mi>u</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mn>0</mn></mrow></math>确定, 根据假设这是可能的. [注记: 这句话看上去有些奇怪, 但实际上就是令<math display="block"><mrow><mi>c</mi><mo>=</mo><mfrac><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&minus;</mo><mrow><mi>L</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mfrac></mrow></math>于是<math><mrow><mrow><mi>u</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mn>0</mn></mrow></math>, 并不存在循环.] 因此, 我们有<math><mrow><mrow><mi>u</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>u</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>u</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mn>0</mn></mrow></math>. 由Rolle定理, 在包含<math><mrow><mi>x</mi><mo>,</mo><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></math>的最小区间上, 存在不同的两点<math><mrow><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub></mrow></math>使得<math><mrow><mrow><msup><mi>u</mi><mo>&prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msup><mi>u</mi><mo>&prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mn>0</mn></mrow></math>. 对于<math><msup><mi>u</mi><mo>&prime;</mo></msup></math>再次应用Rolle定理, 在以<math><mrow><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub></mrow></math>为端点的区间上存在<math><mi>&zeta;</mi></math>满足<math><mrow><mrow><msup><mi>u</mi><mo>&Prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&zeta;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mn>0</mn></mrow></math>. 可是<math><mrow><mrow><msup><mi>u</mi><mo>&Prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><msup><mi>f</mi><mo>&Prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&minus;</mo><mrow><mn>2</mn><mo>&it;</mo><mi>c</mi></mrow></mrow></mrow></math>, 从而<math><mrow><mi>c</mi><mo>=</mo><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>&it;</mo><mrow><msup><mi>f</mi><mo>&Prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&zeta;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>, 即<math display="block"><mrow><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&minus;</mo><mrow><mi>L</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>&it;</mo><mrow><msup><mi>f</mi><mo>&Prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&zeta;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>.</mtext></math><div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><div class="corollary"><b>推论.</b> 如果<math><msup><mi>f</mi><mo>&prime;</mo></msup></math>在<math><mi>J</mi></math>上恒不为零, 且<math><mrow><mrow><mi>&xi;</mi><mo>,</mo><msub><mi>&xi;</mi><mn>0</mn></msub></mrow><mo>&in;</mo><mi>J</mi></mrow></math>满足<math><mrow><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>&xi;</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mn>0</mn></mrow><mo>,</mo><mrow><mrow><mi>L</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&xi;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mn>0</mn></mrow></mrow></math>, 那么存在<math><mrow><mrow><mi>&zeta;</mi><mo>,</mo><msup><mi>&zeta;</mi><mo>&prime;</mo></msup></mrow><mo>&in;</mo><mi>J</mi></mrow></math>满足<math display="block"><mrow><mrow><mi>&xi;</mi><mo>&minus;</mo><msub><mi>&xi;</mi><mn>0</mn></msub></mrow><mo>=</mo><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>&it;</mo><mfrac><mrow><msup><mi>f</mi><mo>&Prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&zeta;</mi><mo stretchy="false">)</mo></mrow></mrow><mrow><msup><mi>f</mi><mo>&prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msup><mi>&zeta;</mi><mo>&prime;</mo></msup><mo stretchy="false">)</mo></mrow></mrow></mfrac><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&xi;</mi><mo>&minus;</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&xi;</mi><mo>&minus;</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>.</mtext></math>如果对于<math><mrow><mi>x</mi><mo>&in;</mo><mi>J</mi></mrow></math>有<math><mrow><mrow><mrow><mo stretchy="false">|</mo><mrow><msup><mi>f</mi><mo>&prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">|</mo></mrow><mo>&ge;</mo><mi>m</mi></mrow><mo>></mo><mn>0</mn></mrow></math>且<math><mrow><mrow><msup><mi>f</mi><mo>&Prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&le;</mo><mi>M</mi></mrow></math>, 那么<math display="block"><mrow><mrow><mo stretchy="false">|</mo><mrow><mi>&xi;</mi><mo>&minus;</mo><msub><mi>&xi;</mi><mn>0</mn></msub></mrow><mo stretchy="false">|</mo></mrow><mo>&le;</mo><mrow><mfrac><mi>M</mi><mrow><mn>2</mn><mo>&it;</mo><mi>m</mi></mrow></mfrac><mo>&it;</mo><mrow><mo stretchy="false">|</mo><mrow><mi>&xi;</mi><mo>&minus;</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo stretchy="false">|</mo></mrow><mo>&it;</mo><mrow><mo stretchy="false">|</mo><mrow><mi>&xi;</mi><mo>&minus;</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><mo stretchy="false">|</mo></mrow></mrow></mrow><mtext>.</mtext></math></div><div class="proof"><b>证明.</b> 根据引理, 我们有<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&xi;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>&it;</mo><mrow><msup><mi>f</mi><mo>&Prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&zeta;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&xi;</mi><mo>&minus;</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&xi;</mi><mo>&minus;</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>另一方面, 根据有限增量公式, 存在以<math><msub><mi>&xi;</mi><mn>0</mn></msub></math>和<math><mi>&xi;</mi></math>为端点的区间上的一个点<math><msup><mi>&zeta;</mi><mo>&prime;</mo></msup></math>满足<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&xi;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>&xi;</mi><mo>&minus;</mo><msub><mi>&xi;</mi><mn>0</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mrow><msup><mi>f</mi><mo>&prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msup><mi>&zeta;</mi><mo>&prime;</mo></msup><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mtext>.</mtext></math>[注记: <math><mrow><mi>&xi;</mi><mo>=</mo><msub><mi>&xi;</mi><mn>0</mn></msub></mrow></math>的退化情况下任取即可.] 由此即得推论.<div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><div class="remark"><b>评注.</b> 若此式给出的误差还不足够小, 那么可以重复进行此步骤. 计算<math><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&xi;</mi><mo stretchy="false">)</mo></mrow></mrow></math>的符号, 由此判断根<math><msub><mi>&xi;</mi><mn>0</mn></msub></math>是在区间<math><mrow><mo stretchy="false">[</mo><mrow><mi>a</mi><mo>,</mo><mi>&xi;</mi></mrow><mo stretchy="false">]</mo></mrow></math>还是<math><mrow><mo stretchy="false">[</mo><mrow><mi>&xi;</mi><mo>,</mo><mi>b</mi></mrow><mo stretchy="false">]</mo></mrow></math>中, 然后可以得到第二近似值<math><msup><mi>&xi;</mi><mo>&prime;</mo></msup></math>. 理论上, 这种方法可以应用无限次, 也可证明得到的数列收敛于<math><msub><mi>&xi;</mi><mn>0</mn></msub></math>.</div><p>注记: 看起来好像根据推论, 不选择根所在的区间也可以缩小误差, 但是问题在于此时我们没法控制一次插值多项式的根仍然还在区间上, 所以不行. 另外, 本节要求二阶导数连续是为了保证<math><mrow><mo stretchy="false">|</mo><mrow><msup><mi>f</mi><mo>&Prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">|</mo></mrow></math>在闭区间上有最大值, 可以控制误差.</p><div class="exercise"><b>练习9.</b> 设在<math><mi>&Ropf;</mi></math>中的区间<math><mrow><mi>J</mi><mo>=</mo><mrow><mo stretchy="false">[</mo><mrow><mi>a</mi><mo>,</mo><mi>b</mi></mrow><mo stretchy="false">]</mo></mrow></mrow></math>上, 二次连续可导函数<math><mi>f</mi></math>满足<math><mrow><mrow><mrow><mo stretchy="false">|</mo><mrow><msup><mi>f</mi><mo>&prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">|</mo></mrow><mo>&ge;</mo><mi>m</mi></mrow><mo>></mo><mn>0</mn></mrow></math>且<math><mrow><mrow><msup><mi>f</mi><mo>&Prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&le;</mo><mi>M</mi></mrow></math>, 且<math><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow></math>和<math><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mrow></math>异号, 证明若<math><mrow><mrow><mrow><mfrac><mi>M</mi><mrow><mn>4</mn><mo>&it;</mo><mi>m</mi></mrow></mfrac><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>b</mi><mo>&minus;</mo><mi>a</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>q</mi></mrow><mo>&lt;</mo><mn>1</mn></mrow></math>, 便可逐步应用试位法<math><mi>n</mi></math>次, 在区间<math><mrow><mo stretchy="false">[</mo><mrow><mi>a</mi><mo>,</mo><mi>b</mi></mrow><mo stretchy="false">]</mo></mrow></math>上找到端点是<math><mrow><msub><mi>a</mi><mi>n</mi></msub><mo>,</mo><msub><mi>b</mi><mi>n</mi></msub></mrow></math>的一个区间, 其包含<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mn>0</mn></mrow></math>的唯一一根, 并且<math display="block"><mrow><mrow><mo stretchy="false">|</mo><mrow><msub><mi>b</mi><mi>n</mi></msub><mo>&minus;</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><mo stretchy="false">|</mo></mrow><mo>&le;</mo><mrow><mfrac><mrow><mn>4</mn><mo>&it;</mo><mi>m</mi></mrow><mi>M</mi></mfrac><mo>&it;</mo><msup><mi>q</mi><msup><mn>2</mn><mi>n</mi></msup></msup></mrow></mrow><mtext>.</mtext></math></div><div class="proof"><b>证明.</b> 实在是不知道怎么做. <math><mrow><mrow><mo stretchy="false">|</mo><mrow><msub><mi>b</mi><mn>0</mn></msub><mo>&minus;</mo><msub><mi>a</mi><mn>0</mn></msub></mrow><mo stretchy="false">|</mo></mrow><mo>=</mo><mrow><mo stretchy="false">|</mo><mrow><mi>b</mi><mo>&minus;</mo><mi>a</mi></mrow><mo stretchy="false">|</mo></mrow></mrow></math>. 设<math><mrow><msub><mi>t</mi><mi>n</mi></msub><mo>=</mo><mrow><mo stretchy="false">|</mo><mrow><msub><mi>b</mi><mi>n</mi></msub><mo>&minus;</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><mo stretchy="false">|</mo></mrow></mrow></math>. 根据答案, 如果能够控制<math display="block"><mrow><msub><mi>t</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&le;</mo><mrow><mn>2</mn><mo>&it;</mo><mrow><mo stretchy="false">|</mo><mrow><msub><mi>&xi;</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>&xi;</mi><mn>0</mn></msub></mrow><mo stretchy="false">|</mo></mrow></mrow><mo>&le;</mo><mrow><mfrac><mi>M</mi><mi>m</mi></mfrac><mo>&it;</mo><mrow><mo stretchy="false">|</mo><mrow><msub><mi>&xi;</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><mo stretchy="false">|</mo></mrow><mo>&it;</mo><mrow><mo stretchy="false">|</mo><mrow><msub><mi>&xi;</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><mo stretchy="false">|</mo></mrow></mrow></mrow></math>其中<math><msub><mi>&xi;</mi><mn>0</mn></msub></math>表示根的精确值, 而<math><msub><mi>&xi;</mi><mi>n</mi></msub></math>在<math><mrow><mi>n</mi><mo>&ge;</mo><mn>1</mn></mrow></math>时表示试位法的第<math><mi>n</mi></math>个猜测值, 那么<math display="block"><mrow><msub><mi>t</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&le;</mo><mrow><mfrac><mi>M</mi><mi>m</mi></mfrac><mo>&it;</mo><mrow><mo stretchy="false">|</mo><mrow><msub><mi>&xi;</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><mo stretchy="false">|</mo></mrow><mo>&it;</mo><mrow><mo stretchy="false">|</mo><mrow><msub><mi>&xi;</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><mo stretchy="false">|</mo></mrow></mrow><mo>&le;</mo><mrow><mrow><mfrac><mi>M</mi><mi>m</mi></mfrac><mo>&it;</mo><msup><mrow><mo>(</mo><mfrac><mrow><mo stretchy="false">|</mo><mrow><msub><mi>b</mi><mi>n</mi></msub><mo>&minus;</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><mo stretchy="false">|</mo></mrow><mn>2</mn></mfrac><mo>)</mo></mrow><mn>2</mn></msup></mrow><mo>=</mo><mrow><mfrac><mi>M</mi><mrow><mn>4</mn><mo>&it;</mo><mi>m</mi></mrow></mfrac><mo>&it;</mo><msubsup><mi>t</mi><mi>n</mi><mn>2</mn></msubsup></mrow></mrow></mrow></math>这实际上就可以和要证明的结论合上了. 设<math><mrow><msub><mi>s</mi><mn>0</mn></msub><mo>=</mo><msub><mi>t</mi><mn>0</mn></msub></mrow></math>, 而<math><mrow><msub><mi>s</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><mfrac><mi>M</mi><mrow><mn>4</mn><mo>&it;</mo><mi>m</mi></mrow></mfrac><mo>&it;</mo><msubsup><mi>s</mi><mi>n</mi><mn>2</mn></msubsup></mrow></mrow></math>, 那么<math><mrow><msub><mi>t</mi><mi>n</mi></msub><mo>&le;</mo><msub><mi>s</mi><mi>n</mi></msub></mrow></math>. 现在考虑求<math><msub><mi>s</mi><mi>n</mi></msub></math>的通项, 这是很简单的. 设<math display="block"><mrow><msub><mi>r</mi><mi>n</mi></msub><mo>=</mo><mroot><msub><mi>s</mi><mi>n</mi></msub><msup><mn>2</mn><mi>n</mi></msup></mroot></mrow></math>[注记: 这破浏览器MathML渲染根式怎么都有问题.] 那么<math display="block"><mrow><msubsup><mi>r</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></msubsup><mo>=</mo><mrow><mfrac><mi>M</mi><mrow><mn>4</mn><mo>&it;</mo><mi>m</mi></mrow></mfrac><mo>&it;</mo><msup><mrow><mo>(</mo><msubsup><mi>r</mi><mi>n</mi><msup><mn>2</mn><mi>n</mi></msup></msubsup><mo>)</mo></mrow><mn>2</mn></msup></mrow><mo>=</mo><mrow><mfrac><mi>M</mi><mrow><mn>4</mn><mo>&it;</mo><mi>m</mi></mrow></mfrac><mo>&it;</mo><msubsup><mi>r</mi><mi>n</mi><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></msubsup></mrow></mrow></math>于是<math display="block"><mrow><mfrac><msub><mi>r</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>r</mi><mi>n</mi></msub></mfrac><mo>=</mo><mroot><mfrac><mi>M</mi><mrow><mn>4</mn><mo>&it;</mo><mi>m</mi></mrow></mfrac><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mroot></mrow></math>对于<math><mrow><mi>n</mi><mo>&ge;</mo><mn>1</mn></mrow></math>, 我们有<math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><msub><mi>r</mi><mi>n</mi></msub></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mfrac><msub><mi>r</mi><mi>n</mi></msub><msub><mi>r</mi><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mfrac><mo>&it;</mo><mo>&ctdot;</mo><mo>&it;</mo><mfrac><msub><mi>r</mi><mn>1</mn></msub><msub><mi>r</mi><mn>0</mn></msub></mfrac><mo>&it;</mo><msub><mi>r</mi><mn>0</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>b</mi><mo>&minus;</mo><mi>a</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mrow><munderover><mo>&prod;</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msup><mrow><mo>(</mo><mfrac><mi>M</mi><mrow><mn>4</mn><mo>&it;</mo><mi>m</mi></mrow></mfrac><mo>)</mo></mrow><mfrac><mn>1</mn><msup><mn>2</mn><mi>k</mi></msup></mfrac></msup></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>b</mi><mo>&minus;</mo><mi>a</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><msup><mrow><mo>(</mo><mfrac><mi>M</mi><mrow><mn>4</mn><mo>&it;</mo><mi>m</mi></mrow></mfrac><mo>)</mo></mrow><mrow><mn>1</mn><mo>&minus;</mo><mfrac><mn>1</mn><msup><mn>2</mn><mi>n</mi></msup></mfrac></mrow></msup></mrow></mtd></mtr></mtable></math>我们发现<math><msub><mi>r</mi><mn>0</mn></msub></math>也满足此公式. 那么, 我们有<math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><msub><mi>s</mi><mi>n</mi></msub></mtd><mtd><mo>=</mo></mtd><mtd><msubsup><mi>r</mi><mi>n</mi><msup><mn>2</mn><mi>n</mi></msup></msubsup></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><msup><mrow><mo stretchy="false">(</mo><mrow><mi>b</mi><mo>&minus;</mo><mi>a</mi></mrow><mo stretchy="false">)</mo></mrow><msup><mn>2</mn><mi>n</mi></msup></msup><mo>&it;</mo><msup><mrow><mo>(</mo><mfrac><mi>M</mi><mrow><mn>4</mn><mo>&it;</mo><mi>m</mi></mrow></mfrac><mo>)</mo></mrow><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mfrac><mrow><mn>4</mn><mo>&it;</mo><mi>m</mi></mrow><mi>M</mi></mfrac><mo>&it;</mo><msup><mrow><mo>[</mo><mrow><mfrac><mi>M</mi><mrow><mn>4</mn><mo>&it;</mo><mi>m</mi></mrow></mfrac><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>b</mi><mo>&minus;</mo><mi>a</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>]</mo></mrow><msup><mn>2</mn><mi>n</mi></msup></msup></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mfrac><mrow><mn>4</mn><mo>&it;</mo><mi>m</mi></mrow><mi>M</mi></mfrac><mo>&it;</mo><msup><mi>q</mi><msup><mn>2</mn><mi>n</mi></msup></msup></mrow></mtd></mtr></mtable></math><div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><h3>3. 用迭代法解<math><mrow><mi>x</mi><mo>=</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math></h3><p>前一节我们有关步骤的出发点是有限增量公式, 即如果<math><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&xi;</mi><mo stretchy="false">)</mo></mrow></mrow></math>是小的, 而<math><msup><mi>f</mi><mo>&prime;</mo></msup></math>却不太小, 那么误差<math><mrow><mo stretchy="false">|</mo><mrow><mi>&xi;</mi><mo>&minus;</mo><msub><mi>&xi;</mi><mn>0</mn></msub></mrow><mo stretchy="false">|</mo></mrow></math>就是小的. 在下面, 我们要明确这种模糊的想法. 首先是迭代法.</p><p>令<math><mrow><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>x</mi><mo>&minus;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>, 那么方程<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mn>0</mn></mrow></math>就等价于方程<math display="block"><mrow><mi>x</mi><mo>=</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>.</mtext></math>换言之, 就是寻找<math><mi>g</mi></math>的不动点. 我们有以下结果:</p></body></html>