<html><head><meta charset="utf-8"/><title>理解Maxima</title><link href="styles.css" rel="stylesheet"/></head><body><h1>理解Maxima</h1><p>阅读Maxima的源代码时记下的一些笔记, 仅此而已.</p><h2>utils.lisp</h2><p><code>while</code>宏的功能恰如其名.</p><pre><code>(defmacro while (cond &amp;rest body)
  `(do ()
       ((not ,cond))
     ,@body))</code></pre><p><code>maxima-getenv</code>是平台无关的获取环境变量的值的函数.</p><pre><code>(defun maxima-getenv (envvar)
  #+gcl     (si::getenv envvar)
  #+ecl     (si::getenv envvar)
  #+allegro (system:getenv envvar)
  #+(or cmu scl) (cdr (assoc envvar ext:*environment-list* :test #'string=))
  #+sbcl    (sb-ext:posix-getenv envvar)
  #+clisp   (ext:getenv envvar)
  #+(or openmcl mcl)     (ccl::getenv envvar)
  #+lispworks (hcl:getenv envvar)
  #+abcl (ext:getenv envvar)
  )</code></pre><p><code>bye</code>是平台无关的退出过程.</p><pre><code>(defun bye (&amp;optional (exit-code 0))
  (declare (ignorable exit-code))
  #+scl       (ext:quit)
  #+clisp              (ext:quit exit-code)
  #+sbcl               (sb-ext:quit :unix-status exit-code)
  #+allegro            (excl:exit exit-code :quiet t)
  #+(or mcl openmcl)   (ccl:quit exit-code)
  #+gcl                (system::quit exit-code)
  #+ecl                (si:quit exit-code)
  #+lispworks          (lispworks:quit)
  #+abcl               (cl-user::quit)
  #+gcl                (lisp::bye)
  #+cmucl
  (handler-case (ext:quit nil exit-code)
    ;; Only the most recent versions of cmucl support an exit code.
    ;; If it doesn't, we get a program error (wrong number of args),
    ;; so catch that and just call quit without the arg.
    (program-error ()
      (ext:quit)))
  )</code></pre><p><code>map2c</code>的参数<code>f</code>应该是一个接受两个参数的函数, 而<code>l</code>应该是一个长度为偶数的列表. 其与<code>mapcar</code>有类似的地方, 但是一次连续从列表中吃下两个元素, 并且最终积累结果的列表顺序是颠倒的. 对于性质列表上的迭代有用.</p><pre><code>(defun map2c (f l)
  (do ((llt l (cddr llt)) (lans))
      ((null llt) lans)
    (push (funcall f (car llt) (cadr llt)) lans)))</code></pre><pre><code>> (map2c #'+ '(1 2 3 4 5 6))
(11 7 3)</code></pre><p><code>andmapcar</code>类似于<code>mapcar</code>, 但是若从左到右依次应用<code>f</code>途中返回<code>nil</code>, 则整个函数立即返回<code>nil</code>. (对于我这个Schemer而言, 大概需要注意不要将其与许多Scheme实现提供的<code>andmap</code>混淆.)</p><pre><code>(defun andmapcar (f l &amp;aux d answer)
  (do ((l l (cdr l)))
      ((null l) (nreverse answer))
    (setq d (funcall f (car l)))
    (if d (push d answer) (return nil))))</code></pre><p><code>xor</code>即不可兼或.</p><pre><code>(defun xor (a b)
  (or (and (not a) b) (and (not b) a)))</code></pre><p><code>among</code>在功能上类似于<code>memq</code>, 但是其在整个列表结构中寻找对象, 而不是一个扁平的列表中. (注意, <code>memq</code>不是Common Lisp标准中的过程, 但是Scheme标准和Emacs Lisp包含这个过程, 也有Common Lisp实现包含这个过程.)</p><pre><code>(defun among (x l)
  (cond ((null l) nil)
        ((atom l) (eq x l))
        (t (or (among x (car l)) (among x (cdr l))))))</code></pre><p><code>amongl</code>类似于<code>among</code>, 但是此时<code>x</code>是一列需要寻找的对象, 找到其中一个即可.</p><pre><code>(defun amongl (x l) 
  (cond ((null l) nil)
        ((atom l) (member l x :test #'eq))
        (t (or (amongl x (car l)) (amongl x (cdr l))))))</code></pre><p><code>subtree-p</code>判断一个树是否是另一个的子树. 默认情况下使用<code>eql</code>作为相等谓词, 但用户也可提供自己的谓词.</p><pre><code>(defun subtree-p (branch tree &amp;key (test #'eql))
  (or (funcall test branch tree)
      (and (not (atom tree))
           (member branch tree
                   :test (lambda (x y) (subtree-p x y :test test))))))</code></pre><p><code>dot2l</code>将关联列表转换为性质列表.</p><pre><code>(defun dot2l (l)
  (cond ((null l) nil)
        (t (list* (caar l) (cdar l) (dot2l (cdr l))))))</code></pre><pre><code>> (dot2l '((a . b) (c . d)))
(A B C D)</code></pre><p><code>cput</code>类似于<code>putprop</code>, 但是读者需要注意一下, Maxima的<code>putprop</code>里的参数顺序和一般情况不太一样. 另外就是<code>putprop</code>并不在Common Lisp标准之中, 但是有的Common Lisp实现会提供. 如果不提供的话, 可以使用<code>setf</code>和<code>get</code>达成同样的目的. 其他Lisp方言及其实现有的也提供<code>putprop</code>或者类似的函数. <code>cput</code>和<code>putprop</code>的区别在于, 若<code>val</code>为<code>nil</code>, 则从与符号相关联的性质列表中删去这个性质, 可能这会使其看上去更紧凑. 至于若<code>val</code>为<code>nil</code>时返回<code>nil</code>, 是因为这可以让人区别两种不同的情况 (当然, 这也是为了与<code>putprop</code>保持一致), 而<code>zl-remprop</code>是根据性质的有无返回<code>t</code>或者<code>nil</code>.</p><pre><code>(defun cput (bas val sel)
  (cond ((null val)
         (zl-remprop bas sel)
         nil)
        (t
         (putprop bas val sel))))</code></pre><h2>sloop.lisp</h2><p>William Schelter (Maxima最终能够成功开源离不开他的努力) 编写的迭代设施, 但现已被Common Lisp提供的<code>loop</code>宏取代.</p><pre><code>(defmacro sloop (&amp;rest body)
  (warn (intl:gettext &quot;Using deprecated macro 'sloop'. Use 'loop' instead.&quot;))
  `(loop ,@body))</code></pre><h2>mutils.lisp</h2><p><code>$assoc</code>类似于<code>assoc</code>, </p><pre><code>(defmfun $assoc (key ielist &amp;optional default)
  (let ((elist (if (listp ielist)
                   (margs ielist)
                   (merror 
                     (intl:gettext
                       &quot;assoc: second argument must be a nonatomic expression; found: ~:M&quot;) 
                     ielist))))
    (if (every #'(lambda (x) (and (listp x) (= 3 (length x)))) elist)
        (let ((found (find key elist :test #'alike1 :key #'second)))
          (if found (third found) default))
        (merror
          (intl:gettext
            &quot;assoc: every argument must be an expression of two parts; found: ~:M&quot;)
          ielist))))</code></pre><p><code>assol</code>类似于<code>assoc</code>, 但是使用<code>alike1</code>作为相等谓词. <code>assolike</code>不是返回序对, 而是直接返回对应的值.</p><pre><code>(defun assol (item alist)
  (dolist (pair alist)
    (if (alike1 item (car pair)) (return pair))))
(defun assolike (item alist) 
  (cdr (assol item alist)))</code></pre><p><code>memalike</code>类似于<code>member</code>, 但是使用<code>alike1</code>比较相等性.</p><pre><code>(defun memalike (x l)
  (do ((l l (cdr l)))
      ((null l))
    (when (alike1 x (car l)) (return l))))</code></pre><p><code>find-duplicate</code>寻找列表中的重复元素, 默认使用<code>eql</code>进行比较. 如果提供了<code>key</code>函数, 那就是比较键值. <code>find-duplicate</code>会返回第一个发现的重复元素, 更准确地说, 是自左往右依次数, 直到碰到重复的情况.</p><pre><code>(defun find-duplicate (list &amp;key (test #'eql) key)
  (declare (optimize (speed 3)))
  (declare (type (or function null) key)
           (type function test))
  (let ((seen nil))
    (dolist (e list)
      (let ((i (if key (funcall key e) e)))
        (when (member i seen :test test)
          (return-from find-duplicate e))
        (push i seen)))))</code></pre><p></p><pre><code>(defmfun $gensym (&amp;optional x)
  (typecase x
    (null
     (intern (symbol-name (gensym &quot;$G&quot;)) :maxima))
    (string
     (intern
       (symbol-name (gensym (format nil &quot;$~a&quot; (maybe-invert-string-case x))))
       :maxima))
    ((integer 0)
     (let ((*gensym-counter* x))
       (intern (symbol-name (gensym &quot;$G&quot;)) :maxima)))
    (t
     (merror
       (intl:gettext
         &quot;gensym: Argument must be a nonnegative integer or a string. Found: ~M&quot;) x))))</code></pre><h2>getopt.lisp</h2><p></p><pre><code>(defun is-short-option (arg)
  (and (>= (length arg) 2)
       (char= #\- (schar arg 0))
       (char/= #\- (schar arg 1))))
(defun is-option-terminator (arg)
  (and (= 2 (length arg))
       (char= #\- (schar arg 0))
       (char= #\- (schar arg 1))))
(defun is-long-option (arg)
  (and (> (length arg) 2)
       (char= #\- (schar arg 0))
       (char= #\- (schar arg 1))
       (char/= #\- (schar arg 2))))</code></pre><p></p><pre><code>(defun analyze-arg (arg)
  &quot;Analyzes an argument. Returns option-type,base-name,argument&quot;
  (let* ((option-type (cond ((is-short-option arg) :short)
                            ((is-long-option arg) :long)
                            (t :arg))))
    (if (or (eq option-type :short) (eq option-type :long))
        (multiple-value-bind (base arg) (decompose-arg arg option-type)
          (values option-type base arg))
        (values :arg arg nil))))</code></pre><h2>maxmac.lisp</h2><p>类似于<code>PUSH</code>, 但是列表的另一端操作. <code>ncons</code>实际上来源于MACLISP, <code>(ncons x)</code>就相当于<code>(list x)</code>或者<code>(cons x nil)</code>. 一般的Common Lisp实现不会提供<code>ncons</code>这个过程.</p><pre><code>(defmacro tuchus (list object)
  `(setf ,list (nconc ,list (ncons ,object))))</code></pre><pre><code>> (defvar l0 '())
L0
> (tuchus l0 'foo)
(FOO)
> (tuchus l0 'bar)
(FOO BAR)
> (tuchus l0 'baz)
(FOO BAR BAZ)</code></pre><h2>mlisp.lisp</h2><p></p><pre><code>(defun margs (form)
  (if (eq (caar form) 'mqapply)
      (cddr form)
      (cdr form)))</code></pre></body></html>