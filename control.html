<html><head><meta charset="utf-8"/><title>编程语言中的控制结构</title><link href="styles.css" rel="stylesheet"/></head><body><h1>编程语言中的控制结构</h1><h2>引论</h2><h2>第1章 早期编程语言</h2><h3>第1.1节 处理器之中的控制流</h3><h3>第1.2节 机器语言, 汇编语言</h3><h3>第1.3节 FORTRAN</h3><h3>第1.4节 ALGOL 60</h3><h3>第1.5节 条件式和循环</h3><h3>第1.6节 从循环和块之中及早退出</h3><h3>第1.7节 深入阅读</h3><h2>第2章 结构化编程</h2><h3>第2.1节 一场运动和一场争议</h3><p>如今<q>结构化编程</q>指的是使用高层次控制结构 (条件式, 循环, ...) 而非低层次的<code>goto</code>跳转这一毫无争议的编程实践. 然而, 在1965-1975期间, 结构化编程则是充满争论的主题, 其既可以视为一场迈向看待软件的新角度的运动, 也可以视为关于如何编写良好程序的一场争议.</p><p><b>结构化编程运动. </b></p><h3>第2.2节 没有goto的编程</h3><h2>第3章 非局部控制</h2><h2>第4章 控制反转</h2><h2>第5章 函数式语言</h2><h3>第5.1节 声明式编程: 抛弃控制?</h3><p>到目前为止, 我们理所当然地认为源代码必须显式描述程序之中的计算顺序 (sequencing), 并且编程语言必须提供表达这种顺序的控制结构. 然而, 这种假设受到了<em>声明式语言</em>的质疑, 其在源代码之中大体将计算顺序留作隐式, 而依赖于编译器确定计算的正确顺序. 换言之, 声明式语言强调<em>什么</em> (什么是要被计算的?) 而非<em>如何</em> (如何将计算分解为基本步骤? 以什么顺序施行这些步骤?).</p><p>声明性方法的一个例子是诸如SQL这样的数据库查询语言: 查询描述了要从数据库里拉取什么记录; 如何搜索数据库则留给数据库管理系统确定. 其他的声明性编程范式包括逻辑编程 (Prolog, Datalog), 纯函数式编程 (Haskell, Agda), 以及数据流编程 (Simulink, Lustre). 诸如Verilog和VHDL这样的硬件描述语言本质上也是声明性的.</p><p>声明式编程于1970年代引入, 其目的在于简化编程和<q>将编程从von Neumann风格之中解放出来</q>, 如Backus (1978) 所言. 1980年代的焦点转移到了并行计算之上: 人们希望声明式语言比起标准的命令式语言并行执行起来更加容易, 这恰恰是因为前者给予了编译器在调度计算方面更大的灵活性. 自1990年代起, 声明式编程因其安全性和与形式验证的亲缘关系而受到认可.</p><p>声明式编程能否摆脱控制结构? 其能否将程序员从表达程序之中的控制的重担中<q>解放</q>出来呢? 本章试图在纯函数式编程的上下文之中回答这些问题, 通过检视三种表达力依次递增的小语言: XL, 一个电子表格语言; APP, 带有与值不同的函数的一个应用性语言; FUN, 将函数作为值的一个函数式语言.</p><h3>第5.2节 XL: 表达式和电子表格</h3><p><b>带有共享的表达式. </b>考虑以下算术表达式和等式的语言, 昵称<q>XL</q>:<math display="block"><mtable columnalign="right right center left left"><mtr><mtd><mtext>表达式:</mtext></mtd><mtd><mi>e</mi></mtd><mtd><mo>&Colone;</mo></mtd><mtd><mrow><mn>0</mn><mo>|</mo><mn>1.2</mn><mo>|</mo><mn>3.1415</mn><mo>|</mo><mo>&hellip;</mo></mrow></mtd><mtd><mtext>常量</mtext></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mo>|</mo></mtd><mtd><mrow><mi>x</mi><mo>|</mo><mi>y</mi><mo>|</mo><mi>z</mi><mo>|</mo><mo>&hellip;</mo></mrow></mtd><mtd><mtext>变量</mtext></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mo>|</mo></mtd><mtd><mrow><mi>op</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>e</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>e</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mtext>运算</mtext></mtd></mtr><mtr><mtd><mtext>程序:</mtext></mtd><mtd><mi>p</mi></mtd><mtd><mo>&Colone;</mo></mtd><mtd><mrow><mo stretchy="false">{</mo><mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><msub><mi>e</mi><mn>1</mn></msub></mrow><mo>;</mo><mo>&hellip;</mo><mo>;</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>=</mo><msub><mi>e</mi><mi>n</mi></msub></mrow></mrow><mo stretchy="false">}</mo></mrow></mtd><mtd><mtext>等式的集合</mtext></mtd></mtr></mtable></math>诸如<math><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow></math>和<math><mrow><mi>y</mi><mo>&times;</mo><mi>z</mi></mrow></math>这样的算术表达式是由常量和变量通过使用诸如<math><mrow><mo>+</mo><mo>,</mo><mo>&minus;</mo><mo>,</mo><mo>&times;</mo><mo>,</mo><mo lspace="0" rspace="0">/</mo></mrow></math>等运算构筑而成的. 程序是变量和表达式之间的等式的集合.</p><p>通过等式被绑定至表达式的变量使用捕获了计算共享的概念. 例如, 以下两个程序<math display="block"><mtable columnalign="right center left" displaystyle="true"><mtr><mtd><msub><mi>p</mi><mn>1</mn></msub></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>x</mi><mo>=</mo><mrow><mn>2</mn><mo>&times;</mo><mn>3</mn></mrow></mrow><mo>;</mo><mrow><mi>y</mi><mo>=</mo><mrow><mi>x</mi><mo>+</mo><mi>x</mi></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mtd></mtr><mtr><mtd><msub><mi>p</mi><mn>2</mn></msub></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>x</mi><mo>=</mo><mrow><mn>2</mn><mo>&times;</mo><mn>3</mn></mrow></mrow><mo>;</mo><mrow><mi>y</mi><mo>=</mo><mrow><mrow><mn>2</mn><mo>&times;</mo><mn>3</mn></mrow><mo>+</mo><mrow><mn>2</mn><mo>&times;</mo><mn>3</mn></mrow></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mtd></mtr></mtable></math>能够计算出相同的结果 (其含义之后将会精确化), 但是<math><msub><mi>p</mi><mn>1</mn></msub></math>只会对于<math><mrow><mn>2</mn><mo>&times;</mo><mn>3</mn></mrow></math>进行一次求值, 之后在对于<math><mrow><mi>x</mi><mo>+</mo><mi>x</mi></mrow></math>的求值过程中共享结果<math><mn>6</mn></math>, 而<math><msub><mi>p</mi><mn>2</mn></msub></math>会对于<math><mrow><mn>2</mn><mo>&times;</mo><mn>3</mn></mrow></math>求值三次.</p><p><b>电子表格. </b></p><p><b>无环条件. </b>我们希望XL程序容易求值. 这意味着避免难以求解的等式, 例如<math><mrow><mi>x</mi><mo>=</mo><mrow><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>&minus;</mo><mrow><mn>2</mn><mo>&it;</mo><msup><mi>x</mi><mn>2</mn></msup></mrow></mrow><mo>+</mo><mn>2</mn></mrow></mrow></math>. 我们还要走的远得多, 排除所有这样的等式<math><mrow><mi>x</mi><mo>=</mo><mi>e</mi></mrow></math>, 其中<math><mi>e</mi></math>依赖于<math><mi>x</mi></math>, 不论直接依赖还是通过其他等式间接依赖, 如以下例子所示:<math display="block"><mtable><mtr><mtd><mrow><mo stretchy="false">{</mo><mrow><mi>x</mi><mo>=</mo><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow></mrow><mo stretchy="false">}</mo></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>x</mi><mo>=</mo><mrow><mi>y</mi><mo>+</mo><mn>1</mn></mrow></mrow><mo>;</mo><mrow><mi>y</mi><mo>=</mo><mrow><mi>x</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mtd></mtr></mtable></math>换言之, 这些等式不能包含依赖循环. 这种无环条件成立当且仅当程序不只是能写作等式的集合, 而且可以写作等式的<em>有序列表</em><math display="block"><mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><msub><mi>e</mi><mn>1</mn></msub></mrow><mo>;</mo><mo>&hellip;</mo><mo>;</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>=</mo><msub><mi>e</mi><mi>n</mi></msub></mrow></mrow></math>其中可以出现在<math><msub><mi>e</mi><mi>i</mi></msub></math>之中的变量只能是满足<math><mrow><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow></math>的变量<math><msub><mi>x</mi><mi>j</mi></msub></math>.</p><p><b>电路和数据流. </b></p><p><b>程序求值. </b></p><h3>第5.3节 APP: 表达式和用户定义的函数</h3><h3>第5.4节 FUN: 函数作为第一级值</h3><h3>第5.5节 上下文下的归约</h3><h3>第5.6节 深入阅读</h3><h2>第6章 延续和CPS变换</h2><h3>第6.1节 延续的概念</h3><p><b>程序点的延续. </b>考虑程序执行过程中的一个点. 这个程序中该程序点的<em>延续</em>是在执行抵达该点之后还要执行的计算序列, 其是为了完成整个程序的执行过程.</p><h3>第6.2节 指称语义回顾</h3><p>指称语义由Christopher Strachey, Dana Scott, Christopher Wadsworth于1960年代后期引入, 其是以数学的精确定义程序的含义之方法. 指称语义以复合性的方式将数学对象与编程语言的每个句法元素 (表达式, 语句, 函数, ...) 联系起来.</p><p>例如, 一个牵涉变量的整数算术表达式<math><mi>e</mi></math>的含义可以被定义为从存储到整数的映射, 其中存储将整数与变量联系起来:</p><h3>第6.3节 基于延续的指称语义</h3><h3>第6.4节 标签和跳转的指称语义</h3><h3>第6.5节 CPS变换</h3><h3>第6.6节 CPS变换的语义性质</h3><h3>第6.7节 深入阅读</h3><h2 id="programming-with-continuations">第7章 延续编程</h2><h2>第8章 控制运算子</h2><p>控制运算子是由某些函数式语言所提供的语言构造, 其允许表达式捕获延续, 将延续作为第一级值操纵, 以及之后重启延续.</p><p>控制运算子使得将高级控制结构 (异常, 回溯, 协作线程, 等等) 编写为库函数成为可能, 其可以在以直接风格写成的程序之中运用. 藉由控制运算子, 我们无需像我们在<cite>第<a href="#programming-with-continuations">7</a>章</cite>所做的那样, 通过将程序改写为延续传递风格以使用用户所定义的高级控制结构.</p><h3>第8.1节 Landin的J运算子</h3><h3>第8.2节 call-with-current-continuation (callcc)</h3><p>最为知名的控制运算子或许是来自于Scheme语言的<q>call-with-current-continuation</q>, 其经常被缩略为<code>call/cc</code>或者<code>callcc</code>. 其允许一个表达式将其自身的延续以函数的形式捕获. 这个运算子在文献里以各种不同的名字出现: </p><h3>第8.3节 使用callcc实现控制结构</h3><h3>第8.4节 callcc的语义</h3><h3>第8.5节 定界延续</h3><h3>第8.6节 定界延续运算子的语义</h3><h3>第8.7节 使用定界延续实现控制结构</h3><h3>第8.8节 定界延续的CPS变换</h3><h3>第8.9节 深入阅读</h3><h2>第9章 异常</h2><h2>第10章 用户定义作用的作用处理器</h2><h2>第11章 单子</h2><h2>第12章 代数作用</h2><h2>第13章 类型和作用系统</h2><h2>第14章 控制结构的Hoare逻辑</h2><h2>第15章 控制运算子的分离逻辑</h2></body></html>