<html><head><meta charset="utf-8"/><title>指称语义学讲义</title><link href="styles.css" rel="stylesheet"/></head><body><h1>指称语义学讲义</h1><h2>前言</h2><p>我们的目的在于介绍domain论和指称语义, 并展示其是如何为推理程序行为提供数学基础的.</p><h3>推荐书目</h3><ul><li>Winskel, G. (1993). <i>The Formal Semantics of Programming Languages. </i>MIT Press.<br/>这是一本操作语义和指称语义的极好导论. 就本课程而言, 相关的章节是5, 8, 9, 10 (第1节和第2节), 以及11. [译注: 有中文译本, 名为程序设计语言的形式语义.]</li><li>Tennent, R. D. (1991). <i>Semantics of Programming Languages. </i>Prentice-Hall.<br/>部分I和II与本讲义有关.</li></ul><h3>深入阅读</h3><ul><li>Gunter, C. A. (1992). <i>Semantics of Programming Languages. Structures and Techniques. </i>MIT Press.<br/>这是一本研究生水平的教材, 包含有诸多本讲义未能涵盖的材料. 就讲义本身而言, 相关的章节是第1章, 第2章, 以及第4到6章.</li><li>Streicher, T. (2006). <i>Domain-Theoretic Foundations of Functional Programming. </i>World Scientific Publishing Co. ISBN 981-270-142-7<br/>一本关于本讲义后半部分所涉及的PCF语言的研究生水平教材.</li></ul><h2>第1章 引论</h2><p>幻灯片1提示了给出编程语言的形式语义的几种方法. 操作性方法于Part IB课程<b>Semantics of Programming Languages</b>中介绍, 而公理性方法在Part II课程<b>Hoare Logic</b>中刻画. 本课程讲义给出了指称性方法的一些技巧的简要导引. 指称语义学的目的之一在于以尽可能抽象且实现无关的方式描述编程语言的构造: 通过这种方法, 我们有可能获得对于某些概念的洞察, 而这些概念构成了编程语言以及其间关系的基础, 甚至有时还能理解在语言设计中实现这些概念的新方式. 当然, 验证指称性描述可以被实现是重要的. 换言之, 即将指称语义和操作语义联系起来: 我们将在之后刻画如何施行此事.</p><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>形式语义的风格</b></div><hr/><p><b>操作的.</b>程序片段的意义基于程序执行过程中其可以施行的<em>计算步骤</em>定义.</p><p><b>公理的.</b>程序片段的意义间接地通过程序性质的某种逻辑的<em>公理和规则</em>定义.</p><p><b>指称的.</b>关心给出编程语言的<em>数学模型</em>. 程序片段的意义抽象地定义为某种适当数学结构的元素.</p></div></td></tr><tr><td align="center">幻灯片1</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>指称语义的特征性质</b></div><hr/><ul><li>每个程序片段<math><mi>P</mi></math>被赋予一个<em>指称</em><math><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>P</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></math>, 这是一个数学对象, 其代表了<math><mi>P</mi></math>对于完整程序的意义的贡献.</li><li>一个程序片段的意义只由其子片段决定, 或者说指称语义是<em>可复合的</em>.</li></ul></div></td></tr><tr><td align="center">幻灯片2</td></tr></table><h3>第1.1节 指称语义的基本例子</h3><p>考虑基本的编程语言IMP<sup><math><mo>&minus;</mo></math></sup>, 其相当于带有控制结构的算术和布尔表达式, 而这里的控制结构是由赋值, 顺序, 条件刻画的, 见幻灯片3.</p><table class="label" align="center"><tr><td><div class="slide" style="height: 300px"><div align="center"><b>指称语义的基本例子 (I):</b></div><hr/><div align="center">IMP<sup><math><mo>&minus;</mo></math></sup>的句法</div><p>算术表达式: <math display="block"><mrow><mrow><mi>A</mi><mo>&in;</mo><ms>Aexp</ms></mrow><mo>&Colone;</mo><mrow><munder><mi>n</mi><mo>&UnderBar;</mo></munder><mo>|</mo><mi>L</mi><mo>|</mo><mrow><mi>A</mi><mo>+</mo><mi>A</mi></mrow><mo>|</mo><mo>&hellip;</mo></mrow></mrow></math>其中<math><mi>n</mi></math>是整数, 而<math><mrow><mi>L</mi><mo>&in;</mo><mi>&Lopf;</mi></mrow></math>, <math><mi>&Lopf;</mi></math>是给定的<em>位置</em>的集合.</p><p>布尔表达式: <math display="block"><mrow><mrow><mi>B</mi><mo>&in;</mo><ms>Bexp</ms></mrow><mo>&Colone;</mo><mrow><ms>true</ms><mo>|</mo><ms>false</ms><mo>|</mo><mrow><mi>A</mi><mo>=</mo><mi>A</mi></mrow><mo>|</mo><mrow><mo>&not;</mo><mi>B</mi></mrow><mo>|</mo><mo>&hellip;</mo></mrow></mrow></math></p><p>命令: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>C</mi><mo>&in;</mo><ms>Comm</ms></mrow></mtd><mtd><mo>&Colone;</mo></mtd><mtd columnalign="left"><mrow><ms>skip</ms><mo>|</mo><mrow><mi>L</mi><mo>&colone;</mo><mi>A</mi></mrow><mo>|</mo><mrow><mi>C</mi><mo>;</mo><mi>C</mi></mrow></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>|</mo></mtd><mtd columnalign="left"><mrow><ms>if</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>then</ms><mtext>&nbsp;</mtext><mi>C</mi><mtext>&nbsp;</mtext><ms>else</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow></mtd></mtr></mtable></math></p></div></td></tr><tr><td align="center">幻灯片3</td></tr></table><div class="tcomment"><b>译者注记.</b> <math><munder><mi>n</mi><mo>&UnderBar;</mo></munder></math>是代表整数<math><mi>n</mi></math>的句法.</div><p>为了给出一个编程语言的<em>指称语义</em>, 我们需要赋予每种程序片段的句法范畴以一个解释的domain (domain of interpretation), 然后复合性地描述各种形成程序片段 (phrase-forming) 的构造所对应的语义函数. 对于IMP<sup><math><mo>&minus;</mo></math></sup>, 幻灯片4到10给出了其指称语义, 并且这个语义也很容易在SML中实现.</p><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>指称语义的基本例子 (II)</b></div><hr/><div align="center">语义函数</div><math display="block"><mtable columnalign="left"><mtr><mtd><mrow><mi mathvariant="script">A</mi><mo>:</mo><mrow><ms>Aexp</ms><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&rarr;</mo><mi>&Zopf;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow><mi mathvariant="script">B</mi><mo>:</mo><mrow><ms>Bexp</ms><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&rarr;</mo><mi>&Bopf;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow><mi mathvariant="script">C</mi><mo>:</mo><mrow><ms>Comm</ms><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr></mtable></math>其中<math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mi>&Zopf;</mi></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mo stretchy="false">{</mo><mrow><mo>&hellip;</mo><mo>,</mo><mrow><mo>&minus;</mo><mn>1</mn></mrow><mo>,</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mo>&hellip;</mo></mrow><mo stretchy="false">}</mo></mrow></mtd></mtr><mtr><mtd columnalign="right"><mi>&Bopf;</mi></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mo stretchy="false">{</mo><mrow><mi>true</mi><mo>,</mo><mi>false</mi></mrow><mo stretchy="false">}</mo></mrow></mtd></mtr><mtr><mtd columnalign="right"><mi>State</mi></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mo stretchy="false">(</mo><mrow><mi>&Lopf;</mi><mo>&rarr;</mo><mi>&Zopf;</mi></mrow><mo stretchy="false">)</mo></mrow></mtd></mtr></mtable></math></div></td></tr><tr><td align="center">幻灯片4</td></tr></table><div class="tcomment"><b>译者注记.</b> <math><mo>&RightVector;</mo></math>的含义是部分函数 (partial function). 另外, <math><ms>true</ms></math>和<math><mi>true</mi></math>是不同的, 前者是句法, 而后者是一个数学对象.</div><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>指称语义的基本例子 (III)</b></div><hr/><div align="center">语义函数<math><mi mathvariant="script">A</mi></math></div><math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi mathvariant="script">A</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><munder><mi>n</mi><mo>&UnderBar;</mo></munder><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mi>n</mi></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow><mi mathvariant="script">A</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>L</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow><mi mathvariant="script">A</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>+</mo><msub><mi>A</mi><mn>2</mn></msub></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mrow><mi mathvariant="script">A</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mrow><mi mathvariant="script">A</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msub><mi>A</mi><mn>2</mn></msub><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mtd></mtr></mtable></math></div></td></tr><tr><td align="center">幻灯片5</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>指称语义的基本例子 (IV)</b></div><hr/><div align="center">语义函数<math><mi mathvariant="script">B</mi></math></div><math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi mathvariant="script">B</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><ms>true</ms><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mi>true</mi></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow><mi mathvariant="script">B</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><ms>false</ms><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mi>false</mi></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow><mi mathvariant="script">B</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>=</mo><msub><mi>A</mi><mn>2</mn></msub></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mi>eq</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mrow><mi mathvariant="script">A</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><mrow><mi mathvariant="script">A</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msub><mi>A</mi><mn>2</mn></msub><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mrow/></mtd><mtd columnalign="left"><mrow><mtext>其中</mtext><mrow><mrow><mi>eq</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>,</mo><msup><mi>a</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mi>true</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>a</mi><mo>=</mo><msup><mi>a</mi><mo>&prime;</mo></msup></mrow></mtd></mtr><mtr><mtd><mi>false</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>a</mi><mo>&ne;</mo><msup><mi>a</mi><mo>&prime;</mo></msup></mrow></mtd></mtr></mtable></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow><mi mathvariant="script">B</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><mo>&not;</mo><mi>B</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mo>&not;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi mathvariant="script">B</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr></mtable></math></div></td></tr><tr><td align="center">幻灯片6</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>指称语义的基本例子 (V)</b></div><hr/><div align="center">语义函数<math><mi mathvariant="script">C</mi></math></div><math display="block"><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><ms>skip</ms><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>=</mo><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mi>s</mi></mrow></mrow></math><p>注记: 从现在开始, 语义函数的名字都将省略.</p></div></td></tr><tr><td align="center">幻灯片7</td></tr></table><table class="label" align="center"><tr><td><div class="slide" style="width: 500px"><div align="center"><b>可复合性一例</b></div><hr/><p>给定部分函数<math><mrow><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>,</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msup><mi>C</mi><mo>&prime;</mo></msup><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow><mo>:</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow></mrow></math>以及函数<math><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>:</mo><mrow><mi>State</mi><mo>&rarr;</mo><mrow><mo stretchy="false">{</mo><mrow><mi>true</mi><mo>,</mo><mi>false</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></mrow></math>, 我们可以定义<math display="block"><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>if</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>then</ms><mtext>&nbsp;</mtext><mi>C</mi><mtext>&nbsp;</mtext><ms>else</ms><mtext>&nbsp;</mtext><msup><mi>C</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>=</mo><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mi>if</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msup><mi>C</mi><mo>&prime;</mo></msup><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>其中<math display="block"><mrow><mrow><mi>if</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>b</mi><mo>,</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mi>x</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>b</mi><mo>=</mo><mi>true</mi></mrow></mtd></mtr><mtr><mtd><msup><mi>x</mi><mo>&prime;</mo></msup></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>b</mi><mo>=</mo><mi>false</mi></mrow></mtd></mtr></mtable></mrow></mrow></math></p></div></td></tr><tr><td align="center">幻灯片8</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>指称语义的基本例子 (VI)</b></div><hr/><div align="center">语义函数<math><mi mathvariant="script">C</mi></math></div><math display="block"><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><mi>L</mi><mo>&colone;</mo><mi>A</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>=</mo><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mi>&lambda;</mi><mrow><mi>l</mi><mo>&in;</mo><mi>&Lopf;</mi></mrow><mo lspace="0">.</mo><mrow><mi>if</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>l</mi><mo>=</mo><mi>L</mi></mrow><mo>,</mo><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>A</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math></div></td></tr><tr><td align="center">幻灯片9</td></tr></table><table class="label" align="center"><tr><td><div class="slide" style="width: 500px; height: 250px"><div align="center"><b>顺序复合的指称语义</b></div><hr/><p>两个命令的顺序复合<math><mrow><mi>C</mi><mo>;</mo><msup><mi>C</mi><mo>&prime;</mo></msup></mrow></math>的指称为<math display="block"><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><mi>C</mi><mo>;</mo><msup><mi>C</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>=</mo><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msup><mi>C</mi><mo>&prime;</mo></msup><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&compfn;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow><mo>=</mo><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msup><mi>C</mi><mo>&prime;</mo></msup><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>这实际上就是命令的指称 (即部分函数<math><mrow><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>,</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msup><mi>C</mi><mo>&prime;</mo></msup><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow><mo>:</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow></mrow></math>) 的复合而已.</p><hr/><p>与之相对的是, 顺序复合的操作语义为<math display="block"><mfrac displaystyle="true"><mrow><mrow><mi>C</mi><mo>,</mo><mrow><mi>s</mi><mo>&dArr;</mo><msup><mi>s</mi><mo>&prime;</mo></msup></mrow></mrow><mspace width="8ex"/><mrow><msup><mi>C</mi><mo>&prime;</mo></msup><mo>,</mo><mrow><msup><mi>s</mi><mo>&prime;</mo></msup><mo>&dArr;</mo><msup><mi>s</mi><mo>&Prime;</mo></msup></mrow></mrow></mrow><mrow><mrow><mi>C</mi><mo>;</mo><msup><mi>C</mi><mo>&prime;</mo></msup></mrow><mo>,</mo><mrow><mi>s</mi><mo>&dArr;</mo><msup><mi>s</mi><mo>&Prime;</mo></msup></mrow></mrow></mfrac></math></p></div></td></tr><tr><td align="center">幻灯片10</td></tr></table><h3>第1.2节 例子: 作为不动点的<math><ms>while</ms></math>循环</h3><p>幻灯片2所提及的<em>可复合性</em>的要求是相当tough的. 我们用以赋予程序片段指称的数学对象必须足够丰富, 因为需要支持建模所讨论编程语言的一切形成程序片段的构造. 某些形成程序片段的构造是容易处理的, 而其他一些可能就不那么容易了. 例如, 牵涉状态改变命令的条件表达式 [译注: 更准确地说, 应该是条件命令] 可以基于应用相应的分支函数于立即子表达式的指称给出其指称语义: 见幻灯片8. 类似地, 命令的顺序复合的指称语义可由从状态到状态的部分函数的复合操作得到, 如幻灯片10.</p><p>现在我们来考虑基本编程语言IMP的指称语义, 其扩展了IMP<sup><math><mo>&minus;</mo></math></sup>以<math><ms>while</ms></math>循环:<math display="block"><mrow><mrow><mi>C</mi><mo>&in;</mo><ms>Comm</ms></mrow><mo>&Colone;</mo><mrow><mo>&hellip;</mo><mo>|</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow></mrow></mrow></math>然而, 这种循环构造并不容易以可复合的方式解释!</p><p><math><ms>while</ms></math>循环的转换语义为<math display="block"><mrow><mrow><mo stretchy="false">&lang;</mo><mrow><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo>,</mo><mi>s</mi></mrow><mo stretchy="false">&rang;</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">&lang;</mo><mrow><mrow><ms>if</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>then</ms><mtext>&nbsp;</mtext><mrow><mi>C</mi><mo>;</mo><mrow><mo stretchy="false">(</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mtext>&nbsp;</mtext><ms>else</ms><mtext>&nbsp;</mtext><ms>skip</ms></mrow><mo>,</mo><mi>s</mi></mrow><mo stretchy="false">&rang;</mo></mrow></mrow></math>这暗示了其作为从状态到状态的部分函数的指称应该满足<math display="block"><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>=</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>if</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>then</ms><mtext>&nbsp;</mtext><mrow><mi>C</mi><mo>;</mo><mrow><mo stretchy="false">(</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mtext>&nbsp;</mtext><ms>else</ms><mtext>&nbsp;</mtext><ms>skip</ms></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></math>我们应该注意到这不能直接用来定义<math><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></math>, 因为右边恰恰包含有一个我们想要定义其指称的子片段. 使用顺序复合和<math><ms>if</ms></math>的指称语义, 以及<math><ms>skip</ms></math>的指称为恒等函数<math><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mi>s</mi></mrow></math>的事实, 上面这条等式是在说<math><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></math>应该是幻灯片11中给出的<em>不动点方程</em>的一个解.</p><table class="label" align="center"><tr><td><div class="slide" style="width: 500px; height: 250px"><div align="center"><b><math><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mtext>的不动点性质</mtext></mrow></math></b></div><hr/><math display="block"><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>=</mo><mrow><msub><mi>f</mi><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>,</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>其中, 对于每个<math><mrow><mi>b</mi><mo>:</mo><mrow><mi>State</mi><mo>&rarr;</mo><mrow><mo stretchy="false">{</mo><mrow><mi>true</mi><mo>,</mo><mi>false</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></mrow></math>和<math><mrow><mi>c</mi><mo>:</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow></mrow></math>, 我们定义<math display="block"><mrow><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>:</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>为<math display="block"><mrow><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>=</mo><mrow><mi>&lambda;</mi><mrow><mi>w</mi><mo>&in;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo lspace="0">.</mo><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mi>if</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>b</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><mi>w</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>c</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mi>s</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math><hr/><ul><li>为什么<math><mrow><mi>w</mi><mo>=</mo><mrow><msub><mi>f</mi><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>,</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>有解?</li><li>若此方程具有多解, 那么选取哪一个作为<math><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></math>呢?</li></ul></div></td></tr><tr><td align="center">幻灯片11</td></tr></table><p>在赋予带有递归特性的编程语言以指称语义时, 这样的不动点方程经常出现. 自Dana Scott于60年代晚期的先驱性研究始, 一种被称为<em>domain论</em>的数学理论建立起来以提供一种背景环境, 其中我们不仅总是可以找到因指称语义而生的不动点方程的解, 而且还能选出在某种适切意义下最小的解, 而这实际上保证了指称语义和操作语义之间的协调配合. 关键的想法在于考虑用作指称的数学对象之间的一种偏序, 此偏序表达了这样的事实, 一个对象由另一个对象<em>近似</em>, 或者说比另一个对象<em>携带了更多的信息</em>, 或者说比另一个对象<em>更加良定</em>. 然后, 不动点方程的最小解可以被构造为对于解的近似升链的极限. 在下一章里, 这些想法将会变得从数学角度来说更加精确和一般, 但是目前先让我们具体地阐明该如何运用此想法解决幻灯片11中的特定问题.</p><p>为了确定起见, 让我们考虑以下特定的<math><ms>while</ms></math>循环<math display="block"><mrow><ms>while</ms><mtext>&nbsp;</mtext><mrow><mi>X</mi><mo>></mo><mn>0</mn></mrow><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>Y</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&#8270;</mo><mi>Y</mi></mrow></mrow><mo>;</mo><mrow><mi>X</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>其中<math><mi>X</mi></math>和<math><mi>Y</mi></math>是两个不同的整数存储位置 (变量), 而位置的集合<math><mrow><mi>&Lopf;</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mi>X</mi><mo>,</mo><mi>Y</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></math>.</p><div class="tcomment"><b>译者注记.</b> 在某种意义上说, 将<math><mi>&Lopf;</mi></math>的元素既用作句法也用作讨论语义时所牵涉的概念对象是一种(司空见惯的)滥用. 但是, 只要满足目的就好.</div><p>在这种情形之下, 我们可以就取状态为赋值<math><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></math>, 其中<math><mrow><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo>&in;</mo><mi>&Zopf;</mi></mrow></math>, 这记录了位置<math><mi>X</mi></math>和<math><mi>Y</mi></math>的当前内容. 因此, <math><mrow><mi>State</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&Lopf;</mi><mo>&rarr;</mo><mi>&Zopf;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>.</p><div class="tcomment"><b>译者注记.</b> 实际上, 幻灯片4中就已经定义<math><mi>State</mi></math>为<math><mrow><mo stretchy="false">(</mo><mrow><mi>&Lopf;</mi><mo>&rarr;</mo><mi>&Zopf;</mi></mrow><mo stretchy="false">)</mo></mrow></math>了.</div><p>我们正在试着将这个<math><ms>while</ms></math>循环的指称定义为一个部分函数<math display="block"><mrow><mi>w</mi><mo>:</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow></mrow></math>其应该是幻灯片11上的不动点方程<math display="block"><mrow><mi>w</mi><mo>=</mo><mrow><msub><mi>f</mi><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><mi>X</mi><mo>></mo><mn>0</mn></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>,</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><mrow><mi>Y</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&#8270;</mo><mi>Y</mi></mrow></mrow><mo>;</mo><mrow><mi>X</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>的一个解.</p><p>对于特定的布尔表达式<math><mrow><mi>B</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>></mo><mn>0</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></math>和命令<math><mrow><mi>C</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>Y</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&#8270;</mo><mi>Y</mi></mrow></mrow><mo>;</mo><mrow><mi>X</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>, 函数<math><msub><mi>f</mi><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>,</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></msub></math>恰好与幻灯片12上定义的函数<math><mi>f</mi></math>相同.</p><table class="label" align="center"><tr><td><div class="slide" style="width: 500px"><div align="center"><b><math><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mrow><mi>X</mi><mo>></mo><mn>0</mn></mrow><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>Y</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&#8270;</mo><mi>Y</mi></mrow></mrow><mo>;</mo><mrow><mi>X</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></math></b></div><hr/>令<math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mi>State</mi></mtd><mtd><mover><mo>=</mo><mi>def</mi></mover></mtd><mtd columnalign="left"><mrow><mo stretchy="false">(</mo><mrow><mi>&Lopf;</mi><mo>&rarr;</mo><mi>&Zopf;</mi></mrow><mo stretchy="false">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right"><mi>D</mi></mtd><mtd><mover><mo>=</mo><mi>def</mi></mover></mtd><mtd columnalign="left"><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow></mtd></mtr></mtable></math>对于<math><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mrow><mi>X</mi><mo>></mo><mn>0</mn></mrow><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>Y</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&#8270;</mo><mi>Y</mi></mrow></mrow><mo>;</mo><mrow><mi>X</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&in;</mo><mi>D</mi></mrow></math>, 我们寻求<math><mrow><mi>w</mi><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>的一个最小的解, 其中<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>被定义为<math display="block"><mrow><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&le;</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mi>w</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mrow><mi>x</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mrow><mi>x</mi><mo>&#8270;</mo><mi>y</mi></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>></mo><mn>0</mn></mrow></mtd></mtr></mtable></mrow></mrow></math></div></td></tr><tr><td align="center">幻灯片12</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b><math><mrow><mi>D</mi><mtext>上的偏序</mtext></mrow></math></b></div><hr/><ul><li><math><mi>D</mi></math>上的偏序<math><mo>&sqsube;</mo></math>:<br/><math><mrow><mi>w</mi><mo>&sqsube;</mo><msup><mi>w</mi><mo>&prime;</mo></msup></mrow></math>当且仅当对于每个<math><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow></math>, 如果<math><mi>w</mi></math>在<math><mi>s</mi></math>上有定义, 那么<math><msup><mi>w</mi><mo>&prime;</mo></msup></math>也在<math><mi>s</mi></math>上有定义, 并且<math><mrow><mrow><mi>w</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msup><mi>w</mi><mo>&prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>. 另外一种描述是, <math><mi>w</mi></math>的图包含于<math><msup><mi>w</mi><mo>&prime;</mo></msup></math>的图.</li><li>最小元<math><mrow><mi>&bottom;</mi><mo>&in;</mo><mi>D</mi></mrow></math> w.r.t. <math><mo>&sqsube;</mo></math>:<br/><math><mi>&bottom;</mi></math>即全然未定义的部分函数, 或者说图为空的部分函数, 其满足对于每个<math><mrow><mi>w</mi><mo>&in;</mo><mi>D</mi></mrow></math>, <math><mrow><mi>&bottom;</mi><mo>&sqsube;</mo><mi>w</mi></mrow></math>.</li></ul></div></td></tr><tr><td align="center">幻灯片13</td></tr></table><p>考虑幻灯片13上给出的<math><mrow><mi>D</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>的元素之间的偏序<math><mo>&sqsube;</mo></math>. 注意到<math><mo>&sqsube;</mo></math>实际上就是前文所提及的&quot;信息序&quot;的具体化身: 如果<math><mrow><mi>w</mi><mo>&sqsube;</mo><msup><mi>w</mi><mo>&prime;</mo></msup></mrow></math>, 那么<math><msup><mi>w</mi><mo>&prime;</mo></msup></math>在<math><mi>w</mi></math>有定义的地方都保持和<math><mi>w</mi></math>的一致, 但是它可能在其他一些参数上也有定义. 我们还应该注意到的是, <math><mi>D</mi></math>包含一个相对于此偏序的最小元: 对于全然未定义的部分函数, 我们将其记作<math><mi>&bottom;</mi></math>, 它满足对于任意的<math><mrow><mi>w</mi><mo>&in;</mo><mi>D</mi></mrow></math>都有<math><mrow><mi>&bottom;</mi><mo>&sqsube;</mo><mi>w</mi></mrow></math>.</p><p>自<math><mi>&bottom;</mi></math>开始, 我们反复应用函数<math><mi>f</mi></math>以构造一个部分函数的序列<math><mrow><msub><mi>w</mi><mn>0</mn></msub><mo>,</mo><msub><mi>w</mi><mn>1</mn></msub><mo>,</mo><msub><mi>w</mi><mn>2</mn></msub><mo>,</mo><mo>&hellip;</mo></mrow></math>:<math display="block"><mrow><mrow><msub><mi>w</mi><mn>0</mn></msub><mover><mo>=</mo><mi>def</mi></mover><mi>&bottom;</mi></mrow><mo>;</mo><mrow><msub><mi>w</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mover><mo>=</mo><mi>def</mi></mover><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mtext>.</mtext></math>使用幻灯片12上的<math><mi>f</mi></math>的定义, 我们发现<math display="block"><mrow><mrow><msub><mi>w</mi><mn>1</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&le;</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mi>undefined</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&ge;</mo><mn>1</mn></mrow></mtd></mtr></mtable></mrow></mrow></math><math display="block"><mrow><mrow><msub><mi>w</mi><mn>2</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&le;</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd><mi>undefined</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&ge;</mo><mn>2</mn></mrow></mtd></mtr></mtable></mrow></mrow></math><math display="block"><mrow><mrow><msub><mi>w</mi><mn>3</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&le;</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mrow><mn>2</mn><mo>&#8270;</mo><mi>y</mi></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mn>2</mn></mrow></mtd></mtr><mtr><mtd><mi>undefined</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&ge;</mo><mn>3</mn></mrow></mtd></mtr></mtable></mrow></mrow></math><math display="block"><mrow><mrow><msub><mi>w</mi><mn>4</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&le;</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mrow><mn>2</mn><mo>&#8270;</mo><mi>y</mi></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mn>2</mn></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mrow><mn>6</mn><mo>&#8270;</mo><mi>y</mi></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mn>3</mn></mrow></mtd></mtr><mtr><mtd><mi>undefined</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&ge;</mo><mn>4</mn></mrow></mtd></mtr></mtable></mrow></mrow></math>并且, 在<math><mrow><mi>n</mi><mo>&ge;</mo><mn>1</mn></mrow></math>的一般情况下, 我们有<math display="block"><mrow><mrow><msub><mi>w</mi><mi>n</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&le;</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mo>!</mo><mi>x</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&#8270;</mo><mi>y</mi></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mn>0</mn><mo>&lt;</mo><mi>x</mi><mo>&lt;</mo><mi>n</mi></mrow></mtd></mtr><mtr><mtd><mi>undefined</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&ge;</mo><mi>n</mi></mrow></mtd></mtr></mtable></mrow></mrow></math>其中<math><mrow><mo>!</mo><mi>x</mi></mrow></math>是<math><mi>x</mi></math>的阶乘.</p><p>因此, 我们得到了一个部分函数的递增序列<math display="block"><mrow><msub><mi>w</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>w</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>w</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo><mo>&sqsube;</mo><msub><mi>w</mi><mi>n</mi></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>所有这些部分函数之并是元素<math><mrow><msub><mi>w</mi><mi>&infin;</mi></msub><mo>&in;</mo><mi>D</mi></mrow></math>, 其为<math display="block"><mrow><mrow><msub><mi>w</mi><mi>&infin;</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&le;</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mo>!</mo><mi>x</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&#8270;</mo><mi>y</mi></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>></mo><mn>0</mn></mrow></mtd></mtr></mtable></mrow></mrow></math>注意到<math><msub><mi>w</mi><mi>&infin;</mi></msub></math>是<math><mi>f</mi></math>的一个不动点, 因为对于每个<math><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></math>, 我们有<math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mi>&infin;</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&le;</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><msub><mi>w</mi><mi>&infin;</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mrow><mi>x</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mrow><mi>x</mi><mo>&#8270;</mo><mi>y</mi></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>></mo><mn>0</mn></mrow></mtd></mtr></mtable></mrow><mspace width="6ex"/><mtext>(根据</mtext><mi>f</mi><mtext>的定义)</mtext></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&le;</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mrow><mn>1</mn><mo>&#8270;</mo><mi>y</mi></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mrow><mrow><mo>!</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>&minus;</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&#8270;</mo><mi>x</mi><mo>&#8270;</mo><mi>y</mi></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>></mo><mn>1</mn></mrow></mtd></mtr></mtable></mrow><mspace width="6ex"/><mtext>(根据</mtext><msub><mi>w</mi><mi>&infin;</mi></msub><mtext>的定义)</mtext></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><msub><mi>w</mi><mi>&infin;</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow></mtd></mtr></mtable></math>实际上, 我们可以表明<math><msub><mi>w</mi><mi>&infin;</mi></msub></math>是<math><mi>f</mi></math>的<em>最小</em>不动点, 意即对于任意的<math><mrow><mi>w</mi><mo>&in;</mo><mi>D</mi></mrow></math>, 有<math display="block"><mrow><mrow><mi>w</mi><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&Implies;</mo><mrow><msub><mi>w</mi><mi>&infin;</mi></msub><mo>&sqsube;</mo><mi>w</mi></mrow></mrow><mtext>.</mtext></math>我们取这个最小不动点<math><msub><mi>w</mi><mi>&infin;</mi></msub></math>作为<math display="block"><mrow><ms>while</ms><mtext>&nbsp;</mtext><mrow><mi>X</mi><mo>></mo><mn>0</mn></mrow><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>Y</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&#8270;</mo><mi>Y</mi></mrow></mrow><mo>;</mo><mrow><mi>X</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>的指称, 其构造方式是下一章要证明的Tarski不动点定理的一个实例. 我们也应该注意到, <math><msub><mi>w</mi><mi>&infin;</mi></msub></math>的确就是命令<math><mrow><ms>while</ms><mtext>&nbsp;</mtext><mrow><mi>X</mi><mo>></mo><mn>0</mn></mrow><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>Y</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&#8270;</mo><mi>Y</mi></mrow></mrow><mo>;</mo><mrow><mi>X</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>的结构操作语义所给出的从状态到状态的函数, 见Part IB课程<b>Semantics of Programming Languages</b>.</p><h3>第1.3节 练习</h3><div class="exercise"><b>练习1.</b> 在SML中实现IMP<sup><math><mo>&minus;</mo></math></sup>的指称语义.</div><div class="exercise"><b>练习2.</b> 考虑幻灯片11上定义的函数<math display="block"><mrow><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>:</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math><ol type="i"><li>根据<math><mi>n</mi></math>上的归纳证明<math display="block"><mrow><mrow><msubsup><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow><mi>n</mi></msubsup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><msup><mi>c</mi><mi>k</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>, 如果存在</mtext><mrow><mn>0</mn><mo>&le;</mo><mi>k</mi><mo>&lt;</mo><mi>n</mi></mrow><mtext>满足对于每个</mtext><mrow><mn>0</mn><mo>&le;</mo><mi>i</mi><mo>&lt;</mo><mi>k</mi></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd columnalign="left"><mtext>有</mtext><mrow><mrow><mi>b</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>c</mi><mi>i</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>true</mi></mrow><mtext>而</mtext><mrow><mrow><mi>b</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>c</mi><mi>k</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>false</mi></mrow></mtd></mtr><mtr><mtd><mi>undefined</mi></mtd><mtd columnalign="left"><mtext>, 如果对于每个</mtext><mrow><mn>0</mn><mo>&le;</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><mtext>有</mtext><mrow><mrow><mi>b</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>c</mi><mi>i</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>true</mi></mrow></mtd></mtr></mtable></mrow></mrow></mrow></math></li><li>令<math><mrow><msub><mi>w</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>:</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow></mrow></math>是由<math display="block"><mrow><msub><mi>w</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mover><mo>=</mo><mi>def</mi></mover><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><msup><mi>c</mi><mi>k</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>, 如果存在</mtext><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow><mtext>满足对于每个</mtext><mrow><mn>0</mn><mo>&le;</mo><mi>i</mi><mo>&lt;</mo><mi>k</mi></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd columnalign="left"><mtext>有</mtext><mrow><mrow><mi>b</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>c</mi><mi>i</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>true</mi></mrow><mtext>而</mtext><mrow><mrow><mi>b</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>c</mi><mi>k</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>false</mi></mrow></mtd></mtr><mtr><mtd><mi>undefined</mi></mtd><mtd columnalign="left"><mtext>, 如果对于每个</mtext><mrow><mi>i</mi><mo>&ge;</mo><mn>0</mn></mrow><mtext>有</mtext><mrow><mrow><mi>b</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>c</mi><mi>i</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>true</mi></mrow></mtd></mtr></mtable></mrow></mrow></mrow></math>定义的部分函数, 证明<math><msub><mi>w</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub></math>满足不动点方程<math display="block"><mrow><msub><mi>w</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>=</mo><mrow><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>.</mtext></math></li><li>对于<math><mrow><mi>b</mi><mo>=</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><ms>true</ms><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>=</mo><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mi>true</mi></mrow></mrow></math>和<math><mrow><mi>c</mi><mo>=</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><ms>skip</ms><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>=</mo><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mi>s</mi></mrow></mrow></math>, 描述函数<math><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub></math>. 什么样的从状态到状态的部分函数是<math><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub></math>的不动点呢? 相对于<math><mo>&sqsube;</mo></math>的最小不动点是什么呢? 这个最小不动点和<math><mrow><ms>while</ms><mtext>&nbsp;</mtext><ms>true</ms><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><ms>skip</ms></mrow></math>的操作语义所确定的从状态到状态的部分函数是一致的吗?</li></ol></div><div class="exercise"><b>练习3.</b> 说明幻灯片13上的关系<math><mo>&sqsube;</mo></math>的确是一个偏序, 而且<math><mi>&bottom;</mi></math>是最小元.</div><div class="exercise"><b>练习4.</b> 证明<math><msub><mi>w</mi><mi>&infin;</mi></msub></math>的确是<math><mi>f</mi></math>的最小不动点. 更一般地, 根据幻灯片13和练习2的定义, 证明对于任意的<math><mrow><mi>w</mi><mo>&in;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>, 有<math display="block"><mrow><mrow><mi>w</mi><mo>=</mo><mrow><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&Implies;</mo><mrow><msub><mi>w</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>&sqsube;</mo><mi>w</mi></mrow></mrow><mtext>.</mtext></math></div><h2>第2章 最小不动点</h2><p>本章介绍了被称为<em>domain论</em>的数学理论, 其为构造各种编程语言特性的指称语义中所用到的最小不动点提供了一个一般性的框架. 该理论是由Dana Scott提出的.</p><h3>第2.1节 偏序集和单调函数</h3><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>论点</b></div><hr/><ul><li>所有计算的domain都是带有最小元的偏序集.</li><li>所有可计算函数都是单调的.</li></ul></div></td></tr><tr><td align="center">幻灯片14</td></tr></table><h4>第2.1.1小节 偏序集</h4><p>domain论使用满足特定完备性质的偏序集. 我们在幻灯片15中回顾了<em>偏序</em>的定义. <math><mi>D</mi></math>被称为偏序集<math><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>的<em>基础集(underlying set)</em>. 大部分时候, 我们只以基础集的名字引用偏序集, 而以相同的符号<math><mo>&sqsube;</mo></math>代表不同偏序集的偏序.</p><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>偏序集</b></div><hr/>集合<math><mi>D</mi></math>上的二元关系<math><mo>&sqsube;</mo></math>是一个偏序, 当且仅当它是<ul><li>自反的: <math><mrow><mo>&forall;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mi>d</mi><mo>&sqsube;</mo><mi>d</mi></mrow></mrow></math>;</li><li>传递的: <math><mrow><mo>&forall;</mo><mrow><mrow><mi>d</mi><mo>,</mo><msup><mi>d</mi><mo>&prime;</mo></msup><mo>,</mo><msup><mi>d</mi><mo>&Prime;</mo></msup></mrow><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&prime;</mo></msup><mo>&sqsube;</mo><msup><mi>d</mi><mo>&Prime;</mo></msup></mrow><mo>&Implies;</mo><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&Prime;</mo></msup></mrow></mrow></mrow></math>;</li><li>反对称的: <math><mrow><mo>&forall;</mo><mrow><mrow><mi>d</mi><mo>,</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&prime;</mo></msup><mo>&sqsube;</mo><mi>d</mi></mrow><mo>&Implies;</mo><mrow><mi>d</mi><mo>=</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow></mrow></mrow></math>.</li></ul>序对<math><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>被称为一个<em>偏序集</em>.</div></td></tr><tr><td align="center">幻灯片15</td></tr></table><div class="tcomment"><b>译者注记.</b> <math><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&prime;</mo></msup><mo>&sqsube;</mo><msup><mi>d</mi><mo>&Prime;</mo></msup></mrow></math>是<math><mrow><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mo>&amp;</mo><mrow><msup><mi>d</mi><mo>&prime;</mo></msup><mo>&sqsube;</mo><msup><mi>d</mi><mo>&Prime;</mo></msup></mrow></mrow></math>的缩写.</div><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>偏序集公理: 规则形式</b></div><hr/><math display="block"><mfrac displaystyle="true"><mrow/><mrow><mi>x</mi><mo>&sqsube;</mo><mi>x</mi></mrow></mfrac></math><br/><math display="block"><mfrac displaystyle="true"><mrow><mrow><mi>x</mi><mo>&sqsube;</mo><mi>y</mi></mrow><mspace width="8ex"/><mrow><mi>y</mi><mo>&sqsube;</mo><mi>z</mi></mrow></mrow><mrow><mi>x</mi><mo>&sqsube;</mo><mi>z</mi></mrow></mfrac></math><br/><math display="block"><mfrac displaystyle="true"><mrow><mrow><mi>x</mi><mo>&sqsube;</mo><mi>y</mi></mrow><mspace width="8ex"/><mrow><mi>y</mi><mo>&sqsube;</mo><mi>x</mi></mrow></mrow><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow></mfrac></math></div></td></tr><tr><td align="center">幻灯片16</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b><math><mrow><mtext>部分函数的domain,&nbsp;</mtext><mrow><mi>X</mi><mo>&RightVector;</mo><mi>Y</mi></mrow></mrow></math></b></div><hr/><ul><li>基础集: 由所有定义域<math><mrow><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sube;</mo><mi>X</mi></mrow></math>且取值于<math><mi>Y</mi></math>的部分函数<math><mi>f</mi></math>构成.</li><li>偏序: <math><mrow><mi>f</mi><mo>&sqsube;</mo><mi>g</mi></mrow></math>当且仅当<math><mrow><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sube;</mo><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>且<math><mrow><mo>&forall;</mo><mrow><mi>x</mi><mo>&in;</mo><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo lspace="0">.</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>, 或者说<math><mrow><mrow><mi>graph</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sube;</mo><mrow><mi>graph</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.</li></ul></div></td></tr><tr><td align="center">幻灯片17</td></tr></table><div class="tcomment"><b>译者注记.</b> 实在是一点可有可无且无聊的注记. 若<math><mrow><mi>A</mi><mo>&sube;</mo><mi>X</mi></mrow></math>而<math><mrow><mi>B</mi><mo>&sube;</mo><mi>Y</mi></mrow></math>, 那么应该将<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&RightVector;</mo><mi>B</mi></mrow></mrow></math>也视为<math><mrow><mi>X</mi><mo>&RightVector;</mo><mi>Y</mi></mrow></math>的元素吗 (假设排除<math><mrow><mi>A</mi><mo>=</mo><mi>X</mi></mrow></math>且<math><mrow><mi>B</mi><mo>=</mo><mi>Y</mi></mrow></math>的平凡情形)? 这是微妙的, 往往取决于具体的上下文.</div><div class="example"><b>例子1.</b> 从集合<math><mi>X</mi></math>到集合<math><mi>Y</mi></math>的所有部分函数构成的集合<math><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>&RightVector;</mo><mi>Y</mi></mrow><mo stretchy="false">)</mo></mrow></math>可以看成是一个偏序集, 如幻灯片17那样. 前一章里, 我们取这个domain在<math><mrow><mi>X</mi><mo>=</mo><mi>Y</mi><mo>=</mo><mi>State</mi></mrow></math> (某个状态集合) 情形下的实例作为命令的指称集.</div><h4>第2.1.2小节 单调函数</h4><p>幻灯片18中给出了偏序集之间的单调映射的概念.</p><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>单调性</b></div><hr/>两个偏序集之间的函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></mrow></math>是<em>单调的</em>, 如果<math display="block"><mrow><mo>&forall;</mo><mrow><mrow><mi>d</mi><mo>,</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mo>&Implies;</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msup><mi>d</mi><mo>&prime;</mo></msup><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow><mtext>.</mtext></math><br/><math display="block"><mfrac displaystyle="true"><mrow><mi>x</mi><mo>&sqsube;</mo><mi>y</mi></mrow><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mfrac><mspace width="8ex"/><mtext>(</mtext><mi>f</mi><mtext>单调)</mtext></math></div></td></tr><tr><td align="center">幻灯片18</td></tr></table><div class="example"><b>例子2.</b> 给定偏序集<math><mi>D</mi></math>和<math><mi>E</mi></math>, 显然常函数<math><mrow><mrow><mi>&lambda;</mi><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mi>e</mi></mrow><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></mrow></math>是单调的.</div><div class="example"><b>例子3.</b> 当<math><mi>D</mi></math>是部分函数的domain <math><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow></math> (见幻灯片17) 时, 幻灯片11上定义的与<math><ms>while</ms></math>循环的指称语义有关的函数<math><mrow><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>是一个单调函数. 我们将其验证留作练习.</div><h3>第2.2节 最小元和前不动点 (pre-fixed point)</h3><div class="definition"><b>定义1.</b> 设<math><mi>D</mi></math>是一个偏序集, <math><mi>S</mi></math>是<math><mi>D</mi></math>的一个子集, <math><mrow><mi>d</mi><mo>&in;</mo><mi>S</mi></mrow></math>被称为<math><mi>S</mi></math>的<em>最小</em>元, 如果其满足<math display="block"><mrow><mo>&forall;</mo><mrow><mi>x</mi><mo>&in;</mo><mi>S</mi></mrow><mo lspace="0">.</mo><mrow><mi>d</mi><mo>&sqsube;</mo><mi>x</mi></mrow></mrow><mtext>.</mtext></math></div><p>注意到因为<math><mo>&sqsube;</mo></math>是反对称的, 所以<math><mi>S</mi></math>至多拥有一个最小元. 我们也应该注意到, 有的偏序集是没有最小元的. 例如, 带有通常偏序的<math><mi>&Zopf;</mi></math>.</p><p>函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>的一个<em>不动点</em>, 根据定义, 是满足<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>d</mi></mrow></math>的一个元素<math><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow></math>. 如果<math><mi>D</mi></math>是一个偏序集, 我们可以考虑一个更弱的概念, 即<em>前不动点</em>, 见幻灯片19.</p><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>前不动点</b></div><hr/>令<math><mi>D</mi></math>是一个偏序集而<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>是一个函数.<br/>一个元素<math><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow></math>是<math><mi>f</mi></math>的一个<em>前不动点</em>, 如果其满足<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></math>.<br/><math><mi>f</mi></math>的<em>最小前不动点</em>, 如果存在的话, 记作<math display="block"><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mtext>.</mtext></math>因此, 最小前不动点由以下两条性质(唯一地)刻画:<ul><li>(lpf1): <math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>;</li><li>(lpf2): <math><mrow><mo>&forall;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow><mo>&Implies;</mo><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></mrow></mrow></math>.</li></ul></div></td></tr><tr><td align="center">幻灯片19</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>证明原理</b></div><hr/><ol><li><math display="block"><mfrac displaystyle="true"><mrow/><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mfrac></math></li><li>令<math><mi>D</mi></math>是一个偏序集, <math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>是一个带有最小前不动点<math><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&in;</mo><mi>D</mi></mrow></math>的函数.<br/>对于任意的<math><mrow><mi>x</mi><mo>&in;</mo><mi>D</mi></mrow></math>, 为了证明<math><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>x</mi></mrow></math>, 只需要证明<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>x</mi></mrow></math>.<math display="block"><mfrac displaystyle="true"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>x</mi></mrow><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>x</mi></mrow></mfrac></math></li></ol></div></td></tr><tr><td align="center">幻灯片20</td></tr></table><div class="proposition"><b>命题2.</b> 设<math><mi>D</mi></math>是一个偏序集而<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>是一个带有最小前不动点<math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>的函数. 只要<math><mi>f</mi></math>是单调的, 那么<math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>实际上就是<math><mi>f</mi></math>的一个不动点, 因此也是<math><mi>f</mi></math>的最小不动点.</div><div class="proof"><b>证明.</b> 因为<math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>是<math><mi>f</mi></math>的前不动点, 所以<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>. 如果<math><mi>f</mi></math>是单调的, 那么<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>.</mtext></math>换言之, <math><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>也是<math><mi>f</mi></math>的一个前不动点. 但是, 鉴于<math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>是最小的前不动点, 我们可以推出<math display="block"><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>.</mtext></math>根据偏序的反对称性, 我们可以断言<math display="block"><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>即<math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>是<math><mi>f</mi></math>的一个不动点. 而且, 考虑到偏序的自反性, 不动点也是前不动点. 对于任意的<math><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow></math>满足<math><mrow><mi>d</mi><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, 我们有<math><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></math>. 换言之, <math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>是<math><mi>f</mi></math>的最小不动点.<div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><h3>第2.3节 完全偏序 (cpo) 和连续函数</h3><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>论点*</b></div><hr/><ul><li>所有计算的domain都是带有最小元的完全偏序.</li><li>所有可计算函数都是连续的.</li></ul></div></td></tr><tr><td align="center">幻灯片21</td></tr></table><h4>第2.3.1小节 domain</h4><div class="definition"><b>定义1.</b> <ol type="i"><li>若存在, 我们将偏序集<math><mi>D</mi></math>的最小元记为<math><msub><mi>&bottom;</mi><mi>D</mi></msub></math>. 若<math><mi>D</mi></math>在上下文中是已知的, 写成<math><mi>&bottom;</mi></math>就可以了. 因此, <math><mi>&bottom;</mi></math>由性质<math display="block"><mrow><mo>&forall;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mi>&bottom;</mi><mo>&sqsube;</mo><mi>d</mi></mrow></mrow></math>唯一确定. 偏序集的最小元有时也被称为其<em>底(bottom)</em>元素.</li><li>偏序集<math><mi>D</mi></math>中的一个可数的升<em>链</em>是由<math><mi>D</mi></math>的元素构成的一个序列满足<math display="block"><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>这样的链的一个<em>上界</em>是任意满足<math><mrow><mo>&forall;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow><mo lspace="0">.</mo><mrow><msub><mi>d</mi><mi>n</mi></msub><mo>&sqsube;</mo><mi>d</mi></mrow></mrow></math>的<math><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow></math>. 若链的<em>最小上界(lub)</em>存在, 我们将其记为<math display="block"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mtext>.</mtext></math>因此, 根据定义:<ul><li><math><mrow><mo>&forall;</mo><mrow><mi>m</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow><mo lspace="0">.</mo><mrow><msub><mi>d</mi><mi>m</mi></msub><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow></mrow></mrow></math>.</li><li>对于任意的<math><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow></math>, 如果<math><mrow><mo>&forall;</mo><mrow><mi>m</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow><mo lspace="0">.</mo><mrow><msub><mi>d</mi><mi>m</mi></msub><mo>&sqsube;</mo><mi>d</mi></mrow></mrow></math>, 那么<math><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></math>.</li></ul></li></ol></div><div class="tcomment"><b>译者注记.</b> 所谓的链, 指的是偏序集的全序子集. 不过, 本讲义实际上只考虑以(通常的)序列面目出现的可数的升链.</div><div class="remark"><b>评注2.</b> 以下是读者应该注意的点.<ol type="i"><li>我们不需要考虑偏序集中不可数的链, 或者降链: 因此, &quot;链&quot;将总是指可数的升链.</li><li>就和偏序集的任意子集的最小元一样, 链的最小上界若存在则唯一. 当然, 链可以没有最小上界, 例如<math><mi>&Nopf;</mi></math>中的<math><mrow><mn>0</mn><mo>&le;</mo><mn>1</mn><mo>&le;</mo><mn>2</mn><mo>&le;</mo><mo>&hellip;</mo></mrow></math>, 不过它连上界也没有.</li><li>最小上界有时也被称为<em>上确界</em>. <math><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow></math>的一些其他常见替代记号为<math display="block"><mrow><munderover><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mi>&infin;</mi></munderover><msub><mi>d</mi><mi>n</mi></msub></mrow><mtext>和</mtext><mrow><mo>&bigsqcup;</mo><mrow><mo stretchy="false">{</mo><mrow><msub><mi>d</mi><mi>n</mi></msub><mo stretchy="false">|</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow><mtext>.</mtext></math></li><li>链的元素不必是互异的. 实际上, 我们称一个链<math><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math><em>终至恒常</em>, 如果存在<math><mrow><mi>N</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>使得<math><mrow><mo>&forall;</mo><mrow><mi>n</mi><mo>&ge;</mo><mi>N</mi></mrow><mo lspace="0">.</mo><mrow><msub><mi>d</mi><mi>n</mi></msub><mo>=</mo><msub><mi>d</mi><mi>N</mi></msub></mrow></mrow></math>. 注意到此时<math><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo>=</mo><msub><mi>d</mi><mi>N</mi></msub></mrow></math>.</li><li>如果我们丢弃链的开头任意有限数目的元素, 也并不会影响其上界集和最小上界:<math display="block"><mrow><mo>&forall;</mo><mrow><mi>N</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow><mo lspace="0">.</mo><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>N</mi><mo>+</mo><mi>n</mi></mrow></msub></mrow></mrow></mrow><mtext>.</mtext></math></li></ol></div><table class="label" align="center"><tr><td><div class="slide" style="width: 500px; height: 300px"><div align="center"><b>cpo和domain</b></div><hr/>一个<em>链完备偏序集(chain-complete poset)</em>, 或者说缩写为<em>cpo</em>, 是一个偏序集<math><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>满足其中的每个链<math><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>都具有最小上界<math><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow></math>:<ul><li>(lub1): <math><mrow><mo>&forall;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow><mo lspace="0">.</mo><mrow><msub><mi>d</mi><mi>m</mi></msub><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow></mrow></mrow></math>;</li><li>(lub2): <math><mrow><mo>&forall;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mo>&forall;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow><mo lspace="0">.</mo><mrow><msub><mi>d</mi><mi>m</mi></msub><mo>&sqsube;</mo><mi>d</mi></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>&Implies;</mo><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></mrow></mrow></math>.</li></ul>一个<em>domain</em>是一个带有最小元<math><mi>&bottom;</mi></math>的cpo:<math display="block"><mrow><mo>&forall;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mi>&bottom;</mi><mo>&sqsube;</mo><mi>d</mi></mrow></mrow><mtext>.</mtext></math></div></td></tr><tr><td align="center">幻灯片22</td></tr></table><div class="tcomment"><b>译者注记.</b> 幻灯片22的两个冒号后面的内容, 只是为了解释什么是最小上界和最小元. 另外, 链完备偏序集也被称为完全偏序, complete partial order.</div><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>最小元和最小上界的定义: 规则形式</b></div><hr/><math display="block"><mfrac displaystyle="true"><mrow/><mrow><mi>&bottom;</mi><mo>&sqsube;</mo><mi>x</mi></mrow></mfrac></math><br/><math display="block"><mfrac displaystyle="true"><mrow/><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>x</mi><mi>n</mi></msub></mrow></mrow></mfrac><mspace width="4ex"/><mtext>(</mtext><mrow><mi>i</mi><mo>&ge;</mo><mn>0</mn></mrow><mtext>而</mtext><mrow><mo stretchy="false">&lang;</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mtext>是一个链)</mtext></math><br/><math display="block"><mfrac displaystyle="true"><mrow><mo>&forall;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow><mo lspace="0">.</mo><mrow><msub><mi>x</mi><mi>m</mi></msub><mo>&sqsube;</mo><mi>x</mi></mrow></mrow><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>x</mi><mi>n</mi></msub></mrow><mo>&sqsube;</mo><mi>x</mi></mrow></mfrac><mspace width="4ex"/><mtext>(</mtext><mrow><mo stretchy="false">&lang;</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mtext>是一个链)</mtext></math></div></td></tr><tr><td align="center">幻灯片23</td></tr></table><p>本讲义里我们关心的是具有特定完备性质的偏序集, 见幻灯片22. 读者应该注意的是, 在有关的指称语义的文献中, 术语&quot;domain&quot;的含义是相当宽泛的: 存在各种各样的domain, 它们可能具有各种各样的序论性质, 而不仅仅是满足链完备性质和拥有最小元.</p><div class="example"><b>例子3.</b> 从集合<math><mi>X</mi></math>到集合<math><mi>Y</mi></math>的所有部分函数的集合<math><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>&RightVector;</mo><mi>Y</mi></mrow><mo stretchy="false">)</mo></mrow></math>上可以赋予一个偏序成为domain, 见幻灯片24. 在第1.2节, 我们使用了<math><mrow><mi>X</mi><mo>=</mo><mi>Y</mi><mo>=</mo><mi>State</mi></mrow></math>的特殊情形作为命令的指称集. 我们应该注意到, 声称是链<math><mrow><msub><mi>f</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>f</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>f</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>的最小上界的<math><mi>f</mi></math>的确是一个良定的部分函数, 因为在有定义的地方, 每个<math><msub><mi>f</mi><mi>n</mi></msub></math>的值都是一致的. 至于验证<math><mi>f</mi></math>的确是偏序集<math><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>X</mi><mo>&RightVector;</mo><mi>Y</mi></mrow><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>中的<math><mrow><msub><mi>f</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>f</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>f</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>的最小上界, 我们将其留给读者作为练习.</div><table class="label" align="center"><tr><td><div class="slide" style="height: 250px; width: 500px"><div align="center"><b><math><mrow><mtext>部分函数的domain,&nbsp;</mtext><mrow><mi>X</mi><mo>&RightVector;</mo><mi>Y</mi></mrow></mrow></math></b></div><hr/><b>基础集: </b>由所有满足以下条件的部分函数<math><mi>f</mi></math>构成, 其定义域<math><mrow><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sube;</mo><mi>X</mi></mrow></math>而取值于<math><mi>Y</mi></math>.<br/><b>偏序: </b><math><mrow><mi>f</mi><mo>&sqsube;</mo><mi>g</mi></mrow></math>当且仅当<math><mrow><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sube;</mo><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>且<math><mrow><mo>&forall;</mo><mrow><mi>x</mi><mo>&in;</mo><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo lspace="0">.</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>, 或者说<math><mrow><mrow><mi>graph</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sube;</mo><mrow><mi>graph</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.<br/><b>链的最小上界: </b>链<math><mrow><msub><mi>f</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>f</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>f</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>的最小上界是部分函数<math><mi>f</mi></math>, 其<math><mrow><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>而<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>, 如果存在某个</mtext><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow><mtext>使得</mtext><mrow><mi>x</mi><mo>&in;</mo><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mi>undefined</mi></mtd><mtd columnalign="left"><mtext>, 否则的话</mtext></mtd></mtr></mtable></mrow></mrow></math><b>最小元素: </b><math><mi>&bottom;</mi></math>是全然未定义的部分函数.</div></td></tr><tr><td align="center">幻灯片24</td></tr></table><div class="example"><b>例子4.</b> 对于任意的偏序集<math><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>而言, 如果<math><mi>D</mi></math>是有限的, 那么该偏序集是一个cpo. 这是因为, 在这样的偏序集中, 任何链都将终至恒常, 因而拥有最小上界. 当然, 有限的偏序集也不一定拥有最小元, 即不是一个domain. 例如, 考虑以下Hasse图所描述的偏序集.<svg width="320" height="150" stroke="black" style="display: block; margin: auto;"><defs><marker id="arrow" viewbox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 2 L 6 5 L 0 8 z"/></marker></defs><circle cx="60" cy="120" r="4"/><circle cx="260" cy="120" r="4"/><circle cx="160" cy="30" r="4"/><line x1="75" y1="106" x2="145" y2="44" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="245" y1="106" x2="175" y2="44" marker-end="url(#arrow)" stroke-width="1.2px"/></svg>一个偏序集的<em>Hasse图</em>是一个有向图, 其顶点是偏序集的基础集的元素, 而从顶点<math><mi>x</mi></math>到顶点<math><mi>y</mi></math>有一条边当且仅当<math><mrow><mi>x</mi><mo>&ne;</mo><mi>y</mi></mrow></math>且<math><mrow><mo>&forall;</mo><mi>z</mi><mo lspace="0">.</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>x</mi><mo>&sqsube;</mo><mi>z</mi></mrow><mo>&amp;</mo><mrow><mi>z</mi><mo>&sqsube;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>&Implies;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>z</mi><mo>=</mo><mi>x</mi></mrow><mo>&or;</mo><mrow><mi>z</mi><mo>=</mo><mi>y</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.</div><table class="label" align="center"><tr><td><svg width="500" height="400" stroke="black" style="display: block; margin: auto;"><defs><marker id="arrow" viewbox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 2 L 6 5 L 0 8 z"/></marker></defs><foreignObject x="23" y="36" width="150" height="30">&quot;扁平自然数集&quot;<math><msub><mi>&Nopf;</mi><mi>&bottom;</mi></msub></math>:</foreignObject><foreignObject x="53" y="66" width="150" height="30"><math><mn>0</mn></math></foreignObject><foreignObject x="113" y="66" width="150" height="30"><math><mn>1</mn></math></foreignObject><foreignObject x="173" y="66" width="150" height="30"><math><mn>2</mn></math></foreignObject><foreignObject x="233" y="66" width="150" height="30"><math><mo>&ctdot;</mo></math></foreignObject><foreignObject x="293" y="66" width="150" height="30"><math><mi>n</mi></math></foreignObject><foreignObject x="353" y="66" width="150" height="30"><math><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></math></foreignObject><foreignObject x="443" y="66" width="150" height="30"><math><mo>&ctdot;</mo></math></foreignObject><foreignObject x="233" y="126" width="150" height="30"><math><mi>&bottom;</mi></math></foreignObject><line x1="222" y1="125" x2="78" y2="85" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="228" y1="125" x2="132" y2="85" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="234" y1="125" x2="186" y2="85" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="246" y1="125" x2="294" y2="85" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="252" y1="125" x2="348" y2="85" marker-end="url(#arrow)" stroke-width="1.2px"/><foreignObject x="23" y="156" width="150" height="30">&quot;垂直自然数集&quot;<math><mi mathvariant="normal">&Omega;</mi></math>:</foreignObject><foreignObject x="233" y="186" width="150" height="30"><math><mi>&omega;</mi></math></foreignObject><foreignObject x="218" y="226" width="150" height="30"><math><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></math></foreignObject><foreignObject x="233" y="266" width="150" height="30"><math><mi>n</mi></math></foreignObject><foreignObject x="233" y="306" width="150" height="30"><math><mn>2</mn></math></foreignObject><foreignObject x="233" y="346" width="150" height="30"><math><mn>1</mn></math></foreignObject><foreignObject x="233" y="386" width="150" height="30"><math><mn>0</mn></math></foreignObject><line x1="237" y1="383" x2="237" y2="366" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="237" y1="343" x2="237" y2="326" marker-end="url(#arrow)" stroke-width="1.2px"/><foreignObject x="236" y="286" width="150" height="30"><math><mo>&vellip;</mo></math></foreignObject><line x1="237" y1="263" x2="237" y2="246" marker-end="url(#arrow)" stroke-width="1.2px"/><foreignObject x="236" y="206" width="150" height="30"><math><mo>&vellip;</mo></math></foreignObject></svg></td></tr><tr><td align="center">图1</td></tr></table><p>图1展示两个非常简单但却无限的domain, 而以下是两个并非cpo的偏序集的例子.</p><div class="example"><b>例子5.</b> 装备有通常偏序<math><mo>&le;</mo></math>的自然数集<math><mrow><mi>&Nopf;</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mo>&hellip;</mo></mrow><mo stretchy="false">}</mo></mrow></mrow></math>不是一个cpo, 因为链<math><mrow><mn>0</mn><mo>&le;</mo><mn>1</mn><mo>&le;</mo><mn>2</mn><mo>&le;</mo><mo>&hellip;</mo></mrow></math>在<math><mi>&Nopf;</mi></math>中没有上界.</div><div class="example"><b>例子6.</b> 考虑上图的第二个例子的一种修改版本, 其中我们为<math><mi>&Nopf;</mi></math>添加了两个不同的上界<math><mrow><msub><mi>&omega;</mi><mn>1</mn></msub><mo>&ne;</mo><msub><mi>&omega;</mi><mn>2</mn></msub></mrow></math>. 换言之, 我们考虑的是<math><mrow><mi>D</mi><mover><mo>=</mo><mi>def</mi></mover><mrow><mi>&Nopf;</mi><mo>&cup;</mo><mrow><mo stretchy="false">{</mo><mrow><msub><mi>&omega;</mi><mn>1</mn></msub><mo>,</mo><msub><mi>&omega;</mi><mn>2</mn></msub></mrow><mo stretchy="false">}</mo></mrow></mrow></mrow></math>, 而其上的偏序<math><mo>&sqsube;</mo></math>为<math display="block"><mrow><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mover><mo>&hArr;</mo><mi>def</mi></mover><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mi>d</mi><mo>&le;</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mrow><mi>d</mi><mo>,</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mo>&in;</mo><mi>&Nopf;</mi></mrow></mtd></mtr><mtr><mtd><mrow><mrow><mi>d</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow><mo>&or;</mo><mrow><mi>d</mi><mo>=</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><msup><mi>d</mi><mo>&prime;</mo></msup><mo>&in;</mo><mrow><mo stretchy="false">{</mo><mrow><msub><mi>&omega;</mi><mn>1</mn></msub><mo>,</mo><msub><mi>&omega;</mi><mn>2</mn></msub></mrow><mo stretchy="false">}</mo></mrow></mrow></mtd></mtr></mtable></mrow></mrow></math>然后, <math><mi>D</mi></math>中的链<math><mrow><mn>0</mn><mo>&sqsube;</mo><mn>1</mn><mo>&sqsube;</mo><mn>2</mn><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>拥有两个上界, 即<math><msub><mi>&omega;</mi><mn>1</mn></msub></math>和<math><msub><mi>&omega;</mi><mn>2</mn></msub></math>, 但是没有最小的上界, 因为<math><msub><mi>&omega;</mi><mn>1</mn></msub></math>和<math><msub><mi>&omega;</mi><mn>2</mn></msub></math>不可比较. 因此, <math><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>不是一个cpo.</div><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>链的最小上界的一些性质</b></div><hr/>设<math><mi>D</mi></math>是一个cpo.<ol><li>对于任意的<math><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow></math>, <math><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mi>d</mi></mrow><mo>=</mo><mi>d</mi></mrow></math>.</li><li>对于<math><mi>D</mi></math>中的每个链<math><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>1</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo><mo>&sqsube;</mo><msub><mi>d</mi><mi>n</mi></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>, 我们有<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>N</mi><mo>+</mo><mi>n</mi></mrow></msub></mrow></mrow></math>对于任意的<math><mrow><mi>N</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>成立.</li></ol></div></td></tr><tr><td align="center">幻灯片25</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>链的最小上界的一些性质 (续)</b></div><hr/><ol start="3"><li>对于<math><mi>D</mi></math>中的两条链<math><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>1</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo><mo>&sqsube;</mo><msub><mi>d</mi><mi>n</mi></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>和<math><mrow><msub><mi>e</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>e</mi><mn>1</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo><mo>&sqsube;</mo><msub><mi>e</mi><mi>n</mi></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>, 如果对于每个<math><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>有<math><mrow><msub><mi>d</mi><mi>n</mi></msub><mo>&sqsube;</mo><msub><mi>e</mi><mi>n</mi></msub></mrow></math>, 那么<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>e</mi><mi>n</mi></msub></mrow></mrow><mtext>.</mtext></math></li></ol><math display="block"><mfrac displaystyle="true"><mrow><mo>&forall;</mo><mrow><mi>n</mi><mo>&in;</mo><mn>0</mn></mrow><mo lspace="0">.</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>&sqsube;</mo><msub><mi>y</mi><mi>n</mi></msub></mrow></mrow><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>x</mi><mi>n</mi></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>y</mi><mi>n</mi></msub></mrow></mrow></mfrac><mspace width="4ex"/><mtext>(</mtext><mrow><mo stretchy="false">&lang;</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mtext>和</mtext><mrow><mo stretchy="false">&lang;</mo><msub><mi>y</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mtext>俱是链)</mtext></math></div></td></tr><tr><td align="center">幻灯片26</td></tr></table><table class="label" align="center"><tr><td><div class="slide" style="height: 300px"><div align="center"><b>双链的对角化</b></div><hr/><div class="lemma"><b>引理.</b> 令<math><mi>D</mi></math>是一个cpo, 设双下标索引的元素<math><mrow><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub><mo>&in;</mo><mi>D</mi></mrow></math> (其中<math><mrow><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow><mo>&ge;</mo><mn>0</mn></mrow></math>) 构成的族满足<math display="block"><mrow><mrow><mrow><mi>m</mi><mo>&le;</mo><msup><mi>m</mi><mo>&prime;</mo></msup></mrow><mo>&amp;</mo><mrow><mi>n</mi><mo>&le;</mo><msup><mi>n</mi><mo>&prime;</mo></msup></mrow></mrow><mo>&Implies;</mo><mrow><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub><mo>&sqsube;</mo><msub><mi>d</mi><mrow><msup><mi>m</mi><mo>&prime;</mo></msup><mo>,</mo><msup><mi>n</mi><mo>&prime;</mo></msup></mrow></msub></mrow></mrow></math>那么我们有<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mn>0</mn><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mn>1</mn><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mn>2</mn><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>以及<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mn>0</mn></mrow></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mn>1</mn></mrow></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mn>2</mn></mrow></msub></mrow><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>而且<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>k</mi><mo>,</mo><mi>k</mi></mrow></msub></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>.</mtext></math></div></div></td></tr><tr><td align="center">幻灯片27</td></tr></table><div class="proof"><b>证明.</b> 我们利用了定义链的最小上界的性质, 即幻灯片22上的(lub1)和(lub2). 首先, 注意到如果<math><mrow><mi>m</mi><mo>&le;</mo><msup><mi>m</mi><mo>&prime;</mo></msup></mrow></math>, 那么<math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub></mtd><mtd><mo>&sqsube;</mo></mtd><mtd><msub><mi>d</mi><mrow><msup><mi>m</mi><mo>&prime;</mo></msup><mo>,</mo><mi>n</mi></mrow></msub></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>&sqsube;</mo></mtd><mtd><mrow><munder><mo>&bigsqcup;</mo><mrow><msup><mi>n</mi><mo>&prime;</mo></msup><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><msup><mi>m</mi><mo>&prime;</mo></msup><mo>,</mo><msup><mi>n</mi><mo>&prime;</mo></msup></mrow></msub></mrow></mtd></mtr></mtable></math>对于每个<math><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></math>成立. 因此, <math><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><msup><mi>n</mi><mo>&prime;</mo></msup><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><msup><mi>m</mi><mo>&prime;</mo></msup><mo>,</mo><msup><mi>n</mi><mo>&prime;</mo></msup></mrow></msub></mrow></mrow></math>. 于是, 我们的确可以得到一条由最小上界构成的链<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mn>0</mn><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mn>1</mn><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mn>2</mn><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>并且我们可以构造其最小上界<math><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub></mrow></mrow></math>. 运用两次(lub1), 我们有<math display="block"><mrow><msub><mi>d</mi><mrow><mi>k</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>k</mi><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub></mrow></mrow></mrow></math>对于每个<math><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow></math>成立, 那么根据(lub2)可以得到<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>k</mi><mo>,</mo><mi>k</mi></mrow></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub></mrow></mrow></mrow></math>反过来, 对于每个<math><mrow><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow><mo>&ge;</mo><mn>0</mn></mrow></math>, 我们注意到<math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub></mtd><mtd><mo>&sqsube;</mo></mtd><mtd><msub><mi>d</mi><mrow><mrow><mi>max</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><mi>max</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></msub></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>&sqsube;</mo></mtd><mtd><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>k</mi><mo>,</mo><mi>k</mi></mrow></msub></mrow></mtd></mtr></mtable></math>因而再应用两次(lub2)就可以推出<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub></mrow></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>k</mi><mo>,</mo><mi>k</mi></mrow></msub></mrow></mrow></math>根据<math><mo>&sqsube;</mo></math>的反对称性, 我们就得出了想要的等式. 剩余的结果也可按照相同的论证手法得到, 只需要交换<math><mi>m</mi></math>和<math><mi>n</mi></math>的角色.<div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><h4>第2.3.2小节 连续函数</h4><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>连续性和严格性</b></div><hr/><ul><li>如果<math><mi>D</mi></math>和<math><mi>E</mi></math>是cpo, 函数<math><mi>f</mi></math>是<em>连续的</em>当且仅当<ol><li><math><mi>f</mi></math>是单调的;</li><li><math><mi>f</mi></math>保持链的最小上界, 即对于<math><mi>D</mi></math>中的每条链<math><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>1</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>, 我们有<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mtext>.</mtext></math></li></ol></li><li>如果<math><mi>D</mi></math>和<math><mi>E</mi></math>都拥有最小元, 那么称函数<math><mi>f</mi></math>是<em>严格的</em>, 如果<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>&bottom;</mi></mrow></math>.</li></ul></div></td></tr><tr><td align="center">幻灯片28</td></tr></table><div class="remark"><b>评注7.</b> 我们注意到如果<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></mrow></math>是单调的, 并且<math><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>是<math><mi>D</mi></math>中的一个链, 那么应用<math><mi>f</mi></math>就可以得到<math><mi>E</mi></math>中的一个链<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>. 而且, 如果<math><mi>d</mi></math>是第一条链的一个上界, 那么<math><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></math>是第二条链的一个上界. 换言之, 如果<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></mrow></math>是cpo之间的单调函数, 我们总有<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>因此, 根据<math><mo>&sqsube;</mo></math>的固有性质, 给定cpo之间的单调函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></mrow></math>, <math><mi>f</mi></math>是连续的等价于对于<math><mi>D</mi></math>中的每条链<math><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>, <math><mi>E</mi></math>中<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>成立.</div><div class="example"><b>例子8.</b> 给定cpo <math><mi>D</mi></math>和<math><mi>E</mi></math>, 对于每个<math><mrow><mi>e</mi><mo>&in;</mo><mi>E</mi></mrow></math>而言, 常函数<math><mrow><mrow><mi>&lambda;</mi><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mi>e</mi></mrow><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></mrow></math>是连续的.</div><div class="example"><b>例子9.</b> 当<math><mi>D</mi></math>是部分函数的domain <math><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow></math>时 (见幻灯片24), 定义于幻灯片11的与<math><ms>while</ms></math>循环的指称语义有关的函数<math><mrow><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>是一个连续函数. 我们将其验证留作练习.</div><div class="example"><b>例子10.</b> 令<math><mi mathvariant="normal">&Omega;</mi></math>是垂直自然数的domain, 那么由<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mn>0</mn></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></mtd></mtr><mtr><mtd><mi>&omega;</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mi>&omega;</mi></mrow></mtd></mtr></mtable></mrow></mrow></math>定义的函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mi mathvariant="normal">&Omega;</mi><mo>&rarr;</mo><mi mathvariant="normal">&Omega;</mi></mrow></mrow></math>既是单调的也是严格的, 但是并非连续, 因为<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mi>n</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&omega;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>&omega;</mi></mrow></math>然而<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mn>0</mn></mrow><mo>=</mo><mn>0</mn></mrow></math></div><h3>第2.4节 Tarski不动点定理</h3><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>Tarski不动点定理</b></div><hr/>令<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>是domain <math><mi>D</mi></math>上的一个连续函数, 那么<ul><li><math><mi>f</mi></math>具有最小前不动点, 由<math display="block"><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>给出.</li><li>于是, <math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>也是<math><mi>f</mi></math>的不动点, 因而是<math><mi>f</mi></math>的<em>最小不动点</em>.</li></ul></div></td></tr><tr><td align="center">幻灯片29</td></tr></table><p>幻灯片29给出了关于domain上的连续函数的关键结果, 其允许我们赋予牵涉递归特性的程序以指称语义. 幻灯片上所用的记号<math><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></math>是递归定义的:<math display="block"><mrow><mrow><mrow><msup><mi>f</mi><mn>0</mn></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mover><mo>=</mo><mi>def</mi></mover><mi>&bottom;</mi></mrow><mo>;</mo><mrow><mrow><msup><mi>f</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mover><mo>=</mo><mi>def</mi></mover><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mtext>.</mtext></math>注意到既然<math><mrow><mo>&forall;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mi>&bottom;</mi><mo>&sqsube;</mo><mi>d</mi></mrow></mrow></math>, 我们有<math><mrow><mrow><mrow><msup><mi>f</mi><mn>0</mn></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>&bottom;</mi></mrow><mo>&sqsube;</mo><mrow><msup><mi>f</mi><mn>1</mn></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>; 而根据单调性, 又可以推出<math display="block"><mrow><mrow><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><msup><mi>f</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&Implies;</mo><mrow><mrow><mrow><msup><mi>f</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&sqsube;</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>f</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msup><mi>f</mi><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow><mtext>.</mtext></math>因此, 通过对于<math><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>进行归纳, 我们可以得到<math display="block"><mrow><mo>&forall;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow><mo lspace="0">.</mo><mrow><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><msup><mi>f</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mtext>.</mtext></math>换言之, 元素<math><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></math>构成了<math><mi>D</mi></math>中的一条链. 所以说, 既然<math><mi>D</mi></math>是cpo, 那么幻灯片29上用到的<math><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>的确是有意义的.</p><div class="proof"><b>证明.</b> 首先我们注意到<math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd columnalign="left"><mrow><mtext>根据</mtext><mi>f</mi><mtext>的连续性</mtext></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msup><mi>f</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd columnalign="left"><mtext>根据函数的幂次的定义</mtext></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd columnalign="left"><mtext>根据第2.3节的评注2</mtext></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></mtd></mtr></mtable></math>因此, <math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>的确是<math><mi>f</mi></math>的一个不动点, 当然也就满足幻灯片19上的条件(lpf1). 为了验证(lpf2), 即前不动点的最小性, 我们设<math><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow></math>满足<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></math>, 那么既然<math><mi>&bottom;</mi></math>在<math><mi>D</mi></math>是最小的, 可以得到<math display="block"><mrow><mrow><mrow><msup><mi>f</mi><mn>0</mn></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>&bottom;</mi></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></math>并且<math display="block"><mrow><mrow><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow><mo>&Implies;</mo><mrow><mrow><mrow><msup><mi>f</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></mrow></math>根据归纳, 我们可以推出<math><mrow><mo>&forall;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow><mo lspace="0">.</mo><mrow><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></mrow></math>. 换言之, <math><mi>d</mi></math>是链的一个上界, 所以它大于等于最小上界, 即<math display="block"><mrow><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></math>这就是我们想要的(lpf2)了.<div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><div class="example"><b>例子1.</b> 定义于幻灯片11上的函数<math><msub><mi>f</mi><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>,</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></msub></math>是domain <math><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow></math>上的一个连续函数, 因而我们可以应用Tarski不动点定理, 将<math><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></math>定义为<math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>,</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></msub><mo stretchy="false">)</mo></mrow></mrow></math>. 实际上, 第1.2节中我们构造部分函数<math><msub><mi>w</mi><mi>&infin;</mi></msub></math>的方法不过就是不动点定理的一个实例而已.</div><table class="label" align="center"><tr><td><div class="slide" style="width: 650px"><div align="center"><b><math><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></math></b></div><hr/><math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>,</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></msub><mo stretchy="false">)</mo></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msubsup><mi>f</mi><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>,</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow><mi>n</mi></msubsup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><msup><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mi>k</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>, 如果存在</mtext><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow><mtext>满足对于每个</mtext><mrow><mn>0</mn><mo>&le;</mo><mi>i</mi><mo>&lt;</mo><mi>k</mi></mrow><mtext>有</mtext></mtd></mtr><mtr><mtd><mrow/></mtd><mtd columnalign="left"><mrow><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mi>i</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>true</mi></mrow><mtext>而</mtext><mrow><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mi>k</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>false</mi></mrow></mtd></mtr><mtr><mtd><mi>undefined</mi></mtd><mtd columnalign="left"><mtext>, 如果对于每个</mtext><mrow><mi>i</mi><mo>&ge;</mo><mn>0</mn></mrow><mtext>有</mtext><mrow><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mi>i</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>true</mi></mrow></mtd></mtr></mtable></mrow></mrow></mtd></mtr></mtable></math></div></td></tr><tr><td align="center">幻灯片30</td></tr></table><h3>第2.5节 练习</h3><div class="exercise"><b>练习1.</b> 验证幻灯片24上的断言.</div><div class="exercise"><b>练习2.</b> 证明幻灯片25和27中的声明.</div><div class="exercise"><b>练习3.</b> 验证例子9中<math><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub></math>是连续函数的断言. 何时<math><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub></math>是严格的?</div><div class="tcomment"><b>译者注记.</b> 以上练习皆相当平凡.</div><h2>第3章 domain上的构造</h2><p>本节我们将给出诸多构造domain和连续函数的方式, 实际上专注于PCF编程语言的指称语义所需的构造, PCF是本讲义的后半部分的研究对象. 注意到为了描述一个cpo, 我们必须先<em>定义</em>一个装备有某二元关系的集合, 然后<em>证明</em><ol type="i"><li>这个关系是一个偏序;</li><li>对于这个偏序集中所有的链, 其最小上界存在.</li></ol>另外, 为了使得cpo成为一个domain, 我们还需要说明<ol type="i" start="3"><li>存在最小的元素.</li></ol>注意到既然链的最小上界以及最小元若存在则唯一, 那么cpo和domain完全由其基础集和偏序决定. [译注: 意味不明.] 之后我们将给出各种各样构造cpo和domain的方法, 而将验证i, ii, iii成立的任务留作练习.</p><h3>第3.1节 扁平domain</h3><p>为了模拟PCF的基本类型 (ground type) <math><mi>nat</mi></math>和<math><mi>bool</mi></math>, 我们将使用幻灯片31给出的<em>扁平domain</em>的概念.</p><table class="label" align="center"><tr><td><div class="slide" style="height: 250px"><div align="center"><b>离散cpo和扁平domain</b></div><hr/>对于任意的集合<math><mi>X</mi></math>, 相等关系<math display="block"><mrow><mrow><mi>x</mi><mo>&sqsube;</mo><msup><mi>x</mi><mo>&prime;</mo></msup></mrow><mover><mo>&hArr;</mo><mi>def</mi></mover><mrow><mi>x</mi><mo>=</mo><msup><mi>x</mi><mo>&prime;</mo></msup></mrow></mrow></math>使得<math><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>成为一个cpo, 其被称为以<math><mi>X</mi></math>为基础集的<em>离散</em>cpo.<br/>令<math><mrow><msub><mi>X</mi><mi>&bottom;</mi></msub><mover><mo>=</mo><mi>def</mi></mover><mrow><mi>X</mi><mo>&cup;</mo><mrow><mo stretchy="false">{</mo><mi>&bottom;</mi><mo stretchy="false">}</mo></mrow></mrow></mrow></math>, 其中<math><mi>&bottom;</mi></math>是某个不在<math><mi>X</mi></math>中的元素, 那么<math display="block"><mrow><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mover><mo>&hArr;</mo><mi>def</mi></mover><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>=</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow><mo>&or;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>=</mo><mi>&bottom;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>使得<math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>X</mi><mi>&bottom;</mi></msub><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>成为一个以<math><mi>&bottom;</mi></math>为最小元的domain, 其被称为由<math><mi>X</mi></math>确定的<em>扁平</em>domain.</div></td></tr><tr><td align="center">幻灯片31</td></tr></table><p>自然数的扁平domain <math><msub><mi>&Nopf;</mi><mi>&bottom;</mi></msub></math>, 上一章的图1中我们就已描绘过其图像. 至于布尔值的扁平domain <math><msub><mi>&Bopf;</mi><mi>&bottom;</mi></msub></math>, 其Hasse图为<svg width="320" height="150" stroke="black" style="display: block; margin: auto;"><defs><marker id="arrow" viewbox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 2 L 6 5 L 0 8 z"/></marker></defs><foreignObject x="53" y="36" width="150" height="30"><math><mi>true</mi></math></foreignObject><foreignObject x="253" y="36" width="150" height="30"><math><mi>false</mi></math></foreignObject><foreignObject x="157" y="126" width="150" height="30"><math><mi>&bottom;</mi></math></foreignObject><line x1="154" y1="125" x2="70" y2="57" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="175" y1="125" x2="264" y2="57" marker-end="url(#arrow)" stroke-width="1.2px"/></svg>以下牵涉扁平domain的连续函数实例对于PCF的指称语义而言也是必要的, 我们将其验证留给读者作为练习.</p><div class="proposition"><b>命题1.</b> 令<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>X</mi><mo>&RightVector;</mo><mi>Y</mi></mrow></mrow></math>是两个集合之间的部分函数, 那么<math display="block"><mrow><mrow><msub><mi>f</mi><mi>&bottom;</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><mover><mo>=</mo><mi>def</mi></mover><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>d</mi><mo>&in;</mo><mi>X</mi></mrow><mtext>且</mtext><mi>f</mi><mtext>定义于</mtext><mi>d</mi></mtd></mtr><mtr><mtd><mi>&bottom;</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>d</mi><mo>&in;</mo><mi>X</mi></mrow><mtext>而</mtext><mi>f</mi><mtext>在</mtext><mi>d</mi><mtext>上没有定义</mtext></mtd></mtr><mtr><mtd><mi>&bottom;</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>d</mi><mo>=</mo><mi>&bottom;</mi></mrow></mtd></mtr></mtable></mrow></mrow></math>定义了相应扁平domain之间的连续函数<math><mrow><msub><mi>f</mi><mi>&bottom;</mi></msub><mo>:</mo><mrow><msub><mi>X</mi><mi>&bottom;</mi></msub><mo>&rarr;</mo><msub><mi>Y</mi><mi>&bottom;</mi></msub></mrow></mrow></math>.</div><h3>第3.2节 domain的积</h3><table class="label" align="center"><tr><td><div class="slide" style="height: 300px"><div align="center"><b>cpo和domain的二元积</b></div><hr/>两个cpo <math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>,</mo><msub><mo lspace="0" rspace="0">&sqsube;</mo><mn>1</mn></msub></mrow><mo stretchy="false">)</mo></mrow></math>和<math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>D</mi><mn>2</mn></msub><mo>,</mo><msub><mo lspace="0" rspace="0">&sqsube;</mo><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></math>之<em>积</em>的基础集为<math display="block"><mrow><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>&times;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo stretchy="false">|</mo><mrow><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>&in;</mo><msub><mi>D</mi><mn>1</mn></msub></mrow><mo>&amp;</mo><mrow><msub><mi>d</mi><mn>2</mn></msub><mo>&in;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>而其上的偏序<math><mo>&sqsube;</mo></math>定义如下<math display="block"><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&sqsube;</mo><mrow><mo stretchy="false">(</mo><mrow><msubsup><mi>d</mi><mn>1</mn><mo>&prime;</mo></msubsup><mo>,</mo><msubsup><mi>d</mi><mn>2</mn><mo>&prime;</mo></msubsup></mrow><mo stretchy="false">)</mo></mrow></mrow><mover><mo>&hArr;</mo><mi>def</mi></mover><mrow><mrow><msub><mi>d</mi><mn>1</mn></msub><msub><mo>&sqsube;</mo><mn>1</mn></msub><msubsup><mi>d</mi><mn>1</mn><mo>&prime;</mo></msubsup></mrow><mo>&amp;</mo><mrow><msub><mi>d</mi><mn>2</mn></msub><msub><mo>&sqsube;</mo><mn>2</mn></msub><msubsup><mi>d</mi><mn>2</mn><mo>&prime;</mo></msubsup></mrow></mrow></mrow></math>链的最小上界可以按照分量进行计算:<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mrow><mn>1</mn><mo>,</mo><mi>n</mi></mrow></msub><mo>,</mo><msub><mi>d</mi><mrow><mn>2</mn><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>i</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mn>1</mn><mo>,</mo><mi>i</mi></mrow></msub></mrow><mo>,</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>j</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mn>2</mn><mo>,</mo><mi>j</mi></mrow></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>若<math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>,</mo><msub><mo lspace="0" rspace="0">&sqsube;</mo><mn>1</mn></msub></mrow><mo stretchy="false">)</mo></mrow></math>和<math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>D</mi><mn>2</mn></msub><mo>,</mo><msub><mo lspace="0" rspace="0">&sqsube;</mo><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></math>都是domain, 那么<math><mrow><mo stretchy="false">(</mo><mrow><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>&times;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>也是一个domain, 并且<math display="block"><mrow><msub><mi>&bottom;</mi><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>&times;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow></msub><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>&bottom;</mi><msub><mi>D</mi><mn>1</mn></msub></msub><mo>,</mo><msub><mi>&bottom;</mi><msub><mi>D</mi><mn>2</mn></msub></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></math></div></td></tr><tr><td align="center">幻灯片32</td></tr></table><div class="proposition"><b>命题1. 投影和配对.</b> 令<math><msub><mi>D</mi><mn>1</mn></msub></math>和<math><msub><mi>D</mi><mn>2</mn></msub></math>是cpo, 那么投影<math display="block"><mrow><msub><mi>&pi;</mi><mn>1</mn></msub><mo>:</mo><mrow><mrow><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>&times;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow><mo>&rarr;</mo><msub><mi>D</mi><mn>1</mn></msub></mrow><mo>,</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&mapsto;</mo><msub><mi>d</mi><mn>1</mn></msub></mrow></mrow></mrow></math>和<math display="block"><mrow><msub><mi>&pi;</mi><mn>2</mn></msub><mo>:</mo><mrow><mrow><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>&times;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow><mo>&rarr;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow><mo>,</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&mapsto;</mo><msub><mi>d</mi><mn>2</mn></msub></mrow></mrow></mrow></math>是连续函数. 如果<math><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><msub><mi>D</mi><mn>1</mn></msub></mrow></mrow></math>和<math><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow></mrow></math>是连续函数, 其中<math><mi>D</mi></math>是一个cpo, 那么<math display="block"><mrow><mrow><mo stretchy="false">&lang;</mo><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>,</mo><msub><mi>f</mi><mn>2</mn></msub></mrow><mo stretchy="false">&rang;</mo></mrow><mo>:</mo><mrow><mrow><mi>D</mi><mo>&rarr;</mo><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>&times;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow></mrow><mo>,</mo><mrow><mi>d</mi><mo>&mapsto;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>是连续的.</div><div class="proof"><b>证明.</b> 这些函数的连续性可由幻灯片32上对于<math><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>&times;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow></math>中的链的最小上界的刻画直接推出.<div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><div class="proposition"><b>命题2.</b> 对于每个domain <math><mi>D</mi></math>, 函数<math display="block"><mrow><mi>if</mi><mo>:</mo><mrow><mrow><mrow><msub><mi>&Bopf;</mi><mi>&bottom;</mi></msub><mo>&times;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>&times;</mo><mi>D</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&rarr;</mo><mi>D</mi></mrow><mo>,</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>&mapsto;</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mi>d</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mi>true</mi></mrow></mtd></mtr><mtr><mtd><msup><mi>d</mi><mo>&prime;</mo></msup></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mi>false</mi></mrow></mtd></mtr><mtr><mtd><msub><mi>&bottom;</mi><mi>D</mi></msub></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mi>&bottom;</mi></mrow></mtd></mtr></mtable></mrow></mrow></mrow></mrow></math>是连续的.</div><p>我们将会需要以下更一般的积构造.</p><div class="definition"><b>定义3. 依赖积.</b> 给定集合<math><mi>I</mi></math>, 设对于每个<math><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></math>我们有一个cpo <math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>,</mo><msub><mo lspace="0" rspace="0">&sqsube;</mo><mi>i</mi></msub></mrow><mo stretchy="false">)</mo></mrow></math>, 那么这个cpo族之<em>积</em>为<ul><li>基础集是集合<math><msub><mi>D</mi><mi>i</mi></msub></math>的<math><mi>I</mi></math>重笛卡尔积<math><mrow><munder><mo>&prod;</mo><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></munder><msub><mi>D</mi><mi>i</mi></msub></mrow></math>, 其由所有这样的函数<math><mi>p</mi></math>构成, <math><mi>p</mi></math>定义在<math><mi>I</mi></math>上, 而<math><mi>p</mi></math>在每个<math><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></math>处的值<math><mrow><mrow><mi>p</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&in;</mo><msub><mi>D</mi><mi>i</mi></msub></mrow></math>;</li><li>偏序<math><mo>&sqsube;</mo></math>为<math display="block"><mrow><mrow><mi>p</mi><mo>&sqsube;</mo><msup><mi>p</mi><mo>&prime;</mo></msup></mrow><mover><mo>&hArr;</mo><mi>def</mi></mover><mrow><mo>&forall;</mo><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mi>p</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow><msub><mo>&sqsube;</mo><mi>i</mi></msub><mrow><msup><mi>p</mi><mo>&prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow><mtext>.</mtext></math></li></ul>就和二元积的情况一样, <math><mrow><mo stretchy="false">(</mo><mrow><mrow><munder><mo>&prod;</mo><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></munder><msub><mi>D</mi><mi>i</mi></msub></mrow><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>中的链的最小上界也可以逐分量计算: 如果<math><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>p</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>p</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>是积cpo中的一个链, 那么其最小上界是将每个<math><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></math>映射至<math><msub><mi>D</mi><mi>i</mi></msub></math>中的链<math><mrow><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><msub><mi>p</mi><mn>2</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>的最小上界的函数, 即<math display="block"><mrow><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>p</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msub><mi>p</mi><mi>n</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mo>,</mo><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></mrow><mtext>.</mtext></math>而且, 对于每个<math><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></math>, 第<math><mi>i</mi></math>投影函数<math display="block"><mrow><msub><mi>&pi;</mi><mi>i</mi></msub><mo>:</mo><mrow><mrow><mrow><munder><mo>&prod;</mo><mrow><mi>j</mi><mo>&in;</mo><mi>I</mi></mrow></munder><msub><mi>D</mi><mi>j</mi></msub></mrow><mo>&rarr;</mo><msub><mi>D</mi><mi>i</mi></msub></mrow><mo>,</mo><mrow><mi>p</mi><mo>&mapsto;</mo><mrow><mi>p</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math>是连续的. 如果每个<math><msub><mi>D</mi><mi>i</mi></msub></math>都是domain, 那么它们的积也是domain, 并且其最小元是将每个<math><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></math>映射至<math><msub><mi>D</mi><mi>i</mi></msub></math>的最小元的函数.</div><table class="label" align="center"><tr><td><div class="slide" style="height: 300px"><div align="center"><b>两个参数的连续函数</b></div><hr/><div class="proposition"><b>命题.</b> 令<math><mrow><mi>D</mi><mo>,</mo><mi>E</mi><mo>,</mo><mi>F</mi></mrow></math>是cpo, 那么函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mrow><mi>D</mi><mo>&times;</mo><mi>E</mi></mrow><mo>&rarr;</mo><mi>F</mi></mrow></mrow></math>是单调的当且仅当其对于每个参数分别都是单调的:<math display="block"><mrow><mo>&forall;</mo><mrow><mrow><mrow><mi>d</mi><mo>,</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mo>&in;</mo><mi>D</mi></mrow><mo>,</mo><mrow><mi>e</mi><mo>&in;</mo><mi>E</mi></mrow></mrow><mo lspace="0">.</mo><mrow><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mo>&Implies;</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>d</mi><mo>&prime;</mo></msup><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math><math display="block"><mrow><mo>&forall;</mo><mrow><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo>,</mo><mrow><mrow><mi>e</mi><mo>,</mo><msup><mi>e</mi><mo>&prime;</mo></msup></mrow><mo>&in;</mo><mi>E</mi></mrow></mrow><mo lspace="0">.</mo><mrow><mrow><mi>e</mi><mo>&sqsube;</mo><msup><mi>e</mi><mo>&prime;</mo></msup></mrow><mo>&Implies;</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><msup><mi>e</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math>而且, 其是连续的当且仅当其对于每个参数分别都是连续的 [译注: 在单调的基础之上, 也就是对于每个参数分别都是保持链的最小上界的]:<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mi>n</mi></msub><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math><math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>e</mi><mi>n</mi></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><msub><mi>e</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math></div></div></td></tr><tr><td align="center">幻灯片33</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>两个参数的连续函数: 推导规则</b></div><hr/><ul><li>在<math><mi>f</mi></math>单调的情况下, 我们有<math display="block"><mfrac displaystyle="true"><mrow><mrow><mi>x</mi><mo>&sqsube;</mo><msup><mi>x</mi><mo>&prime;</mo></msup></mrow><mspace width="8ex"/><mrow><mi>y</mi><mo>&sqsube;</mo><msup><mi>y</mi><mo>&prime;</mo></msup></mrow></mrow><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>x</mi><mo>&prime;</mo></msup><mo>,</mo><msup><mi>y</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mfrac></math></li><li>在<math><mi>f</mi></math>连续的情况下, 我们有<math display="block"><mfrac displaystyle="true"><mrow/><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>x</mi><mi>m</mi></msub></mrow><mo>,</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>y</mi><mi>n</mi></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>x</mi><mi>k</mi></msub><mo>,</mo><msub><mi>y</mi><mi>k</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mfrac></math></li></ul></div></td></tr><tr><td align="center">幻灯片34</td></tr></table><div class="proof"><b>证明.</b> &quot;仅当&quot;的方向是直接的, 其证明依赖于简单的观察, 即<math><mrow><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mo>&Implies;</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&sqsube;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>d</mi><mo>&prime;</mo></msup><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>和<math><mrow><mrow><mo stretchy="false">(</mo><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mi>n</mi></msub><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, 以及它们之于右参数的对偶版本. 对于&quot;当&quot;的方向, 首先设<math><mi>f</mi></math>对于每个参数分别都是单调的, 那么如果<math><mrow><mi>D</mi><mo>&times;</mo><mi>E</mi></mrow></math>中有<math><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&sqsube;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>d</mi><mo>&prime;</mo></msup><mo>,</mo><msup><mi>e</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow></mrow></math>, 根据二元积的定义, 我们可以推出<math><mi>D</mi></math>中有<math><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow></math>而<math><mi>E</mi></math>中有<math><mrow><mi>e</mi><mo>&sqsube;</mo><msup><mi>e</mi><mo>&prime;</mo></msup></mrow></math>, 因此<math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>&sqsube;</mo></mtd><mtd columnalign="left"><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>d</mi><mo>&prime;</mo></msup><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>根据对于第一个参数的单调性</mtext></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>&sqsube;</mo></mtd><mtd columnalign="left"><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>d</mi><mo>&prime;</mo></msup><mo>,</mo><msup><mi>e</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>根据对于第二个参数的单调性</mtext></mtd></mtr></mtable></math>于是, <math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>d</mi><mo>&prime;</mo></msup><mo>,</mo><msup><mi>e</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, 即<math><mi>f</mi></math>是单调函数.<br/>现在设<math><mi>f</mi></math>对于每个参数分别都是连续的, 那么如果<math><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>,</mo><msub><mi>e</mi><mn>0</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&sqsube;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>e</mi><mn>1</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&sqsube;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>2</mn></msub><mo>,</mo><msub><mi>e</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>是二元积中的一个链, 我们有<math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mi>n</mi></msub><mo>,</mo><msub><mi>e</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>i</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>i</mi></msub></mrow><mo>,</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>j</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>e</mi><mi>j</mi></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>见幻灯片32</mtext></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>i</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>,</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>j</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>e</mi><mi>j</mi></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd columnalign="left"><mtext>根据对于第一个参数的连续性</mtext></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>i</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>j</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>,</mo><msub><mi>e</mi><mi>j</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mtd><mtd columnalign="left"><mtext>根据对于第二个参数的连续性</mtext></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mi>n</mi></msub><mo>,</mo><msub><mi>e</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd columnalign="left"><mtext>根据幻灯片27上的引理</mtext></mtd></mtr></mtable></math>而这就说明了<math><mi>f</mi></math>的连续性.<div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><h3>第3.3节 函数domain</h3><p>两个cpo/domain之间的所有连续函数的集合可以赋予一个偏序而成为一个cpo/domain, 见幻灯片35. 有时我们也用术语&quot;指数cpo/domain (exponential cpo/domain)&quot;而不是&quot;函数cpo/domain&quot;.</p><table class="label" align="center"><tr><td><div class="slide" style="height: 250px"><div align="center"><b>函数cpo和domain</b></div><hr/>给定cpo <math><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>,</mo><msub><mo lspace="0" rspace="0">&sqsube;</mo><mi>D</mi></msub></mrow><mo stretchy="false">)</mo></mrow></math>和<math><mrow><mo stretchy="false">(</mo><mrow><mi>E</mi><mo>,</mo><msub><mo lspace="0" rspace="0">&sqsube;</mo><mi>E</mi></msub></mrow><mo stretchy="false">)</mo></mrow></math>, 函数cpo <math><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>的基础集为 [译注: 以下符号有点过载]<math display="block"><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow><mover><mo>=</mo><mi>def</mi></mover><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></mrow><mo stretchy="false">|</mo><mrow><mi>f</mi><mtext>连续</mtext></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>而偏序为<math display="block"><mrow><mrow><mi>f</mi><mo>&sqsube;</mo><msup><mi>f</mi><mo>&prime;</mo></msup></mrow><mover><mo>&hArr;</mo><mi>def</mi></mover><mrow><mo>&forall;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><msub><mo>&sqsube;</mo><mi>E</mi></msub><mrow><msup><mi>f</mi><mo>&prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math>推导规则:<math display="block"><mfrac displaystyle="true"><mrow><mrow><mi>f</mi><msub><mo>&sqsube;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></msub><mi>g</mi></mrow><mspace width="8ex"/><mrow><mi>x</mi><msub><mo>&sqsube;</mo><mi>D</mi></msub><mi>y</mi></mrow></mrow><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><msub><mo>&sqsube;</mo><mi>E</mi></msub><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mfrac></math></div></td></tr><tr><td align="center">幻灯片35</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>函数cpo和domain (续)</b></div><hr/>链的最小上界可以逐参数计算:<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>f</mi><mi>n</mi></msub></mrow><mo>=</mo><mrow><mi>&lambda;</mi><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math>推导规则:<math display="block"><mfrac displaystyle="true"><mrow/><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>f</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msub><mi>f</mi><mi>k</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mfrac></math>如果<math><mi>D</mi></math>和<math><mi>E</mi></math>还是domain, 那么<math><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></math>也成为一个domain, 并且最小元为<math display="block"><mrow><msub><mi>&bottom;</mi><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></msub><mo>:</mo><mrow><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow><mo>,</mo><mrow><mi>d</mi><mo>&mapsto;</mo><msub><mi>&bottom;</mi><mi>E</mi></msub></mrow></mrow></mrow><mtext>.</mtext></math></div></td></tr><tr><td align="center">幻灯片36</td></tr></table><div class="proof"><b>证明.</b> 我们应该证明函数的链<math><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>f</mi><mi>n</mi></msub></mrow></math>的最小上界是连续的. 这个证明使用了幻灯片27的<q>互换律 (interchange law)</q>. 对于<math><mi>D</mi></math>中的一个链<math><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>, 我们有<math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>f</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>m</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>m</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd columnalign="left"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>f</mi><mi>n</mi></msub></mrow><mtext>的定义</mtext></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mi>m</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mrow><mtext>每个</mtext><msub><mi>f</mi><mi>n</mi></msub><mtext>的连续性</mtext></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mi>m</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>互换律</mtext></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>f</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mi>m</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>f</mi><mi>n</mi></msub></mrow><mtext>的定义</mtext></mrow></mtd></mtr></mtable></math><div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><div class="tcomment"><b>译者注记.</b> 这个证明有点没头没脑, 所以我感到有必要写下注记. 原文写的是这是对于幻灯片35的证明, 这实际上就足够令人费解的了. 毕竟幻灯片35是一个定义, 那么需要证明什么呢? 这个证明的目的实际上是为了补足定义里的一点gap, 以使得定义的确是well-defined的. (译者很有先见之明的给幻灯片36取了合适的标题, 而的确要证明的内容和幻灯片36有关.) 我们知道一个cpo需要能够对于(升)链作最小上界操作, 而幻灯片36只是指出可以这么计算该操作, 没有说明这个计算结果的确是最小上界操作. 这个证明比较令人迷惑的地方主要是在证明之前就使用了<math><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>f</mi><mi>n</mi></msub></mrow></math>这种符号, 实际上在证明的过程之中你不应该把它视为最小上界. 另外, 这个证明只是论证了保持最小上界这一性质, 其他还需要论证的内容是单调性, 然后在连续的基础之上说明这个计算结果的确是链的上界且是上界之中最小的. 当然, 额外的内容并不困难, 只是因为先前证明总是过分细致而显得这里省略这么多内容让译者感到有点奇怪.</div><div class="proposition"><b>命题1. 求值和Curry化.</b> 给定cpo <math><mi>D</mi></math>和<math><mi>E</mi></math>, 函数<math display="block"><mrow><mi>ev</mi><mo>:</mo><mrow><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&times;</mo><mi>D</mi></mrow><mo>&rarr;</mo><mi>E</mi></mrow><mo>,</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>,</mo><mi>d</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&mapsto;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math>是连续的. 给定任意的连续函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mrow><msup><mi>D</mi><mo>&prime;</mo></msup><mo>&times;</mo><mi>D</mi></mrow><mo>&rarr;</mo><mi>E</mi></mrow></mrow></math> (其中<math><msup><mi>D</mi><mo>&prime;</mo></msup></math>是一个cpo), 对于每个<math><mrow><msup><mi>d</mi><mo>&prime;</mo></msup><mo>&in;</mo><msup><mi>D</mi><mo>&prime;</mo></msup></mrow></math>, 函数<math><mrow><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo>&mapsto;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>d</mi><mo>&prime;</mo></msup><mo>,</mo><mi>d</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>都是连续的, 因而确定了函数cpo <math><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></math>中的一个元素. 我们将其记为<math><mrow><mrow><mi>cur</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msup><mi>d</mi><mo>&prime;</mo></msup><mo stretchy="false">)</mo></mrow></mrow></math>, 那么<math display="block"><mrow><mrow><mi>cur</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><mrow><mrow><msup><mi>D</mi><mo>&prime;</mo></msup><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><msup><mi>d</mi><mo>&prime;</mo></msup><mo>&mapsto;</mo><mrow><mi>&lambda;</mi><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>d</mi><mo>&prime;</mo></msup><mo>,</mo><mi>d</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></mrow></math>是一个连续函数. [原注: <q>Curry化</q>这个名字是为了纪念逻辑学家H. B. Curry, 一位组合子逻辑和lambda演算先驱.]</div><div class="proof"><b>证明.</b> 对于<math><mi>ev</mi></math>的连续性, 注意到<math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>ev</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mo stretchy="false">(</mo><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>,</mo><msub><mi>d</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>ev</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>i</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>f</mi><mi>i</mi></msub></mrow><mo>,</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>j</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>j</mi></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>积的最小上界是逐分量计算的</mtext></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>i</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>f</mi><mi>i</mi></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>j</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>j</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mrow><mtext>根据</mtext><mi>ev</mi><mtext>的定义</mtext></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>i</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>j</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>j</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd columnalign="left"><mtext>函数cpo中的最小上界是逐参数计算的</mtext></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>i</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>j</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mtd><mtd columnalign="left"><mrow><mtext>根据每个</mtext><msub><mi>f</mi><mi>i</mi></msub><mtext>的连续性</mtext></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd columnalign="left"><mtext>根据幻灯片27的引理</mtext></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>ev</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>,</mo><msub><mi>d</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd columnalign="left"><mrow><mtext>根据</mtext><mi>ev</mi><mtext>的定义</mtext></mrow></mtd></mtr></mtable></math>每个<math><mrow><mrow><mi>cur</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msup><mi>d</mi><mo>&prime;</mo></msup><mo stretchy="false">)</mo></mrow></mrow></math>以及然后<math><mrow><mi>cur</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>的连续性可以由<math><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>&times;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow></math>中的链的最小上界可以逐分量计算这一事实立即推出.<div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>复合的连续性</b></div><hr/>对于cpo <math><mrow><mi>D</mi><mo>,</mo><mi>E</mi><mo>,</mo><mi>F</mi></mrow></math>, 复合函数<math display="block"><mrow><mo>&compfn;</mo><mo>:</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>E</mi><mo>&rarr;</mo><mi>F</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&times;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>F</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>是连续的, 其定义为对于<math><mrow><mi>f</mi><mo>&in;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>和<math><mrow><mi>g</mi><mo>&in;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>E</mi><mo>&rarr;</mo><mi>F</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>,<math display="block"><mrow><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow><mo>=</mo><mrow><mi>&lambda;</mi><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mtext>.</mtext></math></div></td></tr><tr><td align="center">幻灯片37</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>不动点算子的连续性</b></div><hr/>令<math><mi>D</mi></math>是一个domain.<br/>根据Tarski不动点定理, 我们知道每个连续函数<math><mrow><mi>f</mi><mo>&in;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>都拥有一个最小不动点<math><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&in;</mo><mi>D</mi></mrow></math>.<div class="proposition"><b>命题.</b> 函数<math display="block"><mrow><mi>fix</mi><mo>:</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>是连续的.</div></div></td></tr><tr><td align="center">幻灯片38</td></tr></table><div class="proof"><b>证明.</b> 我们必须首先证明<math><mrow><mi>fix</mi><mo>:</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>是一个单调函数. 设<math><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>f</mi><mn>2</mn></msub></mrow></math>是函数domain中的两个元素. 我们需要证明的是<math><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, 不过<math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>&sqsube;</mo></mtd><mtd columnalign="left"><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mrow><mtext>鉴于</mtext><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>f</mi><mn>2</mn></msub></mrow></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>&sqsube;</mo></mtd><mtd columnalign="left"><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mrow><mtext>根据</mtext><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mtext>的(lpf1)</mtext></mrow></mtd></mtr></mtable></math>于是, <math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow></math>是<math><msub><mi>f</mi><mn>1</mn></msub></math>的一个前不动点, 因而根据<math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow></math>的(lpf2)我们有<math><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, 这也正是我们想要的. [译注: 作者这里将lpf均误作lfp, 而lfp在书中并没有出现过, 证明的剩余部分也都写错了. 另外, 读者应该回忆一下, 根据之前的命题, 此时最小前不动点和最小不动点均存在且相等.]<br/>现在我们将注意力转向证明链的最小上界的保持, 设<math><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></math>中有<math><mrow><msub><mi>f</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>f</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>f</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>. 根据第2章第3节的评注7, 我们只需要证明<math display="block"><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>f</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>而根据最小前不动点的(lpf2), 证明<math><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></math>是<math><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>f</mi><mi>n</mi></msub></mrow></math>的一个前不动点就足够了. [译注: 即最小前不动点小于其他的前不动点.] 这是因为:<math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>f</mi><mi>m</mi></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msub><mi>f</mi><mi>m</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd columnalign="left"><mtext>函数链的最小上界可以逐参数计算</mtext></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msub><mi>f</mi><mi>m</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mtd><mtd columnalign="left"><mrow><mtext>鉴于每个</mtext><msub><mi>f</mi><mi>m</mi></msub><mtext>都是连续的</mtext></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msub><mi>f</mi><mi>k</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd columnalign="left"><mtext>根据幻灯片27的引理</mtext></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>&sqsube;</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd columnalign="left"><mrow><mtext>根据每个</mtext><msub><mi>f</mi><mi>k</mi></msub><mtext>的(lpf1)</mtext></mrow></mtd></mtr></mtable></math>[译注: 这里根据幻灯片27的引理需要用到之前证明的单调性, 另外最后一步这里的<math><mo>&sqsube;</mo></math>实际上更确切地说是<math><mo>=</mo></math>, 因为<math><mi>fix</mi></math>是不动点算子, 不过这个证明的所有地方作者都把最小不动点当作最小前不动点使用.]<div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><h3>第3.4节 练习</h3><div class="exercise"><b>练习1.</b> 验证本章未经证明的构造, 证明本章未经证明的命题.</div><div class="exercise"><b>练习2.</b> 令<math><mi>X</mi></math>和<math><mi>Y</mi></math>是集合而<math><msub><mi>X</mi><mi>&bottom;</mi></msub></math>和<math><msub><mi>Y</mi><mi>&bottom;</mi></msub></math>是对应的扁平domain, 如幻灯片31. 证明一个函数<math><mrow><mi>f</mi><mo>:</mo><mrow><msub><mi>X</mi><mi>&bottom;</mi></msub><mo>&rarr;</mo><msub><mi>Y</mi><mi>&bottom;</mi></msub></mrow></mrow></math>是连续的当且仅当以下条件之一成立:<ol type="a"><li><math><mi>f</mi></math>是严格的, 即<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>&bottom;</mi></mrow></math>;</li><li><math><mi>f</mi></math>是常函数, 即<math><mrow><mo>&forall;</mo><mrow><mi>x</mi><mo>&in;</mo><mi>X</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>.</li></ol></div><div class="exercise"><b>练习3.</b> 令<math><mrow><mo stretchy="false">{</mo><mi>&top;</mi><mo stretchy="false">}</mo></mrow></math>是一个单元素集合, 而<math><msub><mrow><mo stretchy="false">{</mo><mi>&top;</mi><mo stretchy="false">}</mo></mrow><mi>&bottom;</mi></msub></math>是相对应的扁平domain. 令<math><mi mathvariant="normal">&Omega;</mi></math>是图1所描绘的<q>垂直自然数</q>的domain. 证明函数domain <math><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">&Omega;</mi><mo>&rarr;</mo><msub><mrow><mo stretchy="false">{</mo><mi>&top;</mi><mo stretchy="false">}</mo></mrow><mi>&bottom;</mi></msub></mrow><mo stretchy="false">)</mo></mrow></math>和<math><mi mathvariant="normal">&Omega;</mi></math>之间存在一个双射.</div><div class="exercise"><b>练习4.</b> 证明幻灯片37的内容.</div><h2>第4章 Scott归纳</h2><h3>第4.1节 链封闭子集和可容许子集</h3><p>在第2章的时候我们看到一个domain <math><mi>D</mi></math>上的一个连续函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>的最小不动点可以表达为自<math><mi>D</mi></math>的最小元素<math><mi>&bottom;</mi></math>起反复应用<math><mi>f</mi></math>所得到的链的最小上界: <math><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>. 这种构造允许我们使用特定方式证明<math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>的性质, <em>只要</em>这个性质满足幻灯片39中的条件, 证明方式为使用数学归纳法表明对于每个<math><mi>n</mi></math>而言<math><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></math>具有该性质. 或许将这种对于数学归纳法的使用方式打包以隐藏<math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>作为某个链的不动点的显式构造也是方便的, 见幻灯片40. 为了澄清幻灯片40的陈述, 注意到<math><mrow><mrow><mrow><msup><mi>f</mi><mn>0</mn></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>&bottom;</mi></mrow><mo>&in;</mo><mi>S</mi></mrow></math>, 此为<b>基本步骤</b>; 而<math><mrow><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&in;</mo><mi>S</mi></mrow></math>可以推出<math><mrow><mrow><mrow><msup><mi>f</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&in;</mo><mi>S</mi></mrow></math>, 此为<b>归纳步骤</b>; 因此, 根据<math><mi>n</mi></math>上的归纳, 我们有<math><mrow><mo>&forall;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow><mo lspace="0">.</mo><mrow><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&in;</mo><mi>S</mi></mrow></mrow></math>. 最后, 根据<math><mi>S</mi></math>的链封闭性, <math><mrow><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mo>&in;</mo><mi>S</mi></mrow></math>, 这正是我们所要的.</p><table class="label" align="center"><tr><td><div class="slide" style="height: 280px"><div align="center"><b>链封闭子集和可容许子集</b></div><hr/>令<math><mi>D</mi></math>是一个cpo. 一个子集<math><mrow><mi>S</mi><mo>&sube;</mo><mi>D</mi></mrow></math>被称为是<em>链封闭的</em>当且仅当对于<math><mi>D</mi></math>中所有的链<math><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>, 有<math display="block"><mrow><mrow><mo stretchy="false">(</mo><mrow><mo>&forall;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow><mo lspace="0">.</mo><mrow><msub><mi>d</mi><mi>n</mi></msub><mo>&in;</mo><mi>S</mi></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>&Implies;</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi>S</mi></mrow></mrow></math>如果<math><mi>D</mi></math>是一个domain, <math><mrow><mi>S</mi><mo>&sube;</mo><mi>D</mi></mrow></math>被称为是<em>可容许的</em>当且仅当其是<math><mi>D</mi></math>的一个链封闭子集且<math><mrow><mi>&bottom;</mi><mo>&in;</mo><mi>S</mi></mrow></math>.<hr/>元素<math><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow></math>的一个性质<math><mrow><mi mathvariant="normal">&Phi;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></math>被称为是<em>链封闭的</em>当且仅当<math><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo stretchy="false">|</mo><mrow><mi mathvariant="normal">&Phi;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></math>是<math><mi>D</mi></math>的一个链封闭子集, 类似地还可以定义可容许性质.</div></td></tr><tr><td align="center">幻灯片39</td></tr></table><div class="tcomment"><b>译者注记.</b> 所谓(<math><mi>D</mi></math>上的)性质指的是一个从<math><mi>D</mi></math>到真假的函数, 这是一种外延性的观念. 另外, 正如幻灯片39, <math><mi>D</mi></math>上的一个性质<math><mi mathvariant="normal">&Phi;</mi></math>也可以由子集<math><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo stretchy="false">|</mo><mrow><mi mathvariant="normal">&Phi;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></math>表示, 这和函数表示是完全等价的.</div><div class="comment"><b>注记.</b> 术语<em>inclusive</em>或者<em>inductive</em>经常用作<q>链封闭</q>的同义词.</div><div class="example"><b>例子1.</b> 考虑图1所描绘的<q>垂直自然数</q>的domain <math><mi mathvariant="normal">&Omega;</mi></math>, 那么<ul><li><math><mi mathvariant="normal">&Omega;</mi></math>的任意<em>有限</em>子集都是链封闭的;</li><li><math><mrow><mo stretchy="false">{</mo><mrow><mn>0</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>4</mn><mo>,</mo><mn>6</mn><mo>,</mo><mo>&hellip;</mo></mrow><mo stretchy="false">}</mo></mrow></math>不是<math><mi mathvariant="normal">&Omega;</mi></math>的一个链封闭子集;</li><li><math><mrow><mrow><mo stretchy="false">{</mo><mrow><mn>0</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>4</mn><mo>,</mo><mn>6</mn><mo>,</mo><mo>&hellip;</mo></mrow><mo stretchy="false">}</mo></mrow><mo>&cup;</mo><mrow><mo stretchy="false">{</mo><mi>&omega;</mi><mo stretchy="false">}</mo></mrow></mrow></math>是<math><mi mathvariant="normal">&Omega;</mi></math>的一个链封闭子集, 当然其也是一个可容许子集.</li></ul></div><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>Scott的不动点归纳原理</b></div><hr/>令<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>是domain <math><mi>D</mi></math>上的一个连续函数.<br/>对于任意的可容许子集<math><mrow><mi>S</mi><mo>&sube;</mo><mi>D</mi></mrow></math>, 为了证明<math><mi>f</mi></math>的最小不动点在<math><mi>S</mi></math>之中, 即<math display="block"><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&in;</mo><mi>S</mi></mrow></math>实际上证明<math display="block"><mrow><mo>&forall;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mi>d</mi><mo>&in;</mo><mi>S</mi></mrow><mo>&Implies;</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&in;</mo><mi>S</mi></mrow></mrow></mrow></math>就足够了.</div></td></tr><tr><td align="center">幻灯片40</td></tr></table><div class="tcomment"><b>译者注记.</b> 约定俗成地, 点号代表辖域尽可能向右延伸.</div><p>在实际情况下应用Scott的不动点归纳原理的难点在于识别出一个适切的可容许子集<math><mi>S</mi></math>, 即寻找一个具有合适强度的<q>归纳假设</q>.</p><h3>第4.2节 例子</h3><div class="example"><b>例子1.</b> 设<math><mi>D</mi></math>是一个domain而<math><mrow><mi>f</mi><mo>:</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>&times;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>&times;</mo><mi>D</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>是一个连续函数. 令<math><mrow><mi>g</mi><mo>:</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>&times;</mo><mi>D</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>&times;</mo><mi>D</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>是由<math display="block"><mrow><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mover><mo>=</mo><mi>def</mi></mover><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>2</mn></msub><mo>,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mtext>, 其中</mtext><mrow><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><mo>&in;</mo><mi>D</mi></mrow></math>定义的连续函数. 那么, <math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>=</mo><msub><mi>u</mi><mn>2</mn></msub></mrow></math>, 其中<math><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>,</mo><msub><mi>u</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mover><mo>=</mo><mi>def</mi></mover><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>. (注意到之所以<math><mi>g</mi></math>是连续的, 是因为我们可以将其表达为复合, 投影和配对, 因而可以应用第3章第2节的命题1和幻灯片37: <math><mrow><mi>g</mi><mo>=</mo><mrow><mo stretchy="false">&lang;</mo><mrow><mrow><mi>f</mi><mo>&compfn;</mo><mrow><mo stretchy="false">&lang;</mo><mrow><msub><mi>&pi;</mi><mn>1</mn></msub><mo>,</mo><mrow><mo stretchy="false">&lang;</mo><mrow><msub><mi>&pi;</mi><mn>1</mn></msub><mo>,</mo><msub><mi>&pi;</mi><mn>2</mn></msub></mrow><mo stretchy="false">&rang;</mo></mrow></mrow><mo stretchy="false">&rang;</mo></mrow></mrow><mo>,</mo><mrow><mi>f</mi><mo>&compfn;</mo><mrow><mo stretchy="false">&lang;</mo><mrow><msub><mi>&pi;</mi><mn>1</mn></msub><mo>,</mo><mrow><mo stretchy="false">&lang;</mo><mrow><msub><mi>&pi;</mi><mn>2</mn></msub><mo>,</mo><msub><mi>&pi;</mi><mn>2</mn></msub></mrow><mo stretchy="false">&rang;</mo></mrow></mrow><mo stretchy="false">&rang;</mo></mrow></mrow></mrow><mo stretchy="false">&rang;</mo></mrow></mrow></math>.)</div><div class="proof"><b>证明.</b> 我们想要证明的是<math><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&in;</mo><mi mathvariant="normal">&Delta;</mi></mrow></math>, 其中<math display="block"><mrow><mi mathvariant="normal">&Delta;</mi><mover><mo>=</mo><mi>def</mi></mover><mrow><mo stretchy="false">{</mo><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mrow><mi>D</mi><mo>&times;</mo><mi>D</mi></mrow></mrow><mo stretchy="false">|</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>=</mo><msub><mi>d</mi><mn>2</mn></msub></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow><mtext>.</mtext></math>不难看出<math><mi mathvariant="normal">&Delta;</mi></math>是积domain <math><mrow><mi>D</mi><mo>&times;</mo><mi>D</mi></mrow></math>的一个可容许子集. 因此, 根据Scott不动点归纳原理, 我们只需要检验<math display="block"><mrow><mo>&forall;</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mrow><mi>D</mi><mo>&times;</mo><mi>D</mi></mrow></mrow><mo lspace="0">.</mo><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi mathvariant="normal">&Delta;</mi></mrow><mo>&Implies;</mo><mrow><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&in;</mo><mi mathvariant="normal">&Delta;</mi></mrow></mrow></mrow></math>其等价于<math display="block"><mrow><mo>&forall;</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mrow><mi>D</mi><mo>&times;</mo><mi>D</mi></mrow></mrow><mo lspace="0">.</mo><mrow><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>=</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><mo>&Implies;</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>d</mi><mn>2</mn></msub><mo>,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math>这显然为真.<div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><p>接下来的例子表明Scott归纳原理对于证明关于程序的(指称版本的)<em>部分正确性(partial correctness)</em>断言来说很有用, 即具有形式<q>如果程序终止, 那么对于结果来说这个那个的性质成立</q>的断言. 与之形成对比的是, <em>完全</em>正确性断言指的是<q>程序的确会终止且对于结果来说这个那个的性质成立</q>. 鉴于Scott归纳只能应用于这样的性质<math><mi mathvariant="normal">&Phi;</mi></math>, 其满足<math><mrow><mi mathvariant="normal">&Phi;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></math>成立, 所以说它对于证明完全正确性不是很有用.</p><div class="example"><b>例子2.</b> 令<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>是幻灯片12上定义的连续函数, 其最小不动点是命令<math display="block"><mrow><ms>while</ms><mtext>&nbsp;</mtext><mrow><mi>X</mi><mo>></mo><mn>0</mn></mrow><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>Y</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&#8270;</mo><mi>Y</mi></mrow></mrow><mo>;</mo><mrow><mi>X</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>的指称. 我们将会使用Scott归纳证明<math display="block"><mrow><mo>&forall;</mo><mrow><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo>&ge;</mo><mn>0</mn></mrow><mo lspace="0">.</mo><mrow><mrow><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>&darr;</mo></mrow><mo>&Implies;</mo><mrow><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mo>!</mo><mi>x</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&#8270;</mo><mi>y</mi></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow></mrow></mrow></math>其中</div><h3>第4.3节 构建链封闭子集</h3><p>Scott归纳的威力依赖于我们有许多链封闭子集储备能用. 幸运的是, 我们可以根据构造方式来保证许多子集是链封闭的.</p><h4>第4.3.1小节 基本关系</h4><p>令<math><mi>D</mi></math>是一个cpo. <math><mrow><mi>D</mi><mo>&times;</mo><mi>D</mi></mrow></math>的子集<math display="block"><mrow><mo stretchy="false">{</mo><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mrow><mi>D</mi><mo>&times;</mo><mi>D</mi></mrow></mrow><mo stretchy="false">|</mo><mrow><mi>x</mi><mo>&sqsube;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></math>和<math display="block"><mrow><mo stretchy="false">{</mo><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mrow><mi>D</mi><mo>&times;</mo><mi>D</mi></mrow></mrow><mo stretchy="false">|</mo><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></math>都是链封闭的 (为什么?). 换言之, <math><mrow><mi>D</mi><mo>&times;</mo><mi>D</mi></mrow></math>上的性质 (或者说谓词) <math><mrow><mi>x</mi><mo>&sqsube;</mo><mi>y</mi></mrow></math>和<math><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow></math>都确定了链封闭集合.</p><div class="tcomment"><b>译者注记.</b> 对于<math><mi>D</mi></math>中的两个链<math><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>x</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>x</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>和<math><mrow><msub><mi>y</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>y</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>y</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>, 如果对于每个<math><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>都有<math><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>&sqsube;</mo><msub><mi>y</mi><mi>n</mi></msub></mrow></math>, 那么<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>x</mi><mi>n</mi></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>y</mi><mi>n</mi></msub></mrow></mrow><mtext>.</mtext></math></div><table class="label" align="center"><tr><td><div class="slide" style="height: 280px;"><div align="center"><b>例子I: 最小前不动点性质</b></div><hr/>令<math><mi>D</mi></math>是一个domain而<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>是一个连续函数, 那么<math display="block"><mrow><mo>&forall;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow><mo>&xrArr;</mo><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></mrow></mrow><mtext>.</mtext></math>以下是使用Scott归纳的证明.<div class="proof"><b>证明.</b> 令<math><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow></math>是<math><mi>f</mi></math>的一个前不动点, 那么<math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><mrow><mi>x</mi><mo>&in;</mo><mrow><mi>&darr;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd><mo>&xrArr;</mo></mtd><mtd><mrow><mi>x</mi><mo>&sqsube;</mo><mi>d</mi></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>&xrArr;</mo></mtd><mtd><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>&xrArr;</mo></mtd><mtd><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>&xrArr;</mo></mtd><mtd><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&in;</mo><mrow><mi>&darr;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr></mtable></math>因此, 我们有<math display="block"><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&in;</mo><mrow><mi>&darr;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>.</mtext></math><div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div></div></td></tr><tr><td align="center">幻灯片41</td></tr></table><div class="tcomment"><b>译者注记.</b> 译者猜测这里使用<math><mo>&xrArr;</mo></math>而非<math><mo>&Implies;</mo></math>的原因在于<math><mo>&xrArr;</mo></math>相当于断言<math><mo>&Implies;</mo></math>为真. 另外, 幻灯片41有很多令译者感到奇怪的地方. 当然, 最奇怪的地方还是证明的命题是定义的一部分, 最小前不动点本来就应该小于其他不动点. 至于存在性之前读者已经看过证明了. 并且因为之前我们一起证明了最小前不动点和最小不动点均存在且相等, 所以说这里的Scott归纳的确也可以应用于最小前不动点. 不过, 实际上如果不看这个幻灯片的标题, 我们肯定会将<math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>当成最小不动点. 而且, 证明的具体内容里本来就没有牵涉不动点和前不动点. 当然, 这是因为其被掩藏在了Scott归纳的抽象之下. 这个证明还有一些gap值得注意. 首先是<math><mrow><mi>&darr;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></math>没有在书中任何地方得到定义, 不过按照格论的习惯其定义应该为<math display="block"><mrow><mrow><mi>&darr;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&colone;</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>x</mi><mo>&in;</mo><mi>D</mi></mrow><mo stretchy="false">|</mo><mrow><mi>x</mi><mo>&sqsube;</mo><mi>d</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow><mtext>.</mtext></math>其次, 这个证明未经验证地使用了所有<math><mrow><mi>&darr;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></math>均为可容许子集这一事实. 不过, 这当然是显然的. 对于<math><mrow><mi>&darr;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></math>中的任意链<math><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>x</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>x</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>, 鉴于每个<math><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>&sqsube;</mo><mi>d</mi></mrow></math>, 故<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>x</mi><mi>n</mi></msub></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></math>即<math><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>x</mi><mi>n</mi></msub></mrow><mo>&in;</mo><mrow><mi>&darr;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>. 另外, 因为<math><mrow><mi>&bottom;</mi><mo>&sqsube;</mo><mi>d</mi></mrow></math>, 所以<math><mrow><mi>&bottom;</mi><mo>&in;</mo><mrow><mi>&darr;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.</div><h4>第4.3.2小节 逆像和替换</h4><p>令<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></mrow></math>是cpo <math><mi>D</mi></math>和<math><mi>E</mi></math>之间的一个连续函数. 设<math><mi>S</mi></math>是<math><mi>E</mi></math>的一个链封闭子集, 那么逆像<math display="block"><mrow><mrow><msup><mi>f</mi><mrow><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>x</mi><mo>&in;</mo><mi>D</mi></mrow><mo stretchy="false">|</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&in;</mo><mi>S</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>是<math><mi>D</mi></math>的一个链封闭子集 (为什么?).</p><div class="tcomment"><b>译者注记.</b> 设<math><mi>S</mi></math>是<math><mi>E</mi></math>的一个链封闭子集, 对于<math><mrow><msup><mi>f</mi><mrow><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow></mrow></math>中的链<math><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>x</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>x</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>, 考虑其最小上界在<math><mi>f</mi></math>下的像<math display="block"><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></math>我们希望其是<math><mi>S</mi></math>的一个元素, 而这实际上是显然的. 根据<math><mi>f</mi></math>的连续性, 我们知道<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>鉴于<math><mi>S</mi></math>是一个链封闭子集, 且对于每个<math><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>, <math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>&in;</mo><mi>S</mi></mrow></math>, 故<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&in;</mo><mi>S</mi></mrow></math>也就是说, 我们有<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>x</mi><mi>n</mi></msub></mrow><mo>&in;</mo><mrow><msup><mi>f</mi><mrow><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>那么, 我们可以断言<math><mrow><msup><mi>f</mi><mrow><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow></mrow></math>是一个链封闭子集. 译注完毕.</div><p>设子集<math><mi>S</mi></math>由<math><mi>E</mi></math>上的性质<math><mi>P</mi></math>所定义, 即<math display="block"><mrow><mi>S</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>y</mi><mo>&in;</mo><mi>E</mi></mrow><mo stretchy="false">|</mo><mrow><mi>P</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>那么<math display="block"><mrow><mrow><msup><mi>f</mi><mrow><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>x</mi><mo>&in;</mo><mi>D</mi></mrow><mo stretchy="false">|</mo><mrow><mi>P</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>也就是说, 若<math><mi>E</mi></math>上的性质<math><mrow><mi>P</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></math>确定了<math><mi>E</mi></math>的一个链封闭子集, 而<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></mrow></math>是一个连续函数, 那么<math><mi>D</mi></math>上的性质<math><mrow><mi>P</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>确定了<math><mi>D</mi></math>的一个链封闭子集.</p><table class="label" align="center"><tr><td><div class="slide" style="height: 280px"><div align="center"><b>例子II</b></div><hr/>令<math><mi>D</mi></math>是一个domain而<math><mrow><mrow><mi>f</mi><mo>,</mo><mi>g</mi></mrow><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>是连续函数并且满足<math><mrow><mrow><mi>f</mi><mo>&compfn;</mo><mi>g</mi></mrow><mo>&sqsube;</mo><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow></mrow></math>, 那么<math display="block"><mrow><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&xrArr;</mo><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mtext>.</mtext></math>以下是使用Scott归纳的证明.<div class="proof"><b>证明.</b> 考虑<math><mi>D</mi></math>的可容许性质<math display="block"><mrow><mrow><mi mathvariant="normal">&Phi;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&equiv;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>鉴于<math display="block"><mrow><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&Implies;</mo><mrow><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&Implies;</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>我们有<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>.</mtext></math><div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div></div></td></tr><tr><td align="center">幻灯片42</td></tr></table><div class="tcomment"><b>译者注记.</b> 我们继续补齐一点gap. 鉴于<math display="block"><mrow><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>故<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>换言之, <math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow></math>是<math><mi>f</mi></math>的一个前不动点. 然而<math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>是<math><mi>f</mi></math>的最小前不动点, 所以有<math display="block"><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>.</mtext></math></div><h4>第4.3.3小节 逻辑运算</h4><p>令<math><mi>D</mi></math>是一个cpo. 令<math><mrow><mi>S</mi><mo>&sube;</mo><mi>D</mi></mrow></math>和<math><mrow><mi>T</mi><mo>&sube;</mo><mi>D</mi></mrow></math>是<math><mi>D</mi></math>的链封闭子集. 那么, 我们有<math display="block"><mrow><mi>S</mi><mo>&cup;</mo><mi>T</mi></mrow><mtext>和</mtext><mrow><mi>S</mi><mo>&cap;</mo><mi>T</mi></mrow></math>都是链封闭子集 (为什么?). 若是基于性质的语言, 若<math><mrow><mi>P</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math>和<math><mrow><mi>Q</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math>都确定了<math><mi>D</mi></math>的链封闭子集, 那么<math display="block"><mrow><mrow><mrow><mi>P</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mtext>或者</mtext><mrow><mi>Q</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>,</mo><mrow><mrow><mi>P</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&amp;</mo><mrow><mi>Q</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>也是如此.</p><p>如果<math><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>,</mo><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></mrow></math>是由集合<math><mi>I</mi></math>索引的<math><mi>D</mi></math>的一个链封闭子集的族, 那么<math><mrow><munder><mo>&bigcap;</mo><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></munder><msub><mi>S</mi><mi>i</mi></msub></mrow></math>是<math><mi>D</mi></math>的一个链封闭子集 (为什么?).</p><div class="tcomment"><b>译者注记.</b> (不论有限还是无限的)交的情况比较简单, 并的情况比较有趣. 对于<math><mrow><mi>S</mi><mo>&cup;</mo><mi>T</mi></mrow></math>中的链<math><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>x</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>x</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>, 我们可以按照是否属于<math><mi>S</mi></math>进行分类. 至少其中一类是无限的, 设其构成了(子)链<math><mrow><msub><mi>y</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>y</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>y</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>. 我们知道<math><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>y</mi><mi>n</mi></msub></mrow></math>肯定是属于<math><mrow><mi>S</mi><mo>&cup;</mo><mi>T</mi></mrow></math>的, 若是能够证明<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>y</mi><mi>n</mi></msub></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>x</mi><mi>n</mi></msub></mrow></mrow></math>那么就结束了. 首先鉴于<math><mrow><mo stretchy="false">{</mo><mrow><msub><mi>y</mi><mn>0</mn></msub><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo></mrow><mo stretchy="false">}</mo></mrow></math>是<math><mrow><mo stretchy="false">{</mo><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo></mrow><mo stretchy="false">}</mo></mrow></math>的一个子集, 所以<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>y</mi><mi>n</mi></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>x</mi><mi>n</mi></msub></mrow></mrow></math>那么我们需要证明的是<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>x</mi><mi>n</mi></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>y</mi><mi>n</mi></msub></mrow></mrow></math>实际上对于任意的<math><mrow><mi>i</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>, 鉴于子链<math><mrow><msub><mi>y</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>y</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>y</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>的长度是无限的, 所以必然可以找到某个<math><mrow><mi>j</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>使得<math><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>&sqsube;</mo><msub><mi>y</mi><mi>j</mi></msub></mrow></math>, 那么可以看出<math><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>y</mi><mi>n</mi></msub></mrow></math>是<math><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>x</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>x</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>的一个上界, 也就是说<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>x</mi><mi>n</mi></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>y</mi><mi>n</mi></msub></mrow></mrow><mtext>.</mtext></math>说明完毕, 以下是正文.</div><p>因此, 如果一个性质<math><mrow><mi>P</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>确定了<math><mrow><mi>D</mi><mo>&times;</mo><mi>E</mi></mrow></math>的一个链封闭子集, 那么性质<math><mrow><mo>&forall;</mo><mrow><mi>x</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mi>P</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>确定了<math><mi>E</mi></math>的一个链封闭子集. 这是因为<math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>y</mi><mo>&in;</mo><mi>E</mi></mrow><mo stretchy="false">|</mo><mrow><mo>&forall;</mo><mrow><mi>x</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mi>P</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><munder><mo>&bigcap;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow></munder><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>y</mi><mo>&in;</mo><mi>E</mi></mrow><mo stretchy="false">|</mo><mrow><mi>P</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><munder><mo>&bigcap;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow></munder><mrow><msup><msub><mi>f</mi><mi>d</mi></msub><mrow><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mrow><mi>D</mi><mo>&times;</mo><mi>E</mi></mrow></mrow><mo stretchy="false">|</mo><mrow><mi>P</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></mrow></mtd></mtr></mtable></math>其中<math><mrow><msub><mi>f</mi><mi>d</mi></msub><mo>:</mo><mrow><mi>E</mi><mo>&rarr;</mo><mrow><mi>D</mi><mo>&times;</mo><mi>E</mi></mrow></mrow></mrow></math>是连续函数, 定义为对于每个<math><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow></math>, <math><mrow><mrow><msub><mi>f</mi><mi>d</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>.</p><p>实际上, 若称形式为<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&ctdot;</mo><mo>,</mo><msub><mi>x</mi><mi>k</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&ctdot;</mo><mo>,</mo><msub><mi>x</mi><mi>l</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>或<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&ctdot;</mo><mo>,</mo><msub><mi>x</mi><mi>k</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&ctdot;</mo><mo>,</mo><msub><mi>x</mi><mi>l</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>的性质为基本性质 (其中<math><mi>f</mi></math>和<math><mi>g</mi></math>为连续函数), 那么对于由基本性质的合取与析取构成的东西进行其中一些变量的全称量化, 那么就会确定非量化的变量所对应的积cpo的一个链封闭子集.</p><div class="tcomment"><b>译者注记.</b> </div><p>不过, 注意到链封闭子集的无限并不必然是链封闭的; 有限子集总是链完备的, 但是其任意的并不是. 因此, 一般情况下我们不能使用存在量化构造链封闭子集.</p><h3>第4.4节 练习</h3><div class="exercise"><b>练习1.</b> </div><h2>第5章 PCF</h2><p>语言PCF (Programming Computable Functions, 编程可计算函数) 是一个简单的函数式编程语言, 其经常用作指称语义和操作语义的理论建立中的示例语言, 也包括这两种语义之间的关系的理论. 其句法是由Dana Scott于大约1969年引入的, 作为<q>Logic of Computable Functions (可计算函数逻辑)</q>的一部分, 其也在具有高度影响力的论文Plotkin (1977) 里作为一种编程语言被研究.</p><p>本章将给出我们在这个讲义里所使用的PCF的某个特定版本的句法和操作语义. 而在第6章中我们将看到如何使用domain和连续函数来赋予它一个指称语义.</p><h3>第5.1节 项和类型</h3><p>PCF语言的<em>类型</em>, <em>表达式</em>, <em>项</em>在幻灯片43中定义.</p><table class="label" align="center"><tr><td><div class="slide" style="height: 300px;"><div align="center"><b>PCF句法</b></div><hr/><em>类型</em><math display="block"><mrow><mi>&tau;</mi><mo>&Colone;</mo><mrow><mi>nat</mi><mo>|</mo><mi>bool</mi><mo>|</mo><mrow><mi>&tau;</mi><mo>&rarr;</mo><mi>&tau;</mi></mrow></mrow></mrow></math><em>表达式</em><math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mi>M</mi></mtd><mtd><mo>&Colone;</mo></mtd><mtd columnalign="left"><mrow><ms>0</ms><mo>|</mo><mrow><ms>succ</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow><mo>|</mo><mrow><ms>pred</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>|</mo></mtd><mtd columnalign="left"><mrow><ms>true</ms><mo>|</mo><ms>false</ms><mo>|</mo><mrow><ms>zero</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>|</mo></mtd><mtd columnalign="left"><mrow><mi>x</mi><mo>|</mo><mrow><ms>if</ms><mtext>&nbsp;</mtext><mi>M</mi><mtext>&nbsp;</mtext><ms>then</ms><mtext>&nbsp;</mtext><mi>M</mi><mtext>&nbsp;</mtext><ms>else</ms><mtext>&nbsp;</mtext><mi>M</mi></mrow></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>|</mo></mtd><mtd columnalign="left"><mrow><mrow><ms>fn</ms><mtext>&nbsp;</mtext><mrow><mi>x</mi><mo>:</mo><mi>&tau;</mi></mrow><mo lspace="0">.</mo><mi>M</mi></mrow><mo>|</mo><mrow><mi>M</mi><mo>&af;</mo><mi>M</mi></mrow><mo>|</mo><mrow><ms>fix</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr></mtable></math>其中<math><mrow><mi>x</mi><mo>&in;</mo><mi>&Vopf;</mi></mrow></math>, 一个<em>变量</em>无限集合.<br/><b>技术细节: </b>我们在绑定变量的<math><mi>&alpha;</mi></math>变换的意义下将表达式视为等同的, 而绑定变量是由<math><ms>fn</ms></math>表达式构造子创建的: 根据定义一个PCF<em>项</em>是一个表达式的<math><mi>&alpha;</mi></math>等价类.</div></td></tr><tr><td align="center">幻灯片43</td></tr></table><p>各种句法形式的意义如下.<ul><li><math><mi>nat</mi></math>是自然数<math><mrow><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mo>&hellip;</mo></mrow></math>的类型. </li></ul></p><h2>第6章 PCF的指称语义</h2><h2>第7章 将指称语义和操作语义联系起来</h2><h2>第8章 完全抽象</h2></body></html>