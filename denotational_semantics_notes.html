<html><head><meta charset="utf-8"/><title>指称语义学讲义</title><link href="styles.css" rel="stylesheet"/></head><body><h1>指称语义学讲义</h1><h2>前言</h2><p>我们的目的在于介绍domain论和指称语义, 并展示其是如何为推理程序行为提供数学基础的.</p><h3>推荐书目</h3><ul><li>Winskel, G. (1993). <i>The Formal Semantics of Programming Languages. </i>MIT Press.<br/>这是一本操作语义和指称语义的极好导论. 就本课程而言, 相关的章节是5, 8, 9, 10 (第1节和第2节), 以及11. [译注: 有中文译本, 名为程序设计语言的形式语义.]</li><li>Tennent, R. D. (1991). <i>Semantics of Programming Languages. </i>Prentice-Hall.<br/>部分I和II与本讲义有关.</li></ul><h3>深入阅读</h3><ul><li>Gunter, C. A. (1992). <i>Semantics of Programming Languages. Structures and Techniques. </i>MIT Press.<br/>这是一本研究生水平的教材, 包含有诸多本讲义未能涵盖的材料. 就讲义本身而言, 相关的章节是第1章, 第2章, 以及第4到6章.</li><li>Streicher, T. (2006). <i>Domain-Theoretic Foundations of Functional Programming. </i>World Scientific Publishing Co. ISBN 981-270-142-7<br/>一本关于本讲义后半部分所涉及的PCF语言的研究生水平教材.</li></ul><h2>第1章 引论</h2><p>幻灯片1提示了给出编程语言的形式语义的几种方法. 操作性方法于Part IB课程<b>Semantics of Programming Languages</b>中介绍, 而公理性方法在Part II课程<b>Hoare Logic</b>中刻画. 本课程讲义给出了指称性方法的一些技巧的简要导引. 指称语义学的目的之一在于以尽可能抽象且实现无关的方式描述编程语言的构造: 通过这种方法, 我们有可能获得对于某些概念的洞察, 而这些概念构成了编程语言以及其间关系的基础, 甚至有时还能理解在语言设计中实现这些概念的新方式. 当然, 验证指称性描述可以被实现是重要的. 换言之, 即将指称语义和操作语义联系起来: 我们将在之后刻画如何施行此事.</p><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>形式语义的风格</b></div><hr/><p><b>操作的.</b>程序片段的意义基于程序执行过程中其可以施行的<em>计算步骤</em>定义.</p><p><b>公理的.</b>程序片段的意义间接地通过程序性质的某种逻辑的<em>公理和规则</em>定义.</p><p><b>指称的.</b>关心给出编程语言的<em>数学模型</em>. 程序片段的意义抽象地定义为某种适当数学结构的元素.</p></div></td></tr><tr><td align="center">幻灯片1</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>指称语义的特征性质</b></div><hr/><ul><li>每个程序片段<math><mi>P</mi></math>被赋予一个<em>指称</em><math><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>P</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></math>, 这是一个数学对象, 其代表了<math><mi>P</mi></math>对于完整程序的意义的贡献.</li><li>一个程序片段的意义只由其子片段决定, 或者说指称语义是<em>可复合的</em>.</li></ul></div></td></tr><tr><td align="center">幻灯片2</td></tr></table><h3>第1.1节 指称语义的基本例子</h3><p>考虑基本的编程语言IMP<sup><math><mo>&minus;</mo></math></sup>, 其相当于带有控制结构的算术和布尔表达式, 而这里的控制结构是由赋值, 顺序, 条件刻画的, 见幻灯片3.</p><table class="label" align="center"><tr><td><div class="slide" style="height: 300px"><div align="center"><b>指称语义的基本例子 (I):</b></div><hr/><div align="center">IMP<sup><math><mo>&minus;</mo></math></sup>的句法</div><p>算术表达式: <math display="block"><mrow><mrow><mi>A</mi><mo>&in;</mo><ms>Aexp</ms></mrow><mo>&Colone;</mo><mrow><munder><mi>n</mi><mo>&UnderBar;</mo></munder><mo>|</mo><mi>L</mi><mo>|</mo><mrow><mi>A</mi><mo>+</mo><mi>A</mi></mrow><mo>|</mo><mo>&hellip;</mo></mrow></mrow></math>其中<math><mi>n</mi></math>是整数, 而<math><mrow><mi>L</mi><mo>&in;</mo><mi>&Lopf;</mi></mrow></math>, <math><mi>&Lopf;</mi></math>是给定的<em>位置</em>的集合.</p><p>布尔表达式: <math display="block"><mrow><mrow><mi>B</mi><mo>&in;</mo><ms>Bexp</ms></mrow><mo>&Colone;</mo><mrow><ms>true</ms><mo>|</mo><ms>false</ms><mo>|</mo><mrow><mi>A</mi><mo>=</mo><mi>A</mi></mrow><mo>|</mo><mrow><mo>&not;</mo><mi>B</mi></mrow><mo>|</mo><mo>&hellip;</mo></mrow></mrow></math></p><p>命令: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>C</mi><mo>&in;</mo><ms>Comm</ms></mrow></mtd><mtd><mo>&Colone;</mo></mtd><mtd columnalign="left"><mrow><ms>skip</ms><mo>|</mo><mrow><mi>L</mi><mo>&colone;</mo><mi>A</mi></mrow><mo>|</mo><mrow><mi>C</mi><mo>;</mo><mi>C</mi></mrow></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>|</mo></mtd><mtd columnalign="left"><mrow><ms>if</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>then</ms><mtext>&nbsp;</mtext><mi>C</mi><mtext>&nbsp;</mtext><ms>else</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow></mtd></mtr></mtable></math></p></div></td></tr><tr><td align="center">幻灯片3</td></tr></table><div class="tcomment"><b>译者注记.</b> <math><munder><mi>n</mi><mo>&UnderBar;</mo></munder></math>是代表整数<math><mi>n</mi></math>的句法.</div><p>为了给出一个编程语言的<em>指称语义</em>, 我们需要赋予每种程序片段的句法范畴以一个解释的domain (domain of interpretation), 然后复合性地描述各种形成程序片段 (phrase-forming) 的构造所对应的语义函数. 对于IMP<sup><math><mo>&minus;</mo></math></sup>, 幻灯片4到10给出了其指称语义, 并且这个语义也很容易在SML中实现.</p><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>指称语义的基本例子 (II)</b></div><hr/><div align="center">语义函数</div><math display="block"><mtable columnalign="left"><mtr><mtd><mrow><mi mathvariant="script">A</mi><mo>:</mo><mrow><ms>Aexp</ms><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&rarr;</mo><mi>&Zopf;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow><mi mathvariant="script">B</mi><mo>:</mo><mrow><ms>Bexp</ms><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&rarr;</mo><mi>&Bopf;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow><mi mathvariant="script">C</mi><mo>:</mo><mrow><ms>Comm</ms><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr></mtable></math>其中<math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mi>&Zopf;</mi></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mo stretchy="false">{</mo><mrow><mo>&hellip;</mo><mo>,</mo><mrow><mo>&minus;</mo><mn>1</mn></mrow><mo>,</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mo>&hellip;</mo></mrow><mo stretchy="false">}</mo></mrow></mtd></mtr><mtr><mtd columnalign="right"><mi>&Bopf;</mi></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mo stretchy="false">{</mo><mrow><mi>true</mi><mo>,</mo><mi>false</mi></mrow><mo stretchy="false">}</mo></mrow></mtd></mtr><mtr><mtd columnalign="right"><mi>State</mi></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mo stretchy="false">(</mo><mrow><mi>&Lopf;</mi><mo>&rarr;</mo><mi>&Zopf;</mi></mrow><mo stretchy="false">)</mo></mrow></mtd></mtr></mtable></math></div></td></tr><tr><td align="center">幻灯片4</td></tr></table><div class="tcomment"><b>译者注记.</b> <math><mo>&RightVector;</mo></math>的含义是部分函数 (partial function). 另外, <math><ms>true</ms></math>和<math><mi>true</mi></math>是不同的, 前者是句法, 而后者是一个数学对象.</div><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>指称语义的基本例子 (III)</b></div><hr/><div align="center">语义函数<math><mi mathvariant="script">A</mi></math></div><math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi mathvariant="script">A</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><munder><mi>n</mi><mo>&UnderBar;</mo></munder><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mi>n</mi></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow><mi mathvariant="script">A</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>L</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow><mi mathvariant="script">A</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>+</mo><msub><mi>A</mi><mn>2</mn></msub></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mrow><mi mathvariant="script">A</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mrow><mi mathvariant="script">A</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msub><mi>A</mi><mn>2</mn></msub><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mtd></mtr></mtable></math></div></td></tr><tr><td align="center">幻灯片5</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>指称语义的基本例子 (IV)</b></div><hr/><div align="center">语义函数<math><mi mathvariant="script">B</mi></math></div><math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi mathvariant="script">B</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><ms>true</ms><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mi>true</mi></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow><mi mathvariant="script">B</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><ms>false</ms><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mi>false</mi></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow><mi mathvariant="script">B</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>=</mo><msub><mi>A</mi><mn>2</mn></msub></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mi>eq</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mrow><mi mathvariant="script">A</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><mrow><mi mathvariant="script">A</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msub><mi>A</mi><mn>2</mn></msub><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mrow/></mtd><mtd columnalign="left"><mrow><mtext>其中</mtext><mrow><mrow><mi>eq</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>,</mo><msup><mi>a</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mi>true</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>a</mi><mo>=</mo><msup><mi>a</mi><mo>&prime;</mo></msup></mrow></mtd></mtr><mtr><mtd><mi>false</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>a</mi><mo>&ne;</mo><msup><mi>a</mi><mo>&prime;</mo></msup></mrow></mtd></mtr></mtable></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow><mi mathvariant="script">B</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><mo>&not;</mo><mi>B</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mo>&not;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi mathvariant="script">B</mi><mo>&af;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr></mtable></math></div></td></tr><tr><td align="center">幻灯片6</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>指称语义的基本例子 (V)</b></div><hr/><div align="center">语义函数<math><mi mathvariant="script">C</mi></math></div><math display="block"><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><ms>skip</ms><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>=</mo><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mi>s</mi></mrow></mrow></math><p>注记: 从现在开始, 语义函数的名字都将省略.</p></div></td></tr><tr><td align="center">幻灯片7</td></tr></table><table class="label" align="center"><tr><td><div class="slide" style="width: 500px"><div align="center"><b>可复合性一例</b></div><hr/><p>给定部分函数<math><mrow><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>,</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msup><mi>C</mi><mo>&prime;</mo></msup><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow><mo>:</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow></mrow></math>以及函数<math><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>:</mo><mrow><mi>State</mi><mo>&rarr;</mo><mrow><mo stretchy="false">{</mo><mrow><mi>true</mi><mo>,</mo><mi>false</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></mrow></math>, 我们可以定义<math display="block"><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>if</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>then</ms><mtext>&nbsp;</mtext><mi>C</mi><mtext>&nbsp;</mtext><ms>else</ms><mtext>&nbsp;</mtext><msup><mi>C</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>=</mo><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mi>if</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msup><mi>C</mi><mo>&prime;</mo></msup><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>其中<math display="block"><mrow><mrow><mi>if</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>b</mi><mo>,</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mi>x</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>b</mi><mo>=</mo><mi>true</mi></mrow></mtd></mtr><mtr><mtd><msup><mi>x</mi><mo>&prime;</mo></msup></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>b</mi><mo>=</mo><mi>false</mi></mrow></mtd></mtr></mtable></mrow></mrow></math></p></div></td></tr><tr><td align="center">幻灯片8</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>指称语义的基本例子 (VI)</b></div><hr/><div align="center">语义函数<math><mi mathvariant="script">C</mi></math></div><math display="block"><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><mi>L</mi><mo>&colone;</mo><mi>A</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>=</mo><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mi>&lambda;</mi><mrow><mi>l</mi><mo>&in;</mo><mi>&Lopf;</mi></mrow><mo lspace="0">.</mo><mrow><mi>if</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>l</mi><mo>=</mo><mi>L</mi></mrow><mo>,</mo><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>A</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math></div></td></tr><tr><td align="center">幻灯片9</td></tr></table><table class="label" align="center"><tr><td><div class="slide" style="width: 500px; height: 250px"><div align="center"><b>顺序复合的指称语义</b></div><hr/><p>两个命令的顺序复合<math><mrow><mi>C</mi><mo>;</mo><msup><mi>C</mi><mo>&prime;</mo></msup></mrow></math>的指称为<math display="block"><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><mi>C</mi><mo>;</mo><msup><mi>C</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>=</mo><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msup><mi>C</mi><mo>&prime;</mo></msup><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&compfn;</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow><mo>=</mo><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msup><mi>C</mi><mo>&prime;</mo></msup><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>这实际上就是命令的指称 (即部分函数<math><mrow><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>,</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msup><mi>C</mi><mo>&prime;</mo></msup><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow><mo>:</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow></mrow></math>) 的复合而已.</p><hr/><p>与之相对的是, 顺序复合的操作语义为<math display="block"><mfrac displaystyle="true"><mrow><mrow><mi>C</mi><mo>,</mo><mrow><mi>s</mi><mo>&dArr;</mo><msup><mi>s</mi><mo>&prime;</mo></msup></mrow></mrow><mspace width="8ex"/><mrow><msup><mi>C</mi><mo>&prime;</mo></msup><mo>,</mo><mrow><msup><mi>s</mi><mo>&prime;</mo></msup><mo>&dArr;</mo><msup><mi>s</mi><mo>&Prime;</mo></msup></mrow></mrow></mrow><mrow><mrow><mi>C</mi><mo>;</mo><msup><mi>C</mi><mo>&prime;</mo></msup></mrow><mo>,</mo><mrow><mi>s</mi><mo>&dArr;</mo><msup><mi>s</mi><mo>&Prime;</mo></msup></mrow></mrow></mfrac></math></p></div></td></tr><tr><td align="center">幻灯片10</td></tr></table><h3>第1.2节 例子: 作为不动点的<math><ms>while</ms></math>循环</h3><p>幻灯片2所提及的<em>可复合性</em>的要求是相当tough的. 我们用以赋予程序片段指称的数学对象必须足够丰富, 因为需要支持建模所讨论编程语言的一切形成程序片段的构造. 某些形成程序片段的构造是容易处理的, 而其他一些可能就不那么容易了. 例如, 牵涉状态改变命令的条件表达式 [译注: 更准确地说, 应该是条件命令] 可以基于应用相应的分支函数于立即子表达式的指称给出其指称语义: 见幻灯片8. 类似地, 命令的顺序复合的指称语义可由从状态到状态的部分函数的复合操作得到, 如幻灯片10.</p><p>现在我们来考虑基本编程语言IMP的指称语义, 其扩展了IMP<sup><math><mo>&minus;</mo></math></sup>以<math><ms>while</ms></math>循环:<math display="block"><mrow><mrow><mi>C</mi><mo>&in;</mo><ms>Comm</ms></mrow><mo>&Colone;</mo><mrow><mo>&hellip;</mo><mo>|</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow></mrow></mrow></math>然而, 这种循环构造并不容易以可复合的方式解释!</p><p><math><ms>while</ms></math>循环的转换语义为<math display="block"><mrow><mrow><mo stretchy="false">&lang;</mo><mrow><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo>,</mo><mi>s</mi></mrow><mo stretchy="false">&rang;</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">&lang;</mo><mrow><mrow><ms>if</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>then</ms><mtext>&nbsp;</mtext><mrow><mi>C</mi><mo>;</mo><mrow><mo stretchy="false">(</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mtext>&nbsp;</mtext><ms>else</ms><mtext>&nbsp;</mtext><ms>skip</ms></mrow><mo>,</mo><mi>s</mi></mrow><mo stretchy="false">&rang;</mo></mrow></mrow></math>这暗示了其作为从状态到状态的部分函数的指称应该满足<math display="block"><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>=</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>if</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>then</ms><mtext>&nbsp;</mtext><mrow><mi>C</mi><mo>;</mo><mrow><mo stretchy="false">(</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mtext>&nbsp;</mtext><ms>else</ms><mtext>&nbsp;</mtext><ms>skip</ms></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></math>我们应该注意到这不能直接用来定义<math><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></math>, 因为右边恰恰包含有一个我们想要定义其指称的子片段. 使用顺序复合和<math><ms>if</ms></math>的指称语义, 以及<math><ms>skip</ms></math>的指称为恒等函数<math><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mi>s</mi></mrow></math>的事实, 上面这条等式是在说<math><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></math>应该是幻灯片11中给出的<em>不动点方程</em>的一个解.</p><table class="label" align="center"><tr><td><div class="slide" style="width: 500px; height: 250px"><div align="center"><b><math><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mtext>的不动点性质</mtext></mrow></math></b></div><hr/><math display="block"><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>=</mo><mrow><msub><mi>f</mi><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>,</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>其中, 对于每个<math><mrow><mi>b</mi><mo>:</mo><mrow><mi>State</mi><mo>&rarr;</mo><mrow><mo stretchy="false">{</mo><mrow><mi>true</mi><mo>,</mo><mi>false</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></mrow></math>和<math><mrow><mi>c</mi><mo>:</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow></mrow></math>, 我们定义<math display="block"><mrow><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>:</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>为<math display="block"><mrow><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>=</mo><mrow><mi>&lambda;</mi><mrow><mi>w</mi><mo>&in;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo lspace="0">.</mo><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mi>if</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>b</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><mi>w</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>c</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mi>s</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math><hr/><ul><li>为什么<math><mrow><mi>w</mi><mo>=</mo><mrow><msub><mi>f</mi><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>,</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>有解?</li><li>若此方程具有多解, 那么选取哪一个作为<math><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></math>呢?</li></ul></div></td></tr><tr><td align="center">幻灯片11</td></tr></table><p>在赋予带有递归特性的编程语言以指称语义时, 这样的不动点方程经常出现. 自Dana Scott于60年代晚期的先驱性研究始, 一种被称为<em>domain论</em>的数学理论建立起来以提供一种背景环境, 其中我们不仅总是可以找到因指称语义而生的不动点方程的解, 而且还能选出在某种适切意义下最小的解, 而这实际上保证了指称语义和操作语义之间的协调配合. 关键的想法在于考虑用作指称的数学对象之间的一种偏序, 此偏序表达了这样的事实, 一个对象由另一个对象<em>近似</em>, 或者说比另一个对象<em>携带了更多的信息</em>, 或者说比另一个对象<em>更加良定</em>. 然后, 不动点方程的最小解可以被构造为对于解的近似升链的极限. 在下一章里, 这些想法将会变得从数学角度来说更加精确和一般, 但是目前先让我们具体地阐明该如何运用此想法解决幻灯片11中的特定问题.</p><p>为了确定起见, 让我们考虑以下特定的<math><ms>while</ms></math>循环<math display="block"><mrow><ms>while</ms><mtext>&nbsp;</mtext><mrow><mi>X</mi><mo>></mo><mn>0</mn></mrow><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>Y</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&#8270;</mo><mi>Y</mi></mrow></mrow><mo>;</mo><mrow><mi>X</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>其中<math><mi>X</mi></math>和<math><mi>Y</mi></math>是两个不同的整数存储位置 (变量), 而位置的集合<math><mrow><mi>&Lopf;</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mi>X</mi><mo>,</mo><mi>Y</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></math>.</p><div class="tcomment"><b>译者注记.</b> 在某种意义上说, 将<math><mi>&Lopf;</mi></math>的元素既用作句法也用作讨论语义时所牵涉的概念对象是一种(司空见惯的)滥用. 但是, 只要满足目的就好.</div><p>在这种情形之下, 我们可以就取状态为赋值<math><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></math>, 其中<math><mrow><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo>&in;</mo><mi>&Zopf;</mi></mrow></math>, 这记录了位置<math><mi>X</mi></math>和<math><mi>Y</mi></math>的当前内容. 因此, <math><mrow><mi>State</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&Lopf;</mi><mo>&rarr;</mo><mi>&Zopf;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>.</p><div class="tcomment"><b>译者注记.</b> 实际上, 幻灯片4中就已经定义<math><mi>State</mi></math>为<math><mrow><mo stretchy="false">(</mo><mrow><mi>&Lopf;</mi><mo>&rarr;</mo><mi>&Zopf;</mi></mrow><mo stretchy="false">)</mo></mrow></math>了.</div><p>我们正在试着将这个<math><ms>while</ms></math>循环的指称定义为一个部分函数<math display="block"><mrow><mi>w</mi><mo>:</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow></mrow></math>其应该是幻灯片11上的不动点方程<math display="block"><mrow><mi>w</mi><mo>=</mo><mrow><msub><mi>f</mi><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><mi>X</mi><mo>></mo><mn>0</mn></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>,</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><mrow><mi>Y</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&#8270;</mo><mi>Y</mi></mrow></mrow><mo>;</mo><mrow><mi>X</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>的一个解.</p><p>对于特定的布尔表达式<math><mrow><mi>B</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>></mo><mn>0</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></math>和命令<math><mrow><mi>C</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>Y</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&#8270;</mo><mi>Y</mi></mrow></mrow><mo>;</mo><mrow><mi>X</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>, 函数<math><msub><mi>f</mi><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>,</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></msub></math>恰好与幻灯片12上定义的函数<math><mi>f</mi></math>相同.</p><table class="label" align="center"><tr><td><div class="slide" style="width: 500px"><div align="center"><b><math><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mrow><mi>X</mi><mo>></mo><mn>0</mn></mrow><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>Y</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&#8270;</mo><mi>Y</mi></mrow></mrow><mo>;</mo><mrow><mi>X</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></math></b></div><hr/>令<math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mi>State</mi></mtd><mtd><mover><mo>=</mo><mi>def</mi></mover></mtd><mtd columnalign="left"><mrow><mo stretchy="false">(</mo><mrow><mi>&Lopf;</mi><mo>&rarr;</mo><mi>&Zopf;</mi></mrow><mo stretchy="false">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right"><mi>D</mi></mtd><mtd><mover><mo>=</mo><mi>def</mi></mover></mtd><mtd columnalign="left"><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow></mtd></mtr></mtable></math>对于<math><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mrow><mi>X</mi><mo>></mo><mn>0</mn></mrow><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>Y</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&#8270;</mo><mi>Y</mi></mrow></mrow><mo>;</mo><mrow><mi>X</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&in;</mo><mi>D</mi></mrow></math>, 我们寻求<math><mrow><mi>w</mi><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>的一个最小的解, 其中<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>被定义为<math display="block"><mrow><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&le;</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mi>w</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mrow><mi>x</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mrow><mi>x</mi><mo>&#8270;</mo><mi>y</mi></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>></mo><mn>0</mn></mrow></mtd></mtr></mtable></mrow></mrow></math></div></td></tr><tr><td align="center">幻灯片12</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b><math><mrow><mi>D</mi><mtext>上的偏序</mtext></mrow></math></b></div><hr/><ul><li><math><mi>D</mi></math>上的偏序<math><mo>&sqsube;</mo></math>:<br/><math><mrow><mi>w</mi><mo>&sqsube;</mo><msup><mi>w</mi><mo>&prime;</mo></msup></mrow></math>当且仅当对于每个<math><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow></math>, 如果<math><mi>w</mi></math>在<math><mi>s</mi></math>上有定义, 那么<math><msup><mi>w</mi><mo>&prime;</mo></msup></math>也在<math><mi>s</mi></math>上有定义, 并且<math><mrow><mrow><mi>w</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msup><mi>w</mi><mo>&prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>. 另外一种描述是, <math><mi>w</mi></math>的图包含于<math><msup><mi>w</mi><mo>&prime;</mo></msup></math>的图.</li><li>最小元<math><mrow><mi>&bottom;</mi><mo>&in;</mo><mi>D</mi></mrow></math> w.r.t. <math><mo>&sqsube;</mo></math>:<br/><math><mi>&bottom;</mi></math>即全然未定义的部分函数, 或者说图为空的部分函数, 其满足对于每个<math><mrow><mi>w</mi><mo>&in;</mo><mi>D</mi></mrow></math>, <math><mrow><mi>&bottom;</mi><mo>&sqsube;</mo><mi>w</mi></mrow></math>.</li></ul></div></td></tr><tr><td align="center">幻灯片13</td></tr></table><p>考虑幻灯片13上给出的<math><mrow><mi>D</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>的元素之间的偏序<math><mo>&sqsube;</mo></math>. 注意到<math><mo>&sqsube;</mo></math>实际上就是前文所提及的&quot;信息序&quot;的具体化身: 如果<math><mrow><mi>w</mi><mo>&sqsube;</mo><msup><mi>w</mi><mo>&prime;</mo></msup></mrow></math>, 那么<math><msup><mi>w</mi><mo>&prime;</mo></msup></math>在<math><mi>w</mi></math>有定义的地方都保持和<math><mi>w</mi></math>的一致, 但是它可能在其他一些参数上也有定义. 我们还应该注意到的是, <math><mi>D</mi></math>包含一个相对于此偏序的最小元: 对于全然未定义的部分函数, 我们将其记作<math><mi>&bottom;</mi></math>, 它满足对于任意的<math><mrow><mi>w</mi><mo>&in;</mo><mi>D</mi></mrow></math>都有<math><mrow><mi>&bottom;</mi><mo>&sqsube;</mo><mi>w</mi></mrow></math>.</p><p>自<math><mi>&bottom;</mi></math>开始, 我们反复应用函数<math><mi>f</mi></math>以构造一个部分函数的序列<math><mrow><msub><mi>w</mi><mn>0</mn></msub><mo>,</mo><msub><mi>w</mi><mn>1</mn></msub><mo>,</mo><msub><mi>w</mi><mn>2</mn></msub><mo>,</mo><mo>&hellip;</mo></mrow></math>:<math display="block"><mrow><mrow><msub><mi>w</mi><mn>0</mn></msub><mover><mo>=</mo><mi>def</mi></mover><mi>&bottom;</mi></mrow><mo>;</mo><mrow><msub><mi>w</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mover><mo>=</mo><mi>def</mi></mover><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mtext>.</mtext></math>使用幻灯片12上的<math><mi>f</mi></math>的定义, 我们发现<math display="block"><mrow><mrow><msub><mi>w</mi><mn>1</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&le;</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mi>undefined</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&ge;</mo><mn>1</mn></mrow></mtd></mtr></mtable></mrow></mrow></math><math display="block"><mrow><mrow><msub><mi>w</mi><mn>2</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&le;</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd><mi>undefined</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&ge;</mo><mn>2</mn></mrow></mtd></mtr></mtable></mrow></mrow></math><math display="block"><mrow><mrow><msub><mi>w</mi><mn>3</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&le;</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mrow><mn>2</mn><mo>&#8270;</mo><mi>y</mi></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mn>2</mn></mrow></mtd></mtr><mtr><mtd><mi>undefined</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&ge;</mo><mn>3</mn></mrow></mtd></mtr></mtable></mrow></mrow></math><math display="block"><mrow><mrow><msub><mi>w</mi><mn>4</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&le;</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mrow><mn>2</mn><mo>&#8270;</mo><mi>y</mi></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mn>2</mn></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mrow><mn>6</mn><mo>&#8270;</mo><mi>y</mi></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mn>3</mn></mrow></mtd></mtr><mtr><mtd><mi>undefined</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&ge;</mo><mn>4</mn></mrow></mtd></mtr></mtable></mrow></mrow></math>并且, 在<math><mrow><mi>n</mi><mo>&ge;</mo><mn>1</mn></mrow></math>的一般情况下, 我们有<math display="block"><mrow><mrow><msub><mi>w</mi><mi>n</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&le;</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mo>!</mo><mi>x</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&#8270;</mo><mi>y</mi></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mn>0</mn><mo>&lt;</mo><mi>x</mi><mo>&lt;</mo><mi>n</mi></mrow></mtd></mtr><mtr><mtd><mi>undefined</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&ge;</mo><mi>n</mi></mrow></mtd></mtr></mtable></mrow></mrow></math>其中<math><mrow><mo>!</mo><mi>x</mi></mrow></math>是<math><mi>x</mi></math>的阶乘.</p><p>因此, 我们得到了一个部分函数的递增序列<math display="block"><mrow><msub><mi>w</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>w</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>w</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo><mo>&sqsube;</mo><msub><mi>w</mi><mi>n</mi></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>所有这些部分函数之并是元素<math><mrow><msub><mi>w</mi><mi>&infin;</mi></msub><mo>&in;</mo><mi>D</mi></mrow></math>, 其为<math display="block"><mrow><mrow><msub><mi>w</mi><mi>&infin;</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&le;</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mo>!</mo><mi>x</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&#8270;</mo><mi>y</mi></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>></mo><mn>0</mn></mrow></mtd></mtr></mtable></mrow></mrow></math>注意到<math><msub><mi>w</mi><mi>&infin;</mi></msub></math>是<math><mi>f</mi></math>的一个不动点, 因为对于每个<math><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></math>, 我们有<math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mi>&infin;</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&le;</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><msub><mi>w</mi><mi>&infin;</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mrow><mi>x</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mrow><mi>x</mi><mo>&#8270;</mo><mi>y</mi></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>></mo><mn>0</mn></mrow></mtd></mtr></mtable></mrow><mspace width="6ex"/><mtext>(根据</mtext><mi>f</mi><mtext>的定义)</mtext></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&le;</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mrow><mn>1</mn><mo>&#8270;</mo><mi>y</mi></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mrow><mrow><mo>!</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>&minus;</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&#8270;</mo><mi>x</mi><mo>&#8270;</mo><mi>y</mi></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>></mo><mn>1</mn></mrow></mtd></mtr></mtable></mrow><mspace width="6ex"/><mtext>(根据</mtext><msub><mi>w</mi><mi>&infin;</mi></msub><mtext>的定义)</mtext></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><msub><mi>w</mi><mi>&infin;</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>X</mi><mo>&mapsto;</mo><mi>x</mi></mrow><mo>,</mo><mrow><mi>Y</mi><mo>&mapsto;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow></mtd></mtr></mtable></math>实际上, 我们可以表明<math><msub><mi>w</mi><mi>&infin;</mi></msub></math>是<math><mi>f</mi></math>的<em>最小</em>不动点, 意即对于任意的<math><mrow><mi>w</mi><mo>&in;</mo><mi>D</mi></mrow></math>, 有<math display="block"><mrow><mrow><mi>w</mi><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&Implies;</mo><mrow><msub><mi>w</mi><mi>&infin;</mi></msub><mo>&sqsube;</mo><mi>w</mi></mrow></mrow><mtext>.</mtext></math>我们取这个最小不动点<math><msub><mi>w</mi><mi>&infin;</mi></msub></math>作为<math display="block"><mrow><ms>while</ms><mtext>&nbsp;</mtext><mrow><mi>X</mi><mo>></mo><mn>0</mn></mrow><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>Y</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&#8270;</mo><mi>Y</mi></mrow></mrow><mo>;</mo><mrow><mi>X</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>的指称, 其构造方式是下一章要证明的Tarski不动点定理的一个实例. 我们也应该注意到, <math><msub><mi>w</mi><mi>&infin;</mi></msub></math>的确就是命令<math><mrow><ms>while</ms><mtext>&nbsp;</mtext><mrow><mi>X</mi><mo>></mo><mn>0</mn></mrow><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>Y</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&#8270;</mo><mi>Y</mi></mrow></mrow><mo>;</mo><mrow><mi>X</mi><mo>&colone;</mo><mrow><mi>X</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>的结构操作语义所给出的从状态到状态的函数, 见Part IB课程<b>Semantics of Programming Languages</b>.</p><h3>第1.3节 练习</h3><div class="exercise"><b>练习1.</b> 在SML中实现IMP<sup><math><mo>&minus;</mo></math></sup>的指称语义.</div><div class="exercise"><b>练习2.</b> 考虑幻灯片11上定义的函数<math display="block"><mrow><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>:</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math><ol type="i"><li>根据<math><mi>n</mi></math>上的归纳证明<math display="block"><mrow><mrow><msubsup><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow><mi>n</mi></msubsup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><msup><mi>c</mi><mi>k</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>, 如果存在</mtext><mrow><mn>0</mn><mo>&le;</mo><mi>k</mi><mo>&lt;</mo><mi>n</mi></mrow><mtext>满足对于每个</mtext><mrow><mn>0</mn><mo>&le;</mo><mi>i</mi><mo>&lt;</mo><mi>k</mi></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd columnalign="left"><mtext>有</mtext><mrow><mrow><mi>b</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>c</mi><mi>i</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>true</mi></mrow><mtext>而</mtext><mrow><mrow><mi>b</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>c</mi><mi>k</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>false</mi></mrow></mtd></mtr><mtr><mtd><mi>undefined</mi></mtd><mtd columnalign="left"><mtext>, 如果对于每个</mtext><mrow><mn>0</mn><mo>&le;</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><mtext>有</mtext><mrow><mrow><mi>b</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>c</mi><mi>i</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>true</mi></mrow></mtd></mtr></mtable></mrow></mrow></mrow></math></li><li>令<math><mrow><msub><mi>w</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>:</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow></mrow></math>是由<math display="block"><mrow><msub><mi>w</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mover><mo>=</mo><mi>def</mi></mover><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><msup><mi>c</mi><mi>k</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>, 如果存在</mtext><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow><mtext>满足对于每个</mtext><mrow><mn>0</mn><mo>&le;</mo><mi>i</mi><mo>&lt;</mo><mi>k</mi></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd columnalign="left"><mtext>有</mtext><mrow><mrow><mi>b</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>c</mi><mi>i</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>true</mi></mrow><mtext>而</mtext><mrow><mrow><mi>b</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>c</mi><mi>k</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>false</mi></mrow></mtd></mtr><mtr><mtd><mi>undefined</mi></mtd><mtd columnalign="left"><mtext>, 如果对于每个</mtext><mrow><mi>i</mi><mo>&ge;</mo><mn>0</mn></mrow><mtext>有</mtext><mrow><mrow><mi>b</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>c</mi><mi>i</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>true</mi></mrow></mtd></mtr></mtable></mrow></mrow></mrow></math>定义的部分函数, 证明<math><msub><mi>w</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub></math>满足不动点方程<math display="block"><mrow><msub><mi>w</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>=</mo><mrow><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>.</mtext></math></li><li>对于<math><mrow><mi>b</mi><mo>=</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><ms>true</ms><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>=</mo><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mi>true</mi></mrow></mrow></math>和<math><mrow><mi>c</mi><mo>=</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><ms>skip</ms><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>=</mo><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mi>s</mi></mrow></mrow></math>, 描述函数<math><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub></math>. 什么样的从状态到状态的部分函数是<math><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub></math>的不动点呢? 相对于<math><mo>&sqsube;</mo></math>的最小不动点是什么呢? 这个最小不动点和<math><mrow><ms>while</ms><mtext>&nbsp;</mtext><ms>true</ms><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><ms>skip</ms></mrow></math>的操作语义所确定的从状态到状态的部分函数是一致的吗?</li></ol></div><div class="exercise"><b>练习3.</b> 说明幻灯片13上的关系<math><mo>&sqsube;</mo></math>的确是一个偏序, 而且<math><mi>&bottom;</mi></math>是最小元.</div><div class="exercise"><b>练习4.</b> 证明<math><msub><mi>w</mi><mi>&infin;</mi></msub></math>的确是<math><mi>f</mi></math>的最小不动点. 更一般地, 根据幻灯片13和练习2的定义, 证明对于任意的<math><mrow><mi>w</mi><mo>&in;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>, 有<math display="block"><mrow><mrow><mi>w</mi><mo>=</mo><mrow><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&Implies;</mo><mrow><msub><mi>w</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>&sqsube;</mo><mi>w</mi></mrow></mrow><mtext>.</mtext></math></div><h2>第2章 最小不动点</h2><p>本章介绍了被称为<em>domain论</em>的数学理论, 其为构造各种编程语言特性的指称语义中所用到的最小不动点提供了一个一般性的框架. 该理论是由Dana Scott提出的.</p><h3>第2.1节 偏序集和单调函数</h3><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>论点</b></div><hr/><ul><li>所有计算的domain都是带有最小元的偏序集.</li><li>所有可计算函数都是单调的.</li></ul></div></td></tr><tr><td align="center">幻灯片14</td></tr></table><h4>第2.1.1小节 偏序集</h4><p>domain论使用满足特定完备性质的偏序集. 我们在幻灯片15中回顾了<em>偏序</em>的定义. <math><mi>D</mi></math>被称为偏序集<math><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>的<em>基础集(underlying set)</em>. 大部分时候, 我们只以基础集的名字引用偏序集, 而以相同的符号<math><mo>&sqsube;</mo></math>代表不同偏序集的偏序.</p><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>偏序集</b></div><hr/>集合<math><mi>D</mi></math>上的二元关系<math><mo>&sqsube;</mo></math>是一个偏序, 当且仅当它是<ul><li>自反的: <math><mrow><mo>&forall;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mi>d</mi><mo>&sqsube;</mo><mi>d</mi></mrow></mrow></math>;</li><li>传递的: <math><mrow><mo>&forall;</mo><mrow><mrow><mi>d</mi><mo>,</mo><msup><mi>d</mi><mo>&prime;</mo></msup><mo>,</mo><msup><mi>d</mi><mo>&Prime;</mo></msup></mrow><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&prime;</mo></msup><mo>&sqsube;</mo><msup><mi>d</mi><mo>&Prime;</mo></msup></mrow><mo>&Implies;</mo><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&Prime;</mo></msup></mrow></mrow></mrow></math>;</li><li>反对称的: <math><mrow><mo>&forall;</mo><mrow><mrow><mi>d</mi><mo>,</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&prime;</mo></msup><mo>&sqsube;</mo><mi>d</mi></mrow><mo>&Implies;</mo><mrow><mi>d</mi><mo>=</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow></mrow></mrow></math>.</li></ul>序对<math><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>被称为一个<em>偏序集</em>.</div></td></tr><tr><td align="center">幻灯片15</td></tr></table><div class="tcomment"><b>译者注记.</b> <math><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&prime;</mo></msup><mo>&sqsube;</mo><msup><mi>d</mi><mo>&Prime;</mo></msup></mrow></math>是<math><mrow><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mo>&amp;</mo><mrow><msup><mi>d</mi><mo>&prime;</mo></msup><mo>&sqsube;</mo><msup><mi>d</mi><mo>&Prime;</mo></msup></mrow></mrow></math>的缩写.</div><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>偏序集公理: 规则形式</b></div><hr/><math display="block"><mfrac displaystyle="true"><mrow/><mrow><mi>x</mi><mo>&sqsube;</mo><mi>x</mi></mrow></mfrac></math><br/><math display="block"><mfrac displaystyle="true"><mrow><mrow><mi>x</mi><mo>&sqsube;</mo><mi>y</mi></mrow><mspace width="8ex"/><mrow><mi>y</mi><mo>&sqsube;</mo><mi>z</mi></mrow></mrow><mrow><mi>x</mi><mo>&sqsube;</mo><mi>z</mi></mrow></mfrac></math><br/><math display="block"><mfrac displaystyle="true"><mrow><mrow><mi>x</mi><mo>&sqsube;</mo><mi>y</mi></mrow><mspace width="8ex"/><mrow><mi>y</mi><mo>&sqsube;</mo><mi>x</mi></mrow></mrow><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow></mfrac></math></div></td></tr><tr><td align="center">幻灯片16</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b><math><mrow><mtext>部分函数的domain,&nbsp;</mtext><mrow><mi>X</mi><mo>&RightVector;</mo><mi>Y</mi></mrow></mrow></math></b></div><hr/><ul><li>基础集: 由所有定义域<math><mrow><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sube;</mo><mi>X</mi></mrow></math>且取值于<math><mi>Y</mi></math>的部分函数<math><mi>f</mi></math>构成.</li><li>偏序: <math><mrow><mi>f</mi><mo>&sqsube;</mo><mi>g</mi></mrow></math>当且仅当<math><mrow><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sube;</mo><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>且<math><mrow><mo>&forall;</mo><mrow><mi>x</mi><mo>&in;</mo><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo lspace="0">.</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>, 或者说<math><mrow><mrow><mi>graph</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sube;</mo><mrow><mi>graph</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.</li></ul></div></td></tr><tr><td align="center">幻灯片17</td></tr></table><div class="tcomment"><b>译者注记.</b> 实在是一点可有可无且无聊的注记. 若<math><mrow><mi>A</mi><mo>&sube;</mo><mi>X</mi></mrow></math>而<math><mrow><mi>B</mi><mo>&sube;</mo><mi>Y</mi></mrow></math>, 那么应该将<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&RightVector;</mo><mi>B</mi></mrow></mrow></math>也视为<math><mrow><mi>X</mi><mo>&RightVector;</mo><mi>Y</mi></mrow></math>的元素吗 (假设排除<math><mrow><mi>A</mi><mo>=</mo><mi>X</mi></mrow></math>且<math><mrow><mi>B</mi><mo>=</mo><mi>Y</mi></mrow></math>的平凡情形)? 这是微妙的, 往往取决于具体的上下文.</div><div class="example"><b>例子1.</b> 从集合<math><mi>X</mi></math>到集合<math><mi>Y</mi></math>的所有部分函数构成的集合<math><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>&RightVector;</mo><mi>Y</mi></mrow><mo stretchy="false">)</mo></mrow></math>可以看成是一个偏序集, 如幻灯片17那样. 前一章里, 我们取这个domain在<math><mrow><mi>X</mi><mo>=</mo><mi>Y</mi><mo>=</mo><mi>State</mi></mrow></math> (某个状态集合) 情形下的实例作为命令的指称集.</div><h4>第2.1.2小节 单调函数</h4><p>幻灯片18中给出了偏序集之间的单调映射的概念.</p><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>单调性</b></div><hr/>两个偏序集之间的函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></mrow></math>是<em>单调的</em>, 如果<math display="block"><mrow><mo>&forall;</mo><mrow><mrow><mi>d</mi><mo>,</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mo>&Implies;</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msup><mi>d</mi><mo>&prime;</mo></msup><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow><mtext>.</mtext></math><br/><math display="block"><mfrac displaystyle="true"><mrow><mi>x</mi><mo>&sqsube;</mo><mi>y</mi></mrow><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mfrac><mspace width="8ex"/><mtext>(</mtext><mi>f</mi><mtext>单调)</mtext></math></div></td></tr><tr><td align="center">幻灯片18</td></tr></table><div class="example"><b>例子2.</b> 给定偏序集<math><mi>D</mi></math>和<math><mi>E</mi></math>, 显然常函数<math><mrow><mrow><mi>&lambda;</mi><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mi>e</mi></mrow><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></mrow></math>是单调的.</div><div class="example"><b>例子3.</b> 当<math><mi>D</mi></math>是部分函数的domain <math><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow></math> (见幻灯片17) 时, 幻灯片11上定义的与<math><ms>while</ms></math>循环的指称语义有关的函数<math><mrow><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>是一个单调函数. 我们将其验证留作练习.</div><h3>第2.2节 最小元和前不动点 (pre-fixed point)</h3><div class="definition"><b>定义1.</b> 设<math><mi>D</mi></math>是一个偏序集, <math><mi>S</mi></math>是<math><mi>D</mi></math>的一个子集, <math><mrow><mi>d</mi><mo>&in;</mo><mi>S</mi></mrow></math>被称为<math><mi>S</mi></math>的<em>最小</em>元, 如果其满足<math display="block"><mrow><mo>&forall;</mo><mrow><mi>x</mi><mo>&in;</mo><mi>S</mi></mrow><mo lspace="0">.</mo><mrow><mi>d</mi><mo>&sqsube;</mo><mi>x</mi></mrow></mrow><mtext>.</mtext></math></div><p>注意到因为<math><mo>&sqsube;</mo></math>是反对称的, 所以<math><mi>S</mi></math>至多拥有一个最小元. 我们也应该注意到, 有的偏序集是没有最小元的. 例如, 带有通常偏序的<math><mi>&Zopf;</mi></math>.</p><p>函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>的一个<em>不动点</em>, 根据定义, 是满足<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>d</mi></mrow></math>的一个元素<math><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow></math>. 如果<math><mi>D</mi></math>是一个偏序集, 我们可以考虑一个更弱的概念, 即<em>前不动点</em>, 见幻灯片19.</p><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>前不动点</b></div><hr/>令<math><mi>D</mi></math>是一个偏序集而<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>是一个函数.<br/>一个元素<math><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow></math>是<math><mi>f</mi></math>的一个<em>前不动点</em>, 如果其满足<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></math>.<br/><math><mi>f</mi></math>的<em>最小前不动点</em>, 如果存在的话, 记作<math display="block"><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mtext>.</mtext></math>因此, 最小前不动点由以下两条性质(唯一地)刻画:<ul><li>(lpf1): <math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>;</li><li>(lpf2): <math><mrow><mo>&forall;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow><mo>&Implies;</mo><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></mrow></mrow></math>.</li></ul></div></td></tr><tr><td align="center">幻灯片19</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>证明原理</b></div><hr/><ol><li><math display="block"><mfrac displaystyle="true"><mrow/><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mfrac></math></li><li>令<math><mi>D</mi></math>是一个偏序集, <math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>是一个带有最小前不动点<math><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&in;</mo><mi>D</mi></mrow></math>的函数.<br/>对于任意的<math><mrow><mi>x</mi><mo>&in;</mo><mi>D</mi></mrow></math>, 为了证明<math><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>x</mi></mrow></math>, 只需要证明<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>x</mi></mrow></math>.<math display="block"><mfrac displaystyle="true"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>x</mi></mrow><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>x</mi></mrow></mfrac></math></li></ol></div></td></tr><tr><td align="center">幻灯片20</td></tr></table><div class="proposition"><b>命题2.</b> 设<math><mi>D</mi></math>是一个偏序集而<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>是一个带有最小前不动点<math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>的函数. 只要<math><mi>f</mi></math>是单调的, 那么<math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>实际上就是<math><mi>f</mi></math>的一个不动点, 因此也是<math><mi>f</mi></math>的最小不动点.</div><div class="proof"><b>证明.</b> 因为<math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>是<math><mi>f</mi></math>的前不动点, 所以<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>. 如果<math><mi>f</mi></math>是单调的, 那么<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>.</mtext></math>换言之, <math><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>也是<math><mi>f</mi></math>的一个前不动点. 但是, 鉴于<math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>是最小的前不动点, 我们可以推出<math display="block"><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>.</mtext></math>根据偏序的反对称性, 我们可以断言<math display="block"><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>即<math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>是<math><mi>f</mi></math>的一个不动点. 而且, 考虑到偏序的自反性, 不动点也是前不动点. 对于任意的<math><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow></math>满足<math><mrow><mi>d</mi><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, 我们有<math><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></math>. 换言之, <math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>是<math><mi>f</mi></math>的最小不动点.<div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><h3>第2.3节 完全偏序 (cpo) 和连续函数</h3><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>论点*</b></div><hr/><ul><li>所有计算的domain都是带有最小元的完全偏序.</li><li>所有可计算函数都是连续的.</li></ul></div></td></tr><tr><td align="center">幻灯片21</td></tr></table><h4>第2.3.1小节 domain</h4><div class="definition"><b>定义1.</b> <ol type="i"><li>若存在, 我们将偏序集<math><mi>D</mi></math>的最小元记为<math><msub><mi>&bottom;</mi><mi>D</mi></msub></math>. 若<math><mi>D</mi></math>在上下文中是已知的, 写成<math><mi>&bottom;</mi></math>就可以了. 因此, <math><mi>&bottom;</mi></math>由性质<math display="block"><mrow><mo>&forall;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mi>&bottom;</mi><mo>&sqsube;</mo><mi>d</mi></mrow></mrow></math>唯一确定. 偏序集的最小元有时也被称为其<em>底(bottom)</em>元素.</li><li>偏序集<math><mi>D</mi></math>中的一个可数的升<em>链</em>是由<math><mi>D</mi></math>的元素构成的一个序列满足<math display="block"><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>这样的链的一个<em>上界</em>是任意满足<math><mrow><mo>&forall;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow><mo lspace="0">.</mo><mrow><msub><mi>d</mi><mi>n</mi></msub><mo>&sqsube;</mo><mi>d</mi></mrow></mrow></math>的<math><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow></math>. 若链的<em>最小上界(lub)</em>存在, 我们将其记为<math display="block"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mtext>.</mtext></math>因此, 根据定义:<ul><li><math><mrow><mo>&forall;</mo><mrow><mi>m</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow><mo lspace="0">.</mo><mrow><msub><mi>d</mi><mi>m</mi></msub><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow></mrow></mrow></math>.</li><li>对于任意的<math><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow></math>, 如果<math><mrow><mo>&forall;</mo><mrow><mi>m</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow><mo lspace="0">.</mo><mrow><msub><mi>d</mi><mi>m</mi></msub><mo>&sqsube;</mo><mi>d</mi></mrow></mrow></math>, 那么<math><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></math>.</li></ul></li></ol></div><div class="tcomment"><b>译者注记.</b> 所谓的链, 指的是偏序集的全序子集. 不过, 本讲义实际上只考虑以(通常的)序列面目出现的可数的升链.</div><div class="remark"><b>评注2.</b> 以下是读者应该注意的点.<ol type="i"><li>我们不需要考虑偏序集中不可数的链, 或者降链: 因此, &quot;链&quot;将总是指可数的升链.</li><li>就和偏序集的任意子集的最小元一样, 链的最小上界若存在则唯一. 当然, 链可以没有最小上界, 例如<math><mi>&Nopf;</mi></math>中的<math><mrow><mn>0</mn><mo>&le;</mo><mn>1</mn><mo>&le;</mo><mn>2</mn><mo>&le;</mo><mo>&hellip;</mo></mrow></math>, 不过它连上界也没有.</li><li>最小上界有时也被称为<em>上确界</em>. <math><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow></math>的一些其他常见替代记号为<math display="block"><mrow><munderover><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mi>&infin;</mi></munderover><msub><mi>d</mi><mi>n</mi></msub></mrow><mtext>和</mtext><mrow><mo>&bigsqcup;</mo><mrow><mo stretchy="false">{</mo><mrow><msub><mi>d</mi><mi>n</mi></msub><mo stretchy="false">|</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow><mtext>.</mtext></math></li><li>链的元素不必是互异的. 实际上, 我们称一个链<math><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math><em>终至恒常</em>, 如果存在<math><mrow><mi>N</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>使得<math><mrow><mo>&forall;</mo><mrow><mi>n</mi><mo>&ge;</mo><mi>N</mi></mrow><mo lspace="0">.</mo><mrow><msub><mi>d</mi><mi>n</mi></msub><mo>=</mo><msub><mi>d</mi><mi>N</mi></msub></mrow></mrow></math>. 注意到此时<math><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo>=</mo><msub><mi>d</mi><mi>N</mi></msub></mrow></math>.</li><li>如果我们丢弃链的开头任意有限数目的元素, 也并不会影响其上界集和最小上界:<math display="block"><mrow><mo>&forall;</mo><mrow><mi>N</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow><mo lspace="0">.</mo><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>N</mi><mo>+</mo><mi>n</mi></mrow></msub></mrow></mrow></mrow><mtext>.</mtext></math></li></ol></div><table class="label" align="center"><tr><td><div class="slide" style="width: 500px; height: 300px"><div align="center"><b>cpo和domain</b></div><hr/>一个<em>链完备偏序集(chain-complete poset)</em>, 或者说缩写为<em>cpo</em>, 是一个偏序集<math><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>满足其中的每个链<math><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>都具有最小上界<math><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow></math>:<ul><li>(lub1): <math><mrow><mo>&forall;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow><mo lspace="0">.</mo><mrow><msub><mi>d</mi><mi>m</mi></msub><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow></mrow></mrow></math>;</li><li>(lub2): <math><mrow><mo>&forall;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mo>&forall;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow><mo lspace="0">.</mo><mrow><msub><mi>d</mi><mi>m</mi></msub><mo>&sqsube;</mo><mi>d</mi></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>&Implies;</mo><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></mrow></mrow></math>.</li></ul>一个<em>domain</em>是一个带有最小元<math><mi>&bottom;</mi></math>的cpo:<math display="block"><mrow><mo>&forall;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mi>&bottom;</mi><mo>&sqsube;</mo><mi>d</mi></mrow></mrow><mtext>.</mtext></math></div></td></tr><tr><td align="center">幻灯片22</td></tr></table><div class="tcomment"><b>译者注记.</b> 幻灯片22的两个冒号后面的内容, 只是为了解释什么是最小上界和最小元. 另外, 链完备偏序集也被称为完全偏序, complete partial order.</div><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>最小元和最小上界的定义: 规则形式</b></div><hr/><math display="block"><mfrac displaystyle="true"><mrow/><mrow><mi>&bottom;</mi><mo>&sqsube;</mo><mi>x</mi></mrow></mfrac></math><br/><math display="block"><mfrac displaystyle="true"><mrow/><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>x</mi><mi>n</mi></msub></mrow></mrow></mfrac><mspace width="4ex"/><mtext>(</mtext><mrow><mi>i</mi><mo>&ge;</mo><mn>0</mn></mrow><mtext>而</mtext><mrow><mo stretchy="false">&lang;</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mtext>是一个链)</mtext></math><br/><math display="block"><mfrac displaystyle="true"><mrow><mo>&forall;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow><mo lspace="0">.</mo><mrow><msub><mi>x</mi><mi>m</mi></msub><mo>&sqsube;</mo><mi>x</mi></mrow></mrow><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>x</mi><mi>n</mi></msub></mrow><mo>&sqsube;</mo><mi>x</mi></mrow></mfrac><mspace width="4ex"/><mtext>(</mtext><mrow><mo stretchy="false">&lang;</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mtext>是一个链)</mtext></math></div></td></tr><tr><td align="center">幻灯片23</td></tr></table><p>本讲义里我们关心的是具有特定完备性质的偏序集, 见幻灯片22. 读者应该注意的是, 在有关的指称语义的文献中, 术语&quot;domain&quot;的含义是相当宽泛的: 存在各种各样的domain, 它们可能具有各种各样的序论性质, 而不仅仅是满足链完备性质和拥有最小元.</p><div class="example"><b>例子3.</b> 从集合<math><mi>X</mi></math>到集合<math><mi>Y</mi></math>的所有部分函数的集合<math><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>&RightVector;</mo><mi>Y</mi></mrow><mo stretchy="false">)</mo></mrow></math>上可以赋予一个偏序成为domain, 见幻灯片24. 在第1.2节, 我们使用了<math><mrow><mi>X</mi><mo>=</mo><mi>Y</mi><mo>=</mo><mi>State</mi></mrow></math>的特殊情形作为命令的指称集. 我们应该注意到, 声称是链<math><mrow><msub><mi>f</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>f</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>f</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>的最小上界的<math><mi>f</mi></math>的确是一个良定的部分函数, 因为在有定义的地方, 每个<math><msub><mi>f</mi><mi>n</mi></msub></math>的值都是一致的. 至于验证<math><mi>f</mi></math>的确是偏序集<math><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>X</mi><mo>&RightVector;</mo><mi>Y</mi></mrow><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>中的<math><mrow><msub><mi>f</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>f</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>f</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>的最小上界, 我们将其留给读者作为练习.</div><table class="label" align="center"><tr><td><div class="slide" style="height: 250px; width: 500px"><div align="center"><b><math><mrow><mtext>部分函数的domain,&nbsp;</mtext><mrow><mi>X</mi><mo>&RightVector;</mo><mi>Y</mi></mrow></mrow></math></b></div><hr/><b>基础集: </b>由所有满足以下条件的部分函数<math><mi>f</mi></math>构成, 其定义域<math><mrow><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sube;</mo><mi>X</mi></mrow></math>而取值于<math><mi>Y</mi></math>.<br/><b>偏序: </b><math><mrow><mi>f</mi><mo>&sqsube;</mo><mi>g</mi></mrow></math>当且仅当<math><mrow><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sube;</mo><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>且<math><mrow><mo>&forall;</mo><mrow><mi>x</mi><mo>&in;</mo><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo lspace="0">.</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>, 或者说<math><mrow><mrow><mi>graph</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sube;</mo><mrow><mi>graph</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.<br/><b>链的最小上界: </b>链<math><mrow><msub><mi>f</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>f</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>f</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>的最小上界是部分函数<math><mi>f</mi></math>, 其<math><mrow><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>而<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>, 如果存在某个</mtext><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow><mtext>使得</mtext><mrow><mi>x</mi><mo>&in;</mo><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mi>undefined</mi></mtd><mtd columnalign="left"><mtext>, 否则的话</mtext></mtd></mtr></mtable></mrow></mrow></math><b>最小元素: </b><math><mi>&bottom;</mi></math>是全然未定义的部分函数.</div></td></tr><tr><td align="center">幻灯片24</td></tr></table><div class="example"><b>例子4.</b> 对于任意的偏序集<math><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>而言, 如果<math><mi>D</mi></math>是有限的, 那么该偏序集是一个cpo. 这是因为, 在这样的偏序集中, 任何链都将终至恒常, 因而拥有最小上界. 当然, 有限的偏序集也不一定拥有最小元, 即不是一个domain. 例如, 考虑以下Hasse图所描述的偏序集.<svg width="320" height="150" stroke="black" style="display: block; margin: auto;"><defs><marker id="arrow" viewbox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 2 L 6 5 L 0 8 z"/></marker></defs><circle cx="60" cy="120" r="4"/><circle cx="260" cy="120" r="4"/><circle cx="160" cy="30" r="4"/><line x1="75" y1="106" x2="145" y2="44" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="245" y1="106" x2="175" y2="44" marker-end="url(#arrow)" stroke-width="1.2px"/></svg>一个偏序集的<em>Hasse图</em>是一个有向图, 其顶点是偏序集的基础集的元素, 而从顶点<math><mi>x</mi></math>到顶点<math><mi>y</mi></math>有一条边当且仅当<math><mrow><mi>x</mi><mo>&ne;</mo><mi>y</mi></mrow></math>且<math><mrow><mo>&forall;</mo><mi>z</mi><mo lspace="0">.</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>x</mi><mo>&sqsube;</mo><mi>z</mi></mrow><mo>&amp;</mo><mrow><mi>z</mi><mo>&sqsube;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>&Implies;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>z</mi><mo>=</mo><mi>x</mi></mrow><mo>&or;</mo><mrow><mi>z</mi><mo>=</mo><mi>y</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.</div><table class="label" align="center"><tr><td><svg width="500" height="400" stroke="black" style="display: block; margin: auto;"><defs><marker id="arrow" viewbox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 2 L 6 5 L 0 8 z"/></marker></defs><foreignObject x="23" y="36" width="150" height="30">&quot;扁平自然数集&quot;<math><msub><mi>&Nopf;</mi><mi>&bottom;</mi></msub></math>:</foreignObject><foreignObject x="53" y="66" width="150" height="30"><math><mn>0</mn></math></foreignObject><foreignObject x="113" y="66" width="150" height="30"><math><mn>1</mn></math></foreignObject><foreignObject x="173" y="66" width="150" height="30"><math><mn>2</mn></math></foreignObject><foreignObject x="233" y="66" width="150" height="30"><math><mo>&ctdot;</mo></math></foreignObject><foreignObject x="293" y="66" width="150" height="30"><math><mi>n</mi></math></foreignObject><foreignObject x="353" y="66" width="150" height="30"><math><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></math></foreignObject><foreignObject x="443" y="66" width="150" height="30"><math><mo>&ctdot;</mo></math></foreignObject><foreignObject x="233" y="126" width="150" height="30"><math><mi>&bottom;</mi></math></foreignObject><line x1="222" y1="125" x2="78" y2="85" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="228" y1="125" x2="132" y2="85" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="234" y1="125" x2="186" y2="85" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="246" y1="125" x2="294" y2="85" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="252" y1="125" x2="348" y2="85" marker-end="url(#arrow)" stroke-width="1.2px"/><foreignObject x="23" y="156" width="150" height="30">&quot;垂直自然数集&quot;<math><mi mathvariant="normal">&Omega;</mi></math>:</foreignObject><foreignObject x="233" y="186" width="150" height="30"><math><mi>&omega;</mi></math></foreignObject><foreignObject x="218" y="226" width="150" height="30"><math><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></math></foreignObject><foreignObject x="233" y="266" width="150" height="30"><math><mi>n</mi></math></foreignObject><foreignObject x="233" y="306" width="150" height="30"><math><mn>2</mn></math></foreignObject><foreignObject x="233" y="346" width="150" height="30"><math><mn>1</mn></math></foreignObject><foreignObject x="233" y="386" width="150" height="30"><math><mn>0</mn></math></foreignObject><line x1="237" y1="383" x2="237" y2="366" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="237" y1="343" x2="237" y2="326" marker-end="url(#arrow)" stroke-width="1.2px"/><foreignObject x="236" y="286" width="150" height="30"><math><mo>&vellip;</mo></math></foreignObject><line x1="237" y1="263" x2="237" y2="246" marker-end="url(#arrow)" stroke-width="1.2px"/><foreignObject x="236" y="206" width="150" height="30"><math><mo>&vellip;</mo></math></foreignObject></svg></td></tr><tr><td align="center">图1</td></tr></table><p>图1展示两个非常简单但却无限的domain, 而以下是两个并非cpo的偏序集的例子.</p><div class="example"><b>例子5.</b> 装备有通常偏序<math><mo>&le;</mo></math>的自然数集<math><mrow><mi>&Nopf;</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mo>&hellip;</mo></mrow><mo stretchy="false">}</mo></mrow></mrow></math>不是一个cpo, 因为链<math><mrow><mn>0</mn><mo>&le;</mo><mn>1</mn><mo>&le;</mo><mn>2</mn><mo>&le;</mo><mo>&hellip;</mo></mrow></math>在<math><mi>&Nopf;</mi></math>中没有上界.</div><div class="example"><b>例子6.</b> 考虑上图的第二个例子的一种修改版本, 其中我们为<math><mi>&Nopf;</mi></math>添加了两个不同的上界<math><mrow><msub><mi>&omega;</mi><mn>1</mn></msub><mo>&ne;</mo><msub><mi>&omega;</mi><mn>2</mn></msub></mrow></math>. 换言之, 我们考虑的是<math><mrow><mi>D</mi><mover><mo>=</mo><mi>def</mi></mover><mrow><mi>&Nopf;</mi><mo>&cup;</mo><mrow><mo stretchy="false">{</mo><mrow><msub><mi>&omega;</mi><mn>1</mn></msub><mo>,</mo><msub><mi>&omega;</mi><mn>2</mn></msub></mrow><mo stretchy="false">}</mo></mrow></mrow></mrow></math>, 而其上的偏序<math><mo>&sqsube;</mo></math>为<math display="block"><mrow><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mover><mo>&hArr;</mo><mi>def</mi></mover><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mi>d</mi><mo>&le;</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mrow><mi>d</mi><mo>,</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mo>&in;</mo><mi>&Nopf;</mi></mrow></mtd></mtr><mtr><mtd><mrow><mrow><mi>d</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow><mo>&or;</mo><mrow><mi>d</mi><mo>=</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><msup><mi>d</mi><mo>&prime;</mo></msup><mo>&in;</mo><mrow><mo stretchy="false">{</mo><mrow><msub><mi>&omega;</mi><mn>1</mn></msub><mo>,</mo><msub><mi>&omega;</mi><mn>2</mn></msub></mrow><mo stretchy="false">}</mo></mrow></mrow></mtd></mtr></mtable></mrow></mrow></math>然后, <math><mi>D</mi></math>中的链<math><mrow><mn>0</mn><mo>&sqsube;</mo><mn>1</mn><mo>&sqsube;</mo><mn>2</mn><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>拥有两个上界, 即<math><msub><mi>&omega;</mi><mn>1</mn></msub></math>和<math><msub><mi>&omega;</mi><mn>2</mn></msub></math>, 但是没有最小的上界, 因为<math><msub><mi>&omega;</mi><mn>1</mn></msub></math>和<math><msub><mi>&omega;</mi><mn>2</mn></msub></math>不可比较. 因此, <math><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>不是一个cpo.</div><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>链的最小上界的一些性质</b></div><hr/>设<math><mi>D</mi></math>是一个cpo.<ol><li>对于任意的<math><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow></math>, <math><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mi>d</mi></mrow><mo>=</mo><mi>d</mi></mrow></math>.</li><li>对于<math><mi>D</mi></math>中的每个链<math><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>1</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo><mo>&sqsube;</mo><msub><mi>d</mi><mi>n</mi></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>, 我们有<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>N</mi><mo>+</mo><mi>n</mi></mrow></msub></mrow></mrow></math>对于任意的<math><mrow><mi>N</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>成立.</li></ol></div></td></tr><tr><td align="center">幻灯片25</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>链的最小上界的一些性质 (续)</b></div><hr/><ol start="3"><li>对于<math><mi>D</mi></math>中的两条链<math><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>1</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo><mo>&sqsube;</mo><msub><mi>d</mi><mi>n</mi></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>和<math><mrow><msub><mi>e</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>e</mi><mn>1</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo><mo>&sqsube;</mo><msub><mi>e</mi><mi>n</mi></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>, 如果对于每个<math><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>有<math><mrow><msub><mi>d</mi><mi>n</mi></msub><mo>&sqsube;</mo><msub><mi>e</mi><mi>n</mi></msub></mrow></math>, 那么<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>e</mi><mi>n</mi></msub></mrow></mrow><mtext>.</mtext></math></li></ol><math display="block"><mfrac displaystyle="true"><mrow><mo>&forall;</mo><mrow><mi>n</mi><mo>&in;</mo><mn>0</mn></mrow><mo lspace="0">.</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>&sqsube;</mo><msub><mi>y</mi><mi>n</mi></msub></mrow></mrow><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>x</mi><mi>n</mi></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>y</mi><mi>n</mi></msub></mrow></mrow></mfrac><mspace width="4ex"/><mtext>(</mtext><mrow><mo stretchy="false">&lang;</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mtext>和</mtext><mrow><mo stretchy="false">&lang;</mo><msub><mi>y</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mtext>俱是链)</mtext></math></div></td></tr><tr><td align="center">幻灯片26</td></tr></table><table class="label" align="center"><tr><td><div class="slide" style="height: 300px"><div align="center"><b>双链的对角化</b></div><hr/><div class="lemma"><b>引理.</b> 令<math><mi>D</mi></math>是一个cpo, 设双下标索引的元素<math><mrow><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub><mo>&in;</mo><mi>D</mi></mrow></math> (其中<math><mrow><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow><mo>&ge;</mo><mn>0</mn></mrow></math>) 构成的族满足<math display="block"><mrow><mrow><mrow><mi>m</mi><mo>&le;</mo><msup><mi>m</mi><mo>&prime;</mo></msup></mrow><mo>&amp;</mo><mrow><mi>n</mi><mo>&le;</mo><msup><mi>n</mi><mo>&prime;</mo></msup></mrow></mrow><mo>&Implies;</mo><mrow><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub><mo>&sqsube;</mo><msub><mi>d</mi><mrow><msup><mi>m</mi><mo>&prime;</mo></msup><mo>,</mo><msup><mi>n</mi><mo>&prime;</mo></msup></mrow></msub></mrow></mrow></math>那么我们有<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mn>0</mn><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mn>1</mn><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mn>2</mn><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>以及<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mn>0</mn></mrow></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mn>1</mn></mrow></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mn>2</mn></mrow></msub></mrow><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>而且<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>k</mi><mo>,</mo><mi>k</mi></mrow></msub></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>.</mtext></math></div></div></td></tr><tr><td align="center">幻灯片27</td></tr></table><div class="proof"><b>证明.</b> 我们利用了定义链的最小上界的性质, 即幻灯片22上的(lub1)和(lub2). 首先, 注意到如果<math><mrow><mi>m</mi><mo>&le;</mo><msup><mi>m</mi><mo>&prime;</mo></msup></mrow></math>, 那么<math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub></mtd><mtd><mo>&sqsube;</mo></mtd><mtd><msub><mi>d</mi><mrow><msup><mi>m</mi><mo>&prime;</mo></msup><mo>,</mo><mi>n</mi></mrow></msub></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>&sqsube;</mo></mtd><mtd><mrow><munder><mo>&bigsqcup;</mo><mrow><msup><mi>n</mi><mo>&prime;</mo></msup><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><msup><mi>m</mi><mo>&prime;</mo></msup><mo>,</mo><msup><mi>n</mi><mo>&prime;</mo></msup></mrow></msub></mrow></mtd></mtr></mtable></math>对于每个<math><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></math>成立. 因此, <math><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><msup><mi>n</mi><mo>&prime;</mo></msup><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><msup><mi>m</mi><mo>&prime;</mo></msup><mo>,</mo><msup><mi>n</mi><mo>&prime;</mo></msup></mrow></msub></mrow></mrow></math>. 于是, 我们的确可以得到一条由最小上界构成的链<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mn>0</mn><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mn>1</mn><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mn>2</mn><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>并且我们可以构造其最小上界<math><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub></mrow></mrow></math>. 运用两次(lub1), 我们有<math display="block"><mrow><msub><mi>d</mi><mrow><mi>k</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>k</mi><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub></mrow></mrow></mrow></math>对于每个<math><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow></math>成立, 那么根据(lub2)可以得到<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>k</mi><mo>,</mo><mi>k</mi></mrow></msub></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub></mrow></mrow></mrow></math>反过来, 对于每个<math><mrow><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow><mo>&ge;</mo><mn>0</mn></mrow></math>, 我们注意到<math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub></mtd><mtd><mo>&sqsube;</mo></mtd><mtd><msub><mi>d</mi><mrow><mrow><mi>max</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><mi>max</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></msub></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>&sqsube;</mo></mtd><mtd><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>k</mi><mo>,</mo><mi>k</mi></mrow></msub></mrow></mtd></mtr></mtable></math>因而再应用两次(lub2)就可以推出<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow></msub></mrow></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mi>k</mi><mo>,</mo><mi>k</mi></mrow></msub></mrow></mrow></math>根据<math><mo>&sqsube;</mo></math>的反对称性, 我们就得出了想要的等式. 剩余的结果也可按照相同的论证手法得到, 只需要交换<math><mi>m</mi></math>和<math><mi>n</mi></math>的角色.<div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><h4>第2.3.2小节 连续函数</h4><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>连续性和严格性</b></div><hr/><ul><li>如果<math><mi>D</mi></math>和<math><mi>E</mi></math>是cpo, 函数<math><mi>f</mi></math>是<em>连续的</em>当且仅当<ol><li><math><mi>f</mi></math>是单调的;</li><li><math><mi>f</mi></math>保持链的最小上界, 即对于<math><mi>D</mi></math>中的每条链<math><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>1</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>, 我们有<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mtext>.</mtext></math></li></ol></li><li>如果<math><mi>D</mi></math>和<math><mi>E</mi></math>都拥有最小元, 那么称函数<math><mi>f</mi></math>是<em>严格的</em>, 如果<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>&bottom;</mi></mrow></math>.</li></ul></div></td></tr><tr><td align="center">幻灯片28</td></tr></table><div class="remark"><b>评注7.</b> 我们注意到如果<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></mrow></math>是单调的, 并且<math><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>是<math><mi>D</mi></math>中的一个链, 那么应用<math><mi>f</mi></math>就可以得到<math><mi>E</mi></math>中的一个链<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>. 而且, 如果<math><mi>d</mi></math>是第一条链的一个上界, 那么<math><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></math>是第二条链的一个上界. 换言之, 如果<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></mrow></math>是cpo之间的单调函数, 我们总有<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>因此, 根据<math><mo>&sqsube;</mo></math>的固有性质, 给定cpo之间的单调函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></mrow></math>, <math><mi>f</mi></math>是连续的等价于对于<math><mi>D</mi></math>中的每条链<math><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>d</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>, <math><mi>E</mi></math>中<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>成立.</div><div class="example"><b>例子8.</b> 给定cpo <math><mi>D</mi></math>和<math><mi>E</mi></math>, 对于每个<math><mrow><mi>e</mi><mo>&in;</mo><mi>E</mi></mrow></math>而言, 常函数<math><mrow><mrow><mi>&lambda;</mi><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mi>e</mi></mrow><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></mrow></math>是连续的.</div><div class="example"><b>例子9.</b> 当<math><mi>D</mi></math>是部分函数的domain <math><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow></math>时 (见幻灯片24), 定义于幻灯片11的与<math><ms>while</ms></math>循环的指称语义有关的函数<math><mrow><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>是一个连续函数. 我们将其验证留作练习.</div><div class="example"><b>例子10.</b> 令<math><mi mathvariant="normal">&Omega;</mi></math>是垂直自然数的domain, 那么由<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mn>0</mn></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></mtd></mtr><mtr><mtd><mi>&omega;</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mi>&omega;</mi></mrow></mtd></mtr></mtable></mrow></mrow></math>定义的函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mi mathvariant="normal">&Omega;</mi><mo>&rarr;</mo><mi mathvariant="normal">&Omega;</mi></mrow></mrow></math>既是单调的也是严格的, 但是并非连续, 因为<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mi>n</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&omega;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>&omega;</mi></mrow></math>然而<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mn>0</mn></mrow><mo>=</mo><mn>0</mn></mrow></math></div><h3>第2.4节 Tarski不动点定理</h3><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>Tarski不动点定理</b></div><hr/>令<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>是domain <math><mi>D</mi></math>上的一个连续函数, 那么<ul><li><math><mi>f</mi></math>具有最小前不动点, 由<math display="block"><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>给出.</li><li>于是, <math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>也是<math><mi>f</mi></math>的不动点, 因而是<math><mi>f</mi></math>的<em>最小不动点</em>.</li></ul></div></td></tr><tr><td align="center">幻灯片29</td></tr></table><p>幻灯片29给出了关于domain上的连续函数的关键结果, 其允许我们赋予牵涉递归特性的程序以指称语义. 幻灯片上所用的记号<math><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></math>是递归定义的:<math display="block"><mrow><mrow><mrow><msup><mi>f</mi><mn>0</mn></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mover><mo>=</mo><mi>def</mi></mover><mi>&bottom;</mi></mrow><mo>;</mo><mrow><mrow><msup><mi>f</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mover><mo>=</mo><mi>def</mi></mover><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mtext>.</mtext></math>注意到既然<math><mrow><mo>&forall;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mi>&bottom;</mi><mo>&sqsube;</mo><mi>d</mi></mrow></mrow></math>, 我们有<math><mrow><mrow><mrow><msup><mi>f</mi><mn>0</mn></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>&bottom;</mi></mrow><mo>&sqsube;</mo><mrow><msup><mi>f</mi><mn>1</mn></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>; 而根据单调性, 又可以推出<math display="block"><mrow><mrow><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><msup><mi>f</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&Implies;</mo><mrow><mrow><mrow><msup><mi>f</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&sqsube;</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>f</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msup><mi>f</mi><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow><mtext>.</mtext></math>因此, 通过对于<math><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>进行归纳, 我们可以得到<math display="block"><mrow><mo>&forall;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow><mo lspace="0">.</mo><mrow><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><msup><mi>f</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mtext>.</mtext></math>换言之, 元素<math><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></math>构成了<math><mi>D</mi></math>中的一条链. 所以说, 既然<math><mi>D</mi></math>是cpo, 那么幻灯片29上用到的<math><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>的确是有意义的.</p><div class="proof"><b>证明.</b> 首先我们注意到<math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd columnalign="left"><mrow><mtext>根据</mtext><mi>f</mi><mtext>的连续性</mtext></mrow></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msup><mi>f</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd columnalign="left"><mtext>根据函数的幂次的定义</mtext></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd columnalign="left"><mtext>根据第2.3节的评注2</mtext></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></mtd></mtr></mtable></math>因此, <math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>的确是<math><mi>f</mi></math>的一个不动点, 当然也就满足幻灯片19上的条件(lpf1). 为了验证(lpf2), 即前不动点的最小性, 我们设<math><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow></math>满足<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></math>, 那么既然<math><mi>&bottom;</mi></math>在<math><mi>D</mi></math>是最小的, 可以得到<math display="block"><mrow><mrow><mrow><msup><mi>f</mi><mn>0</mn></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>&bottom;</mi></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></math>并且<math display="block"><mrow><mrow><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow><mo>&Implies;</mo><mrow><mrow><mrow><msup><mi>f</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></mrow></math>根据归纳, 我们可以推出<math><mrow><mo>&forall;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow><mo lspace="0">.</mo><mrow><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></mrow></math>. 换言之, <math><mi>d</mi></math>是链的一个上界, 所以它大于等于最小上界, 即<math display="block"><mrow><mrow><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mo>&sqsube;</mo><mi>d</mi></mrow></math>这就是我们想要的(lpf2)了.<div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><div class="example"><b>例子1.</b> 定义于幻灯片11上的函数<math><msub><mi>f</mi><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>,</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></msub></math>是domain <math><mrow><mo stretchy="false">(</mo><mrow><mi>State</mi><mo>&RightVector;</mo><mi>State</mi></mrow><mo stretchy="false">)</mo></mrow></math>上的一个连续函数, 因而我们可以应用Tarski不动点定理, 将<math><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></math>定义为<math><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>,</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></msub><mo stretchy="false">)</mo></mrow></mrow></math>. 实际上, 第1.2节中我们构造部分函数<math><msub><mi>w</mi><mi>&infin;</mi></msub></math>的方法不过就是不动点定理的一个实例而已.</div><table class="label" align="center"><tr><td><div class="slide" style="width: 650px"><div align="center"><b><math><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></math></b></div><hr/><math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><ms>while</ms><mtext>&nbsp;</mtext><mi>B</mi><mtext>&nbsp;</mtext><ms>do</ms><mtext>&nbsp;</mtext><mi>C</mi></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mi>fix</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>,</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></msub><mo stretchy="false">)</mo></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msubsup><mi>f</mi><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>,</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow><mi>n</mi></msubsup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mi>&lambda;</mi><mrow><mi>s</mi><mo>&in;</mo><mi>State</mi></mrow><mo lspace="0">.</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><msup><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mi>k</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>, 如果存在</mtext><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow><mtext>满足对于每个</mtext><mrow><mn>0</mn><mo>&le;</mo><mi>i</mi><mo>&lt;</mo><mi>k</mi></mrow><mtext>有</mtext></mtd></mtr><mtr><mtd><mrow/></mtd><mtd columnalign="left"><mrow><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mi>i</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>true</mi></mrow><mtext>而</mtext><mrow><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mi>k</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>false</mi></mrow></mtd></mtr><mtr><mtd><mi>undefined</mi></mtd><mtd columnalign="left"><mtext>, 如果对于每个</mtext><mrow><mi>i</mi><mo>&ge;</mo><mn>0</mn></mrow><mtext>有</mtext><mrow><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>B</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>C</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mi>i</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>true</mi></mrow></mtd></mtr></mtable></mrow></mrow></mtd></mtr></mtable></math></div></td></tr><tr><td align="center">幻灯片30</td></tr></table><h3>第2.5节 练习</h3><div class="exercise"><b>练习1.</b> 验证幻灯片24上的断言.</div><div class="exercise"><b>练习2.</b> 证明幻灯片25和27中的声明.</div><div class="exercise"><b>练习3.</b> 验证例子9中<math><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub></math>是连续函数的断言. 何时<math><msub><mi>f</mi><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow></msub></math>是严格的?</div><div class="tcomment"><b>译者注记.</b> 以上练习皆相当平凡.</div><h2>第3章 domain上的构造</h2><p>本节我们将给出诸多构造domain和连续函数的方式, 实际上专注于PCF编程语言的指称语义所需的构造, PCF是本讲义的后半部分的研究对象. 注意到为了描述一个cpo, 我们必须先<em>定义</em>一个装备有某二元关系的集合, 然后<em>证明</em><ol type="i"><li>这个关系是一个偏序;</li><li>对于这个偏序集中所有的链, 其最小上界存在.</li></ol>另外, 为了使得cpo成为一个domain, 我们还需要说明<ol type="i" start="3"><li>存在最小的元素.</li></ol>注意到既然链的最小上界以及最小元若存在则唯一, 那么cpo和domain完全由其基础集和偏序决定. [译注: 意味不明.] 之后我们将给出各种各样构造cpo和domain的方法, 而将验证i, ii, iii成立的任务留作练习.</p><h3>第3.1节 扁平domain</h3><p>为了模拟PCF的基本类型 (ground type) <math><mi>nat</mi></math>和<math><mi>bool</mi></math>, 我们将使用幻灯片31给出的<em>扁平domain</em>的概念.</p><table class="label" align="center"><tr><td><div class="slide" style="height: 250px"><div align="center"><b>离散cpo和扁平domain</b></div><hr/>对于任意的集合<math><mi>X</mi></math>, 相等关系<math display="block"><mrow><mrow><mi>x</mi><mo>&sqsube;</mo><msup><mi>x</mi><mo>&prime;</mo></msup></mrow><mover><mo>&hArr;</mo><mi>def</mi></mover><mrow><mi>x</mi><mo>=</mo><msup><mi>x</mi><mo>&prime;</mo></msup></mrow></mrow></math>使得<math><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>成为一个cpo, 其被称为以<math><mi>X</mi></math>为基础集的<em>离散</em>cpo.<br/>令<math><mrow><msub><mi>X</mi><mi>&bottom;</mi></msub><mover><mo>=</mo><mi>def</mi></mover><mrow><mi>X</mi><mo>&cup;</mo><mrow><mo stretchy="false">{</mo><mi>&bottom;</mi><mo stretchy="false">}</mo></mrow></mrow></mrow></math>, 其中<math><mi>&bottom;</mi></math>是某个不在<math><mi>X</mi></math>中的元素, 那么<math display="block"><mrow><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mover><mo>&hArr;</mo><mi>def</mi></mover><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>=</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow><mo>&or;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>=</mo><mi>&bottom;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>使得<math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>X</mi><mi>&bottom;</mi></msub><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>成为一个以<math><mi>&bottom;</mi></math>为最小元的domain, 其被称为由<math><mi>X</mi></math>确定的<em>扁平</em>domain.</div></td></tr><tr><td align="center">幻灯片31</td></tr></table><p>自然数的扁平domain <math><msub><mi>&Nopf;</mi><mi>&bottom;</mi></msub></math>, 上一章的图1中我们就已描绘过其图像. 至于布尔值的扁平domain <math><msub><mi>&Bopf;</mi><mi>&bottom;</mi></msub></math>, 其Hasse图为<svg width="320" height="150" stroke="black" style="display: block; margin: auto;"><defs><marker id="arrow" viewbox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 2 L 6 5 L 0 8 z"/></marker></defs><foreignObject x="53" y="36" width="150" height="30"><math><mi>true</mi></math></foreignObject><foreignObject x="253" y="36" width="150" height="30"><math><mi>false</mi></math></foreignObject><foreignObject x="157" y="126" width="150" height="30"><math><mi>&bottom;</mi></math></foreignObject><line x1="154" y1="125" x2="70" y2="57" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="175" y1="125" x2="264" y2="57" marker-end="url(#arrow)" stroke-width="1.2px"/></svg>以下牵涉扁平domain的连续函数实例对于PCF的指称语义而言也是必要的, 我们将其验证留给读者作为练习.</p><div class="proposition"><b>命题1.</b> 令<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>X</mi><mo>&RightVector;</mo><mi>Y</mi></mrow></mrow></math>是两个集合之间的部分函数, 那么<math display="block"><mrow><mrow><msub><mi>f</mi><mi>&bottom;</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><mover><mo>=</mo><mi>def</mi></mover><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>d</mi><mo>&in;</mo><mi>X</mi></mrow><mtext>且</mtext><mi>f</mi><mtext>定义于</mtext><mi>d</mi></mtd></mtr><mtr><mtd><mi>&bottom;</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>d</mi><mo>&in;</mo><mi>X</mi></mrow><mtext>而</mtext><mi>f</mi><mtext>在</mtext><mi>d</mi><mtext>上没有定义</mtext></mtd></mtr><mtr><mtd><mi>&bottom;</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>d</mi><mo>=</mo><mi>&bottom;</mi></mrow></mtd></mtr></mtable></mrow></mrow></math>定义了相应扁平domain之间的连续函数<math><mrow><msub><mi>f</mi><mi>&bottom;</mi></msub><mo>:</mo><mrow><msub><mi>X</mi><mi>&bottom;</mi></msub><mo>&rarr;</mo><msub><mi>Y</mi><mi>&bottom;</mi></msub></mrow></mrow></math>.</div><h3>第3.2节 domain的积</h3><table class="label" align="center"><tr><td><div class="slide" style="height: 300px"><div align="center"><b>cpo和domain的二元积</b></div><hr/>两个cpo <math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>,</mo><msub><mo lspace="0" rspace="0">&sqsube;</mo><mn>1</mn></msub></mrow><mo stretchy="false">)</mo></mrow></math>和<math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>D</mi><mn>2</mn></msub><mo>,</mo><msub><mo lspace="0" rspace="0">&sqsube;</mo><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></math>之<em>积</em>的基础集为<math display="block"><mrow><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>&times;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo stretchy="false">|</mo><mrow><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>&in;</mo><msub><mi>D</mi><mn>1</mn></msub></mrow><mo>&amp;</mo><mrow><msub><mi>d</mi><mn>2</mn></msub><mo>&in;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>而其上的偏序<math><mo>&sqsube;</mo></math>定义如下<math display="block"><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&sqsube;</mo><mrow><mo stretchy="false">(</mo><mrow><msubsup><mi>d</mi><mn>1</mn><mo>&prime;</mo></msubsup><mo>,</mo><msubsup><mi>d</mi><mn>2</mn><mo>&prime;</mo></msubsup></mrow><mo stretchy="false">)</mo></mrow></mrow><mover><mo>&hArr;</mo><mi>def</mi></mover><mrow><mrow><msub><mi>d</mi><mn>1</mn></msub><msub><mo>&sqsube;</mo><mn>1</mn></msub><msubsup><mi>d</mi><mn>1</mn><mo>&prime;</mo></msubsup></mrow><mo>&amp;</mo><mrow><msub><mi>d</mi><mn>2</mn></msub><msub><mo>&sqsube;</mo><mn>2</mn></msub><msubsup><mi>d</mi><mn>2</mn><mo>&prime;</mo></msubsup></mrow></mrow></mrow></math>链的最小上界可以按照分量进行计算:<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mrow><mn>1</mn><mo>,</mo><mi>n</mi></mrow></msub><mo>,</mo><msub><mi>d</mi><mrow><mn>2</mn><mo>,</mo><mi>n</mi></mrow></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>i</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mn>1</mn><mo>,</mo><mi>i</mi></mrow></msub></mrow><mo>,</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>j</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mrow><mn>2</mn><mo>,</mo><mi>j</mi></mrow></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>若<math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>,</mo><msub><mo lspace="0" rspace="0">&sqsube;</mo><mn>1</mn></msub></mrow><mo stretchy="false">)</mo></mrow></math>和<math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>D</mi><mn>2</mn></msub><mo>,</mo><msub><mo lspace="0" rspace="0">&sqsube;</mo><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></math>都是domain, 那么<math><mrow><mo stretchy="false">(</mo><mrow><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>&times;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>也是一个domain, 并且<math display="block"><mrow><msub><mi>&bottom;</mi><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>&times;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow></msub><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>&bottom;</mi><msub><mi>D</mi><mn>1</mn></msub></msub><mo>,</mo><msub><mi>&bottom;</mi><msub><mi>D</mi><mn>2</mn></msub></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></math></div></td></tr><tr><td align="center">幻灯片32</td></tr></table><div class="proposition"><b>命题1. 投影和配对.</b> 令<math><msub><mi>D</mi><mn>1</mn></msub></math>和<math><msub><mi>D</mi><mn>2</mn></msub></math>是cpo, 那么投影<math display="block"><mrow><msub><mi>&pi;</mi><mn>1</mn></msub><mo>:</mo><mrow><mrow><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>&times;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow><mo>&rarr;</mo><msub><mi>D</mi><mn>1</mn></msub></mrow><mo>,</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&mapsto;</mo><msub><mi>d</mi><mn>1</mn></msub></mrow></mrow></mrow></math>和<math display="block"><mrow><msub><mi>&pi;</mi><mn>2</mn></msub><mo>:</mo><mrow><mrow><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>&times;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow><mo>&rarr;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow><mo>,</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&mapsto;</mo><msub><mi>d</mi><mn>2</mn></msub></mrow></mrow></mrow></math>是连续函数. 如果<math><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><msub><mi>D</mi><mn>1</mn></msub></mrow></mrow></math>和<math><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow></mrow></math>是连续函数, 其中<math><mi>D</mi></math>是一个cpo, 那么<math display="block"><mrow><mrow><mo stretchy="false">&lang;</mo><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>,</mo><msub><mi>f</mi><mn>2</mn></msub></mrow><mo stretchy="false">&rang;</mo></mrow><mo>:</mo><mrow><mrow><mi>D</mi><mo>&rarr;</mo><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>&times;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow></mrow><mo>,</mo><mrow><mi>d</mi><mo>&mapsto;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>是连续的.</div><div class="proof"><b>证明.</b> 这些函数的连续性可由幻灯片32上对于<math><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>&times;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow></math>中的链的最小上界的刻画直接推出.<div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><div class="proposition"><b>命题2.</b> 对于每个domain <math><mi>D</mi></math>, 函数<math display="block"><mrow><mi>if</mi><mo>:</mo><mrow><mrow><mrow><msub><mi>&Bopf;</mi><mi>&bottom;</mi></msub><mo>&times;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>&times;</mo><mi>D</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&rarr;</mo><mi>D</mi></mrow><mo>,</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>&mapsto;</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mi>d</mi></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mi>true</mi></mrow></mtd></mtr><mtr><mtd><msup><mi>d</mi><mo>&prime;</mo></msup></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mi>false</mi></mrow></mtd></mtr><mtr><mtd><msub><mi>&bottom;</mi><mi>D</mi></msub></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi>x</mi><mo>=</mo><mi>&bottom;</mi></mrow></mtd></mtr></mtable></mrow></mrow></mrow></mrow></math>是连续的.</div><p>我们将会需要以下更一般的积构造.</p><div class="definition"><b>定义3. 依赖积.</b> 给定集合<math><mi>I</mi></math>, 设对于每个<math><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></math>我们有一个cpo <math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>,</mo><msub><mo lspace="0" rspace="0">&sqsube;</mo><mi>i</mi></msub></mrow><mo stretchy="false">)</mo></mrow></math>, 那么这个cpo族之<em>积</em>为<ul><li>基础集是集合<math><msub><mi>D</mi><mi>i</mi></msub></math>的<math><mi>I</mi></math>重笛卡尔积<math><mrow><munder><mo>&prod;</mo><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></munder><msub><mi>D</mi><mi>i</mi></msub></mrow></math>, 其由所有这样的函数<math><mi>p</mi></math>构成, <math><mi>p</mi></math>定义在<math><mi>I</mi></math>上, 而<math><mi>p</mi></math>在每个<math><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></math>处的值<math><mrow><mrow><mi>p</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&in;</mo><msub><mi>D</mi><mi>i</mi></msub></mrow></math>;</li><li>偏序<math><mo>&sqsube;</mo></math>为<math display="block"><mrow><mrow><mi>p</mi><mo>&sqsube;</mo><msup><mi>p</mi><mo>&prime;</mo></msup></mrow><mover><mo>&hArr;</mo><mi>def</mi></mover><mrow><mo>&forall;</mo><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mi>p</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow><msub><mo>&sqsube;</mo><mi>i</mi></msub><mrow><msup><mi>p</mi><mo>&prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow><mtext>.</mtext></math></li></ul>就和二元积的情况一样, <math><mrow><mo stretchy="false">(</mo><mrow><mrow><munder><mo>&prod;</mo><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></munder><msub><mi>D</mi><mi>i</mi></msub></mrow><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>中的链的最小上界也可以逐分量计算: 如果<math><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>&sqsube;</mo><msub><mi>p</mi><mn>1</mn></msub><mo>&sqsube;</mo><msub><mi>p</mi><mn>2</mn></msub><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>是积cpo中的一个链, 那么其最小上界是将每个<math><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></math>映射至<math><msub><mi>D</mi><mi>i</mi></msub></math>中的链<math><mrow><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><msub><mi>p</mi><mn>2</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>的最小上界的函数, 即<math display="block"><mrow><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>p</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msub><mi>p</mi><mi>n</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mo>,</mo><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></mrow><mtext>.</mtext></math>而且, 对于每个<math><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></math>, 第<math><mi>i</mi></math>投影函数<math display="block"><mrow><msub><mi>&pi;</mi><mi>i</mi></msub><mo>:</mo><mrow><mrow><mrow><munder><mo>&prod;</mo><mrow><mi>j</mi><mo>&in;</mo><mi>I</mi></mrow></munder><msub><mi>D</mi><mi>j</mi></msub></mrow><mo>&rarr;</mo><msub><mi>D</mi><mi>i</mi></msub></mrow><mo>,</mo><mrow><mi>p</mi><mo>&mapsto;</mo><mrow><mi>p</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math>是连续的. 如果每个<math><msub><mi>D</mi><mi>i</mi></msub></math>都是domain, 那么它们的积也是domain, 并且其最小元是将每个<math><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></math>映射至<math><msub><mi>D</mi><mi>i</mi></msub></math>的最小元的函数.</div><table class="label" align="center"><tr><td><div class="slide" style="height: 300px"><div align="center"><b>两个参数的连续函数</b></div><hr/><div class="proposition"><b>命题.</b> 令<math><mrow><mi>D</mi><mo>,</mo><mi>E</mi><mo>,</mo><mi>F</mi></mrow></math>是cpo, 那么函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mrow><mi>D</mi><mo>&times;</mo><mi>E</mi></mrow><mo>&rarr;</mo><mi>F</mi></mrow></mrow></math>是单调的当且仅当其对于每个参数分别都是单调的:<math display="block"><mrow><mo>&forall;</mo><mrow><mrow><mrow><mi>d</mi><mo>,</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mo>&in;</mo><mi>D</mi></mrow><mo>,</mo><mrow><mi>e</mi><mo>&in;</mo><mi>E</mi></mrow></mrow><mo lspace="0">.</mo><mrow><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mo>&Implies;</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>d</mi><mo>&prime;</mo></msup><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math><math display="block"><mrow><mo>&forall;</mo><mrow><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo>,</mo><mrow><mrow><mi>e</mi><mo>,</mo><msup><mi>e</mi><mo>&prime;</mo></msup></mrow><mo>&in;</mo><mi>E</mi></mrow></mrow><mo lspace="0">.</mo><mrow><mrow><mi>e</mi><mo>&sqsube;</mo><msup><mi>e</mi><mo>&prime;</mo></msup></mrow><mo>&Implies;</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><msup><mi>e</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math>而且, 其是连续的当且仅当其对于每个参数分别都是连续的 [译注: 在单调的基础之上, 也就是对于每个参数分别都是保持链的最小上界的]:<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mi>n</mi></msub><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math><math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>e</mi><mi>n</mi></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><msub><mi>e</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math></div></div></td></tr><tr><td align="center">幻灯片33</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>两个参数的连续函数: 推导规则</b></div><hr/><ul><li>在<math><mi>f</mi></math>单调的情况下, 我们有<math display="block"><mfrac displaystyle="true"><mrow><mrow><mi>x</mi><mo>&sqsube;</mo><msup><mi>x</mi><mo>&prime;</mo></msup></mrow><mspace width="8ex"/><mrow><mi>y</mi><mo>&sqsube;</mo><msup><mi>y</mi><mo>&prime;</mo></msup></mrow></mrow><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>x</mi><mo>&prime;</mo></msup><mo>,</mo><msup><mi>y</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mfrac></math></li><li>在<math><mi>f</mi></math>连续的情况下, 我们有<math display="block"><mfrac displaystyle="true"><mrow/><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>m</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>x</mi><mi>m</mi></msub></mrow><mo>,</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>y</mi><mi>n</mi></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>x</mi><mi>k</mi></msub><mo>,</mo><msub><mi>y</mi><mi>k</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mfrac></math></li></ul></div></td></tr><tr><td align="center">幻灯片34</td></tr></table><div class="proof"><b>证明.</b> &quot;仅当&quot;的方向是直接的, 其证明依赖于简单的观察, 即<math><mrow><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow><mo>&Implies;</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&sqsube;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>d</mi><mo>&prime;</mo></msup><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>和<math><mrow><mrow><mo stretchy="false">(</mo><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>n</mi></msub></mrow><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mi>n</mi></msub><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, 以及它们之于右参数的对偶版本. 对于&quot;当&quot;的方向, 首先设<math><mi>f</mi></math>对于每个参数分别都是单调的, 那么如果<math><mrow><mi>D</mi><mo>&times;</mo><mi>E</mi></mrow></math>中有<math><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&sqsube;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>d</mi><mo>&prime;</mo></msup><mo>,</mo><msup><mi>e</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow></mrow></math>, 根据二元积的定义, 我们可以推出<math><mi>D</mi></math>中有<math><mrow><mi>d</mi><mo>&sqsube;</mo><msup><mi>d</mi><mo>&prime;</mo></msup></mrow></math>而<math><mi>E</mi></math>中有<math><mrow><mi>e</mi><mo>&sqsube;</mo><msup><mi>e</mi><mo>&prime;</mo></msup></mrow></math>, 因此<math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>&sqsube;</mo></mtd><mtd columnalign="left"><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>d</mi><mo>&prime;</mo></msup><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>根据对于第一个参数的单调性</mtext></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>&sqsube;</mo></mtd><mtd columnalign="left"><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>d</mi><mo>&prime;</mo></msup><mo>,</mo><msup><mi>e</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>根据对于第二个参数的单调性</mtext></mtd></mtr></mtable></math>于是, <math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sqsube;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>d</mi><mo>&prime;</mo></msup><mo>,</mo><msup><mi>e</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, 即<math><mi>f</mi></math>是单调函数.<br/>现在设<math><mi>f</mi></math>对于每个参数分别都是连续的, 那么如果<math><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>,</mo><msub><mi>e</mi><mn>0</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&sqsube;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><msub><mi>e</mi><mn>1</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&sqsube;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mn>2</mn></msub><mo>,</mo><msub><mi>e</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&sqsube;</mo><mo>&hellip;</mo></mrow></math>是二元积中的一个链, 我们有<math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mi>n</mi></msub><mo>,</mo><msub><mi>e</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>i</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>d</mi><mi>i</mi></msub></mrow><mo>,</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>j</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>e</mi><mi>j</mi></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>见幻灯片32</mtext></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>i</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>,</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>j</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>e</mi><mi>j</mi></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd columnalign="left"><mtext>根据对于第一个参数的连续性</mtext></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>i</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>j</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>,</mo><msub><mi>e</mi><mi>j</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mtd><mtd columnalign="left"><mtext>根据对于第二个参数的连续性</mtext></mtd></mtr><mtr><mtd columnalign="right"><mrow/></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>d</mi><mi>n</mi></msub><mo>,</mo><msub><mi>e</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd columnalign="left"><mtext>根据幻灯片27上的引理</mtext></mtd></mtr></mtable></math>而这就说明了<math><mi>f</mi></math>的连续性.<div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><h3>第3.3节 函数domain</h3><p>两个cpo/domain之间的所有连续函数的集合可以赋予一个偏序而成为一个cpo/domain, 见幻灯片35. 有时我们也用术语&quot;指数cpo/domain (exponential cpo/domain)&quot;而不是&quot;函数cpo/domain&quot;.</p><table class="label" align="center"><tr><td><div class="slide" style="height: 250px"><div align="center"><b>函数cpo和domain</b></div><hr/>给定cpo <math><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>,</mo><msub><mo lspace="0" rspace="0">&sqsube;</mo><mi>D</mi></msub></mrow><mo stretchy="false">)</mo></mrow></math>和<math><mrow><mo stretchy="false">(</mo><mrow><mi>E</mi><mo>,</mo><msub><mo lspace="0" rspace="0">&sqsube;</mo><mi>E</mi></msub></mrow><mo stretchy="false">)</mo></mrow></math>, 函数cpo <math><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow><mo>,</mo><mo lspace="0" rspace="0">&sqsube;</mo></mrow><mo stretchy="false">)</mo></mrow></math>的基础集为 [译注: 以下符号有点过载]<math display="block"><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow><mover><mo>=</mo><mi>def</mi></mover><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></mrow><mo stretchy="false">|</mo><mrow><mi>f</mi><mtext>连续</mtext></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>而偏序为<math display="block"><mrow><mrow><mi>f</mi><mo>&sqsube;</mo><msup><mi>f</mi><mo>&prime;</mo></msup></mrow><mover><mo>&hArr;</mo><mi>def</mi></mover><mrow><mo>&forall;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow><msub><mo>&sqsube;</mo><mi>E</mi></msub><mrow><msup><mi>f</mi><mo>&prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math>推导规则:<math display="block"><mfrac displaystyle="true"><mrow><mrow><mi>f</mi><msub><mo>&sqsube;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></msub><mi>g</mi></mrow><mspace width="8ex"/><mrow><mi>x</mi><msub><mo>&sqsube;</mo><mi>D</mi></msub><mi>y</mi></mrow></mrow><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><msub><mo>&sqsube;</mo><mi>E</mi></msub><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mfrac></math></div></td></tr><tr><td align="center">幻灯片35</td></tr></table><table class="label" align="center"><tr><td><div class="slide"><div align="center"><b>函数cpo和domain (续)</b></div><hr/>链的最小上界可以逐参数计算:<math display="block"><mrow><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>f</mi><mi>n</mi></msub></mrow><mo>=</mo><mrow><mi>&lambda;</mi><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mo lspace="0">.</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math>推导规则:<math display="block"><mfrac displaystyle="true"><mrow/><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>f</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>&bigsqcup;</mo><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow></munder><mrow><msub><mi>f</mi><mi>k</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mfrac></math>如果<math><mi>D</mi></math>和<math><mi>E</mi></math>还是domain, 那么<math><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></math>也成为一个domain, 并且最小元为<math display="block"><mrow><msub><mi>&bottom;</mi><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow></msub><mo>:</mo><mrow><mrow><mi>D</mi><mo>&rarr;</mo><mi>E</mi></mrow><mo>,</mo><mrow><mi>d</mi><mo>&mapsto;</mo><msub><mi>&bottom;</mi><mi>E</mi></msub></mrow></mrow></mrow><mtext>.</mtext></math></div></td></tr><tr><td align="center">幻灯片36</td></tr></table><div class="proof"><b>证明.</b> <div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><h2>第4章 Scott归纳</h2><h2>第5章 PCF</h2><h2>第6章 PCF的指称语义</h2><h2>第7章 将指称语义和操作语义联系起来</h2><h2>第8章 完全抽象</h2></body></html>