<html><head><meta charset="utf-8"/><title>类型和编程语言</title><link href="styles.css" rel="stylesheet"/></head><body><h1>类型和编程语言</h1><p>这是一本历久弥新的编程语言入门教科书. 这本书的特点在于深入浅出, 几乎不假设读者具有任何数学知识. 另外, 这本书还使用了OCaml语言编写的程序来帮助读者理解, 避免自然语言的一些可能的歧义和模糊.</p><h2>第1章 引论</h2><h2>第2章 数学预备</h2><h2>第3章 无类型算术表达式</h2><h2>第4章 算术表达式的一个ML实现</h2><h2>第5章 无类型lambda演算</h2><h2>第6章 项的匿名表示</h2><h2>第7章 lambda演算的一个ML实现</h2><h2>第8章 类型化的算术表达式</h2><h3>第8.1节 类型</h3><h3>第8.2节 定型关系</h3><h3>第8.3节 安全=进展+保持</h3><h2>第9章 简单类型lambda演算</h2><h3>第9.1节 函数类型</h3><h3>第9.2节 定型关系</h3><h3>第9.3节 定型的性质</h3><h3>第9.4节 Curry-Howard对应</h3><h3>第9.5节 擦除和可定型性</h3><h3>第9.6节 Curry风格和Church风格的对比</h3><h2>第10章 简单类型的一个ML实现</h2><h2>第11章 简单扩展</h2><h2>第12章 规范化</h2><p>这一章我们将考虑纯简单类型lambda演算的另一个基础的理论性质: </p><h3>第12.1节 简单类型的规范化</h3><h3>第12.2节 注记</h3><h2>第13章 引用</h2><h2>第14章 异常</h2><h2>第15章 子定型</h2><p>我们已经花了数章时间在简单类型lambda演算的框架之下研究了诸多语言特性的类型行为. 这一章所面对的是一种更为基本的扩展: <em>子定型</em> (有时也被称为<em>子类型多态</em>). 和我们之前所研究的特性不同的是, 前面的特性或多或少算是正交的, 而子定型是一个横切的扩展, 与大多数其他语言特性以非平凡的方式进行交互. {译注: 也就是说, 加入子定型会影响语言的全局.}</p><p>子定型总是可以作为<em>面向对象</em>语言的特征而找到, 其经常被认为是面向对象风格的一个本质特性. 我们将会在第18章仔细探索这种关联, 然而现在我们将会在只有函数和记录这一更为经济的场景下呈现子定型, 不过最有趣的问题已然出现. 第15.5节讨论了子定型与之前我们所见过的一些其他特性的组合. 在最后一节 (也就是15.6), 我们考虑了子定型的一种更为细化的语义, 其中子定型的使用对应于运行时<em>强制</em>的插入.</p><h3>第15.1节 涵摄 (subsumption)</h3><p>简单类型lambda演算没有子定型, 其规则有时可能恼人地顽固. 类型系统对于参数类型和函数的定义域类型必须精确匹配的坚持将导致类型检查器会拒绝许多对于程序员而言显然良行为的程序. 例如, 回忆一下函数应用的定型规则:<math display="block"><mtable columnalign="left center right" width="100%"><mtr><mtd><mphantom><mtext class="small-caps">(T-App)</mtext></mphantom></mtd><mtd><mfrac displaystyle="true"><mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>:</mo><mrow><msub><mi>T</mi><mn>11</mn></msub><mo>&rarr;</mo><msub><mi>T</mi><mn>12</mn></msub></mrow></mrow></mrow><mspace width="8ex"/><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>:</mo><msub><mi>T</mi><mn>11</mn></msub></mrow></mrow></mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mrow><msub><mi>t</mi><mn>1</mn></msub><mspace width="2ex"/><msub><mi>t</mi><mn>2</mn></msub></mrow><mo>:</mo><msub><mi>T</mi><mn>12</mn></msub></mrow></mrow></mfrac></mtd><mtd><mtext class="small-caps">(T-App)</mtext></mtd></mtr></mtable></math>根据这条规则, 良行为的项<pre><code>(λr:{x:Nat}. r.x) {x=0,y=1}</code></pre>是不可定型的, 因为其参数的类型为<code>{x:Nat,y:Nat}</code>. 但是显然, 这个函数只是要求其参数应该是一个带有域<code>x</code>的记录. 它并不在意参数有还是没有其他的域. 而且, 我们从函数的类型就足以看出来这一点&mdash;&mdash;我们不需要观察其体来验证它没有使用任何<code>x</code>之外的域这一事实. 将具有类型<code>{x:Nat,y:Nat}</code>的参数传递给期待类型<code>{x:Nat}</code>的函数<em>总是</em>安全的.</p><p>子定型的目的在于对定型规则进行细化, 以使得类型系统可以接受如上所描述的项. 我们达成所用的方式在于形式化某些类型比其他类型更有信息 (informative) 这一直觉: 我们称<code>S</code>是<code>T</code>的一个<em>子类型</em>, 记作<code>S &lt;: T</code>, 来表达任何具有类型<code>S</code>的项都可以安全地用在期待具有类型<code>T</code>的项的上下文之中这一事实. 这种看待子定型的观念被称为<em>安全替换原则</em>.</p><p>更简单的直觉在于将<code>S &lt;: T</code>读作<q>每个由<code>S</code>所描述的值也可由<code>T</code>所描述</q>. 也就是说, <q><code>S</code>的元素 (复数) 是<code>T</code>的元素 (复数) 的一个子集</q>. 我们将会在第15.6节看到其他的偶尔有用的更为细化的对于子定型的解释, 但是当前这种<em>子集语义</em>对于绝大多数目的而言已经足够了.</p><p>定型关系和子类型关系之间的桥梁是通过添加一条新的定型规则提供的, 即所谓的<em>涵摄</em>规则:<math display="block"><mtable columnalign="left center right" width="100%"><mtr><mtd><mphantom><mtext class="small-caps">(T-Sub)</mtext></mphantom></mtd><mtd><mfrac displaystyle="true"><mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mi>t</mi><mo>:</mo><mi>S</mi></mrow></mrow><mspace width="8ex"/><mrow><mi>S</mi><mo>&lt;:</mo><mi>T</mi></mrow></mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mi>t</mi><mo>:</mo><mi>T</mi></mrow></mrow></mfrac></mtd><mtd><mtext class="small-caps">(T-Sub)</mtext></mtd></mtr></mtable></math>这条规则告诉我们, 如果<code>S &lt;: T</code>, 那么<code>S</code>的每个元素<code>t</code>也是<code>T</code>一个元素. 例如, 如果我们定义某种子类型关系使得<code>{x:Nat,y:Nat} &lt;: {x:Nat}</code>, 那么我们就可以使用规则<math><mtext class="small-caps">T-Sub</mtext></math>来推导出<code>⊢ {x=0,y=1} : {x:Nat}</code>, 这是我们为了使得我们的启发性例子通过类型检查所需要的.</p><h3>第15.2节 子类型关系</h3><p>子类型关系可以形式化为一集用于推导具有形式<code>S &lt;: T</code>的陈述的推理规则, <code>S &lt;: T</code>应该读作<q><code>S</code>是<code>T</code>的一个子类型</q>或者<q><code>T</code>是<code>S</code>的一个超类型</q>. 我们分别考虑每种形式的类型 (函数类型, 记录类型, 等等); 对于每种情况, 我们引入一或多条规则来形式化在期望某个类型的地方何时可以安全地允许使用具有这种形式的另一类型的元素.</p><p>在讨论特定类型构造子的(子定型)规则之前, 我们作出两条一般性约定:<br/>首先, 子定型规则应该是自反的, 即<math display="block"><mtable columnalign="left center right" width="100%"><mtr><mtd><mphantom><mtext class="small-caps">(S-Refl)</mtext></mphantom></mtd><mtd><mrow><mi>S</mi><mo>&lt;:</mo><mi>S</mi></mrow></mtd><mtd><mtext class="small-caps">(S-Refl)</mtext></mtd></mtr></mtable></math>其次, 它应该是传递的, 即<math display="block"><mtable columnalign="left center right" width="100%"><mtr><mtd><mphantom><mtext class="small-caps">(S-Trans)</mtext></mphantom></mtd><mtd><mfrac displaystyle="true"><mrow><mrow><mi>S</mi><mo>&lt;:</mo><mi>U</mi></mrow><mspace width="8ex"/><mrow><mi>U</mi><mo>&lt;:</mo><mi>T</mi></mrow></mrow><mrow><mi>S</mi><mo>&lt;:</mo><mi>T</mi></mrow></mfrac></mtd><mtd><mtext class="small-caps">(S-Trans)</mtext></mtd></mtr></mtable></math>这些规则可以直接根据安全替换的直觉推得.</p><p>对于记录类型, 现在我们已经明白了我们想要考虑的是将类型<code>S = {k1:S1...km:Sm}</code>作为<code>T = {l1:T1...ln:Tn</code>的一个子类型, 如果<code>T</code>相较于<code>S</code>有着更少的域. 作为一种特别情形, <q>忘记</q>某个记录类型的末端的一些域是安全的. 所谓的<em>宽度子定型</em>规则捕获了这种直觉:<math display="block"><mtable columnalign="left center right" width="100%"><mtr><mtd><mphantom><mtext class="small-caps">(S-RcdWidth)</mtext></mphantom></mtd><mtd><mrow><mrow><mo stretchy="false">{</mo><msup><mrow><msub><mi>l</mi><mi>i</mi></msub><mo>:</mo><msub><mi>T</mi><mi>i</mi></msub></mrow><mrow><mi>i</mi><mo>&in;</mo><mrow><mn>1</mn><mo>,</mo><mo>&hellip;</mo><mo>,</mo><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></mrow></mrow></msup><mo stretchy="false">}</mo></mrow><mo>&lt;:</mo><mrow><mo stretchy="false">{</mo><msup><mrow><msub><mi>l</mi><mi>i</mi></msub><mo>:</mo><msub><mi>T</mi><mi>i</mi></msub></mrow><mrow><mi>i</mi><mo>&in;</mo><mrow><mn>1</mn><mo>,</mo><mo>&hellip;</mo><mo>,</mo><mi>n</mi></mrow></mrow></msup><mo stretchy="false">}</mo></mrow></mrow></mtd><mtd><mtext class="small-caps">(S-RcdWidth)</mtext></mtd></mtr></mtable></math>或许会令人惊讶的是, <q>更小</q>的类型&mdash;&mdash;即子类型&mdash;&mdash;反而有着<em>更多</em>的域. 理解这种现象的最简单方式在于如我们在第11.8节那样采用对待记录类型的一种更自由的观念, 将一个记录类型<code>{x:Nat}</code>描述为<q>由所有<em>至少</em>拥有类型为<code>Nat</code>的域<code>x</code>的记录构成的集合</q>. 诸如<code>{x=3}</code>和<code>{x=5}</code>这样的值是这个类型的元素, 诸如<code>{x=3,y=100}</code>和<code>{x=3,a=true,b=true}</code>这样的值也是这个类型的元素. 类似地, 记录类型<code>{x:Nat,y:Nat}</code>描述了<em>至少</em>拥有类型都为<code>Nat</code>的域<code>x</code>和<code>y</code>的记录. 诸如<code>{x=3,y=100}</code>和<code>{x=3,y=100,z=true}</code>这样的值是这个类型的成员, 但是<code>{x=3}</code>不是, <code>{x=3,a=true,b=true}</code>也不是. 因此, 属于第二个类型的值构成的集合是属于第一个类型的值构成的集合的一个真子集. 更长的记录类型构成了要求更多&mdash;&mdash;即更有信息&mdash;&mdash;的刻画, 故其描述了更小的值集合.</p><p>宽度子定型规则只适用于共同的域等同的记录类型. 允许单独的域的类型发生变化也是安全的, 只要两个记录类型里每个相应的域的类型处于子类型关系. <em>深度子定型</em>规则表达了这种直觉:<math display="block"><mtable columnalign="left center right" width="100%"><mtr><mtd><mphantom><mtext class="small-caps">(S-RcdDepth)</mtext></mphantom></mtd><mtd><mfrac displaystyle="true"><mrow><mo>&forall;</mo><mi>i</mi><mo>.</mo><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>&lt;:</mo><msub><mi>T</mi><mi>i</mi></msub></mrow></mrow><mrow><mrow><mo stretchy="false">{</mo><msup><mrow><msub><mi>l</mi><mi>i</mi></msub><mo>:</mo><msub><mi>S</mi><mi>i</mi></msub></mrow><mrow><mi>i</mi><mo>&in;</mo><mrow><mn>1</mn><mo>,</mo><mo>&hellip;</mo><mo>,</mo><mi>n</mi></mrow></mrow></msup><mo stretchy="false">}</mo></mrow><mo>&lt;:</mo><mrow><mo stretchy="false">{</mo><msup><mrow><msub><mi>l</mi><mi>i</mi></msub><mo>:</mo><msub><mi>T</mi><mi>i</mi></msub></mrow><mrow><mi>i</mi><mo>&in;</mo><mrow><mn>1</mn><mo>,</mo><mo>&hellip;</mo><mo>,</mo><mi>n</mi></mrow></mrow></msup><mo stretchy="false">}</mo></mrow></mrow></mfrac></mtd><mtd><mtext class="small-caps">(S-RcdDepth)</mtext></mtd></mtr></mtable></math></p><p>下列子定型推导联合使用了<math><mtext class="small-caps">S-RcdWidth</mtext></math>和<math><mtext class="small-caps">S-RcdDepth</mtext></math>来表明嵌套的记录类型<code>{x:{a:Nat,b:Nat},y:{m:Nat}}</code>是<code>{x:{a:Nat},y:{}}</code>的一个子类型:<math display="block"><mrow><mfrac displaystyle="true"><mrow><mrow><mfrac displaystyle="true"><mrow/><mrow><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>a</mi><mo>:</mo><mi>Nat</mi></mrow><mo>,</mo><mrow><mi>b</mi><mo>:</mo><mi>Nat</mi></mrow></mrow><mo stretchy="false">}</mo></mrow><mo>&lt;:</mo><mrow><mo stretchy="false">{</mo><mrow><mi>a</mi><mo>:</mo><mi>Nat</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></mfrac><mtext class="small-caps">S-RcdWidth</mtext></mrow><mspace width="8ex"/><mrow><mfrac displaystyle="true"><mrow/><mrow><mrow><mo stretchy="false">{</mo><mrow><mi>m</mi><mo>:</mo><mi>Nat</mi></mrow><mo stretchy="false">}</mo></mrow><mo>&lt;:</mo><mrow><mo stretchy="false">{</mo><mrow/><mo stretchy="false">}</mo></mrow></mrow></mfrac><mtext class="small-caps">S-RcdWidth</mtext></mrow></mrow><mrow><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>x</mi><mo>:</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>a</mi><mo>:</mo><mi>Nat</mi></mrow><mo>,</mo><mrow><mi>b</mi><mo>:</mo><mi>Nat</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow><mo>,</mo><mrow><mi>y</mi><mo>:</mo><mrow><mo stretchy="false">{</mo><mrow><mi>m</mi><mo>:</mo><mi>Nat</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow><mo>&lt;:</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>x</mi><mo>:</mo><mrow><mo stretchy="false">{</mo><mrow><mi>a</mi><mo>:</mo><mi>Nat</mi></mrow><mo stretchy="false">}</mo></mrow></mrow><mo>,</mo><mrow><mi>y</mi><mo>:</mo><mrow><mo stretchy="false">{</mo><mrow/><mo stretchy="false">}</mo></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></mfrac><mtext class="small-caps">S-RcdDepth</mtext></mrow></math>如果我们想要使用<math><mtext class="small-caps">S-RcdDepth</mtext></math>来仅仅细化单独一个记录域 (而不是细化每个域, 如以上例子), 我们可以使用<math><mtext class="small-caps">S-Refl</mtext></math>来对于其他的域获得平凡子定型的推导.<math display="block"><mrow><mfrac displaystyle="true"><mrow><mrow><mfrac displaystyle="true"><mrow/><mrow><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>a</mi><mo>:</mo><mi>Nat</mi></mrow><mo>,</mo><mrow><mi>b</mi><mo>:</mo><mi>Nat</mi></mrow></mrow><mo stretchy="false">}</mo></mrow><mo>&lt;:</mo><mrow><mo stretchy="false">{</mo><mrow><mi>a</mi><mo>:</mo><mi>Nat</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></mfrac><mtext class="small-caps">S-RcdWidth</mtext></mrow><mspace width="8ex"/><mrow><mfrac displaystyle="true"><mrow/><mrow><mrow><mo stretchy="false">{</mo><mrow><mi>m</mi><mo>:</mo><mi>Nat</mi></mrow><mo stretchy="false">}</mo></mrow><mo>&lt;:</mo><mrow><mo stretchy="false">{</mo><mrow><mi>m</mi><mo>:</mo><mi>Nat</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></mfrac><mtext class="small-caps">S-Refl</mtext></mrow></mrow><mrow><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>x</mi><mo>:</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>a</mi><mo>:</mo><mi>Nat</mi></mrow><mo>,</mo><mrow><mi>b</mi><mo>:</mo><mi>Nat</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow><mo>,</mo><mrow><mi>y</mi><mo>:</mo><mrow><mo stretchy="false">{</mo><mrow><mi>m</mi><mo>:</mo><mi>Nat</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow><mo>&lt;:</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>x</mi><mo>:</mo><mrow><mo stretchy="false">{</mo><mrow><mi>a</mi><mo>:</mo><mi>Nat</mi></mrow><mo stretchy="false">}</mo></mrow></mrow><mo>,</mo><mrow><mi>y</mi><mo>:</mo><mrow><mo stretchy="false">{</mo><mrow><mi>m</mi><mo>:</mo><mi>Nat</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></mfrac><mtext class="small-caps">S-RcdDepth</mtext></mrow></math>我们也可以将传递性规则<math><mtext class="small-caps">S-Trans</mtext></math>与宽度和深度子定型规则结合起来使用. </p><h2>第16章 子定型的元理论</h2><h2>第17章 子定型的一个ML实现</h2><h2>第18章 案例研究: 命令式对象</h2><h2>第19章 案例研究: Featherweight Java</h2><h2>第20章 递归类型</h2><h2>第21章 递归类型的元理论</h2><h2>第22章 类型重构</h2><h2>第23章 全称类型</h2><h2>第24章 存在类型</h2><h2>第25章 System F的一个ML实现</h2><h2>第26章 有界量化</h2><h2>第27章 案例研究: 命令式对象, Redux</h2><h2>第28章 有界量化的元理论</h2></body></html>