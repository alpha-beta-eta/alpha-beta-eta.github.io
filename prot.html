<html><head><meta charset="utf-8"/><title>证明与类型</title><link href="styles.css" rel="stylesheet"/></head><body><h1>证明与类型</h1><h2>前言</h2><p>这本小书来源于1986至1987年秋季学期于Universit&eacute; Paris VII开设的一门关于类型<math><mi>&lambda;</mi></math>演算的短期研究生课程. 它并不意图是百科全书式的, 例如Church-Rosser定理就没有证明, 而且主题的选取是相当随意的.</p><p>关于逻辑的基本常识是必要的, 然而我们也并不会陷入乏味的细节之中. </p><h2>第1章 涵义, 指称和语义</h2><p>理论计算尚非科学. 许多基本概念亟待澄清, 并且当前该领域的研究遵循一种&quot;婚礼蛋糕&quot;范式: 例如, 语言设计让人想到Ptolemy天文学&mdash;&mdash;不断需要更加深入的修正. 然而, 也存在一些有限的主题, 例如复杂度理论和指称语义学, 它们相当远离这种批判.</p><p>在这样的情况下, 方法论式的评论极其重要, 因为我们不得不将方法论视为<em>战略</em>而将具体的结果视为具有<em>战术</em>性质.</p><p>我们尤其感兴趣的东西可在1900年代的逻辑漩涡的源头找到, 由Frege, Löwenheim, Gödel等名字刻画. 不熟悉逻辑学史的读者应该参考<cite>[<a href="#vanHeijenoort">4</a>]</cite>.</p><h3>第1.1节 逻辑中的涵义和指称</h3><p>让我们从一个例子开始. 存在一个乘法的标准过程, 它由输入<math><mn>27</mn></math>和<math><mn>37</mn></math>产生结果<math><mn>999</mn></math>. 对于这个事实我们可以言称什么?</p><p>最初的尝试是言称我们拥有了一个<em>等式</em><math display="block"><mrow><mrow><mn>27</mn><mo>&times;</mo><mn>37</mn></mrow><mo>=</mo><mn>999</mn></mrow></math>这个等式在数学主流中以言称两边指称相同的整数且<math><mo>&times;</mo></math>是Cantor的图的意义下的一个<em>函数</em>而获得了含义. (译注: 这里&quot;整数&quot;的原文是&quot;integer&quot;, 又有原注, 全文的<em>integer</em>将表示<em>natural number</em>: <math><mrow><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mo>&hellip;</mo></mrow></math>)</p><p>这是指称性的方面, 无疑是正确的, 然而它忽略了基本的点.</p><p>存在一个有限的<em>计算</em>过程表明这两个指称是相等的. 言称<math><mrow><mn>27</mn><mo>&times;</mo><mn>37</mn></mrow></math>等于<math><mn>999</mn></math>是一种滥用 (这并非什么廉价的哲学&mdash;&mdash;而是一个具体的问题), 因为如果我们所拥有的这两个东西真是<em>相同</em>的, 那么我们就不会感到陈述它们的相等性的需要了. 具体地说, 我们在问一个<em>问题</em>, <math><mrow><mn>27</mn><mo>&times;</mo><mn>37</mn></mrow></math>, 然后得到了一个答案, <math><mn>999</mn></math>. 这两个表达式具有不同的<em>涵义</em>, 而我们必须<em>做</em>些什么 (编制证明或者进行计算, 或是至少查询百科全书) 来表明这两个<em>涵义</em>具有相同的<em>指称</em>.</p><p>关于<math><mo>&times;</mo></math>, 将其称为一个(作为图的)函数是不正确的, 因为加载了乘法程序的机器无法容纳下一个无限的图. (译注: 这句话是说<em>实无限</em>是不可能容纳于一个经典计算机器之中的, 当然<em>潜无限</em>的确是可以的.) 因此, 我们不得不总结道, 我们面对的是与这个涵义之问相关的一种<em>有限</em>的动力学.</p><p>尽管指称在很早的阶段就被建模, 涵义则被推向了<em>主观主义</em>, 导致当前的数学对于涵义的处理或多或少沦为了<em>句法</em>操作. 这在我们所要讨论的主题的本质之下并非<em>先验</em>, 而我们可以期待在接下来的几十年里找到一种对于计算的处理, 它结合了指称语义学 (数学的清晰性) 和句法 (有限的动力学) 的优点. 本书显然坐落于传统之上, 这种传统基于不幸的当前状况: 在<em>无限的静态的指称</em>与<em>有限的动态的涵义</em>的对立之中, 指称性的一方要远比另一方先进.</p><p>于是乎, 逻辑中由Frege指出的最根本的一个区分是: 给定一个句子<math><mi>A</mi></math>, 存在两种看待它的方式:<ul><li>作为<em>指令</em>的序列, 确定了其<em>涵义</em>, 例如<math><mrow><mi>A</mi><mo>&or;</mo><mi>B</mi></mrow></math>的意思是&quot;<math><mi>A</mi></math>或<math><mi>B</mi></math>&quot;, 等等.</li><li>作为由这些操作找到的<em>理想结果</em>: 此即其<em>指称</em>.</li></ul>&quot;指称 (denotation)&quot;与&quot;记号 (notation)&quot;相对, 是<em>被指称</em>的什么, 而不是<em>进行指称</em>的什么. 例如一个逻辑句子的是<math><mi mathvariant="bold">t</mi></math> (true, 真) 或者<math><mi mathvariant="bold">f</mi></math> (false, 假), 而<math><mrow><mi>A</mi><mo>&or;</mo><mi>B</mi></mrow></math>的指称可由<math><mi>A</mi></math>和<math><mi>B</mi></math>的指称通过析取的真值表得到.</p><p>拥有相同涵义的两个句子当然拥有相同的指称, 这是显然的; 但是两个拥有相同指称的句子很少拥有相同的涵义. 例如, 取一个复杂的数学等价<math><mrow><mi>A</mi><mo>&hArr;</mo><mi>B</mi></mrow></math>. 两个句子拥有相同的指称 (它们同时为真), 但肯定拥有不同的涵义; 不然的话, 表明这种等价的意义何在?</p><p>这个例子允许我们引入一些成组的想法:<ul><li>涵义, 句法, 证明;</li><li>指称, 真值, 语义, 代数操作.</li></ul>这是逻辑中的根本对立. 虽然话是这么说, 两方的地位完全不对称!</p><h4>第1.1.1小节 代数传统</h4><p>这个传统 (早在Frege的时代之前就由Boole开始) 基于对Ockham剃刀的激进应用: 我们相当轻易地舍弃了涵义, 只考虑指称. 澄清这种对于逻辑的肢解的合理性的是其可操作的一面: <em>it works!</em></p><p>建立了这种传统的主导性地位的基本转折点在于1916年的L&ouml;wenheim定理. 如今, 人们可以将模型论视为这种业已古老的认识论选择所带来的丰富回报. 实际上, 从指称的角度, 即从操作的<em>结果</em>的角度来看, 如此考虑逻辑, 我们发现了一种有些特殊的代数, 但它允许我们去检视对于更加传统的代数而言并不熟悉的操作. 实际上, 避免局限于<em>等式性</em>变体而考虑一般的<em>可定义</em>结构也是可以的. 因此, 模型论常以fruitful的方式为代数的想法和方法注入了活力.</p><h4>第1.1.2小节 句法传统</h4><p>另一方面, <q>全然忘记指称而专注于涵义</q>是不可能的, 这出于简单的原因, 即涵义包含指称, 至少是隐式地包含. 因此, 这并非对称的情况. 实际上, 几乎不存在统一的句法观点, 因为我们从未能够赋予神秘的<em>涵义</em>以一种操作性的涵义. 关于涵义唯一可感知的现实在于其被写下来的方式, 即形式化; 但是, 形式化仍然是一种不够理想的研究对象, 不具备真切的结构, 就像一片<em>soft camembert</em>.</p><p>这难道意味着纯粹句法的方法毫无讨论的价值吗? 当然不是, 1934年Gentzen的著名定理表明在句法层面上逻辑具有某些深远的对称性 (由<em>切消</em>表达). 然而, 这些对称被句法的不完美之处掩盖了. 换句话说, 它们不是句法的对称, 而是涵义的对称. 但是, 要想更进一步, 我们必须要将那些对称表达为句法的性质, 而结果并不是很美丽.</p><p>那么, 总结我们对于这种传统的观点, 它总是在寻找其根本概念, 也就是说, 涵义和句法之间的操作性区别. 或者把话说得更具体些, 它意在寻找深刻的句法的几何形状上的<em>不变量</em>: 其中可以找到涵义.</p><p>被称为<q>句法性</q> (因为没有更加高贵的名字了) 的传统, 从没能达到其对手的高度. 近些年来, 也就是说代数传统繁荣发展的时期, 句法传统不值一提, 并且无疑可能将因为缺少问题和方法论而在一二十年内消失. 这个灾难因为计算机科学 (伟大的句法操纵装置) 得以避免, 其提出了一些非常重要的理论问题.</p><p>其中一些问题 (例如关于算法复杂度的) 似乎更多地需要逻辑的字面而非逻辑的灵魂. 另一方面, 一切和程序的正确性和模块性有关的问题都深刻诉诸于句法传统, 诉诸于<em>证明论</em>. 我们被引导至从可追溯到1930年的Herbrand的根本性定理开始对于证明论进行修订. 这个修订给那些一度被认为永远固定下来了的领域带来了新的光亮, 那里曾在很长一段时间内盛行着墨守成规.</p><p>在句法逻辑传统与计算机科学之间的交流中, 人们可以在计算的一侧等待着新的语言和新的机器. 但是, 在逻辑的一侧 (也就是本书的主要作者所在的领域), 人们终于可以期望用上一直被残忍忽视的概念基础了.</p><h3>第1.2节 两种语义传统</h3><h4>第1.2.1小节 Tarski</h4><p>这种传统以极端的陈词滥调为人所知: 联结词<q><math><mo>&or;</mo></math></q>被翻译为<q>或</q>, 诸如此类. 这种解释没有告诉我们关于逻辑联结词的特别突出的东西: 它显然的抱负缺乏是其可操作性的潜在理由. 我们只关心句法的句子 (封闭表达式) 的指称, <math><mi mathvariant="bold">t</mi></math>或<math><mi mathvariant="bold">f</mi></math>.</p><ol><li>对于原子句子, 我们假定其指称已然知晓; 例如:<ul><li><math><mrow><mrow><mn>3</mn><mo>+</mo><mn>2</mn></mrow><mo>=</mo><mn>5</mn></mrow></math>具有指称<math><mi mathvariant="bold">t</mi></math>.</li><li><math><mrow><mrow><mn>3</mn><mo>+</mo><mn>3</mn></mrow><mo>=</mo><mn>5</mn></mrow></math>具有指称<math><mi mathvariant="bold">f</mi></math>.</li></ul></li><li>表达式</li></ol><h2>第2章 自然演绎</h2><p>正如我们之前所言, 句法性的观点展现了逻辑学的某种深远的对称. Gentzen的相继式演算以特别令人满意的方式完成了这种观点. 不幸的是, 其计算上的意义在某种程度上被其句法上的复杂性所掩盖, 尽管这种复杂与本质无关, 但是从来没有真正被克服. 这就是为什么我们在处理相继式演算之前要先呈现Prawitz的自然演绎.</p><p>自然演绎在某种意义上是有点悖论性的系统. 其局限于直觉主义的情形 (在古典情形下没有什么良好的性质), 但是它也只是对于语言的<math><mrow><mo stretchy="false">(</mo><mrow><mo lspace="0" rspace="0">&and;</mo><mo>,</mo><mo lspace="0" rspace="0">&rArr;</mo><mo>,</mo><mo>&forall;</mo></mrow><mo stretchy="false">)</mo></mrow></math>部分令人满意而已: 我们将对于<math><mo>&or;</mo></math>和<math><mo>&exist;</mo></math>的考虑推迟到第10章. 尽管如此, 析取和存在是两种最<em>典型</em>的直觉主义的联结词!</p><p>自然演绎的基本想法是一种不对称: 一个证明大致上是一个树状的结构, 其有一个或多个假设 (也可能没有), 但是只有一个结论. 这种演算的深刻对称在于相互精准匹配的<em>引入</em>和<em>消去</em>规则. 我们应该顺便观察到这样的事实, 对于这样一种树状结构, 我们总是可以唯一地确定哪一条规则是<em>最后</em>被使用的. 如果有多个结论的话, 那是无法做到的.</p><h3>第2.1节 演算</h3><p>我们将使用记号<math display="block"><mtable><mtr><mtd><mo>&vellip;</mo></mtd></mtr><mtr><mtd><mi>A</mi></mtd></mtr></mtable></math>来指对于<math><mi>A</mi></math>的一个<em>演绎(deduction)</em>, 即停止于<math><mi>A</mi></math>. 这个演绎会被写成一个有限的树的形式, 并且树的叶子会被标记以句子. [译注: 这个指的不是带标签的树 (labelled tree).] 对于这些句子, 存在两种可能的状态, <em>死</em>或<em>生</em>. [译注: 更准确地说, 是对于这些叶子.]</p><p>在通常状态下, 一个句子是活着的, 也就是说其在证明中还处于活跃的地位: 我们称其是一个<em>假设(hypothesis)</em>. 典型的情况由自然演绎的第一条规则刻画, 其允许我们构造一个仅包含一个句子的演绎:<math display="block"><mi>A</mi></math>这里的<math><mi>A</mi></math>既是叶子也是根; 从逻辑上说, 我们推出了<math><mi>A</mi></math>, 但这只是因为<math><mi>A</mi></math>是被假定成立的!</p><p>现在位于叶子位置的句子是可以死去的, 当其不再于证明中活跃时. 死去的句子可以通过杀死活着的句子得到. 最典型的例子是<math><mo>&rArr;</mo></math>的引入规则:<math display="block"><mrow><mfrac displaystyle="true"><mtable><mtr><mtd><mrow><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow></mtd></mtr><mtr><mtd><mo>&vellip;</mo></mtd></mtr><mtr><mtd><mi>B</mi></mtd></mtr></mtable><mrow><mi>A</mi><mo>&rArr;</mo><mi>B</mi></mrow></mfrac><mrow><mo lspace="0" rspace="0">&rArr;</mo><mi mathvariant="script">I</mi></mrow></mrow></math>以上的演绎必须按照如下方式理解: 我们从<math><mi>B</mi></math>的一个演绎开始, 在这个<math><mi>B</mi></math>的演绎中, 我们选取了特定数目的<math><mi>A</mi></math>的出现作为<em>假设</em> (这个数字可以是任意的: <math><mrow><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>250</mn><mo>,</mo><mo>&hellip;</mo></mrow></math>), 然后我们构造了一个新的演绎, 其结论是<math><mrow><mi>A</mi><mo>&rArr;</mo><mi>B</mi></mrow></math>, 但是其中的这些选定的<math><mi>A</mi></math>的出现都会被<em>discharged</em>, 即被杀死. 可能还存在其他<math><mi>A</mi></math>的出现我们选择不去discharge.</p><p>这条规则很好地刻画了树状的记号的样貌: 知道<em>何时</em>一个假设被discharged是重要的, 因而有必要记录这种信息. 但是如果在以上的例子中这样做, 这意味着我们需要将被叉掉的<math><mi>A</mi></math>和<math><mrow><mo lspace="0" rspace="0">&rArr;</mo><mi mathvariant="script">I</mi></mrow></math>规则那行连起来; 但是连起来之后这个东西就不再是之前我们所考虑的真正的树结构了!</p><h4>第2.1.1小节 规则</h4><ul><li><em>假设</em>: <math><mi>A</mi></math></li><li><em>引入</em>:<math display="block"><mrow><mrow><mfrac displaystyle="true"><mrow><mtable><mtr><mtd><mo>&vellip;</mo></mtd></mtr><mtr><mtd><mi>A</mi></mtd></mtr></mtable><mspace width="8ex"/><mtable><mtr><mtd><mo>&vellip;</mo></mtd></mtr><mtr><mtd><mi>B</mi></mtd></mtr></mtable></mrow><mrow><mi>A</mi><mo>&and;</mo><mi>B</mi></mrow></mfrac><mrow><mo lspace="0" rspace="0">&and;</mo><mi mathvariant="script">I</mi></mrow></mrow><mspace width="16ex"/><mrow><mfrac displaystyle="true"><mtable><mtr><mtd><mrow><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow></mtd></mtr><mtr><mtd><mo>&vellip;</mo></mtd></mtr><mtr><mtd><mi>B</mi></mtd></mtr></mtable><mrow><mi>A</mi><mo>&rArr;</mo><mi>B</mi></mrow></mfrac><mrow><mo lspace="0" rspace="0">&rArr;</mo><mi mathvariant="script">I</mi></mrow></mrow><mspace width="16ex"/><mrow><mfrac displaystyle="true"><mtable><mtr><mtd><mo>&vellip;</mo></mtd></mtr><mtr><mtd><mi>A</mi></mtd></mtr></mtable><mrow><mo>&forall;</mo><mi>&xi;</mi><mo lspace="0">.</mo><mi>A</mi></mrow></mfrac><mrow><mo>&forall;</mo><mi mathvariant="script">I</mi></mrow></mrow></mrow></math></li><li><em>消去</em>:<math display="block"><mrow><mrow><mfrac displaystyle="true"><mtable><mtr><mtd><mo>&vellip;</mo></mtd></mtr><mtr><mtd><mrow><mi>A</mi><mo>&and;</mo><mi>B</mi></mrow></mtd></mtr></mtable><mi>A</mi></mfrac><mrow><mo lspace="0" rspace="0">&and;</mo><mn>1</mn><mi mathvariant="script">E</mi></mrow></mrow><mspace width="16ex"/><mrow><mfrac displaystyle="true"><mtable><mtr><mtd><mo>&vellip;</mo></mtd></mtr><mtr><mtd><mrow><mi>A</mi><mo>&and;</mo><mi>B</mi></mrow></mtd></mtr></mtable><mi>B</mi></mfrac><mrow><mo lspace="0" rspace="0">&and;</mo><mn>2</mn><mi mathvariant="script">E</mi></mrow></mrow><mspace width="16ex"/><mrow><mfrac displaystyle="true"><mrow><mtable><mtr><mtd><mo>&vellip;</mo></mtd></mtr><mtr><mtd><mi>A</mi></mtd></mtr></mtable><mspace width="8ex"/><mtable><mtr><mtd><mo>&vellip;</mo></mtd></mtr><mtr><mtd><mrow><mi>A</mi><mo>&rArr;</mo><mi>B</mi></mrow></mtd></mtr></mtable></mrow><mi>B</mi></mfrac><mrow><mo lspace="0" rspace="0">&rArr;</mo><mi mathvariant="script">E</mi></mrow></mrow><mspace width="16ex"/><mrow><mfrac displaystyle="true"><mrow><mo>&forall;</mo><mi>&xi;</mi><mo lspace="0">.</mo><mi>A</mi></mrow><mrow><mi>A</mi><mrow><mo stretchy="false">[</mo><mrow><mi>a</mi><mo lspace="0" rspace="0">/</mo><mi>&xi;</mi></mrow><mo stretchy="false">]</mo></mrow></mrow></mfrac><mrow><mo>&forall;</mo><mi mathvariant="script">E</mi></mrow></mrow></mrow></math>在传统上<math><mrow><mo lspace="0" rspace="0">&rArr;</mo><mi mathvariant="script">E</mi></mrow></math>被称为<em>modus ponens</em>.</li></ul><p>一些注记:<br/>所有的规则, 除了<math><mrow><mo lspace="0" rspace="0">&rArr;</mo><mi mathvariant="script">I</mi></mrow></math>, 都保持the stock of hypotheses: 例如, 以上以<math><mrow><mo lspace="0" rspace="0">&rArr;</mo><mi mathvariant="script">E</mi></mrow></math>作结的演绎, 其假设是两个立即子演绎的假设.<br/>出于众所周知的逻辑原因, 有必要将<math><mrow><mo>&forall;</mo><mi mathvariant="script">I</mi></mrow></math>限制于变量<math><mi>&xi;</mi></math>不能在任何假设中自由出现的情形 (但是, 从另一方面说, 其可以在死去的叶子中自由出现).<br/>这个系统的基础对称在于<em>引入/消去</em>对称, 其代替了不能在这种上下文中被实现的<em>假设/结论</em>对称.</p><p>原注: 变量<math><mi>&xi;</mi></math>属于<em>对象语言</em> (其可能代表一个数字, 一个数据记录, 一个事件). 我们为<math><mi>&lambda;</mi></math>演算的变量保留符号<math><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi></mrow></math>, 下一节我们将引入这个概念. [译注: 元语言和对象语言是相对的概念.]</p><h3>第2.2节 计算上的意义</h3><p>我们将以Heyting语义的角度重新检视自然演绎系统. 我们固定原子公式的解释以及量词的范围. 一个公式<math><mi>A</mi></math>将被看成是其所有可能的演绎构成的集合; 不说&quot;<math><mi>&delta;</mi></math>证明了<math><mi>A</mi></math>&quot;, 我们说&quot;<math><mrow><mi>&delta;</mi><mo>&in;</mo><mi>A</mi></mrow></math>&quot;.</p><p>然后自然演绎的规则就以构造函数的特别方式显现: 以<math><mrow><msub><mi>B</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>B</mi><mi>n</mi></msub></mrow></math>为假设的一个演绎<math><mi>A</mi></math>, 可以被看成是一个函数<math><mrow><mi>t</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">]</mo></mrow></mrow></math>, 其联系<math><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>&in;</mo><msub><mi>B</mi><mi>i</mi></msub></mrow></math>以结果<math><mrow><mrow><mi>t</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><msub><mi>b</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>&in;</mo><mi>A</mi></mrow></math>. 实际上, 为了使得这种对应精确, 我们需要处理<em>parcels of hypotheses</em>: 相同的公式<math><mi>B</mi></math>可能在假设中出现多次, 而在相同的parcel中的两次<math><mi>B</mi></math>的出现应该对应于相同的变量.</p><p>以上的内容听起来似乎有些神秘, 但是通过一些例子, 其很快就会变得清晰起来.</p><h4>第2.2.1小节 规则的解释</h4><ol><li>仅由一个假设<math><mi>A</mi></math>构成的演绎由表达式<math><mi>x</mi></math>表示, 其中<math><mi>x</mi></math>是代表<math><mi>A</mi></math>的一个元素的变量. 之后, 若还有<math><mi>A</mi></math>的出现, 我们将选择相同的<math><mi>x</mi></math>, 或者另外一个变量, 这取决于这些出现是否在相同的parcel之中.</li><li>如果一个演绎由两个演绎通过<math><mrow><mo lspace="0" rspace="0">&and;</mo><mi mathvariant="script">I</mi></mrow></math>得到, 并且这两个演绎分别对应于<math><mrow><mi>u</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">]</mo></mrow></mrow></math>和<math><mrow><mi>v</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">]</mo></mrow></mrow></math>, 那么我们联系该演绎以序对<math><mrow><mo stretchy="false">&lang;</mo><mrow><mrow><mi>u</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>,</mo><mrow><mi>v</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">]</mo></mrow></mrow></mrow><mo stretchy="false">&rang;</mo></mrow></math>, 这不过是因为对于合取的证明是一个<em>序对</em>. 我们刚才使得<math><mi>u</mi></math>和<math><mi>v</mi></math>依赖于相同的变量; 的确, 对于<math><mi>u</mi></math>和<math><mi>v</mi></math>的变量的选择是相互关联的, 因为某些parcels of hypotheses应该是同一个.</li><li>如果一个演绎以<math><mrow><mo lspace="0" rspace="0">&and;</mo><mn>1</mn><mi mathvariant="script">E</mi></mrow></math>作结, 并且<math><mrow><mi>t</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">]</mo></mrow></mrow></math>与立即子演绎相对应, 那么我们就将我们的证明与<math><mrow><msup><mi>&pi;</mi><mn>1</mn></msup><mo>&af;</mo><mrow><mi>t</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">]</mo></mrow></mrow></mrow></math>相关联. 此即<em>第一投影</em>, 这不过是因为<math><mi>t</mi></math>作为对于合取的证明应该是一个序对. 类似地, <math><mrow><mo lspace="0" rspace="0">&and;</mo><mn>2</mn><mi mathvariant="script">E</mi></mrow></math>和<em>第二投影</em><math><msup><mi>&pi;</mi><mn>2</mn></msup></math>有关.<br/>尽管不是很形式化, 但是考虑以下基础等式是必要的:<math display="block"><mrow><mrow><mrow><msup><mi>&pi;</mi><mn>1</mn></msup><mo>&af;</mo><mrow><mo stretchy="false">&lang;</mo><mrow><mi>u</mi><mo>,</mo><mi>v</mi></mrow><mo stretchy="false">&rang;</mo></mrow></mrow><mo>=</mo><mi>u</mi></mrow><mo>,</mo><mrow><mrow><msup><mi>&pi;</mi><mn>2</mn></msup><mo>&af;</mo><mrow><mo stretchy="false">&lang;</mo><mrow><mi>u</mi><mo>,</mo><mi>v</mi></mrow><mo stretchy="false">&rang;</mo></mrow></mrow><mo>=</mo><mi>v</mi></mrow><mo>,</mo><mrow><mrow><mo stretchy="false">&lang;</mo><mrow><mrow><msup><mi>&pi;</mi><mn>1</mn></msup><mo>&af;</mo><mi>t</mi></mrow><mo>,</mo><mrow><msup><mi>&pi;</mi><mn>2</mn></msup><mo>&af;</mo><mi>t</mi></mrow></mrow><mo stretchy="false">&rang;</mo></mrow><mo>=</mo><mi>t</mi></mrow></mrow></math>这些等式是逻辑学和计算机科学之间的对应的本质.</li><li>如果一个演绎以<math><mrow><mo lspace="0" rspace="0">&rArr;</mo><mi mathvariant="script">I</mi></mrow></math>作结, 令<math><mi>v</mi></math>是与立即子演绎相关联的项; 这个立即子演绎在parcels of hypotheses的层次上是被无歧义地确定的, 这是在说一整个<math><mi>A</mi></math>-parcel都被discharged了. 如果<math><mi>x</mi></math>是一个与该parcel相关联的变量, 那么我们就有了一个函数<math><mrow><mi>v</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mi>x</mi><mo>,</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">]</mo></mrow></mrow></math>. 我们将我们的演绎与函数<math><mrow><mi>t</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">]</mo></mrow></mrow></math>相关联, 其将每个<math><mi>A</mi></math>的参数<math><mi>a</mi></math>映射至<math><mrow><mi>v</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mi>a</mi><mo>,</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">]</mo></mrow></mrow></math>. 我们所用的记号是<math><mrow><mi>&lambda;</mi><mi>x</mi><mo lspace="0">.</mo><mrow><mi>v</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mi>x</mi><mo>,</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">]</mo></mrow></mrow></mrow></math>, 其中<math><mi>x</mi></math>是被绑定的变量.<br/>我们应该观察到<em>绑定(binding)</em>对应于<em>discharge</em>.</li><li>以<math><mrow><mo lspace="0" rspace="0">&rArr;</mo><mi mathvariant="script">E</mi></mrow></math>作结的演绎的情况由考虑两个函数<math><mrow><mi>t</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">]</mo></mrow></mrow></math>和<math><mrow><mi>u</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">]</mo></mrow></mrow></math>处理, 其分别对应于两个立即子演绎. </li></ol><h2>第3章 Curry-Howard同构</h2><p>我们已经看到Heyting的想法在自然演绎的框架之下执行得非常好. 我们将建立一个类型化项 (typed term) 的<em>形式</em>系统以讨论藏在证明背后的泛函对象. 这个系统的意义是藉由我们已经写下的泛函方程给出的. 实际上, 这些方程可以用两种不同的方式阅读, 这再次强化了涵义和指称之间的二分:<ul><li>作为定义了项的相等性的<em>等式</em>, 换言之即指称的相等 (<em>静态</em>观点).</li><li>作为<em>重写</em>规则, 其允许我们通过规约至规范形式来计算项. 这是一种操作性的, <em>动态</em>的观点, 而且对于逻辑学的此方面而言, 这是唯一真正带来丰富结果 (fruitful) 的观点.</li></ul></p><p>当然, 第二种观点和第一种比起来有欠发展, 至少对于逻辑学是这样! 例如, 程序的<em>指称</em>语义 (例如, Scott语义) 有很多: 对于这种语义, 程序的执行过程中没有东西会发生变化. 另一方面, 几乎没有任何打磨精致的程序的<em>操作</em>语义 (我们排除只是粗糙重述迈向规范形式的步骤的<em>ad hoc</em>语义). 建立真正的算法的操作语义或许是计算机科学中最重要的问题.</p><p>类型和命题之间的对应在<cite>[<a href="#Howard">3</a>]</cite>之中建立起来.</p><h3>第3.1节 lambda演算</h3><h4>第3.1.1小节 类型</h4><p>当我们以Heyting的精神思考证明, 公式就成为了<em>类型</em>. 具体来说, 类型如下:<ol><li>原子类型<math><mrow><msub><mi>T</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>T</mi><mi>n</mi></msub></mrow></math>是类型.</li><li>如果<math><mi>U</mi></math>和<math><mi>V</mi></math>是类型, 那么<math><mrow><mi>U</mi><mo>&times;</mo><mi>V</mi></mrow></math>和<math><mrow><mi>U</mi><mo>&rarr;</mo><mi>V</mi></mrow></math>是类型.</li><li>(暂时)仅有的类型都是通过1和2得到的.</li></ol></p><p>这与命题演算的<math><mrow><mo stretchy="false">(</mo><mrow><mo lspace="0" rspace="0">&and;</mo><mo>,</mo><mo lspace="0" rspace="0">&rArr;</mo></mrow><mo stretchy="false">)</mo></mrow></math>相对应: 原子命题写作<math><msub><mi>T</mi><mi>i</mi></msub></math>, <math><mo>&and;</mo></math>成为<math><mo>&times;</mo></math>, <math><mo>&rArr;</mo></math>成为<math><mo>&rarr;</mo></math>.</p><h4>第3.1.2小节 项</h4><p>证明就成了<em>项</em>. 更准确地说, <math><mi>A</mi></math>的一个证明 (<math><mi>A</mi></math>作为公式) 成为一个<em>具有类型<math><mi>A</mi></math>的项</em> (<math><mi>A</mi></math>作为类型). 具体来说, 项如下:<ol><li>变量<math><mrow><msubsup><mi>x</mi><mn>0</mn><mi>T</mi></msubsup><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msubsup><mi>x</mi><mi>n</mi><mi>T</mi></msubsup><mo>,</mo><mo>&hellip;</mo></mrow></math>是具有类型<math><mi>T</mi></math>的项.</li><li>如果<math><mi>u</mi></math>和<math><mi>v</mi></math>分别是具有类型<math><mi>U</mi></math>和<math><mi>V</mi></math>的项, 那么<math><mrow><mo stretchy="false">&lang;</mo><mrow><mi>u</mi><mo>,</mo><mi>v</mi></mrow><mo stretchy="false">&rang;</mo></mrow></math>是具有类型<math><mrow><mi>U</mi><mo>&times;</mo><mi>V</mi></mrow></math>的项.</li><li>如果<math><mi>t</mi></math>是具有类型<math><mrow><mi>U</mi><mo>&times;</mo><mi>V</mi></mrow></math>的项, 那么<math><mrow><msup><mi>&pi;</mi><mn>1</mn></msup><mo>&af;</mo><mi>t</mi></mrow></math>和<math><mrow><msup><mi>&pi;</mi><mn>2</mn></msup><mo>&af;</mo><mi>t</mi></mrow></math>分别是具有类型<math><mi>U</mi></math>和<math><mi>V</mi></math>的项.</li><li>如果<math><mi>v</mi></math>是具有类型<math><mi>V</mi></math>的一个项并且<math><msubsup><mi>x</mi><mi>n</mi><mi>U</mi></msubsup></math>是一个具有类型<math><mi>U</mi></math>的变量, 那么<math><mrow><mi>&lambda;</mi><msubsup><mi>x</mi><mi>n</mi><mi>U</mi></msubsup><mo lspace="0">.</mo><mi>v</mi></mrow></math>是一个具有类型<math><mrow><mi>U</mi><mo>&rarr;</mo><mi>V</mi></mrow></math>的项. 一般而言, 我们将假定我们已经解决了绑定变量的选取以及替换问题, 通过这样或那样的方法, 这允许我们不需要考虑绑定变量的名字, 想法在于绑定变量没有individuality.</li><li>如果<math><mi>t</mi></math>和<math><mi>u</mi></math>分别是具有类型<math><mrow><mi>U</mi><mo>&rarr;</mo><mi>V</mi></mrow></math>和<math><mi>U</mi></math>的项, 那么<math><mrow><mi>t</mi><mo>&af;</mo><mi>u</mi></mrow></math>是具有类型<math><mi>V</mi></math>的项.</li></ol></p><h3>第3.2节 指称上的意义</h3><p>类型代表了某种正在被讨论的对象. 例如, 一个具有类型<math><mrow><mi>U</mi><mo>&rarr;</mo><mi>V</mi></mrow></math>的对象是一个从<math><mi>U</mi></math>到<math><mi>V</mi></math>的函数, 一个具有类型<math><mrow><mi>U</mi><mo>&times;</mo><mi>V</mi></mrow></math>的对象是一个序对, 由一个<math><mi>U</mi></math>的对象和一个<math><mi>V</mi></math>的对象构成. 原子类型的含义是不重要的, 其依赖于上下文.</p><h3>第3.3节 操作性的意义</h3><p>一般来说, <em>项</em>代表<em>程序</em>. 程序的目的在于计算其指称, 或者至少是将指称置于一种便利的形式. 程序的<em>类型</em>被视为一种<em>描述(specification)</em>, 即程序(抽象地)做了什么. 先验地说这是一种具有形式&quot;这个程序计算两个整数之和&quot;的评论.</p><h3>第3.4节 转换</h3><p>一个项被称为<em>规范的</em>, 如果没有其子项具有形式:<math display="block"><mrow><mrow><msup><mi>&pi;</mi><mn>1</mn></msup><mo>&af;</mo><mrow><mo stretchy="false">&lang;</mo><mrow><mi>u</mi><mo>,</mo><mi>v</mi></mrow><mo stretchy="false">&rang;</mo></mrow></mrow><mspace width="16ex"/><mrow><msup><mi>&pi;</mi><mn>2</mn></msup><mo>&af;</mo><mrow><mo stretchy="false">&lang;</mo><mrow><mi>u</mi><mo>,</mo><mi>v</mi></mrow><mo stretchy="false">&rang;</mo></mrow></mrow><mspace width="16ex"/><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>&lambda;</mi><msubsup><mi>x</mi><mi>n</mi><mi>U</mi></msubsup><mo lspace="0">.</mo><mi>v</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mi>u</mi></mrow></mrow></math></p><h3>第3.5节 对于同构的描述</h3><p></p><h2>第4章 规范化定理 (正则化定理)</h2><p>本章关心的是确保类型化<math><mi>&lambda;</mi></math>演算能够在计算上表现良好的两个结果. <em>规范化定理</em>提供了规范形式的存在性, 而与此同时<em>Church-Rosser</em>性质保证了其唯一性. 实际上, 对于后者而言, 我们仅是简单陈述其内容但不加以证明, 因为其确非类型论的内容, 而且在许多文献中都有很好的讲解了, 例如<cite>[<a href="#Barendregt">1</a>]</cite>.</p><p>规范化定理具有两种形式:<ul><li><em>弱形式</em> (存在<em>某个</em>规范化的能够终止的策略), 这将在本章中进行证明.</li><li><em>强形式</em> (<em>所有可能的</em>规范化策略都将终止), 这在第6章中证明.</li></ul></p><h3>第4.1节 Church-Rosser性质</h3><p>这个性质表达了规范形式的唯一性, 这独立于其存在性. 实际上, 它对于其他演算来说也有意义, 例如<em>无类型</em><math><mi>&lambda;</mi></math>演算, 在无类型的<math><mi>&lambda;</mi></math>演算里规范化定理不成立.</p><div class="theorem"><b>定理.</b> 如果<math><mrow><mi>t</mi><mo>&zigrarr;</mo><mrow><mi>u</mi><mo>,</mo><mi>v</mi></mrow></mrow></math>, 那么我们可以找到<math><mi>w</mi></math>使得<math><mrow><mrow><mi>u</mi><mo>,</mo><mi>v</mi></mrow><mo>&zigrarr;</mo><mi>w</mi></mrow></math>.</div><div class="corollary"><b>推论.</b> 一个项<math><mi>t</mi></math>至多只有一个规范形式.</div><div class="proof"><b>证明.</b> 如果<math><mrow><mi>t</mi><mo>&zigrarr;</mo><mrow><mi>u</mi><mo>,</mo><mi>v</mi></mrow></mrow></math>, 其中<math><mi>u</mi></math>和<math><mi>v</mi></math>是规范形式, 那么存在某个<math><mi>w</mi></math>使得<math><mrow><mrow><mi>u</mi><mo>,</mo><mi>v</mi></mrow><mo>&zigrarr;</mo><mi>w</mi></mrow></math>, 但是既然<math><mi>u</mi></math>和<math><mi>v</mi></math>已经是规范的了, 它们就不可能被规约至除了自身以外的项, 所以<math><mrow><mi>u</mi><mo>=</mo><mi>w</mi><mo>=</mo><mi>v</mi></mrow></math>.<div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><p>Church-Rosser定理</p><h3>第4.2节 弱规范化定理</h3><p>这个结果陈述了每个项的规范形式的<em>存在性</em>, 当然它必然也是唯一的. 其立即的推论在于指称相等的<em>可判定性</em>. </p><h3>第4.3节 弱规范化定理的证明</h3><h3>第4.4节 强规范化定理</h3><h2>第5章 相继式演算</h2><p>归功于Gentzen, <em>相继式演算</em>是对于逻辑学的对称的最漂亮刻画. 其与自然演绎有着诸多类似之处, 但是不局限于直觉主义的情形.</p><p>这种演算一般来说被计算机科学家所忽略, 尽管其刻画了某些基础性的想法: 例如, Prolog这种语言是对于相继式演算的部分实现, 而自动定理证明领域使用的&quot;tableaux&quot;方法不过是这种演算的一个特殊情形. 换言之, 它浑然不觉地被许多人使用, 但是混杂了<em>控制</em>特性, 即编程设备 (programming device). 使得这一切运作的是相继式演算及其深刻的对称性, 而不是什么特别的技巧. 所以说, 若是不知道相继式演算的微妙之处, 是很难考虑, 例如, Prolog的理论的.</p><p>从算法的角度来说, 相继式演算没有<em>Curry-Howard同构</em>, 这是因为太多书写相同证明的方式. 这阻止了我们将其当作类型化<math><mi>&lambda;</mi></math>演算使用, 尽管我们瞥见了某种类似物的深层结构, 可能与并行有关. 但是, 它需要对于句法的新方法, 例如带有多个结论的自然演绎.</p><h3>第5.1节 演算</h3><h4>第5.1.1小节 相继式</h4><p>一个<em>相继式</em>是一个表达式<math><mrow><munder><mi>A</mi><mo>&UnderBar;</mo></munder><mo>&vdash;</mo><munder><mi>B</mi><mo>&UnderBar;</mo></munder></mrow></math>, 其中<math><munder><mi>A</mi><mo>&UnderBar;</mo></munder></math>和<math><munder><mi>B</mi><mo>&UnderBar;</mo></munder></math>是公式的有限序列<math><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>A</mi><mi>n</mi></msub></mrow></math>和<math><mrow><msub><mi>B</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>B</mi><mi>m</mi></msub></mrow></math>.</p><p>幼稚的(指称性)解释在于<math><msub><mi>A</mi><mi>i</mi></msub></math>的合取推出了<math><msub><mi>B</mi><mi>j</mi></msub></math>的析取, 特别地<ul><li>如果<math><munder><mi>A</mi><mo>&UnderBar;</mo></munder></math>为空, 那么相继式就断言了<math><msub><mi>B</mi><mi>j</mi></msub></math>的析取;</li><li>如果<math><munder><mi>A</mi><mo>&UnderBar;</mo></munder></math>为空并且<math><munder><mi>B</mi><mo>&UnderBar;</mo></munder></math>就是<math><msub><mi>B</mi><mn>1</mn></msub></math>, 那么它断言了<math><msub><mi>B</mi><mn>1</mn></msub></math>;</li><li>如果<math><munder><mi>B</mi><mo>&UnderBar;</mo></munder></math>为空, 那么它断言了<math><msub><mi>A</mi><mi>i</mi></msub></math>的合取的否定;</li><li>如果<math><munder><mi>A</mi><mo>&UnderBar;</mo></munder></math>和<math><munder><mi>B</mi><mo>&UnderBar;</mo></munder></math>均为空, 那么它断言了一个矛盾.</li></ul></p><h4>第5.1.2小节 结构规则</h4><p>这些规则, 似乎什么也没说, 强制规定了管理&quot;槽&quot;的一种特定方式, 在槽中人们书写公式. 规则如下, 它们是:<ol><li><em>交换</em>规则<math display="block"><mrow><mrow><mfrac displaystyle="true"><mrow><mrow><munder><mi>A</mi><mo>&UnderBar;</mo></munder><mo>,</mo><mi>C</mi><mo>,</mo><mi>D</mi><mo>,</mo><munder><msup><mi>A</mi><mo>&prime;</mo></msup><mo>&UnderBar;</mo></munder></mrow><mo>&vdash;</mo><munder><mi>B</mi><mo>&UnderBar;</mo></munder></mrow><mrow><mrow><munder><mi>A</mi><mo>&UnderBar;</mo></munder><mo>,</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo>,</mo><munder><msup><mi>A</mi><mo>&prime;</mo></msup><mo>&UnderBar;</mo></munder></mrow><mo>&vdash;</mo><munder><mi>B</mi><mo>&UnderBar;</mo></munder></mrow></mfrac><mrow><mi mathvariant="script">L</mi><mi mathvariant="sans-serif">X</mi></mrow></mrow><mspace width="16ex"/><mrow><mfrac displaystyle="true"><mrow><mi>A</mi><mo>&vdash;</mo><mrow><munder><mi>B</mi><mo>&UnderBar;</mo></munder><mo>,</mo><mi>C</mi><mo>,</mo><mi>D</mi><mo>,</mo><munder><msup><mi>B</mi><mo>&prime;</mo></msup><mo>&UnderBar;</mo></munder></mrow></mrow><mrow><mi>A</mi><mo>&vdash;</mo><mrow><munder><mi>B</mi><mo>&UnderBar;</mo></munder><mo>,</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo>,</mo><munder><msup><mi>B</mi><mo>&prime;</mo></msup><mo>&UnderBar;</mo></munder></mrow></mrow></mfrac><mrow><mi mathvariant="script">R</mi><mi mathvariant="sans-serif">X</mi></mrow></mrow></mrow></math>这些规则表达了逻辑的<em>交换性</em>, 通过允许符号<math><mo>&vdash;</mo></math>每一边的公式进行置换.</li><li><em>削弱</em>规则<math display="block"><mrow><mrow><mfrac displaystyle="true"><mrow><munder><mi>A</mi><mo>&UnderBar;</mo></munder><mo>&vdash;</mo><munder><mi>B</mi><mo>&UnderBar;</mo></munder></mrow><mrow><mrow><munder><mi>A</mi><mo>&UnderBar;</mo></munder><mo>,</mo><mi>C</mi></mrow><mo>&vdash;</mo><munder><mi>B</mi><mo>&UnderBar;</mo></munder></mrow></mfrac><mrow><mi mathvariant="script">L</mi><mi mathvariant="sans-serif">W</mi></mrow></mrow><mspace width="16ex"/><mrow><mfrac displaystyle="true"><mrow><munder><mi>A</mi><mo>&UnderBar;</mo></munder><mo>&vdash;</mo><munder><mi>B</mi><mo>&UnderBar;</mo></munder></mrow><mrow><munder><mi>A</mi><mo>&UnderBar;</mo></munder><mo>&vdash;</mo><mrow><mi>C</mi><mo>,</mo><munder><mi>B</mi><mo>&UnderBar;</mo></munder></mrow></mrow></mfrac><mrow><mi mathvariant="script">R</mi><mi mathvariant="sans-serif">W</mi></mrow></mrow></mrow></math>正如名字所暗示的那样, 其允许将相继式代替以一个更弱的相继式.</li><li><em>收缩</em>规则<math display="block"><mrow><mrow><mfrac displaystyle="true"><mrow><mrow><munder><mi>A</mi><mo>&UnderBar;</mo></munder><mo>,</mo><mi>C</mi><mo>,</mo><mi>C</mi></mrow><mo>&vdash;</mo><munder><mi>B</mi><mo>&UnderBar;</mo></munder></mrow><mrow><mrow><munder><mi>A</mi><mo>&UnderBar;</mo></munder><mo>,</mo><mi>C</mi></mrow><mo>&vdash;</mo><munder><mi>B</mi><mo>&UnderBar;</mo></munder></mrow></mfrac><mrow><mi mathvariant="script">L</mi><mi mathvariant="sans-serif">C</mi></mrow></mrow><mspace width="16ex"/><mrow><mfrac displaystyle="true"><mrow><munder><mi>A</mi><mo>&UnderBar;</mo></munder><mo>&vdash;</mo><mrow><mi>C</mi><mo>,</mo><mi>C</mi><mo>,</mo><munder><mi>B</mi><mo>&UnderBar;</mo></munder></mrow></mrow><mrow><munder><mi>A</mi><mo>&UnderBar;</mo></munder><mo>&vdash;</mo><mrow><mi>C</mi><mo>,</mo><munder><mi>B</mi><mo>&UnderBar;</mo></munder></mrow></mrow></mfrac><mrow><mi mathvariant="script">R</mi><mi mathvariant="sans-serif">C</mi></mrow></mrow></mrow></math>表达了合取与析取的幂等性.</li></ol></p><p>事实上, 与流行的认知相反, 这些规则才是整个演算里最重要的部分. 这是因为, 在还没有写下任何一个逻辑符号之前, 我们实际上就已经能够确定逻辑操作的未来行为. 尽管这些规则从指称的角度来看是显然的, 但是我们应该从操作的角度仔细检视这些规则, 特别是<em>收缩</em>.</p><p></p><h4>第5.1.3小节 直觉主义的情形</h4><h4>第5.1.4小节 &quot;相等&quot;群</h4><ol><li></li></ol><h4>第5.1.5小节 逻辑规则</h4><p>传统上人们认为逻辑是一种形式游戏, 一连串或多或少有些随意的公理和规则. 相继式演算 (当然自然演绎也是) 表明实际上完全不是这么一回事: 人们可以自娱自乐地发明他们自己的逻辑操作, 但是这些逻辑操作不得不尊重左/右对称, 否则的话他们发明的就只是一种毫无趣味的逻辑暴行. 具体来说, 对称指的是我们可以<em>消除</em>切规则.</p><ol><li></li></ol><h3>第5.2节 无切系统的一些性质</h3><h2>第6章 强规范化定理</h2><p>本章我们将证明简单类型<math><mi>&lambda;</mi></math>演算的强规范化定理, 但是既然</p><h2>第7章 G&ouml;del的系统T</h2><h3>第7.1节 演算</h3><h4>第7.1.1小节 类型</h4><p>第3章中我们允许额外的常量类型; 现在我们将描述两种这样的类型, 分别是<math><mi mathvariant="sans-serif">Int</mi></math> (整数) 和<math><mi mathvariant="sans-serif">Bool</mi></math> (布尔).</p><p>译注: 根据第1章的原注, 本书的整数都是指自然数.</p><h4>第7.1.2小节 项</h4><p>除了常见的五种, 对于<math><mi mathvariant="sans-serif">Int</mi></math>和<math><mi mathvariant="sans-serif">Bool</mi></math>存在特定的scheme. 我们保持了使用<em>引入/消去</em>术语, 因为这些scheme还将出现在之后的<math><mi mathvariant="bold">F</mi></math>之中.</p><ol><li><math><mi mathvariant="sans-serif">Int</mi></math><em>引入</em>:<ul><li><math><mi mathvariant="sans-serif">O</mi></math>是一个具有类型<math><mi mathvariant="sans-serif">Int</mi></math>的常量;</li><li>如果<math><mi>t</mi></math>具有类型<math><mi mathvariant="sans-serif">Int</mi></math>, 那么<math><mrow><mi mathvariant="sans-serif">S</mi><mo>&af;</mo><mi>t</mi></mrow></math>具有类型<math><mi mathvariant="sans-serif">Int</mi></math>.</li></ul></li><li><math><mi mathvariant="sans-serif">Int</mi></math><em>消去</em>: 如果<math><mrow><mi>u</mi><mo>,</mo><mi>v</mi><mo>,</mo><mi>t</mi></mrow></math>分别具有类型<math><mrow><mi>U</mi><mo>,</mo><mrow><mi>U</mi><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="sans-serif">Int</mi><mo>&rarr;</mo><mi>U</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mi mathvariant="sans-serif">Int</mi></mrow></math>, 那么<math><mrow><mrow><mrow><mi mathvariant="sans-serif">R</mi><mo>&af;</mo><mi>u</mi></mrow><mo>&af;</mo><mi>v</mi></mrow><mo>&af;</mo><mi>t</mi></mrow></math>具有类型<math><mi>U</mi></math>.</li><li><math><mi mathvariant="sans-serif">Bool</mi></math><em>引入</em>: <math><mi mathvariant="sans-serif">T</mi></math>和<math><mi mathvariant="sans-serif">F</mi></math>具有类型<math><mi mathvariant="sans-serif">Bool</mi></math>.</li><li><math><mi mathvariant="sans-serif">Bool</mi></math><em>消去</em>: 如果<math><mrow><mi>u</mi><mo>,</mo><mi>v</mi><mo>,</mo><mi>t</mi></mrow></math>分别具有类型<math><mrow><mi>U</mi><mo>,</mo><mi>U</mi><mo>,</mo><mi mathvariant="sans-serif">Bool</mi></mrow></math>, 那么<math><mrow><mrow><mrow><mi mathvariant="sans-serif">D</mi><mo>&af;</mo><mi>u</mi></mrow><mo>&af;</mo><mi>v</mi></mrow><mo>&af;</mo><mi>t</mi></mrow></math>具有类型<math><mi>U</mi></math>.</li></ol><h4>第7.1.3小节 意图的含义</h4><ol><li><math><mi mathvariant="sans-serif">O</mi></math>和<math><mi mathvariant="sans-serif">S</mi></math>分别是零元和后继函数.</li><li><math><mi mathvariant="sans-serif">R</mi></math>是递归算子: <math><mrow><mrow><mrow><mrow><mi mathvariant="sans-serif">R</mi><mo>&af;</mo><mi>u</mi></mrow><mo>&af;</mo><mi>v</mi></mrow><mo>&af;</mo><mn>0</mn></mrow><mo>=</mo><mi>u</mi></mrow></math>, <math><mrow><mrow><mrow><mrow><mi mathvariant="sans-serif">R</mi><mo>&af;</mo><mi>u</mi></mrow><mo>&af;</mo><mi>v</mi></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>v</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mrow><mi mathvariant="sans-serif">R</mi><mo>&af;</mo><mi>u</mi></mrow><mo>&af;</mo><mi>v</mi></mrow><mo>&af;</mo><mi>n</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mi>n</mi></mrow></mrow></math>.</li><li><math><mi mathvariant="sans-serif">T</mi></math>和<math><mi mathvariant="sans-serif">F</mi></math>是真值.</li><li><math><mi mathvariant="sans-serif">D</mi></math>是&quot;if ... then ... else&quot;: <math><mrow><mrow><mrow><mrow><mi mathvariant="sans-serif">D</mi><mo>&af;</mo><mi>u</mi></mrow><mo>&af;</mo><mi>v</mi></mrow><mo>&af;</mo><mi mathvariant="sans-serif">T</mi></mrow><mo>=</mo><mi>u</mi></mrow></math>, <math><mrow><mrow><mrow><mrow><mi mathvariant="sans-serif">D</mi><mo>&af;</mo><mi>u</mi></mrow><mo>&af;</mo><mi>v</mi></mrow><mo>&af;</mo><mi mathvariant="sans-serif">F</mi></mrow><mo>=</mo><mi>v</mi></mrow></math>.</li></ol><p>译注: 在某种意义上这里有点符号滥用.</p><h4>第7.1.4小节 转换</h4><p>除了经典的redex, 我们加入了:<math display="block"><mrow><mrow><mrow><mrow><mi mathvariant="sans-serif">R</mi><mo>&af;</mo><mi>u</mi></mrow><mo>&af;</mo><mi>v</mi></mrow><mo>&af;</mo><mi mathvariant="sans-serif">O</mi></mrow><mo>&zigrarr;</mo><mi>u</mi></mrow></math><math display="block"><mrow><mrow><mrow><mrow><mi mathvariant="sans-serif">R</mi><mo>&af;</mo><mi>u</mi></mrow><mo>&af;</mo><mi>v</mi></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="sans-serif">S</mi><mo>&af;</mo><mi>t</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&zigrarr;</mo><mrow><mrow><mi>v</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mrow><mi mathvariant="sans-serif">R</mi><mo>&af;</mo><mi>u</mi></mrow><mo>&af;</mo><mi>v</mi></mrow><mo>&af;</mo><mi>t</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mi>t</mi></mrow></mrow></math><math display="block"><mrow><mrow><mrow><mrow><mi mathvariant="sans-serif">D</mi><mo>&af;</mo><mi>u</mi></mrow><mo>&af;</mo><mi>v</mi></mrow><mo>&af;</mo><mi mathvariant="sans-serif">T</mi></mrow><mo>&zigrarr;</mo><mi>u</mi></mrow></math><math display="block"><mrow><mrow><mrow><mrow><mi mathvariant="sans-serif">D</mi><mo>&af;</mo><mi>u</mi></mrow><mo>&af;</mo><mi>v</mi></mrow><mo>&af;</mo><mi mathvariant="sans-serif">F</mi></mrow><mo>&zigrarr;</mo><mi>v</mi></mrow></math></p><h3>第7.2节 规范化定理</h3><p>在<math><mi mathvariant="bold">T</mi></math>中, 所有的规约序列都是有限的, 并将导向相同的规范形式.</p><div class="proof"><b>证明.</b> <div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><h3>第7.3节 表达力: 例子</h3><h4>第7.3.1小节 布尔</h4><p>典型的例子是逻辑联结词:<math display="block"><mrow><mrow><mrow><mi mathvariant="sans-serif">neg</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mrow><mi mathvariant="sans-serif">D</mi><mo>&af;</mo><mi mathvariant="sans-serif">F</mi></mrow><mo>&af;</mo><mi mathvariant="sans-serif">T</mi></mrow><mo>&af;</mo><mi>u</mi></mrow></mrow><mspace width="16ex"/><mrow><mrow><mi mathvariant="sans-serif">disj</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>u</mi><mo>,</mo><mi>v</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mrow><mi mathvariant="sans-serif">D</mi><mo>&af;</mo><mi mathvariant="sans-serif">T</mi></mrow><mo>&af;</mo><mi>v</mi></mrow><mo>&af;</mo><mi>u</mi></mrow></mrow><mspace width="16ex"/><mrow><mrow><mi mathvariant="sans-serif">conj</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>u</mi><mo>,</mo><mi>v</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mrow><mi mathvariant="sans-serif">D</mi><mo>&af;</mo><mi>v</mi></mrow><mo>&af;</mo><mi mathvariant="sans-serif">F</mi></mrow><mo>&af;</mo><mi>u</mi></mrow></mrow></mrow></math>例如, <math><mrow><mrow><mi mathvariant="sans-serif">disj</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="sans-serif">T</mi><mo>,</mo><mi>x</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&zigrarr;</mo><mi mathvariant="sans-serif">T</mi></mrow></math>和<math><mrow><mrow><mi mathvariant="sans-serif">disj</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="sans-serif">F</mi><mo>,</mo><mi>x</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&zigrarr;</mo><mi>x</mi></mrow></math>. 但是, 从另一方面来说, 如果遇到了表达式<math><mrow><mi mathvariant="sans-serif">disj</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi mathvariant="sans-serif">T</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>, 那么我们就不知道该做什么了.</p><p><b>问题.</b> 有没有一种可能定义另外一种析取, 但它是对称的?</p><p>在第9.3.1小节的时候, 我们将看到, 根据语义方法, 可以说明不存在具有类型<math><mrow><mrow><mi mathvariant="sans-serif">Bool</mi><mo>,</mo><mi mathvariant="sans-serif">Bool</mi></mrow><mo>&rarr;</mo><mi mathvariant="sans-serif">Bool</mi></mrow></math>的项<math><mi>G</mi></math>满足<math display="block"><mrow><mrow><mrow><mi>G</mi><mo>&af;</mo><mrow><mo stretchy="false">&lang;</mo><mrow><mi mathvariant="sans-serif">T</mi><mo>,</mo><mi>x</mi></mrow><mo stretchy="false">&rang;</mo></mrow></mrow><mo>&zigrarr;</mo><mi mathvariant="sans-serif">T</mi></mrow><mspace width="16ex"/><mrow><mrow><mi>G</mi><mo>&af;</mo><mrow><mo stretchy="false">&lang;</mo><mrow><mi>x</mi><mo>,</mo><mi mathvariant="sans-serif">T</mi></mrow><mo stretchy="false">&rang;</mo></mrow></mrow><mo>&zigrarr;</mo><mi mathvariant="sans-serif">T</mi></mrow><mspace width="16ex"/><mrow><mrow><mi>G</mi><mo>&af;</mo><mrow><mo stretchy="false">&lang;</mo><mrow><mi mathvariant="sans-serif">F</mi><mo>,</mo><mi mathvariant="sans-serif">F</mi></mrow><mo stretchy="false">&rang;</mo></mrow></mrow><mo>&zigrarr;</mo><mi mathvariant="sans-serif">F</mi></mrow></mrow></math></p><h4>第7.3.2小节 整数</h4><p>首先我们必须表示整数: 选择用<math><mrow><mover><mi>n</mi><mo>&OverBar;</mo></mover><mo>=</mo><mrow><msup><mi mathvariant="sans-serif">S</mi><mi>n</mi></msup><mo>&af;</mo><mi mathvariant="sans-serif">O</mi></mrow></mrow></math>来表示整数<math><mi>n</mi></math>是显然的.</p><p>经典的函数可以用简单的递推关系定义 [虽然译者觉得应该说是递归?]. 让我们给出加法的例子: 我们需要从我们已经熟知的定义方程开始:<math display="block"><mrow><mrow><mrow><mi>x</mi><mo>+</mo><mi mathvariant="sans-serif">O</mi></mrow><mo>=</mo><mi>x</mi></mrow><mspace width="16ex"/><mrow><mrow><mi>x</mi><mo>+</mo><mrow><mi mathvariant="sans-serif">S</mi><mo>&af;</mo><mi>y</mi></mrow></mrow><mo>=</mo><mrow><mi mathvariant="sans-serif">S</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math></p><p>考虑<math><mrow><mrow><mi>t</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>=</mo><mrow><mrow><mrow><mi mathvariant="sans-serif">R</mi><mo>&af;</mo><mi>x</mi></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&lambda;</mi><msup><mi>z</mi><mi mathvariant="sans-serif">Int</mi></msup><mo lspace="0">.</mo><mrow><mi>&lambda;</mi><msup><msup><mi>z</mi><mo>&prime;</mo></msup><mi mathvariant="sans-serif">Int</mi></msup><mo lspace="0">.</mo><mrow><mi mathvariant="sans-serif">S</mi><mo>&af;</mo><mi>z</mi></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mi>y</mi></mrow></mrow></math>:<math display="block"><mrow><mrow><mrow><mi>t</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mi>x</mi><mo>,</mo><mi mathvariant="sans-serif">O</mi></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>&zigrarr;</mo><mi>x</mi></mrow><mspace width="16ex"/><mrow><mrow><mi>t</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mi>x</mi><mo>,</mo><mrow><mi mathvariant="sans-serif">S</mi><mo>&af;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>&zigrarr;</mo><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>&lambda;</mi><msup><mi>z</mi><mi mathvariant="sans-serif">Int</mi></msup><mo lspace="0">.</mo><mrow><mi>&lambda;</mi><msup><msup><mi>z</mi><mo>&prime;</mo></msup><mi mathvariant="sans-serif">Int</mi></msup><mo lspace="0">.</mo><mrow><mi mathvariant="sans-serif">S</mi><mo>&af;</mo><mi>z</mi></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>t</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">]</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mi>y</mi></mrow><mo>&zigrarr;</mo><mrow><mi mathvariant="sans-serif">S</mi><mo>&af;</mo><mrow><mi>t</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">]</mo></mrow></mrow></mrow></mrow></mrow></math>这表明我们可以将<math><mrow><mi>t</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">]</mo></mrow></mrow></math>当作<math><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow></math>的一个定义.</p><p>通过类似这种风格的简单练习, 我们可以自娱自乐地定义乘法, 幂, 前继, 等等.</p><p>整数上的谓词当然也可以被定义, 例如<math display="block"><mrow><mrow><mrow><mi mathvariant="sans-serif">null</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi mathvariant="sans-serif">O</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi mathvariant="sans-serif">T</mi></mrow><mspace width="16ex"/><mrow><mrow><mi mathvariant="sans-serif">null</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="sans-serif">S</mi><mo>&af;</mo><mi>x</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi mathvariant="sans-serif">F</mi></mrow></mrow></math>给出了<math display="block"><mrow><mrow><mi mathvariant="sans-serif">null</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mover><mo>=</mo><mi>def</mi></mover><mrow><mrow><mrow><mi mathvariant="sans-serif">R</mi><mo>&af;</mo><mi mathvariant="sans-serif">T</mi></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&lambda;</mi><msup><mi>z</mi><mi mathvariant="sans-serif">Bool</mi></msup><mo lspace="0">.</mo><mrow><mi>&lambda;</mi><msup><msup><mi>z</mi><mo>&prime;</mo></msup><mi mathvariant="sans-serif">Int</mi></msup><mo lspace="0">.</mo><mi mathvariant="sans-serif">F</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mi>x</mi></mrow></mrow></math>这允许我们将一个特征函数 (类型<math><mi mathvariant="sans-serif">Int</mi></math>) 转换为一个谓词 (类型<math><mi mathvariant="sans-serif">Bool</mi></math>).</p><p>这些例子都没有严肃地运用高阶类型. 然而, 随着在递归中使用的类型的增加, 越来越多的函数变得可以表达. 例如, 如果<math><mi>f</mi></math>具有类型<math><mrow><mi mathvariant="sans-serif">Int</mi><mo>&rarr;</mo><mi mathvariant="sans-serif">Int</mi></mrow></math>, 我们可以定义类型为<math><mrow><mi mathvariant="sans-serif">Int</mi><mo>&rarr;</mo><mi mathvariant="sans-serif">Int</mi></mrow></math>的<math><mrow><mi mathvariant="sans-serif">it</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>为<math display="block"><mrow><mrow><mrow><mi mathvariant="sans-serif">it</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mi>x</mi></mrow><mo>=</mo><mrow><mrow><mrow><mi mathvariant="sans-serif">R</mi><mo>&af;</mo><mover><mn>1</mn><mo>&OverBar;</mo></mover></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&lambda;</mi><msup><mi>z</mi><mi mathvariant="sans-serif">Int</mi></msup><mo lspace="0">.</mo><mrow><mi>&lambda;</mi><msup><msup><mi>z</mi><mo>&prime;</mo></msup><mi mathvariant="sans-serif">Int</mi></msup><mo lspace="0">.</mo><mrow><mi>f</mi><mo>&af;</mo><mi>z</mi></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mi>x</mi></mrow></mrow></math>那么<math><mrow><mrow><mi mathvariant="sans-serif">it</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mover><mi>n</mi><mo>&OverBar;</mo></mover></mrow></math>就是<math><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>&af;</mo><mover><mn>1</mn><mo>&OverBar;</mo></mover></mrow></math>了. 作为具有类型<math><mrow><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="sans-serif">Int</mi><mo>&rarr;</mo><mi mathvariant="sans-serif">Int</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="sans-serif">Int</mi><mo>&rarr;</mo><mi mathvariant="sans-serif">Int</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>的对象, 函数<math><mi mathvariant="sans-serif">it</mi></math>是:<math display="block"><mrow><mi>&lambda;</mi><msup><mi>x</mi><mrow><mi mathvariant="sans-serif">Int</mi><mo>&rarr;</mo><mi mathvariant="sans-serif">Int</mi></mrow></msup><mo lspace="0">.</mo><mrow><mi mathvariant="sans-serif">it</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math></p><p>很容易看出来, 通过某个合理的函数<math><msub><mi>f</mi><mn>0</mn></msub></math>的有限迭代, 我们可以超越每个原始递归函数. 例如, 给定<math><mi>n</mi></math>返回<math><mrow><msup><mi mathvariant="sans-serif">it</mi><mi>n</mi></msup><mo>&af;</mo><msub><mi>f</mi><mn>0</mn></msub></mrow></math>的函数 (Ackermann函数) 就要比所有原始递归函数增长得更快.</p><p>译注: 上面这段话不是很理解, 因为我不知道什么是<math><msub><mi>f</mi><mn>0</mn></msub></math>.</p><p>这种函数在<math><mi mathvariant="bold">T</mi></math>中很容易定义, 只要我们使用一个复杂类型上的递归, 例如<math><mrow><mi mathvariant="sans-serif">Int</mi><mo>&rarr;</mo><mi mathvariant="sans-serif">Int</mi></mrow></math>: 取<math><mrow><mrow><mrow><mi mathvariant="sans-serif">R</mi><mo>&af;</mo><msub><mi>f</mi><mn>0</mn></msub></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&lambda;</mi><msup><mi>x</mi><mrow><mi mathvariant="sans-serif">Int</mi><mo>&rarr;</mo><mi mathvariant="sans-serif">Int</mi></mrow></msup><mo lspace="0">.</mo><mrow><mi>&lambda;</mi><msup><mi>z</mi><mi mathvariant="sans-serif">Int</mi></msup><mo lspace="0">.</mo><mrow><mi mathvariant="sans-serif">it</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mi>y</mi></mrow></math>, 其对于<math><mrow><mi>y</mi><mo>=</mo><mi mathvariant="sans-serif">O</mi></mrow></math>将被规范化为<math><msub><mi>f</mi><mn>0</mn></msub></math>, 对于<math><mover><mi>n</mi><mo>&OverBar;</mo></mover></math>将被规范化为<math><mrow><msup><mi mathvariant="sans-serif">it</mi><mi>n</mi></msup><mo>&af;</mo><msub><mi>f</mi><mn>0</mn></msub></mrow></math>.</p><p>为了给本小节作结, 我们应该指出<math><mrow><mrow><mrow><mi mathvariant="sans-serif">R</mi><mo>&af;</mo><mi>u</mi></mrow><mo>&af;</mo><mi>v</mi></mrow><mo>&af;</mo><mi>t</mi></mrow></math>中的<math><mi>v</mi></math>的第二个参数实际上经常是不用的. 可能有人更倾向于使用迭代子<math><mi mathvariant="sans-serif">It</mi></math>而不是<math><mi mathvariant="sans-serif">R</mi></math>, 其应用于具有类型<math><mi>T</mi></math>的<math><mi>u</mi></math>, 具有类型<math><mrow><mi>T</mi><mo>&rarr;</mo><mi>T</mi></mrow></math>的<math><mi>v</mi></math>, 以及具有类型<math><mi mathvariant="sans-serif">Int</mi></math>的<math><mi>t</mi></math>, 而规则是:<math display="block"><mrow><mrow><mrow><mrow><mi mathvariant="sans-serif">It</mi><mo>&af;</mo><mi>u</mi></mrow><mo>&af;</mo><mi>v</mi></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="sans-serif">S</mi><mo>&af;</mo><mi>t</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&zigrarr;</mo><mrow><mi>v</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mrow><mi mathvariant="sans-serif">It</mi><mo>&af;</mo><mi>u</mi></mrow><mo>&af;</mo><mi>v</mi></mrow><mo>&af;</mo><mi>t</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math></p><p>满足等式</p><h3>第7.4节 表达力: 结果</h3><h2>第8章 coherence空间</h2><p>指称语义学领域最早的工作是由[Scott69]对于无类型<math><mi>&lambda;</mi></math>演算完成的, 自那时起已经又有很多内容了. 他的方法由<em>连续性</em>刻画, 即保持有向join. [译注: 有很多人将join翻译成并, 但是我感觉这不是很好.] 本章介绍了一种新型的domain论 [译注: 有人将domain论翻译成论域论, 我觉得也容易造成误解], 其中我们也有上有界的meet (<em>拉回</em>), 并且meet也得到保持. 这种性质, 被称为<em>稳定性</em>, 最初是由[Berry]引入的, 其试图给出<em>顺序</em>算法的语义刻画. 我们将发现这种语义很适合系统<math><mi mathvariant="bold">F</mi></math>, 并且它会将我们引向线性逻辑.</p><h3>第8.1节 一般想法</h3><p>指称语义的基本想法在于解释规约 (一种动态概念) 以相等性 (一种静态概念). 换言之, 我们对于演算的不变量进行建模. 这是在说, 存在着模型和模型: 自G&ouml;del (1930) 起, 如何将模型构造为极大一致扩张就已经是众所周知的了. 这当然不是我要说的东西, 因为这种方法没有给出<em>信息</em>.</p><p>我们心中已经有毋须用纸笔写下的幼稚解释, 即类型<math><mrow><mi>U</mi><mo>&rarr;</mo><mi>V</mi></mrow></math>的一个对象是一个从<math><mi>U</mi></math>到<math><mi>V</mi></math>的函数, 现在让我们来看看能否赋予词汇<q>函数</q>以一个合理的含义. 以这种方式, 我们尽力去避免贪大求全, 而是去寻找简单的几何想法.</p><p>第一个想到的会是以下内容:<ul><li>类型 = 集合.</li><li><math><mrow><mi>U</mi><mo>&rarr;</mo><mi>V</mi></mrow></math>是所有从<math><mi>U</mi></math>到<math><mi>V</mi></math>的(集合论意义上的)函数的集合.</li></ul>这种解释当然很好, 但是什么也没解释. 计算上令人感兴趣的对象在集合论式函数的海洋中淹死了. 函数空间也会很快变得庞大无比.</p><p>Kreisel有着以下的想法 (hereditarily effective operation):<ul><li>类型 = <math><mi>&Nopf;</mi></math>上的部分等价关系.</li><li><math><mrow><mi>U</mi><mo>&rarr;</mo><mi>V</mi></mrow></math>是满足以下条件的部分递归函数<math><mi>f</mi></math>(的代码)的集合, 如果<math><mrow><mi>x</mi><mi>U</mi><mi>y</mi></mrow></math>, 那么<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mi>V</mi><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>. 这个集合服从于以下等价关系:<math display="block"><mrow><mi>f</mi><mrow><mo stretchy="false">(</mo><mrow><mi>U</mi><mo>&rarr;</mo><mi>V</mi></mrow><mo stretchy="false">)</mo></mrow><mi>g</mi></mrow><mtext>当且仅当</mtext><mrow><mo>&forall;</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>x</mi><mi>U</mi><mi>y</mi></mrow><mo>&rArr;</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mi>V</mi><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math></li></ul>这离我们所寻求模拟的计算范式更近了, 但是似乎又太近了, 因为实际上它没有做比它自己解释句法更多的事情了, 除开一些无聊的编码的话.</p><p>Scott的想法就好多了:<ul><li>类型 = 拓扑空间</li><li><math><mrow><mi>U</mi><mo>&rarr;</mo><mi>V</mi></mrow></math> = 从<math><mi>U</mi></math>到<math><mi>V</mi></math>的连续函数.</li></ul>现在众所周知的是拓扑并不意味着我们就能知道如何去构造函数空间. (Now it is well known that the topology does not lend itself well to the construction of function spaces.) 何时我们称函数序列收敛呢, 逐点还是说某种一致的收敛? (原注1)</p><p>原注1. 这个问题最常见的回答 (但是完全不意味着是放之四海而皆准的回答) 是使用<em>紧开</em>拓扑. 在这种拓扑里, 函数位于一个基本的开集中, 如果该函数限制于某个预先刻画的紧集时, 其值位于某个预先刻画的开集里. 这种拓扑只在空间是局部紧 (每个点都有紧邻域基) 时表现良好, 即便如此函数空间也不必自身是局部紧的.</p><p>为了解决这些问题, Scott</p><h2>第9章 T的指称语义</h2><h2>第10章 自然演绎中的和</h2><h2>第11章 系统F</h2><h2>第12章 和的coherence语义</h2><h2>第13章 切消 (Hauptsatz)</h2><h2>第14章 F的强规范化性质</h2><h2>第15章 表示定理</h2><h2>附录A: 系统F的语义</h2><h2>附录B: 什么是线性逻辑?</h2><h2>参考文献</h2><div class="bibliography" id="Barendregt">[1] H. Barendregt, The lambda-calculus: its syntax and semantics, North-Holland (1980).</div><div class="bibliography" id="HinSel">[2] J.R. Hindley and J.P. Seldin, To H.B. Curry: Essays on combinatory logic, Lambda Calculus and Formalism, Academic Press (1980).</div><div class="bibliography" id="Howard">[3] W.A. Howard, The formulae-as-types notion of construction, in <cite>[<a href="#HinSel">2</a>]</cite>.</div><div class="bibliography" id="vanHeijenoort">[4] J. van Heijenoort, From Frege to G&ouml;del, a source book in mathematical logic, 1879–1931, Harvard University Press (1967)</div></body></html>