<html><head><meta charset="utf-8"/><title>自动微分的简单本质</title><link href="styles.css" rel="stylesheet"/></head><body><h1>自动微分的简单本质</h1><h2>第1章 引论</h2><h2>第2章 什么是导数?</h2><p>既然自动微分 (AD) 和计算导数有关, 让我们以考虑什么是导数开始. 如果你所接受的入门性微积分课程和我差不多的话, 那么你会学到一个函数<math><mrow><mi>f</mi><mo>::</mo><mrow><mi>&Ropf;</mi><mo>&rarr;</mo><mi>&Ropf;</mi></mrow></mrow></math>在一个点<math><mi>x</mi></math>处 (要求其在<math><mi>f</mi></math>的定义域之中) 的导数<math><mrow><msup><mi>f</mi><mo>&prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math>是一个<em>数字</em>, 定义如下:<math display="block"><mtable columnalign="left center right" width="100%"><mtr><mtd><mphantom><mtext>(1)</mtext></mphantom></mtd><mtd displaystyle="true"><mrow><mrow><msup><mi>f</mi><mo>&prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>lim</mo><mrow><mi>&epsilon;</mi><mo lspace="0" rspace="0">&rarr;</mo><mn>0</mn></mrow></munder><mfrac><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>+</mo><mi>&epsilon;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&minus;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mi>&epsilon;</mi></mfrac></mrow></mrow></mtd><mtd><mtext>(1)</mtext></mtd></mtr></mtable></math>也就是说, <math><mrow><msup><mi>f</mi><mo>&prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math>告诉了我们<math><mi>f</mi></math>在<math><mi>x</mi></math>处对于输入变化的缩放有多快.</p><p>这个定义对于类型<math><mrow><mi>&Ropf;</mi><mo>&rarr;</mo><mi>&Ropf;</mi></mrow></math>之外的函数有多适用呢? 复数情形 (<math><mrow><mi>&Copf;</mi><mo>&rarr;</mo><mi>&Copf;</mi></mrow></math>) 表现良好, 其中除法也有定义. 扩展至<math><mrow><mi>&Ropf;</mi><mo>&rarr;</mo><msup><mi>&Ropf;</mi><mi>n</mi></msup></mrow></math>的情形也能成立, 如果我们以通常的方式解释一个(<math><msup><mi>&Ropf;</mi><mi>n</mi></msup></math>中的)向量除以一个标量. 然而, 如果我们扩展至<math><mrow><msup><mi>&Ropf;</mi><mi>m</mi></msup><mo>&rarr;</mo><msup><mi>&Ropf;</mi><mi>n</mi></msup></mrow></math>的情形, 或者甚至只是<math><mrow><msup><mi>&Ropf;</mi><mi>m</mi></msup><mo>&rarr;</mo><mi>&Ropf;</mi></mrow></math>, 这个定义就不再适用了, 因为其依赖于除以一个向量<math><mrow><mi>&epsilon;</mi><mo>::</mo><msup><mi>&Ropf;</mi><mi>m</mi></msup></mrow></math>.</p><p>这种非标量定义域上的微分的困难通常以相对于<math><msup><mi>&Ropf;</mi><mi>m</mi></msup></math>的<math><mi>m</mi></math>个标量分量的<q>偏导数</q>的概念解决, 经常记作<math><mrow><mrow><mi>&part;</mi><mo>&af;</mo><mi>f</mi></mrow><mo lspace="0" rspace="0">/</mo><mrow><mi>&part;</mi><mo>&af;</mo><msub><mi>x</mi><mi>j</mi></msub></mrow></mrow></math>, 其中<math><mrow><mi>j</mi><mo>&in;</mo><mrow><mo stretchy="false">{</mo><mrow><mn>1</mn><mo>,</mo><mo>&hellip;</mo><mo>,</mo><mi>m</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></math>. 当<math><msup><mi>&Ropf;</mi><mi>n</mi></msup></math>也是一个非标量时, 即<math><mrow><mi>n</mi><mo>></mo><mn>1</mn></mrow></math>, 那么我们就有了一个矩阵<math><mi mathvariant="bold">J</mi></math> (Jacobi矩阵), 其中<math><mrow><msub><mi mathvariant="bold">J</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>=</mo><mrow><mrow><mi>&part;</mi><mo>&af;</mo><msub><mi>f</mi><mi>i</mi></msub></mrow><mo lspace="0" rspace="0">/</mo><mrow><mi>&part;</mi><mo>&af;</mo><msub><mi>x</mi><mi>j</mi></msub></mrow></mrow></mrow></math>而每个<math><msub><mi>f</mi><mi>i</mi></msub></math>是函数<math><mi>f</mi></math>的第<math><mi>i</mi></math>投影, 其由取<math><mi>f</mi></math>的结果的第<math><mi>i</mi></math>个分量得到. {译注: 然而, 即便<math><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow></math>, 我们得到的也是一个矩阵, 只不过是<math><mrow><mn>1</mn><mo>&times;</mo><mi>m</mi></mrow></math>的矩阵而已.}</p><p>到目前为止, 我们已经看到了一个函数的导数可以是一个数字 (<math><mrow><mi>&Ropf;</mi><mo>&rarr;</mo><mi>&Ropf;</mi></mrow></math>), 一个向量 (<math><mrow><mi>&Ropf;</mi><mo>&rarr;</mo><msup><mi>&Ropf;</mi><mi>n</mi></msup></mrow></math>), 一个矩阵(<math><mrow><msup><mi>&Ropf;</mi><mi>m</mi></msup><mo>&rarr;</mo><msup><mi>&Ropf;</mi><mi>n</mi></msup></mrow></math>). 而且, 每种情形都有与之相伴的链式规则, 其说明了该如何对于函数的复合进行微分. 标量链式规则牵涉将两个标量导数相乘, 而向量链式规则牵涉将两个矩阵<math><mi mathvariant="bold">A</mi></math>和<math><mi mathvariant="bold">B</mi></math> (Jacobi矩阵) <q>相乘</q>, 其定义如下:<math display="block"><mrow><msub><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="bold">A</mi><mo>&sdot;</mo><mi mathvariant="bold">B</mi></mrow><mo stretchy="false">)</mo></mrow><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>=</mo><mrow><munderover><mo>&sum;</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mrow><msub><mi mathvariant="bold">A</mi><mrow><mi>i</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>&sdot;</mo><msub><mi mathvariant="bold">B</mi><mrow><mi>k</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow></mrow></mrow></math>既然我们可以将标量视为向量的特殊情形, 那么标量乘法也可以是为矩阵乘法的特殊情形, 或许我们已经抵达了所需的一般性. 然而, 当我们将注意力转向高阶导数的时候, 即导数的导数, 情况就变得复杂起来了, 我们需要更高维度的表示, 以及相应的更加复杂的链式规则.</p><p>幸运的是, </p><h2>第3章 微分的规则</h2><h3>第3.1节 顺序复合</h3><h3>第3.2节 并行复合</h3><h3>第3.3节 线性函数</h3><h2>第4章 将碎片拼在一起</h2><h3>第4.1节 范畴</h3><h3>第4.2节 幺半范畴</h3><h3>第4.3节 笛卡尔范畴</h3><h3>第4.4节 余笛卡尔范畴</h3></body></html>