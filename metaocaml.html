<html><head><meta charset="utf-8"/><title>协调抽象和高性能: MetaOCaml方法</title><link href="styles.css" rel="stylesheet"/></head><body><h1>协调抽象和高性能: MetaOCaml方法</h1><h2>摘要</h2><p>生成式编程的一个常见应用是生成高度特化于手头问题的高性能计算内核. 一个典型的线性代数内核会针对数值域 (有理数, 浮点数, 双精度浮点数, 等等), 循环展开因子, 数组布局和先验知识 (例如, 矩阵是正定的) 进行特化. 手动特化 (编写相同算法的诸多变种) 是乏味无聊且容易出错的.</p><p>广泛使用的生成器, 例如ATLAS和SPIRAL, 能够可靠地产生高度特化的代码, 但是很难扩展. 对于ATLAS而言, 其使用printf生成代码, 甚至连括号匹配都成为了挑战. 根据ATLAS的作者所言, debug如同梦魇.</p><h2>第1章 引入</h2><h3>第1.1节 为什么元编程?</h3><h3>第1.2节 为什么这个教程?</h3><h3>第1.3节 为什么MetaOCaml</h3><h3>第1.4节 概览</h3><h3>第1.5节 获得MetaOCaml</h3><h2>第2章 第一步</h2><h3>第2.1节 Now or later</h3><h3>第2.2节 幂</h3><p>尽管已经成为陈词滥调, <code>power</code>这个例子仍然是介绍元编程的最快方式之一. 以下的<code>power</code>函数可以计算<math><msup><mi>x</mi><mi>n</mi></msup></math>:<pre><code>let square x = x * x
let rec power : int -> int -> int = fun n x ->
  if n = 0 then 1
  else if n mod 2 = 0 then square(power (n/2) x)
  else x * (power (n-1) x)</code></pre>我们已经显式地附加了类型签名, 尽管并无必要: 类型可以推断出来. 不过, 给top-level的函数添加签名一般而言是个好的想法: 它可以使得代码更容易编写, 之后更容易理解, 并且能够使得错误信息更加清晰. </p><p>设我们的程序需要计算<math><msup><mi>x</mi><mn>7</mn></msup></math>很多次, 那么我们可以定义<pre><code>let power7 x = power 7 x</code></pre>来命名和分享这部分求值.</p><p>在MetaOCaml里, 我们也可以<em>特化</em>幂函数于一个特定的值<math><mi>n</mi></math>, 得到之后可以接受<math><mi>x</mi></math>并计算<math><msup><mi>x</mi><mi>n</mi></msup></math>的代码. </p><h2>第3章 滤波</h2><p>滤波在无线电以及各种音声应用之中普遍存在. 当我们想要收听电台90.5 MHz时, </p><p>和之前一样, 我们将会在与MetaOCaml的交互过程中编写代码, </p><p>数字滤波对于表示为采样或者说一致采样信号值的序列的数字化了的信号进行变换: <math><msub><mi>x</mi><mi>i</mi></msub></math>代表在第<math><mi>i</mi></math>次采样的时刻的信号幅度. 这个教程处理的是所谓有限冲激响应 (FIR) 滤波, 具有以下的一般形式:<math display="block"><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mrow><munderover><mo>&sum;</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mrow><msub><mi>b</mi><mi>k</mi></msub><mo>&it;</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>&minus;</mo><mi>k</mi></mrow></msub></mrow></mrow></mrow></math>输出信号的采样<math><msub><mi>y</mi><mi>i</mi></msub></math>是<math><mi>m</mi></math>个最近的输入信号采样<math><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>,</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>x</mi><mrow><mrow><mi>i</mi><mo>&minus;</mo><mi>m</mi></mrow><mo>+</mo><mn>1</mn></mrow></msub></mrow></math>的加权和. 权重<math><msub><mi>b</mi><mi>k</mi></msub></math>是滤波器的系数. 数字<math><mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow></math>被称为滤波器的阶. 既然系数的数目 (一般还有系数的值) 往往是已知的, 那么特化滤波器的计算是很合理的. 滤波器往往需要处理很长的信号, 或者需要在线处理信号.</p><p>这里我们遇到了我们之前已经说过太多了的一般性和性能之间的取舍, 而且我们还要再遇到无数次. 我们想要以全然的一般性一劳永逸地写完滤波器的代码, 并且希望其具有对于领域专家而言熟悉的形式. 那么, 我们想要借助于特定的情形 (例如系数已知) 来特化或者优化代码. 我们不会在本章立刻达到理想的境地. </p><p>上述的滤波器等式可以按照以下习用方式在OCaml之中进行编码:<pre><code>let filter : float array -> float array -> float array = fun b x ->
  let m = Array.length b in
  let y i =
    if i &lt; m-1 then x.(i) else
    let sum = ref 0.0 in
    for k = 0 to m-1 do
      sum := !sum +. b.(k) *. x.(i-k)
    done;
    !sum
  in
  Array.init (Array.length x) y        (* essentially, for-loop *)</code></pre>函数<code>filter</code>接受系数的数组<code>b</code>和输入采样的数组<code>x</code>, 返回经过滤波处理的(新鲜分配的)信号采样数组. 在OCaml之中, 取一个数组<code>x</code>的第<code>i</code>个元素记作<code>x.(i)</code>. 为了简单起见, 我们没有考虑原地滤波或者类似于流的滤波. 然而, 本章我们所学到的</p><h2>第4章 线性代数DSL: 复向量运算和数据布局</h2><p>现在我们转向生成优化代码的系统性方法. 我们的目的在于以清晰和显然正确的方式编写代码, 并且记号近于领域专家所使用的&mdash;&mdash;然后将这种记号解释为一个代码生成器, 然后逐步添加各种优化. 每个优化都体现了某种领域知识, 由领域专家独立开发. 和前一章作为对比的是, 我们特化和优化代码而不需要不断重写和注解.</p><p>使得优化模块化和可复合的是一个共同的领域特定语言 (DSL), 或者更准确地说, 是一种特定的DSL实现技巧: 所谓的tagless-final风格. 当在类似于OCaml这样的宿主语言之中嵌入一个DSL时, 一般会将DSL表达式表示为某个代数数据类型的值: 每个DSL语言形式, 诸如数值字面量或者加法, 都对应于这个数据类型的一个数据构造子. 这是所谓的<q>深嵌入</q>. tagless-final方法则是一种替代. 其被定义为从DSL表达式到宿主语言 (OCaml) 的映射, 因而可以视为表达式的意义, 或者说指称. 这个映射是复合性的: 每种DSL表达式形式都对应于一个宿主函数, 其根据其直接组件的意义来计算形式的意义. 因此, tagless-final方法将一个DSL表示为一个代数, 也称为一个<q>代数结构</q>. 我们可以选取各种OCaml的值集合作为DSL表达式的意义. 换言之, 我们可以以不同的方式解释相同的表达式, 这取决于手头上的任务. 一个代码生成器只是其中一种解释. tagless-final风格的DSL是可扩展的: 特性可以依照愿望增加, 而不需要破坏之前所写过的任何代码. 解释也是可扩展的, 可以根据需要添加(领域特定的)优化. 这种DSL是有类型的. 解释 (代码生成器) 也是 (和MetaOCaml本身一样) 有类型的. 因此, 生成的代码总是良形式, 卫生, 且良类型的. 类型不仅阻止了显然错误的生成器, 而且还能够帮助我们编写生成器. 因此, 在接下来的章节里, 我们将会开发以tagless-final风格嵌入(Meta)OCaml的DSL.</p><p>我们的主题是线性代数. 本章处理的向量-向量运算 (也就是所谓的BLAS Level 1) 和数据布局. <cite>第<a href="#BLAS2">5</a>章</cite>继续处理矩阵-向量运算 (BLAS Level 2), 代数化简, 以及领域特定的稀疏矩阵优化. 我们的DSL代码看起来会像是<pre><code>let vmult vout v1 v2 = vout := v1 *. v2
let mvmult vout a v = vout := a * v</code></pre><s>{译注: 内心小小的疑问, 这里的<code>a * v</code>真不是<code>a *. v</code>吗? 抑或是甚至<code>v1 *. v2</code>其实是<code>v1 * v2</code>? 总之感觉不是很协调.}</s> 这里的记号类似于Matlab, 还能生成特化于特定数据布局的命令式循环. 顺便一说, 这里也没有见到bracket和escape {译注: 用于元编程的}. 的确如此, 以精心择取的抽象, 面向用户的代码 (以及许多优化层) 并不会出现台面上的staging注解. 它们只会出现在非常低层次的生成器里.</p><h3>第4.1节 数据布局问题</h3><p>这个问题是对于一种特定的数据表示进行实际的特化. 某些计算机架构偏爱所谓的结构的数组, 而GPU和向量处理器则偏爱数组的结构. 将一个程序从GPU移植到超级计算机上或者反过来一般需要改变数据表示. 我们的目的在于自动化这样的改变, 仅仅实现算法一次, 然后机械化地使其适应于不同的数据布局.</p><p>具体来说, 当前的问题是实现两个复向量的逐点乘法, 以允许轻易特化于不同复向量表示的方式:<ul><li><code>float cmplx array</code><br/>一个数组, 其元素都是复数: 浮点数序对, 分别代表<math><mi mathvariant="fraktur">R</mi></math>部和<math><mi mathvariant="fraktur">I</mi></math>部. 这种所谓的结构的数组表示流行于基于缓存的机器之中.</li><li>单独的<code>float array</code> (<math><mi mathvariant="fraktur">R</mi></math>部) 和<code>float array</code> (<math><mi mathvariant="fraktur">I</mi></math>部)<br/>向量处理器和GPU更青睐于这种数组的结构表示.</li><li>一个单独的<code>float array</code><br/>前半部分<math><mi mathvariant="fraktur">R</mi></math>部, 后半部分<math><mi mathvariant="fraktur">I</mi></math>部, 前一种表示的变种.</li></ul></p><p><table align="center"><tr><td><code>v: float cmplx array</code></td><td><math><mrow><munder><mtable frame="solid" rowlines="solid" columnlines="solid"><mtr><mtd><mrow><msub><mi>v</mi><mn>0</mn></msub><mo lspace="0" rspace="0">.</mo><mi mathvariant="fraktur">R</mi></mrow></mtd><mtd><mrow><msub><mi>v</mi><mn>0</mn></msub><mo lspace="0" rspace="0">.</mo><mi mathvariant="fraktur">I</mi></mrow></mtd></mtr></mtable><munder><mo>&UnderBrace;</mo><msub><mi>v</mi><mn>0</mn></msub></munder></munder><mspace width="8px"/><munder><mtable frame="solid" rowlines="solid" columnlines="solid"><mtr><mtd><mrow><msub><mi>v</mi><mn>1</mn></msub><mo lspace="0" rspace="0">.</mo><mi mathvariant="fraktur">R</mi></mrow></mtd><mtd><mrow><msub><mi>v</mi><mn>1</mn></msub><mo lspace="0" rspace="0">.</mo><mi mathvariant="fraktur">I</mi></mrow></mtd></mtr></mtable><munder><mo>&UnderBrace;</mo><msub><mi>v</mi><mn>1</mn></msub></munder></munder><mspace width="8px"/><mo>&ctdot;</mo></mrow></math></td></tr><tr><td><code>v': float array cmplx</code></td><td><math><mrow><munder><mtable frame="solid" rowlines="solid" columnlines="solid"><mtr><mtd><mrow><msubsup><mi>v</mi><mn>0</mn><mo>&prime;</mo></msubsup><mo lspace="0" rspace="0">.</mo><mi mathvariant="fraktur">R</mi></mrow></mtd><mtd><mrow><msubsup><mi>v</mi><mn>1</mn><mo>&prime;</mo></msubsup><mo lspace="0" rspace="0">.</mo><mi mathvariant="fraktur">R</mi></mrow></mtd><mtd><mo>&ctdot;</mo></mtd></mtr></mtable><munder><mo>&UnderBrace;</mo><mrow><msup><mi>v</mi><mo>&prime;</mo></msup><mo lspace="0" rspace="0">.</mo><mi mathvariant="fraktur">R</mi></mrow></munder></munder><mspace width="8px"/><munder><mtable frame="solid" rowlines="solid" columnlines="solid"><mtr><mtd><mrow><msubsup><mi>v</mi><mn>0</mn><mo>&prime;</mo></msubsup><mo lspace="0" rspace="0">.</mo><mi mathvariant="fraktur">I</mi></mrow></mtd><mtd><mrow><msubsup><mi>v</mi><mn>1</mn><mo>&prime;</mo></msubsup><mo lspace="0" rspace="0">.</mo><mi mathvariant="fraktur">I</mi></mrow></mtd><mtd><mo>&ctdot;</mo></mtd></mtr></mtable><munder><mo>&UnderBrace;</mo><mrow><msup><mi>v</mi><mo>&prime;</mo></msup><mo lspace="0" rspace="0">.</mo><mi mathvariant="fraktur">I</mi></mrow></munder></munder></mrow></math></td></tr></table><b>图4.1: </b>数据布局: 结构的数组<code>v</code>和数组的结构<code>v'</code></p><p>不同布局在图4.1之中进行了系统地比较. 为了使得区别更加明显, </p><h3>第4.2节 抽象算术</h3><p>我们开始教授系统性的方法, 通过为能够相加和相乘的东西设计一个DSL. 这看起来像是经典开局, 特别是对于HPC实践者而言: 算术在HPC之中是如此基础, 以至于任何的运算开销都是不可忍受的. 犬儒主义者或许会将我们的DSL当作沉溺于抽象废话 (abstract nonsense) 的借口. 很快我们将会看到, 我们的抽象不仅是实际的, 而且最终还是无开销的.</p><p>又一次, </p><p>我们从最小的DSL开始, 只有目前所需的运算. 更多的东西总是可以之后再加: 可扩展性是tagless-final方法的优点. 暂时我们需要的是一集我们可以做加法, 减法, 乘法的对象, 带有两个突出元素<code>zero</code>和<code>one</code>. 这集操作可以组织为所谓的(模块)<em>签名</em>:<pre><code>module type RING = sig
  type t
  val zero : t
  val one  : t
  val add  : t -> t -> t
  val sub  : t -> t -> t
  val mul  : t -> t -> t
end</code></pre>声明<code>type t</code>给我们的对象的类型赋予了一个(非常没有想象力的)名字. 这个类型是抽象的: 我们对其一无所知, 除了它的名字<code>t</code>. 具体的实现可以实现<code>t</code>为浮点数或者复数之类的东西. 然而, DSL代码并不能知晓或者依赖于<code>t</code>的具体实现 (这是OCaml的类型系统所控制的), 因而可以应用于任何可能的实现. 我们也可以选取更加fancy的名字, 比如说<code>+%</code>甚至是<code>+</code>而非<code>add</code>.</p><p>暂时我们仅仅是定义了<code>t</code>上的运算的名字和它们的元数. 这些运算被隐式地假定满足我们所熟悉的性质: <code>add</code>是交换且结合的, 并且具有单位元<code>zero</code>; <code>mul</code>是结合的, 且具有单位元<code>one</code>和零元<code>zero</code> {译注: <code>zero</code>是所谓的零元的事实可由环的公理导出}; <code>mul</code>对于<code>add</code>分配. 换言之, 我们是要定义一个数学上的<em>环</em>. 尽管如此, 我们还没有在地方陈述过这些代数律. <cite>第<a href="#BLAS2">5</a>章</cite>里我们将会接触它们.</p><p>我们可以将签名<code>RING</code>视为定义了一个迷你DSL, 其具有两个常量和三个运算. (实际上, 这就是tagless-final的观点.) 这个DSL可以立刻使用:<pre><code>module ExArith(R:RING) = struct
  open R
  let xsq1 x = add (mul x x) one
end
(* module ExArith : functor (R : RING) -> sig val xsq1 : R.t -> R.t end *)</code></pre></p><p>为了尝试刚才定义的DSL函数, 我们需要<code>RING</code>的一个实现. </p><h3>第4.3节 对于向量进行抽象</h3><p>特化于各种各样的向量内存布局呼吁着找到一个合适的对于向量的抽象表示. 一个常规的浮点数数组或许可以想成是一个函数<code>int -> float</code>, 当然取值是一些特定的整数. 如果推广这个想法, 我们可以定义(输入)向量为一个函数, 其取一个索引, 返回这个索引位置的值; 向量也应该携带关于向量定义域范围的最小和最大索引的信息.<pre><code>type ('i,'a) vec = Vec of 'i * ('i -> 'a)</code></pre>索引<math><mi>&iota;</mi></math>被假定是一个可枚举的类型. 为了简单起见, 我们默认索引范围的下界是零值, 而其只需携带上界的信息: 索引范围的长度. 这种<code>vec</code>有时也被称为<q>pull vector</q>. 数组是可变的数据结构. 为了表示数组赋值, 我们引入输出向量:<pre><code>type ('i,'a,'w) ovec = OVec of 'i * ('i -> 'a -> 'w)</code></pre>其是向量长度和变动函数 (mutation function) 的序对. 后者取一个索引和一个存储于该索引位置的值, 然后返回更新过了的向量的某种表示. 对于破坏性的复制, 结果<math><mi>&omega;</mi></math>可以是<code>unit</code>.</p><p>为了获得对于抽象向量更为真切的感受, </p><h3>第4.4节 向量算术DSL</h3><h4>第4.4.1小节 湘南挑战1</h4><h4>第4.4.2小节 BLAS 2 DSL</h4><h2 id="BLAS2">第5章 线性代数DSL: 矩阵-向量运算和模块化优化</h2><h2>第6章 从解释器到编译器: 图像操作DSL</h2></body></html>