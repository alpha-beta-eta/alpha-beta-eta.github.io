<html><head><meta charset="utf-8"/><title>REFAL-5编程指南和参考手册</title><link href="styles.css" rel="stylesheet"/></head><body><h1>REFAL-5编程指南和参考手册</h1><h2>第1章 基本的REFAL</h2><h3>第1.1节 一个简单的函数定义</h3><p>考虑这个非常简单的问题. 你想要定义一个函数来判定一个给定字符串是否是一个回文. 一个回文是一个自左向右读和自右向左读相同的字符串. 存在两种显然的方式可以使得这个定义更加精确. 第一种方式是定义一个反转字符串的过程, 然后将反转的字符串和初始的字符串进行比较. 显然, 以这种定义为基础的算法不会是最高效的. 如果一个字符串以一个不同于开头字符的字符作结, 那么它肯定不是回文, 而这种定义无需反转即可建立. 因此, 我们将采取这另外的定义, 其可以写成通常的数学形式:<ol><li>一个空字符串是一个回文.</li><li>单个符号构成的字符串是一个回文.</li><li>如果一个字符串以相同的符号开头和作结, 那么其是回文当且仅当去除首尾符号之后剩下来的字符串是一个回文.</li><li>如果以上规则均无法应用, 那么该字符串不是回文.</li></ol></p><p>让我们称想要定义的函数为<code>Pal</code>, 并且当参数是回文时取<code>True</code>值, 否则的话则取<code>False</code>. Refal中的定义紧贴数学定义:<pre><code>Pal { = True;
      s.1 = True;
      s.1 e.2 s.1 = &lt;Pal e.2>;
      e.1 = False;  }</code></pre></p><p>这个程序以函数名开始, 后面跟着由括号括起的<em>块</em>. 一个块是一列由分号隔开的句子. 在我们的这种情况下块有着四个句子, 分别对应于以上由文字描述的数学定义的每个分句. 每个句子都是一个替换规则. 其左边代表函数的参数的模式; 而由相等符号<code>=</code>隔开的右边, 则是对于函数调用的替换.</p><p>第一个句子里, 函数<code>Pal</code>的参数为空(字符串), 因而值必然为<code>True</code>.</p><p>第二个句子里, 参数以一个符号的自由变量<code>s.1</code>的形式给出. 其匹配任意的符号, 例如一个字符, 但只是一个符号. 因此, 这个句子应该读作: 如果参数是一个单独的符号, 那么将调用替换为<code>True</code>.</p><p>第三个句子代表的情形是参数以某个符号<code>s.1</code>开头和作结, 并且表达式<code>e.2</code>夹在中间. 表达式是Refal中最一般的数据结构; 具体地说, 它可以是一个符号的串. 这个句子的右边是以<code>e.2</code>为参数的对于函数<code>Pal</code>的调用. 我们使用圆括号来创建数据结构, 但是尖括号用来表示函数调用. <code>&lt;Pal e.2></code>在数学上的类似记号为<math><mrow><mi>pal</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow></math>.</p><p>最后一个句子的参数是一个任意的表达式 (字符串). Refal中的函数定义里的每个句子只会在前述句子均不可应用时才会使用, 因此最后一个句子应该读作: 如果以上均不可行, 那么不论什么参数, 这个函数调用的值应该是<code>False</code>.</p><p>Refal程序的算法意义的精确定义是通过定义执行Refal程序 (即对于定义在Refal里的函数求值) 的抽象Refal机器完成的 (见<cite>第<a href="#abstract-refal-machine">1.5</a>节</cite>). Refal机器按步骤运行, 每一步都是应用一个句子. 例如, 如果利用Refal机器以参数<code>'revolver'</code>调用<code>Pal</code>, 即对于<code>&lt;Pal 'revolver'></code>求值, 那么Refal的工作空间 (我们称之为view field) 将会经历以下阶段:<pre><code>&lt;Pal 'revolver'>
 &lt;Pal 'evolve'>
  &lt;Pal 'volv'>
   &lt;Pal 'ol'>
     False</code></pre>这给出了计算过程的详细图景. 程序员可以使用跟踪器来控制这个过程. 最简单的使用方法是, 正如我们以上所做的, 程序员可以检视并输出过程的所有相继阶段.</p><h3>第1.2节 符号和表达式</h3><p>现在我们开始系统地定义Refal. 对于语言句法的总结也作为参考手册的B部分附于末尾.</p><p>Refal中的<em>符号</em>是数据结构的最小句法元素. 我们使用以下种类的符号:<ul><li>字符;</li><li><em>复合符号</em>, 一个具体的例子是<em>标识符</em> (也被称为符号名字);</li><li>非负整数 (macrodigits).</li></ul></p><p>字符以单引号围住, 例如<code>'a'</code>和<code>'+'</code>. 一串字符被引号围成一个整体. 因此, <code>'a+b'</code>是由三个符号构成的一个序列: <code>'a'</code>, <code>'+'</code>和<code>'b'</code>. 一个串可能仅包含零个字符, 即<code>''</code>. 这是一个空表达式, 代表什么都没有, 但它当然不是一个符号.</p><h3>第1.3节 模式匹配</h3><h3>第1.4节 句子和程序</h3><h3 id="abstract-refal-machine">第1.5节 抽象Refal机器</h3><h3>第1.6节 更多函数的例子</h3><h2>第2章 计算机中的REFAL</h2><h3>第2.1节 如何运行程序</h3><h3>第2.2节 程序模块</h3><h3>第2.3节 输入输出</h3><h3>第2.4节 Refal表达式的表示</h3><h3>第2.5节 模式匹配的算法</h3><h2>第3章 基本的编程技巧</h2><h3>第3.1节 括号作为指针</h3><h3>第3.2节 函数的格式</h3><h3>第3.3节 隐式和显式递归</h3><h3>第3.4节 变量的重复</h3><h3>第3.5节 将算法分解为函数</h3><h3>第3.6节 递归和迭代</h3><h3>第3.7节 处理嵌套括号</h3><h2>第4章 扩展的REFAL</h2><h3>第4.1节 条件</h3><h3>第4.2节 块</h3><h3>第4.3节 埋藏-挖掘函数</h3><h2>第5章 程序建立</h2><h3>第5.1节 传教士和食人者</h3><h3>第5.2节 排序算法</h3><h3>第5.3节 图中的路径</h3><h3>第5.4节 算术表达式的转换</h3><h2>第6章 元系统转换</h2><h3>第6.1节 元函数<code>Mu</code></h3><h3>第6.2节 元代码</h3><h3>第6.3节 求值器</h3><h3>第6.4节 冻结器</h3><h2>练习解答</h2><h2>参考手册</h2><h3>A. 安装和使用</h3><h3>B. 句法总结</h3><h3>C. 内置函数</h3><h3>D. Refal跟踪器</h3></body></html>