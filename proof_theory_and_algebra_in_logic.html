<html><head><meta charset="utf-8"/><title>证明论和逻辑代数</title><link href="styles.css" rel="stylesheet"/></head><body><h1>证明论和逻辑代数</h1><h2>第1章 相继式系统</h2><p>在第1.1节给出预备评注和对于本书范围的简要解释之后, 我们将分别为古典逻辑和直觉主义逻辑引入两个相继式系统<b>LK</b>和<b>LJ</b>. 这两个相继式系统对于第I部分的证明论研究都是基础性的, 其最初由G. Gentzen在他的论文 (Gentzen 1935) 里引入. 基本的证明和可证明性的概念首先被引入. 然后对于<b>LK</b>的完备性和切消的初等证明被给出, 通过使用古典逻辑的一个可逆相继式系统<b>LK*</b>, 其是<b>LK</b>的一种替代. 这将会是展现证明论式论证如何进行的一个简明例子.</p><h3>第1.1节 开篇</h3><h4>基本概念和记号</h4><p>我们将会使用<math><mo>&and;</mo></math>, <math><mo>&or;</mo></math>, <math><mo>&rarr;</mo></math>, <math><mo>&not;</mo></math>分别表达基本的逻辑联结词<em>合取</em>, <em>析取</em>, <em>implication</em>, <em>否定</em>. {译注: 为了避免各种可能的混淆, implication就不翻译了.} 若有必要, 例如当我们讨论模态逻辑和亚结构逻辑的时候, 我们将会引入额外的逻辑联结词和逻辑常量. 我们从外部取一个<em>固定的命题变量的可数集</em>. 公式和通常情况一样通过归纳定义, 从命题变量和逻辑常量开始, 然后反复应用逻辑联结词. 括号会按照通常方式进行省略, 只要不至于引起误解. 为了简化表达式, 我们采取约定, <math><mo>&not;</mo></math>比其他逻辑联结词都结合得更紧密. 因此, 例如, 公式<math><mrow><mi>p</mi><mo>&or;</mo><mrow><mo>&not;</mo><mi>q</mi></mrow></mrow></math>表示<math><mrow><mi>p</mi><mo>&or;</mo><mrow><mo stretchy="false">(</mo><mrow><mo>&not;</mo><mi>q</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>. 我们将会使用小写希腊字母表达公式. 当一个公式<math><mi>&beta;</mi></math>出现在一个公式<math><mi>&alpha;</mi></math>的归纳定义之中, 公式<math><mi>&beta;</mi></math>被称为<math><mi>&alpha;</mi></math>的一个<em>子公式</em>. 除开<math><mi>&alpha;</mi></math>之外的<math><mi>&alpha;</mi></math>的每个子公式被称为<math><mi>&alpha;</mi></math>的一个<em>真子公式</em>. 例如, <math><mrow><mi>p</mi><mo>,</mo><mi>q</mi><mo>,</mo><mrow><mo>&not;</mo><mi>q</mi></mrow><mo>,</mo><mrow><mi>p</mi><mo>&or;</mo><mrow><mo>&not;</mo><mi>q</mi></mrow></mrow></mrow></math>都是<math><mrow><mi>p</mi><mo>&or;</mo><mrow><mo>&not;</mo><mi>q</mi></mrow></mrow></math>的子公式, 而前三个则是<math><mrow><mi>p</mi><mo>&or;</mo><mrow><mo>&not;</mo><mi>q</mi></mrow></mrow></math>的真子公式.</p><p>有时我们按照以下方式对于公式的构造施行归纳论证. 也就是说, 为了确保每个公式都具有某个给定的性质<math><mi>P</mi></math>, 我们要表明 (1) 每个命题变量 (以及每个常量) 都具有<math><mi>P</mi></math> (2) 对于每个<math><mi>&beta;</mi></math>, 若<math><mi>&beta;</mi></math>的每个真子公式<math><mi>&gamma;</mi></math>都具有<math><mi>P</mi></math>, 那么<math><mi>&beta;</mi></math>也具有<math><mi>P</mi></math>. 这种形式的归纳也可以表达为对于公式的<em>长度</em>进行归纳. 这里某个给定公式<math><mi>&alpha;</mi></math>的长度的含义是<math><mi>&alpha;</mi></math>中的逻辑符号的总数目. 可能公式<math><mi>&beta;</mi></math>在某个给定的<math><mi>&alpha;</mi></math>中作为子公式出现不止一次, 但是在不同的地方出现. 例如, 公式<math><mi>p</mi></math>在公式<math><mrow><mi>p</mi><mo>&or;</mo><mrow><mo>&not;</mo><mi>p</mi></mrow></mrow></math>里出现了两次. 如果我们需要进行区分, 那么我们会使用术语<em>公式出现</em>. 然后, 我们可以说<math><mrow><mi>p</mi><mo>&or;</mo><mrow><mo>&not;</mo><mi>p</mi></mrow></mrow></math>拥有<math><mi>p</mi></math>的两次公式出现. 一般而言, 当我们不只是关心表达式本身也关心其出现的位置时, 我们就会使用词汇<em>出现</em>. 在本书中, 我们有时使用<em>iff</em>作为<em>if and only if</em>的缩写. {译注: 当然了, 我们都会将其翻译为<em>当且仅当</em>, 这是Paul Halmos所创制的表达.}</p><h4>逻辑的句法方法和语义方法之比较</h4><p>在以下内容里, 我们将简要介绍主题的背景, 特别是本教科书的第I部分和第II部分的区别和联系. 熟悉这部分内容的读者可以跳过.</p><p>引入一个逻辑的标准方式时将其描述为一个形式系统. 一个形式系统通常由<em>公理</em>和<em>推理规则</em>构成, 其确定了系统中的公式的<em>可证明性</em>. 一个给定公式<math><mi>&alpha;</mi></math>在系统中是<em>可证的</em>, 如果<math><mi>&alpha;</mi></math>可以在系统中被推导出来, 即通过从系统的公理开始, 反复应用系统的规则得到. 一个对于<math><mi>&alpha;</mi></math>的<em>证明</em> (或者<em>推导</em>) 是一个有限的figure, 其表明了<math><mi>&alpha;</mi></math>在系统中是如何推导出来的. 证明和可证明性的概念由此是<em>句法性</em>的概念, 其由符号和机械过程构成.</p><p>作为形式系统的一个例子, 以下我们将给出古典逻辑的一个标准Hilbert风格系统<b>HK</b>. 其由作为单一规则的<em>modus ponens</em>和以下给出的<em>公理模式</em>构成. 这里的modus ponens是说一个公式<math><mi>&beta;</mi></math>可以由<math><mi>&alpha;</mi></math>和<math><mrow><mi>&alpha;</mi><mo>&rarr;</mo><mi>&beta;</mi></mrow></math>共同推导出来. 另外, 每个公理模式不是单一的公式, 而是具有模式所表示的相同句法形式的所有公式. 因此, 一个公理模式的每个实例都可以视为一个公理. (出于简单性的考量, <math><mrow><mo>&not;</mo><mi>&alpha;</mi></mrow></math>在本节的剩余部分里将被视为<math><mrow><mi>&alpha;</mi><mo>&rarr;</mo><mn>0</mn></mrow></math>的缩略, 其中<math><mn>0</mn></math>是一个逻辑常量, 其表达了一个矛盾.) {原注: 为了避免符号太过复杂, 我们使用相同的符号表达公式和公式模式.}</p><p>现在<b>HK</b>的公理模式列出如下, 其看上去和标准的有些许不同. 不过, 我们的选择是为了容易看出其与下一节要引入的古典逻辑的相继式系统<b>LK</b>之间的联系.<ol><li><math><mrow><mi>&alpha;</mi><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&beta;</mi><mo>&rarr;</mo><mi>&alpha;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math> (左弱化公理)</li><li><math><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>&alpha;</mi><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&alpha;</mi><mo>&rarr;</mo><mi>&gamma;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&alpha;</mi><mo>&rarr;</mo><mi>&gamma;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math> (收缩公理)</li><li><math><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>&alpha;</mi><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&beta;</mi><mo>&rarr;</mo><mi>&gamma;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&beta;</mi><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&alpha;</mi><mo>&rarr;</mo><mi>&gamma;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math> (交换公理)</li><li><math><mrow><mn>0</mn><mo>&rarr;</mo><mi>&alpha;</mi></mrow></math></li><li><math><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>&alpha;</mi><mo>&rarr;</mo><mi>&beta;</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>&gamma;</mi><mo>&rarr;</mo><mi>&alpha;</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&gamma;</mi><mo>&rarr;</mo><mi>&beta;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math></li><li><math><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>&alpha;</mi><mo>&rarr;</mo><mi>&gamma;</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>&beta;</mi><mo>&rarr;</mo><mi>&gamma;</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>&alpha;</mi><mo>&or;</mo><mi>&beta;</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mi>&gamma;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math></li><li><math><mrow><mi>&alpha;</mi><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&alpha;</mi><mo>&or;</mo><mi>&beta;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math></li><li><math><mrow><mi>&beta;</mi><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&alpha;</mi><mo>&or;</mo><mi>&beta;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math></li><li><math><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>&gamma;</mi><mo>&rarr;</mo><mi>&alpha;</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>&gamma;</mi><mo>&rarr;</mo><mi>&beta;</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&gamma;</mi><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&alpha;</mi><mo>&and;</mo><mi>&beta;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math></li><li><math><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>&alpha;</mi><mo>&and;</mo><mi>&beta;</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mi>&alpha;</mi></mrow></math></li><li><math><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>&alpha;</mi><mo>&and;</mo><mi>&beta;</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mi>&beta;</mi></mrow></math></li><li><math><mrow><mrow><mo>&not;</mo><mrow><mo>&not;</mo><mi>&alpha;</mi></mrow></mrow><mo>&rarr;</mo><mi>&alpha;</mi></mrow></math> (双重否定律)</li></ol></p><p>呈现Hilbert风格系统的另一种方式是取modus ponens和<em>替换规则</em>作为规则, 然后取<em>公理</em>而非公理模式. 通过这里的替换规则我们可以根据<math><mi>&alpha;</mi></math>对于任意的一致替换<math><mi>&sigma;</mi></math>推出<math><mrow><mi>&sigma;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow></mrow></math>. {原注: 这里的<math><mi>&sigma;</mi></math>是一个从命题变量的有限集合<math><mrow><mo stretchy="false">{</mo><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>p</mi><mi>m</mi></msub></mrow><mo stretchy="false">}</mo></mrow></math>到某个公式集合的映射, 而<math><mrow><mi>&sigma;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow></mrow></math>代表由<math><mi>&alpha;</mi></math>通过将<math><mi>&alpha;</mi></math>中的每个<math><msub><mi>p</mi><mi>i</mi></msub></math>同时替换为<math><mrow><mi>&sigma;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mrow></math>得到的公式, 其中<math><mrow><mi>i</mi><mo>=</mo><mrow><mn>1</mn><mo>,</mo><mo>&hellip;</mo><mo>,</mo><mi>m</mi></mrow></mrow></math>. 这样一个公式<math><mrow><mi>&sigma;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow></mrow></math>被称为<math><mi>&alpha;</mi></math>的一个<em>替换实例</em> (或者更简单地说, 实例).} 在这种情况下, 例如弱化公理就是通过一个单独的公理<math><mrow><mi>p</mi><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>q</mi><mo>&rarr;</mo><mi>p</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>给出的, 其中<math><mi>p</mi></math>和<math><mi>q</mi></math>是不同的命题变量. 其他的弱化公理则是通过这条公理应用替换规则得到的.</p><h3>第1.2节 古典逻辑的相继式系统LK</h3><p>我们将要引入古典逻辑的一个相继式系统<b>LK</b>. 与Hilbert风格系统不同的是, 相继式系统中的基本表达式是<em>相继式</em>. <b>LK</b>中的每个相继式都是具有以下形式的表达式, 其中每个<math><msub><mi>&alpha;</mi><mi>i</mi></msub></math> (<math><mrow><mi>i</mi><mo>&le;</mo><mi>m</mi></mrow></math>) 和每个<math><msub><mi>&beta;</mi><mi>j</mi></msub></math> (<math><mrow><mi>j</mi><mo>&le;</mo><mi>n</mi></mrow></math>) 都是公式, 而<math><mrow><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow><mo>&ge;</mo><mn>0</mn></mrow></math>. 这里的逗号<q><math><mo>,</mo></math></q>和箭头<q><math><mo>&Implies;</mo></math></q>都是元逻辑符号.<math display="block"><mrow><mrow><msub><mi>&alpha;</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>&alpha;</mi><mi>m</mi></msub></mrow><mo>&Implies;</mo><mrow><msub><mi>&beta;</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>&beta;</mi><mi>n</mi></msub></mrow></mrow></math>因此, 每个相继式都是由逗号分隔的公式的有限序列, 而相继式又由<math><mo>&Implies;</mo></math>划分为<em>前件(antecedents)</em><math><mrow><msub><mi>&alpha;</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>&alpha;</mi><mi>m</mi></msub></mrow></math>和<em>后件(succedents)</em><math><mrow><msub><mi>&beta;</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>&beta;</mi><mi>n</mi></msub></mrow></math>.</p><p>大致来说, 前件和后件可以分别理解为<em>假设</em>和<em>结论</em>. 但是, 这里我们必须要小心, 因为前件是<em>合取式(conjunctive-like)</em>理解而后件是<em>析取式(disjunctive-like)</em>理解. 也就是说, 上述的相继式从直觉上来理解即<math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>&beta;</mi><mn>1</mn></msub><mo>&or;</mo><mo>&hellip;</mo><mo>&or;</mo><msub><mi>&beta;</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></math>可由假设<math><mrow><msub><mi>&alpha;</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>&alpha;</mi><mi>m</mi></msub></mrow></math>推出, 或者等价地说, 可由假设<math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>&alpha;</mi><mn>1</mn></msub><mo>&and;</mo><mo>&hellip;</mo><mo>&and;</mo><msub><mi>&alpha;</mi><mi>m</mi></msub></mrow><mo stretchy="false">)</mo></mrow></math>推出. 当后件为空时, 相继式<math><mrow><mrow><msub><mi>&alpha;</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>&alpha;</mi><mi>m</mi></msub></mrow><mo>&Implies;</mo><mrow/></mrow></math>的含义是<q>根据假设<math><mrow><msub><mi>&alpha;</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>&alpha;</mi><mi>m</mi></msub></mrow></math>可以推出一个矛盾</q>. 从另一方面来说, 如果前件为空, 相继式<math><mrow><mrow/><mo>&Implies;</mo><mrow><msub><mi>&beta;</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>&beta;</mi><mi>n</mi></msub></mrow></mrow></math>应该理解为(在没有任何假设的情况下)可以推出<math><mrow><msub><mi>&beta;</mi><mn>1</mn></msub><mo>&or;</mo><mo>&hellip;</mo><mo>&or;</mo><msub><mi>&beta;</mi><mi>n</mi></msub></mrow></math>.</p><p>在相继式系统里, 我们讨论<em>相继式</em>的可证明性和有效性, 而非公式的, 它们分别代表了句法和语义的视角. 每个相继式系统都由<em>初始相继式</em>和<em>规则</em>构成. 前者对应于Hilbert风格系统中的公理模式. 一个给定的相继式系统的每条规则确定了一个相继式何时以及如何由其他已经推得的相继式推出 (通常来说, 是从有限数目的相继式推出). 在我们的系统<b>LK</b>中, 如下所示, 每条规则由一或两个<em>上相继式(upper sequent)</em>和一个<em>下相继式(lower sequent)</em>构成, 意即下相继式可由这些上相继式推出. 以下的大写希腊字母代表(可能为空的)公式的有限序列. <b>LK</b>具有以下三个种类的规则{原注: 切规则经常被视为一种结构规则, 但是本书将其从结构规则中分离出来, 因为接下来介绍亚结构逻辑的时候会更加方便.}:<ol><li>逻辑联结词<math><mrow><mo>&or;</mo><mo>,</mo><mo>&and;</mo><mo>,</mo><mo>&rarr;</mo><mo>,</mo><mo>&not;</mo></mrow></math>的(左和右)规则,</li><li>切规则,</li><li>(左和右)结构规则.</li></ol></p><p><b>LK</b>具有以下初始相继式和规则.</p><p>0. 初始相继式: <b>LK</b>的每个初始相继式都是一个具有形式<math><mrow><mi>&alpha;</mi><mo>&Implies;</mo><mi>&alpha;</mi></mrow></math>的相继式.</p><p>1. 逻辑联结词的规则:<math display="block"><mrow><mfrac displaystyle="true"><mrow><mrow><mrow><mi>&alpha;</mi><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mi>&Pi;</mi></mrow><mspace width="8ex"/><mrow><mrow><mi>&beta;</mi><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mi>&Pi;</mi></mrow></mrow><mrow><mrow><mrow><mi>&alpha;</mi><mo>&or;</mo><mi>&beta;</mi></mrow><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mi>&Pi;</mi></mrow></mfrac><mrow><mo stretchy="false">(</mo><mrow><mo>&or;</mo><mi>&rArr;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math><math display="block"><mrow><mrow><mfrac displaystyle="true"><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mrow><mi>&Lambda;</mi><mo>,</mo><mi>&alpha;</mi></mrow></mrow><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mrow><mi>&Lambda;</mi><mo>,</mo><mrow><mi>&alpha;</mi><mo>&or;</mo><mi>&beta;</mi></mrow></mrow></mrow></mfrac><mrow><mo stretchy="false">(</mo><mrow><mi>&rArr;</mi><mo>&or;</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></mrow><mspace width="16ex"/><mrow><mfrac displaystyle="true"><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mrow><mi>&Lambda;</mi><mo>,</mo><mi>&beta;</mi></mrow></mrow><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mrow><mi>&Lambda;</mi><mo>,</mo><mrow><mi>&alpha;</mi><mo>&or;</mo><mi>&beta;</mi></mrow></mrow></mrow></mfrac><mrow><mo stretchy="false">(</mo><mrow><mi>&rArr;</mi><mo>&or;</mo><mn>2</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math><math display="block"><mrow><mrow><mfrac displaystyle="true"><mrow><mrow><mi>&alpha;</mi><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mi>&Pi;</mi></mrow><mrow><mrow><mrow><mi>&alpha;</mi><mo>&and;</mo><mi>&beta;</mi></mrow><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mi>&Pi;</mi></mrow></mfrac><mrow><mo stretchy="false">(</mo><mrow><mo>&and;</mo><mn>1</mn><mi>&rArr;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mspace width="16ex"/><mrow><mfrac displaystyle="true"><mrow><mrow><mi>&beta;</mi><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mi>&Pi;</mi></mrow><mrow><mrow><mrow><mi>&alpha;</mi><mo>&and;</mo><mi>&beta;</mi></mrow><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mi>&Pi;</mi></mrow></mfrac><mrow><mo stretchy="false">(</mo><mrow><mo>&and;</mo><mn>2</mn><mi>&rArr;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math><math display="block"><mrow><mfrac displaystyle="true"><mrow><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mrow><mi>&Lambda;</mi><mo>,</mo><mi>&alpha;</mi></mrow></mrow><mspace width="8ex"/><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mrow><mi>&Lambda;</mi><mo>,</mo><mi>&beta;</mi></mrow></mrow></mrow><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mrow><mi>&Lambda;</mi><mo>,</mo><mrow><mi>&alpha;</mi><mo>&and;</mo><mi>&beta;</mi></mrow></mrow></mrow></mfrac><mrow><mo stretchy="false">(</mo><mrow><mi>&rArr;</mi><mo>&and;</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></math><math display="block"><mrow><mrow><mfrac displaystyle="true"><mrow><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mrow><mi>&Lambda;</mi><mo>,</mo><mi>&alpha;</mi></mrow></mrow><mspace width="8ex"/><mrow><mrow><mi>&beta;</mi><mo>,</mo><mi>&Delta;</mi></mrow><mo>&Implies;</mo><mi>&Pi;</mi></mrow></mrow><mrow><mrow><mrow><mi>&alpha;</mi><mo>&rarr;</mo><mi>&beta;</mi></mrow><mo>,</mo><mi>&Gamma;</mi><mo>,</mo><mi>&Delta;</mi></mrow><mo>&Implies;</mo><mrow><mi>&Lambda;</mi><mo>,</mo><mi>&Pi;</mi></mrow></mrow></mfrac><mrow><mo stretchy="false">(</mo><mrow><mo>&rarr;</mo><mi>&rArr;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mspace width="16ex"/><mrow><mfrac displaystyle="true"><mrow><mrow><mi>&alpha;</mi><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mrow><mi>&Lambda;</mi><mo>,</mo><mi>&beta;</mi></mrow></mrow><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mrow><mi>&Lambda;</mi><mo>,</mo><mrow><mi>&alpha;</mi><mo>&rarr;</mo><mi>&beta;</mi></mrow></mrow></mrow></mfrac><mrow><mo stretchy="false">(</mo><mrow><mi>&rArr;</mi><mo>&rarr;</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math><math display="block"><mrow><mrow><mfrac displaystyle="true"><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mrow><mi>&Lambda;</mi><mo>,</mo><mi>&alpha;</mi></mrow></mrow><mrow><mrow><mrow><mo>&not;</mo><mi>&alpha;</mi></mrow><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mi>&Lambda;</mi></mrow></mfrac><mrow><mo stretchy="false">(</mo><mrow><mo>&not;</mo><mi>&rArr;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mspace width="16ex"/><mrow><mfrac displaystyle="true"><mrow><mrow><mi>&alpha;</mi><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mi>&Lambda;</mi></mrow><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mrow><mi>&Lambda;</mi><mo>,</mo><mrow><mo>&not;</mo><mi>&alpha;</mi></mrow></mrow></mrow></mfrac><mrow><mo stretchy="false">(</mo><mrow><mi>&rArr;</mi><mo>&not;</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math></p><p>2. 切规则<math display="block"><mrow><mfrac displaystyle="true"><mrow><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mrow><mi>&Lambda;</mi><mo>,</mo><mi>&alpha;</mi></mrow></mrow><mspace width="8ex"/><mrow><mrow><mi>&alpha;</mi><mo>,</mo><mi>&Delta;</mi></mrow><mo>&Implies;</mo><mi>&Pi;</mi></mrow></mrow><mrow><mrow><mi>&Gamma;</mi><mo>,</mo><mi>&Delta;</mi></mrow><mo>&Implies;</mo><mrow><mi>&Lambda;</mi><mo>,</mo><mi>&Pi;</mi></mrow></mrow></mfrac><mrow><mo stretchy="false">(</mo><mi>cut</mi><mo stretchy="false">)</mo></mrow></mrow></math></p><p>3. 结构规则<ul><li>交换规则:<math display="block"><mrow><mrow><mfrac displaystyle="true"><mrow><mrow><mi>&Gamma;</mi><mo>,</mo><mi>&alpha;</mi><mo>,</mo><mi>&beta;</mi><mo>,</mo><mi>&Delta;</mi></mrow><mo>&Implies;</mo><mi>&Pi;</mi></mrow><mrow><mrow><mi>&Gamma;</mi><mo>,</mo><mi>&beta;</mi><mo>,</mo><mi>&alpha;</mi><mo>,</mo><mi>&Delta;</mi></mrow><mo>&Implies;</mo><mi>&Pi;</mi></mrow></mfrac><mrow><mo stretchy="false">(</mo><mrow><mi>e</mi><mi>&rArr;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mspace width="16ex"/><mrow><mfrac displaystyle="true"><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mrow><mi>&Pi;</mi><mo>,</mo><mi>&alpha;</mi><mo>,</mo><mi>&beta;</mi><mo>,</mo><mi>&Lambda;</mi></mrow></mrow><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mrow><mi>&Pi;</mi><mo>,</mo><mi>&beta;</mi><mo>,</mo><mi>&alpha;</mi><mo>,</mo><mi>&Lambda;</mi></mrow></mrow></mfrac><mrow><mo stretchy="false">(</mo><mrow><mi>&rArr;</mi><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math></li><li>收缩规则:<math display="block"><mrow><mrow><mfrac displaystyle="true"><mrow><mrow><mi>&alpha;</mi><mo>,</mo><mi>&alpha;</mi><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mi>&Pi;</mi></mrow><mrow><mrow><mi>&alpha;</mi><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mi>&Pi;</mi></mrow></mfrac><mrow><mo stretchy="false">(</mo><mrow><mi>c</mi><mi>&rArr;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mspace width="16ex"/><mrow><mfrac displaystyle="true"><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mrow><mi>&Pi;</mi><mo>,</mo><mi>&alpha;</mi><mo>,</mo><mi>&alpha;</mi></mrow></mrow><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mrow><mi>&Pi;</mi><mo>,</mo><mi>&alpha;</mi></mrow></mrow></mfrac><mrow><mo stretchy="false">(</mo><mrow><mi>&rArr;</mi><mi>c</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math></li><li>弱化规则:<math display="block"><mrow><mrow><mfrac displaystyle="true"><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mi>&Pi;</mi></mrow><mrow><mrow><mi>&alpha;</mi><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mi>&Pi;</mi></mrow></mfrac><mrow><mo stretchy="false">(</mo><mrow><mi>w</mi><mi>&rArr;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mspace width="16ex"/><mrow><mfrac displaystyle="true"><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mi>&Pi;</mi></mrow><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mrow><mi>&Pi;</mi><mo>,</mo><mi>&alpha;</mi></mrow></mrow></mfrac><mrow><mo stretchy="false">(</mo><mrow><mi>&rArr;</mi><mi>w</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math></li></ul></p><p>出于方便的考量, 我们为每条规则附加了一个诸如<math><mrow><mo stretchy="false">(</mo><mrow><mo>&or;</mo><mi>&rArr;</mi></mrow><mo stretchy="false">)</mo></mrow></math>这样的名字. 在每条规则里, 使用小写希腊字母<math><mi>&alpha;</mi></math>和<math><mi>&beta;</mi></math>的公式被称为<em>活跃(active)</em>公式. 另外, 每条规则里的下相继式里显式呈现的使用小写希腊字母的公式被称为规则的<em>主(principal)</em>公式. 例如, <math><mrow><mi>&alpha;</mi><mo>&or;</mo><mi>&beta;</mi></mrow></math>是规则<math><mrow><mo stretchy="false">(</mo><mrow><mo>&or;</mo><mi>&rArr;</mi></mrow><mo stretchy="false">)</mo></mrow></math>的主公式, 而<math><mi>&alpha;</mi></math>是规则<math><mrow><mo stretchy="false">(</mo><mrow><mi>w</mi><mi>&rArr;</mi></mrow><mo stretchy="false">)</mo></mrow></math>的主公式. 其他的公式都被称为<em>副(side)</em>公式. 切规则的活跃公式被称为<em>切公式</em>. 对于逻辑联结词的规则而言, 主公式出现在前件里的是<em>左规则</em>. 对于结构规则, 活跃公式都出现在前件里的是<em>左规则</em>. 将前件替换为后件, 可以得到<em>右规则</em>的定义. 左规则的名字具有形式<math><mrow><mo stretchy="false">(</mo><mrow><mi>&sharp;</mi><mi>&rArr;</mi></mrow><mo stretchy="false">)</mo></mrow></math>, 右规则的名字具有形式<math><mrow><mo stretchy="false">(</mo><mrow><mi>&rArr;</mi><mi>&sharp;</mi></mrow><mo stretchy="false">)</mo></mrow></math>.</p><p>每条规则都是说<em>当上相继式可证明时, 其下相继式也是可证明的</em>. 例如, 规则<math><mrow><mo stretchy="false">(</mo><mrow><mo>&and;</mo><mn>1</mn><mi>&rArr;</mi></mrow><mo stretchy="false">)</mo></mrow></math>是说每当相继式<math><mrow><mrow><mi>&alpha;</mi><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mi>&Pi;</mi></mrow></math>可证明时, 相继式<math><mrow><mrow><mrow><mi>&alpha;</mi><mo>&and;</mo><mi>&beta;</mi></mrow><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mi>&Pi;</mi></mrow></math>也是可证明的. 类似地, 规则<math><mrow><mo stretchy="false">(</mo><mrow><mi>&rArr;</mi><mo>&and;</mo></mrow><mo stretchy="false">)</mo></mrow></math>是说 (为了简洁, 假定<math><mi>&Lambda;</mi></math>为空) 每当<math><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mi>&alpha;</mi></mrow></math>和<math><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mi>&beta;</mi></mrow></math>都是可证的, 那么<math><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mrow><mi>&alpha;</mi><mo>&and;</mo><mi>&beta;</mi></mrow></mrow></math>也是可证的. 以这种方式, 每个逻辑联结词的公式精确地描述了这个联结词的功能.</p><p>切规则表达了演绎推理的一种基础原则. 实际上, 其是在说 (又一次为了简洁, 假定<math><mi>&Lambda;</mi></math>为空) 如果<math><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mi>&alpha;</mi></mrow></math>是可证明的, 并且<math><mrow><mrow><mi>&alpha;</mi><mo>,</mo><mi>&Delta;</mi></mrow><mo>&Implies;</mo><mi>&Pi;</mi></mrow></math>是可证明的, 那么<math><mrow><mrow><mi>&Gamma;</mi><mo>,</mo><mi>&Delta;</mi></mrow><mo>&Implies;</mo><mi>&Pi;</mi></mrow></math>也是可证明的. 所有的结构规则作为一个整体控制了给定相继式里的前件和后件里的公式的顺序, 重复和省略. 特别地, 每条左结构规则从直觉上来说含义如下:<ul><li>交换规则允许我们使用前件里的公式, 不论它们以何种顺序排列.</li><li>收缩规则表达了前件里的公式出现在推理结论时可以使用不止一次.</li><li>左弱化规则允许我们将任意的公式放在前件里, 即便其在推理结论时没有用到.</li></ul></p><div class="definition"><b>定义1.1.</b> <em>(证明和可证明性) </em><b>LK</b>中的某个相继式<math><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mi>&Delta;</mi></mrow></math>的一个<em>证明</em><math><mi mathvariant="sans-serif">P</mi></math>是一个有限树状图形, 以如下方式定义, 其展现了该相继式在<b>LK</b>中是如何从初始相继式推导出来的.<ul><li>证明<math><mi mathvariant="sans-serif">P</mi></math>中的每个最上层相继式都是初始相继式.</li><li>证明<math><mi mathvariant="sans-serif">P</mi></math>中除了最上层相继式之外的所有相继式都是通过应用任意一条规则得到的.</li><li><math><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mi>&Delta;</mi></mrow></math>是唯一的最下层相继式, 其被称为证明<math><mi mathvariant="sans-serif">P</mi></math>的<em>终相继式(end sequent)</em>.</li></ul>一个相继式<math><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mi>&Delta;</mi></mrow></math>在<b>LK</b>中是<em>可证明的</em>当且仅当存在一个对于<math><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mi>&Delta;</mi></mrow></math>的证明. 另外, 当相继式<math><mrow><mrow/><mo>&Implies;</mo><mi>&alpha;</mi></mrow></math>在<b>LK</b>中可证明时, 我们也称公式<math><mi>&alpha;</mi></math>在<b>LK</b>是可证明的.</div><p>我们注意到一个相继式在可证明时或许拥有数个不同的证明. 对于某个相继式<math><mrow><mi>&Gamma;</mi><mo>&Implies;</mo><mi>&Delta;</mi></mrow></math>的一个给定证明<math><mi mathvariant="sans-serif">P</mi></math>, 设<math><mrow><mi>&Sigma;</mi><mo>&Implies;</mo><mi>&Theta;</mi></mrow></math>是出现在<math><mi mathvariant="sans-serif">P</mi></math>中的一个相继式. 那么, 证明<math><mi mathvariant="sans-serif">P</mi></math>中相继式<math><mrow><mi>&Sigma;</mi><mo>&Implies;</mo><mi>&Theta;</mi></mrow></math>之上 (也包括自身) 的子图形<math><mi mathvariant="sans-serif">Q</mi></math>构成了一个终相继式为<math><mrow><mi>&Sigma;</mi><mo>&Implies;</mo><mi>&Theta;</mi></mrow></math>的证明. 作为<math><mi mathvariant="sans-serif">Q</mi></math>这样的一个证明被称为<math><mi mathvariant="sans-serif">P</mi></math>的一个<em>子证明</em>.</p><p>在给出证明的具体例子之前, 我们给出为了简化对于证明的描述的约定. 我们注意到在我们所列出的<b>LK</b>的规则里, 上相继式里的活跃公式总是置于前件的最左边或者后件的最右边, 除了交换规则. 理由只是为了简化规则的呈现, 因而这些限制不是本质性的. 实际上, <em>只要活跃公式出现在相应的前件或者后件的任何位置</em>, 规则就可以应用. 这是因为, 我们可以首先对于上相继式应用交换规则, 将活跃公式移至前件的最左边或者后件的最右边, 然后应用所牵涉的规则, 最后再用交换规则将活跃公式移回去. 为了解释这种调整, 让我们考虑以下形式的规则<math><mrow><mo stretchy="false">(</mo><mrow><mo>&and;</mo><mn>1</mn><mi>&rArr;</mi></mrow><mo stretchy="false">)</mo></mrow></math>:<math display="block"><mfrac displaystyle="true"><mrow><mrow><mi>&Sigma;</mi><mo>,</mo><mi>&alpha;</mi><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mi>&Delta;</mi></mrow><mrow><mrow><mi>&Sigma;</mi><mo>,</mo><mrow><mi>&alpha;</mi><mo>&and;</mo><mi>&beta;</mi></mrow><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mi>&Delta;</mi></mrow></mfrac></math>以下是从这上相继式得到下相继式的方式.<math display="block"><mfrac displaystyle="true"><mfrac displaystyle="true"><mrow><mfrac displaystyle="true"><mfrac displaystyle="true"><mfrac displaystyle="true"><mrow><mrow><mi>&Sigma;</mi><mo>,</mo><mi>&alpha;</mi><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mi>&Delta;</mi></mrow><mo>&ctdot;</mo></mfrac><mrow><mrow><mi>&alpha;</mi><mo>,</mo><mi>&Sigma;</mi><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mi>&Delta;</mi></mrow></mfrac><mrow><mrow><mrow><mi>&alpha;</mi><mo>&and;</mo><mi>&beta;</mi></mrow><mo>,</mo><mi>&Sigma;</mi><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mi>&Delta;</mi></mrow></mfrac><mrow><mo stretchy="false">(</mo><mrow><mo>&and;</mo><mn>1</mn><mi>&rArr;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&ctdot;</mo></mfrac><mrow><mrow><mi>&Sigma;</mi><mo>,</mo><mrow><mi>&alpha;</mi><mo>&and;</mo><mi>&beta;</mi></mrow><mo>,</mo><mi>&Gamma;</mi></mrow><mo>&Implies;</mo><mi>&Delta;</mi></mrow></mfrac></math>这里的点<math><mo>&hellip;</mo></math>代表对于交换规则的数次应用. 以这种方法, 我们将允许应用每条规则而不管其活跃公式出现在哪里.</p><div class="example"><b>例子1.2.</b> </div><div class="exercise"><b>练习1.1.</b> 在<b>LK</b>中给出对于以下相继式的证明.<ol><li><math><mrow><mrow/><mo>&Implies;</mo><mrow><mi>&alpha;</mi><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&beta;</mi><mo>&rarr;</mo><mi>&alpha;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math></li><li><math><mrow><mrow><mi>&alpha;</mi><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&beta;</mi><mo>&rarr;</mo><mi>&gamma;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&Implies;</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>&alpha;</mi><mo>&rarr;</mo><mi>&beta;</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&alpha;</mi><mo>&rarr;</mo><mi>&gamma;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math></li></ol></div><div class="exercise"><b>练习1.2.</b> </div><div class="remark"><b>评注1.3.</b> </div><h4>使用公式的多重集的一个对于LK的改进呈现</h4><h4>在给定证明的长度上进行归纳</h4><h4>可逆系统LK*</h4><h2>第2章 相继式系统的切消</h2><h2>第3章 逻辑性质的证明论式分析</h2><h2>第4章 模态逻辑和亚结构逻辑</h2><h2>第5章 </h2><h2>第6章 从代数到逻辑</h2><h2>第7章 代数逻辑的基本</h2></body></html>