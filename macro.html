<html><head><meta charset="utf-8"/><title>卫生宏技术</title><link href="styles.css" rel="stylesheet"/></head><body><h1>卫生宏技术</h1><h2>翻译术语对照</h2><table align="center"><tr><td>英文</td><td>中文</td></tr><tr><td>macro</td><td>宏</td></tr><tr><td>naive</td><td>朴素</td></tr><tr><td>sound</td><td>可靠</td></tr><tr><td>unsound</td><td>不可靠</td></tr><tr><td>elimination rule</td><td>消去规则</td></tr><tr><td>hygiene</td><td>卫生</td></tr><tr><td>hygienic macro</td><td>卫生宏</td></tr></table><h2>第1章 捕获问题</h2><p>宏的本质是在一段代码里将一个表达式替换为另一个表达式.</p><p>正如逻辑学和lambda演算中为人所熟知的, 朴素替换是不可靠的. 例如, 考虑一阶逻辑的全称消去规则. 这条规则经常被陈述为<math display="block"><mrow><mfrac displaystyle="true"><mrow><mo>&forall;</mo><mi>x</mi><mo>.</mo><mi>&phi;</mi></mrow><mrow><mi>&phi;</mi><mrow><mo stretchy="false">[</mo><mrow><mi>t</mi><mo lspace="0" rspace="0">/</mo><mi>x</mi></mrow><mo stretchy="false">]</mo></mrow></mrow></mfrac><mrow><mi>&forall;</mi><mi>E</mi></mrow></mrow></math>其是说</p><h2>第2章 卫生之前的Lisp宏</h2><h2>第3章 卫生之前的Scheme宏</h2><p>Scheme编程语言由Guy L Steele Jr和Gerald J Sussman于1975年设计和实现. 鉴于Scheme起初被构想为Carl Hewitt的Actor模型的一个顺序实现 [Steele and Gabriel 1993a; Clinger 2008], 其与(当时)大多数其他的Lisp方言在以下方面有所不同:<ul><li>正确尾递归 (于是过程调用不会施行没有必要的压栈操作)</li><li>第一级延续 (所有那时已知的顺序控制结构均可由此合成)</li><li>词法作用域 (如lambda演算, Algol, 以及其他许多块结构语言)</li><li>第一级过程 (如lambda演算)</li><li>一致的求值 (如lambda演算)</li><li>统一的环境 (如lambda演算)</li></ul>根据上述的最后四点, Scheme在lambda演算的意义下是一个<em>高阶语言</em>: </p><h2>第4章 Kohlbecker的算法</h2><p>现在我们考虑<em>Kohlbecker算法</em>, 其似乎是第一个全然可靠的技术, (1) 赋予了程序员以避免意外捕获的力量, (2) 被实际实现.</p><h3>第4.1节 Kohlbecker的术语</h3><h3>第4.2节 目标和设计决策</h3><h3>第4.3节 其是如何工作的</h3><h2>第5章 国家和国际标准</h2><h2>第6章 句法闭包的兴起与衰落</h2><h2>第7章 行之有效的宏</h2><h2>第8章 强卫生性被发现压根不那么强</h2><h2>第9章 <code>syntax-case</code></h2><h2>第10章 从R4RS到R5RS</h2><h2>第11章 从R5RS到R6RS</h2><h2>第12章 从R6RS到R7RS</h2><h2>第13章 绑定作为作用域集合</h2></body></html>