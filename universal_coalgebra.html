<html><head><meta charset="utf-8"/><title>泛余代数: 系统的一个理论</title><link href="styles.css" rel="stylesheet"/></head><body><h1>泛余代数: 系统的一个理论</h1><h2>摘要</h2><p>编程的语义学中诸如有限列表这样的有限数据类型在传统上是由始代数所建模的. 之后的终<em>余代数</em>用以处理<em>无限</em>数据类型. 而且, 作为代数的对偶, 余代数被证明适合用作特定类型的自动机以及更一般的(转换和动态)<em>系统</em>的模型. 始代数的一个重要性质在于其满足令人熟悉的归纳原理. 这样一种原理直至Aczel关于非良基集合的理论的工作之前对于余代数而言都是缺失的, 而Aczel的论文引入了一个如今被称为<em>余归纳</em>的证明原理. 余归纳是以<em>双模拟</em>的语言表述的, 双模拟这个概念最初成长于并发编程语言的世界. 使用<em>余代数同态</em>的概念, 余代数上的双模拟的定义可以表明是形式对偶于代数上的congruence的定义的. 因此, 泛代数的三种基本概念, 即代数, 代数的同态, 以及congruence, 实际上分别对应于余代数, 余代数的同态, 以及双模拟. </p><h2>第1章 引论</h2><p>在编程的语义学中, 数据类型通常呈现为代数 (参见 [24,47]). </p><h2>第2章 余代数, 同态, 以及双模拟</h2><h2>第3章 系统, 系统, 系统</h2><h2>第4章 系统的极限和余极限</h2><h2>第5章 关于双模拟的基本事实</h2><h2>第6章 子系统</h2><h2>第7章 三个同构定理</h2><h2>第8章 简单系统和余归纳</h2><h2>第9章 终系统</h2><h2>第10章 终系统的存在性</h2><h2>第11章 余归纳定义的例子</h2><h2>第12章 余归纳证明的例子</h2><h2>第13章 归纳和余归纳</h2><h2>第14章 最大和最小不动点</h2><h2>第15章 系统的自然变换</h2></body></html>