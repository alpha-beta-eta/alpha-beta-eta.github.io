<html><head><meta charset="utf-8"/><title>结构证明论</title><link href="styles.css" rel="stylesheet"/></head><body><h1>结构证明论</h1><h2>前言</h2><p>本书源于我们对于无收缩规则的相继式演算的迷恋. 本书的第一部分, 从第1章到第4章, 是基于这种演算的对于直觉主义谓词逻辑和古典谓词逻辑的介绍. 本书的第二部分, 从第5章到第8章, 主要呈现了我们自己的工作, 其利用了对于证明的控制, 而这是因为无收缩规则的演算才成为可能.</p><h2>导引</h2><h3>结构证明论</h3><p>数学证明的想法非常古老, 尽管精确的证明原则大概只是在过去数百年间才确定下来的. 证明论最初是基于只有一到两个推理规则的公理系统的. 这样的系统作为对于什么是可证明的形式呈现而言可能是有用的, 然而在公理系统中实际发现证明近乎是不可能的. 一个证明从公理的实例开始, 但是并不存在找出这些实例应该是什么的系统方法. 公理证明论最初由David Hilbert建立, 其目的在于研究数学公理系统的一致性, 相互独立性以及完备性.</p><p><b>结构证明论</b>研究数学证明的一般结构和性质. 其由Gerhard Gentzen (1909-1945) 于1930年代初发现并在其1933年的博士论文<i>Untersuchungen &uuml;ber das logische Schliessen</i>中呈现. 在他的论文里, Gentzen给出了对于逻辑规则系统两种主要的形式化, <b>自然演绎</b>和<b>相继式演算</b>. 前者意在提供定理证明实践的一种近似对应; 而后者, Gentzen通过这种形式化发现了其主要的结果, 其经常被引用为Gentzen的&quot;Hauptsatz&quot;. 它是在说证明可以被转换为一种特定的&quot;无切&quot;形式, 而从这种形式可以得到关于证明的一般性结论, 例如规则系统的一致性.</p><p>Gentzen开始他的研究的年代发生了一件标志性的大事, 这是一项伟大但却令人费解的发现, 即1931年算术的G&ouml;del不完备性定理: 已知的证明原则不足以推导出算术的一切; 而且, 没有单一的公理和规则系统可以满足此要求. Gentzen对于算术的证明论研究产生了<b>序数证明论</b>, 其主要任务在于研究包含无穷多证明原则的形式系统的演绎强度. 这一部分的证明论我们将不作讨论.</p><p>对于Gentzen在其博士论文中给出的两种形式的结构证明论, 自然演绎对于证明规则的处理仍然保持了显著的稳定性, 然而相继式演算却沿着各种不同的方向进行发展. 其中一种发展方向, 自Gentzen始经由Ketonen, Kleene, Dragalin, Troelstra直至现在被称为<b>无收缩规则</b>的相继式演算系统. 这些逻辑学家之中的每一位都添加了一些基本的发现, 直至宝石诞生. 在当前这个阶段我们只能暗示如下: 存在一种组织证明原理的方式使得我们可以从要证明的定理出发, 然后通过分析以受引导的方式将其分为更简单的部分. 所谓的宝石正是这&quot;受引导的方式&quot;; 也就是说, 如果我们确定了最后的推导规则是什么, 那么最后一步的前提也就确定了. </p><h2>第1章 从自然演绎到相继式演算</h2><h3>第1.1节 逻辑系统</h3><p>一个逻辑系统由一个形式语言和一个用于进行逻辑推理的公理和规则系统构成.</p><p><b>(a) 逻辑语言:</b> 一个逻辑语言经常通过一集归纳语句被定义为合式公式. 想法在于形式语言的表达式是来源于某个给定的字母表的符号的特定序列, 由归纳定义生成. 另一种定义形式语言的方法是通过<b>范畴文法</b>. 这样的文法对于自然语言领域而言是众所周知的, 亦用于编程语言, 但在逻辑学中不那么常见.</p><p>在第一种方法下, 逻辑语言的表达式是由两种语句归纳定义的公式: 1. 陈述何为<b>基本 (prime) </b>公式. 这些公式不包含其他公式作为其一部分. 2. 陈述何为<b>复合 (compound) </b>公式. 这些公式由更简单的公式通过逻辑联结词构造, 并且其定义需要引用<b>任意</b>的公式, 以及说明这些公式是如何与逻辑联结词的符号放在一起以给出新的公式的. 给定一个公式, 我们可以找出其是如何由其他公式和逻辑联结词放在一起的. 或许括号对于唯一地指明复合的方式而言是必要的, 然后我们可以明白如何得到公式的各个部分, 直至抵达基本公式. 因此, 到最后, 所有公式都是由基本公式, 逻辑联结词和括号构成的.</p><p>我们将定义<b>命题逻辑</b>的语言:<ol><li>基本公式是记作<math><mrow><mi>P</mi><mo>,</mo><mi>Q</mi><mo>,</mo><mi>R</mi><mo>,</mo><mo>&hellip;</mo></mrow></math>的<b>原子</b>公式和记作<math><mi>&bottom;</mi></math>的<b>谬</b>.</li><li>如果<math><mi>A</mi></math>和<math><mi>B</mi></math>是公式, 那么<b>合取</b><math><mrow><mi>A</mi><mo>&amp;</mo><mi>B</mi></mrow></math>, <b>析取</b><math><mrow><mi>A</mi><mo>&or;</mo><mi>B</mi></mrow></math>和<b>推论</b><math><mrow><mi>A</mi><mo>&sup;</mo><mi>B</mi></mrow></math>也是公式.</li></ol>为了公式的unique readability, 公式的部分 (component) 应该被置于括号里, 然而在实践中, 若合取和析取是推论的部分, 括号则通常被省略. 往往<math><mi>&bottom;</mi></math>被当作原子公式, 但是在证明论中最好将其视为零元联结词. <b>否定</b><math><mrow><mo>&Tilde;</mo><mi>A</mi></mrow></math>和<b>等价</b><math><mrow><mi>A</mi><mo>&sup;&sub;</mo><mi>B</mi></mrow></math>分别被定义为<math><mrow><mrow><mo>&Tilde;</mo><mi>A</mi></mrow><mo>=</mo><mrow><mi>A</mi><mo>&sup;</mo><mi>&bottom;</mi></mrow></mrow></math>和<math><mrow><mrow><mi>A</mi><mo>&sup;&sub;</mo><mi>B</mi></mrow><mo>=</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>&sup;</mo><mi>B</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&amp;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>B</mi><mo>&sup;</mo><mi>A</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.</p><p>语言的表达式应该表达什么东西, 而不仅仅是以正确方式放在一起的来源于某个字母表的符号的序列. 在逻辑学中, 这样所表达的东西被称为<b>命题</b>. 往往人们并不说&quot;由公式<math><mi>A</mi></math>表达的命题&quot;, 而仅仅是说&quot;命题<math><mi>A</mi></math>&quot;. 在哲学中对于命题究竟是什么存在着长期的争辩. 当重心在逻辑学上, 而不是在哲学分析下的逻辑是什么上的时候, 我们以形式上的意义考虑表达式, 讨论公式.</p><p>在近来的文献中, 将表达式定义为符号序列被称为是<b>具体句法</b>. 往往从另一个角度看待表达式是有用的, 即<b>抽象句法</b>的角度, 如在范畴文法中. 范畴文法的基本想法在于语言的表达式拥有一种<b>函数式结构 (functional structure)</b>. 例如, 英语句子<math><mi>John walks</mi></math>可以藉由将不及物动词<math><mi>walk</mi></math>表示为从名词词组范畴<math><mi>NP</mi></math>到句子范畴<math><mi>S</mi></math>的函数得到, 在通常的函数记号下即<math><mrow><mi>walk</mi><mo>:</mo><mrow><mi>NP</mi><mo>&rarr;</mo><mi>S</mi></mrow></mrow></math>. <math><mi>John</mi></math>是范畴<math><mi>NP</mi></math>的一个元素, 而将函数<math><mi>walk</mi></math><b>应用</b>于它则得到了作为值的<math><mrow><mi>walk</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>John</mi><mo stretchy="false">)</mo></mrow></mrow></math>, 这是句子范畴<math><mi>S</mi></math>的一个元素. 为了隐藏函数式的结构以生成原本的句子<math><mi>John walks</mi></math>, 更进一步的<b>线性化</b>是必要的. 在逻辑学和数学中, 这最后阶段产生的不同无足轻重. 自Frege始, 人们只考虑函数式结构的逻辑内容.</p><p>我们将简要从范畴文法的角度看看命题逻辑语言的定义. 存在一个命题的<b>基本范畴</b>, 记作<math><mi>Prop</mi></math>. 原子命题是作为参数<math><mrow><mi>P</mi><mo>,</mo><mi>Q</mi><mo>,</mo><mi>R</mi><mo>,</mo><mo>&hellip;</mo></mrow></math>被引入的, 其无结构, 带有范畴化<math display="block"><mrow><mrow><mi>P</mi><mo>:</mo><mi>Prop</mi></mrow><mo>,</mo><mrow><mi>Q</mi><mo>:</mo><mi>Prop</mi></mrow><mo>,</mo><mrow><mi>R</mi><mo>:</mo><mi>Prop</mi></mrow><mo>,</mo><mo>&hellip;</mo></mrow></math>谬也是类似的, <math><mrow><mi>&bottom;</mi><mo>:</mo><mi>Prop</mi></mrow></math>. 联结词是由给定命题构造新命题的二元函数. </p><h3>第1.2节 自然演绎</h3><h3>第1.3节 从自然演绎到相继式演算</h3><h3>第1.4节 证明的结构</h3><h3>第1章的注记</h3><h2>第2章 直觉主义逻辑的相继式演算</h2><h2>第3章 古典逻辑的相继式演算</h2></body></html>