<html><head><meta charset="utf-8"/><title>组合学笔记</title><link href="styles.css" rel="stylesheet"/></head><body><h1>组合学笔记</h1><p>偶然间发现了所谓的de Bruijn的组合学的课堂笔记, 我有点好奇, 遂读之.</p><h2>第1章 引论</h2><h2>第2章 生成函数</h2><p>组合学中一个非常古老的想法是生成函数, 其可以追溯至Laplace.</p><p>给定一无穷数列<math display="block"><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>,</mo><mo>&hellip;</mo></mrow></math>其生成函数为以下级数<math display="block"><mrow><mrow><mi>A</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&it;</mo><mi>x</mi></mrow><mo>+</mo><mrow><msub><mi>a</mi><mn>2</mn></msub><mo>&it;</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><mo>+</mo><mo>&ctdot;</mo></mrow></mrow></math></p><p>生成函数这种技术的想法在于<math display="block"><mtable><mtr><mtd><mtable frame="solid" displaystyle="true"><mtr><mtd><mtext>关于序列的知识</mtext></mtd></mtr></mtable></mtd><mtd><mover><mo>&rarr;</mo><mtext>向前转换</mtext></mover></mtd><mtd><mtable frame="solid" displaystyle="true"><mtr><mtd><mtext>关于</mtext><mrow><mi>A</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mtext>的知识</mtext></mtd></mtr></mtable></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mrow><mo>&darr;</mo><mtext>各种操作</mtext></mrow></mtd></mtr><mtr><mtd><mtable frame="solid" displaystyle="true"><mtr><mtd><mtext>更多关于序列的知识</mtext></mtd></mtr></mtable></mtd><mtd><munder><mo>&larr;</mo><mtext>向后转换</mtext></munder></mtd><mtd><mtable frame="solid" displaystyle="true"><mtr><mtd><mtext>更多关于</mtext><mrow><mi>A</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mtext>的知识</mtext></mtd></mtr></mtable></mtd></mtr></mtable></math>这有点像是Laplace积分<math display="block"><mrow><mrow><mi>F</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msubsup><mo>&int;</mo><mn>0</mn><mi>&infin;</mi></msubsup><mrow><msup><mi>e</mi><mrow><mi>x</mi><mo>&it;</mo><mi>t</mi></mrow></msup><mo>&it;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo rspace="0">d</mo><mi>t</mi></mrow></mrow></math>其想法在于<math display="block"><mtable><mtr><mtd><mtable frame="solid" displaystyle="true"><mtr><mtd><mtext>关于</mtext><mi>f</mi><mtext>的微分方程</mtext></mtd></mtr></mtable></mtd><mtd><mover><mo>&rarr;</mo><mtext>Laplace变换</mtext></mover></mtd><mtd><mtable frame="solid" displaystyle="true"><mtr><mtd><mtext>关于</mtext><mi>F</mi><mtext>的代数方程</mtext></mtd></mtr></mtable></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mrow><mo>&darr;</mo><mtext>求解代数方程</mtext></mrow></mtd></mtr><mtr><mtd><mtable frame="solid" displaystyle="true"><mtr><mtd><mtext>关于</mtext><mi>f</mi><mtext>的微分方程的解</mtext></mtd></mtr></mtable></mtd><mtd><munder><mo>&larr;</mo><mtext>向后转换</mtext></munder></mtd><mtd><mtable frame="solid" displaystyle="true"><mtr><mtd><mtext>关于</mtext><mi>F</mi><mtext>的代数方程的解</mtext></mtd></mtr></mtable></mtd></mtr></mtable></math></p><div class="notation"><b>记号.</b> 为了避免可能的歧义, 我们定义<math display="block"><mrow><msub><mi>&Nopf;</mi><mn>0</mn></msub><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mo>&hellip;</mo></mrow><mo stretchy="false">}</mo></mrow></mrow></math>以及<math display="block"><mrow><msub><mi>&Nopf;</mi><mn>1</mn></msub><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mo>&hellip;</mo></mrow><mo stretchy="false">}</mo></mrow></mrow></math></div><div class="example"><b>例子.</b> Fibonacci数列定义如下<math display="block"><mrow><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>=</mo><mn>1</mn></mrow><mo>;</mo><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><mo>;</mo><mrow><mrow><msub><mi>a</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><msub><mi>a</mi><mi>n</mi></msub><mo>+</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow></mrow><mo>,</mo><mrow><mi>n</mi><mo>&in;</mo><msub><mi>&Nopf;</mi><mn>1</mn></msub></mrow></mrow></mrow></math>Fibonacci数列的生成函数为<math display="block"><mrow><mrow><mi>A</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mn>1</mn><mo>+</mo><mrow><mn>1</mn><mo>&it;</mo><mi>x</mi></mrow><mo>+</mo><mrow><mn>2</mn><mo>&it;</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><mo>+</mo><mrow><mn>3</mn><mo>&it;</mo><msup><mi>x</mi><mn>3</mn></msup></mrow><mo>+</mo><mrow><mn>5</mn><mo>&it;</mo><msup><mi>x</mi><mn>4</mn></msup></mrow><mo>+</mo><mrow><mn>8</mn><mo>&it;</mo><msup><mi>x</mi><mn>5</mn></msup></mrow><mo>+</mo><mrow><mn>13</mn><mo>&it;</mo><msup><mi>x</mi><mn>6</mn></msup></mrow><mo>+</mo><mo>&ctdot;</mo></mrow></mrow></math>基于其系数的递推关系, 我们发现<math display="block"><mrow><mrow><mi>x</mi><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mrow><mi>A</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mrow><mi>A</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&minus;</mo><mn>1</mn></mrow></mrow></math>于是<math display="block"><mrow><mrow><mi>A</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mfrac><mrow><mo>&minus;</mo><mn>1</mn></mrow><mrow><mrow><mo>&minus;</mo><mn>1</mn></mrow><mo>+</mo><mi>x</mi><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup></mrow></mfrac></mrow></math>将该分式拆分可以得到<math display="block"><mrow><mrow><mi>A</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo>(</mo><mrow><mfrac><mn>1</mn><mrow><mi>x</mi><mo>&minus;</mo><msub><mi>&alpha;</mi><mn>1</mn></msub></mrow></mfrac><mo>&minus;</mo><mfrac><mn>1</mn><mrow><mi>x</mi><mo>&minus;</mo><msub><mi>&alpha;</mi><mn>2</mn></msub></mrow></mfrac></mrow><mo>)</mo></mrow><mo>&it;</mo><mfrac><mrow><mo>&minus;</mo><mn>1</mn></mrow><mrow><msub><mi>&alpha;</mi><mn>1</mn></msub><mo>&minus;</mo><msub><mi>&alpha;</mi><mn>2</mn></msub></mrow></mfrac></mrow></mrow></math>其中<math><msub><mi>&alpha;</mi><mn>1</mn></msub></math>和<math><msub><mi>&alpha;</mi><mn>2</mn></msub></math>是<math><mrow><mrow><mo>&minus;</mo><mn>1</mn></mrow><mo>+</mo><mi>x</mi><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup></mrow></math>的两根.<br/>若是我们将这些分式再写成幂级数的形式, 然后合并同类项, 就可以得到<math display="block"><mrow><msub><mi>a</mi><mi>n</mi></msub><mo>=</mo><mrow><mfrac><mn>1</mn><msqrt><mn>5</mn></msqrt></mfrac><mo>&it;</mo><mrow><mo>[</mo><mrow><msup><mrow><mo>(</mo><mfrac><mrow><mn>1</mn><mo>+</mo><msqrt><mn>5</mn></msqrt></mrow><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>&minus;</mo><msup><mrow><mo>(</mo><mfrac><mrow><mn>1</mn><mo>&minus;</mo><msqrt><mn>5</mn></msqrt></mrow><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mo>]</mo></mrow></mrow></mrow></math></div><p>我们可用三种方式为这把戏 (hocus-pocus) 进行辩护<ol><li>作为启发式 (heuristic). 反正我们得到了结果, 不论是怎么得到的. 之后我们可以验证其正确与否, 比如说这种情况下我们可以使用数学归纳法.</li><li>通过收敛幂级数的理论. 我们可以将<math><mi>A</mi></math>视为一个定义在<math><mi>&Copf;</mi></math>平面中的零点的某个小邻域上的解析函数. 这可以澄清我们对于<math><mi>A</mi></math>施行的计算. 问题在于我们需要检视其收敛性, 即其具有某个正的收敛半径, 虽然就这个例子而言并不是什么困难. 我们可以用归纳法轻易地验证<math display="block"><mrow><mrow><mo>&forall;</mo><mrow><mi>n</mi><mo>&in;</mo><msub><mi>&Nopf;</mi><mn>0</mn></msub></mrow></mrow><mo>,</mo><mrow><mrow><mo stretchy="false">|</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">|</mo></mrow><mo>&le;</mo><msup><mn>2</mn><mi>n</mi></msup></mrow></mrow></math>根据Cauchy–Hadamard定理, 我们知道收敛半径大于等于<math><mrow><mn>1</mn><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow></math>.</li><li>通过建立形式幂级数的理论. 这可以做得相当形式化, 就是非常无聊而已. 当然, 也不会有什么新东西.</li></ol></p><h4>形式幂级数的理论概览.</h4><p>我们将给出复系数幂级数的理论, 虽然仅需很少的调整其也可以对于环成立. 你应该将形式幂级数看成是具有无限次数的多项式. 或者说, 实际上你应该将确定了形式幂级数的序列当成是形式幂级数自身. 也就是说, 我们的形式幂级数不过就是一个映射<math display="block"><mrow><mrow><msub><mi>&Nopf;</mi><mn>0</mn></msub><mo>&rarr;</mo><mi>&Copf;</mi></mrow><mo>,</mo><mrow><mi>n</mi><mo>&mapsto;</mo><msub><mi>a</mi><mi>n</mi></msub></mrow></mrow></math>加法被定义为逐项之和. 令<math display="block"><mtable columnalign="left"><mtr><mtd><mrow><mrow><mi>A</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&it;</mo><mi>x</mi></mrow><mo>+</mo><mrow><msub><mi>a</mi><mn>2</mn></msub><mo>&it;</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><mo>+</mo><mo>&ctdot;</mo></mrow></mrow></mtd></mtr><mtr><mtd><mrow><mrow><mi>B</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>b</mi><mn>0</mn></msub><mo>+</mo><mrow><msub><mi>b</mi><mn>1</mn></msub><mo>&it;</mo><mi>x</mi></mrow><mo>+</mo><mrow><msub><mi>b</mi><mn>2</mn></msub><mo>&it;</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><mo>+</mo><mo>&ctdot;</mo></mrow></mrow></mtd></mtr></mtable></math>那么<math display="block"><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>+</mo><mi>B</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>b</mi><mn>0</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>+</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>+</mo><msub><mi>b</mi><mn>1</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mi>x</mi></mrow><mo>+</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>a</mi><mn>2</mn></msub><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><mo>+</mo><mo>&ctdot;</mo></mrow></mrow></math>乘法被定义为所谓的Cauchy乘积<math display="block"><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>&it;</mo><mi>B</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>&it;</mo><msub><mi>b</mi><mn>0</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>+</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>&it;</mo><msub><mi>b</mi><mn>1</mn></msub></mrow><mo>+</mo><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&it;</mo><msub><mi>b</mi><mn>0</mn></msub></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mi>x</mi></mrow><mo>+</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>&it;</mo><msub><mi>b</mi><mn>2</mn></msub></mrow><mo>+</mo><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&it;</mo><msub><mi>b</mi><mn>1</mn></msub></mrow><mo>+</mo><mrow><msub><mi>a</mi><mn>2</mn></msub><mo>&it;</mo><msub><mi>b</mi><mn>0</mn></msub></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><mo>+</mo><mo>&ctdot;</mo></mrow></mrow></math><math><msup><mi>x</mi><mi>n</mi></msup></math>的系数为<math><mrow><munderover><mo>&sum;</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mrow><msub><mi>a</mi><mi>j</mi></msub><mo>&it;</mo><msub><mi>b</mi><mrow><mi>n</mi><mo>&minus;</mo><mi>j</mi></mrow></msub></mrow></mrow></math>. 如果<math><mrow><msub><mi>b</mi><mn>0</mn></msub><mo>&ne;</mo><mn>0</mn></mrow></math>, 那么<math><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo lspace="0" rspace="0">/</mo><mi>B</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math>也是有定义的. 如果<math><mrow><msub><mi>b</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow></math>, 那么<math><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>&compfn;</mo><mi>B</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math>也是有定义的, 甚至我们可以确定一个<math><mrow><mi>C</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math>使得<math><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>C</mi><mo>&compfn;</mo><mi>B</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>x</mi></mrow></math>. 我们可以形式化地对于幂级数进行微分. 在特定条件下, 我们可以定义幂级数的无穷级数和无穷乘积.</p><div class="remark"><b>评注.</b> 我们的一个重要想法在于, 如果一个操作对于每个系数的计算只涉及有限多的非平凡步骤, 那么其也应该是可行的, 哪怕这个操作实际上是无穷的. 什么是平凡的呢, 比如说加上<math><mn>0</mn></math>, 乘上<math><mn>0</mn></math>, 乘上<math><mn>1</mn></math>这种.<br/>让我们考虑一个例子<math display="block"><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>&compfn;</mo><mi>B</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&it;</mo><mrow><mi>B</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>+</mo><mrow><msub><mi>a</mi><mn>2</mn></msub><mo>&it;</mo><msup><mrow><mi>B</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mn>2</mn></msup></mrow><mo>+</mo><mrow><msub><mi>a</mi><mn>3</mn></msub><mo>&it;</mo><msup><mrow><mi>B</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mn>3</mn></msup></mrow><mo>+</mo><mo>&ctdot;</mo></mrow></mrow></math>当<math><mrow><msub><mi>b</mi><mn>0</mn></msub><mo>&ne;</mo><mn>0</mn></mrow></math>时, 每一项<math><mrow><msub><mi>a</mi><mi>n</mi></msub><mo>&it;</mo><msup><mrow><mi>B</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mi>n</mi></msup></mrow></math>都包含一个非零的常数项, 将其合并就得到<math display="block"><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&it;</mo><msub><mi>b</mi><mn>0</mn></msub></mrow><mo>+</mo><mrow><msub><mi>a</mi><mn>2</mn></msub><mo>&it;</mo><msubsup><mi>b</mi><mn>0</mn><mn>2</mn></msubsup></mrow><mo>+</mo><mo>&ctdot;</mo></mrow></math>这是我们所不允许的无限形式的操作.<br/>再看另外一个例子. 对于<math><mrow><mi>k</mi><mo>&in;</mo><msub><mi>&Nopf;</mi><mn>0</mn></msub></mrow></math>, 我们将<math><mrow><msub><mi>A</mi><mi>k</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math>定义为从<math><mrow><msub><mi>a</mi><mi>k</mi></msub><mo>&it;</mo><msup><mi>x</mi><mi>k</mi></msup></mrow></math>开始的幂级数. 那么, 我们可以定义<math><mrow><munderover><mo>&sum;</mo><mrow><mi>k</mi><mo>&ge;</mo><mn>0</mn></mrow><mrow/></munderover><mrow><msub><mi>A</mi><mi>k</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>: 对于第<math><mi>k</mi></math>项, 我们仅需加起<math><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></math>个项.</div><h3>第2.1节 零钱问题</h3><p>如果你需要付<math><mn>67</mn></math>分钱买一杯咖啡, 而只能以<math><mrow><mn>1</mn><mo>,</mo><mn>5</mn><mo>,</mo><mn>10</mn><mo>,</mo><mn>25</mn></mrow></math>分钱的硬币付款, 假定每种硬币的数量都是足够多的, 那么有多少种付款的方式呢? 我们可以先尝试枚举一些具体的方案.<math display="block"><mtable><mtr><mtd><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mtd><mtd><mrow><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow></mtd><mtd><mrow><mo stretchy="false">(</mo><mn>10</mn><mo stretchy="false">)</mo></mrow></mtd><mtd><mrow><mo stretchy="false">(</mo><mn>25</mn><mo stretchy="false">)</mo></mrow></mtd></mtr><mtr><mtd><mn>2</mn></mtd><mtd><mn>2</mn></mtd><mtd><mn>3</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>7</mn></mtd><mtd><mn>2</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>2</mn></mtd></mtr><mtr><mtd><mn>7</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>2</mn></mtd></mtr></mtable></math>换言之, 一种方案完全由其频率函数<math display="block"><mrow><mi>f</mi><mo>:</mo><mrow><mrow><mo stretchy="false">{</mo><mrow><mn>1</mn><mo>,</mo><mn>5</mn><mo>,</mo><mn>10</mn><mo>,</mo><mn>25</mn></mrow><mo stretchy="false">}</mo></mrow><mo>&rarr;</mo><msub><mi>&Nopf;</mi><mn>0</mn></msub></mrow></mrow></math>刻画. 我们的问题是存在多少个总值为<math><mn>67</mn></math>的这样的频率函数. 频率函数<math><mi>f</mi></math>的总值即<math display="block"><mrow><mrow><mn>1</mn><mo>&times;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>+</mo><mrow><mn>5</mn><mo>&times;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>+</mo><mrow><mn>10</mn><mo>&times;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>10</mn><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>+</mo><mrow><mn>25</mn><mo>&times;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>25</mn><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math></p><h4>解法.</h4><p>刚才我们并不成系统. 实际上, 答案是<math display="block"><mtable columnalign="left"><mtr><mtd><mrow><mo stretchy="false">(</mo><mrow><mn>1</mn><mo>+</mo><mi>x</mi><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mo>&ctdot;</mo></mrow><mo stretchy="false">)</mo></mrow></mtd><mtd><mo>&times;</mo></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">(</mo><mrow><mn>1</mn><mo>+</mo><msup><mi>x</mi><mn>5</mn></msup><mo>+</mo><msup><mi>x</mi><mn>10</mn></msup><mo>+</mo><msup><mi>x</mi><mn>15</mn></msup><mo>+</mo><mo>&ctdot;</mo></mrow><mo stretchy="false">)</mo></mrow></mtd><mtd><mo>&times;</mo></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">(</mo><mrow><mn>1</mn><mo>+</mo><msup><mi>x</mi><mn>10</mn></msup><mo>+</mo><msup><mi>x</mi><mn>20</mn></msup><mo>+</mo><msup><mi>x</mi><mn>30</mn></msup><mo>+</mo><mo>&ctdot;</mo></mrow><mo stretchy="false">)</mo></mrow></mtd><mtd><mo>&times;</mo></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">(</mo><mrow><mn>1</mn><mo>+</mo><msup><mi>x</mi><mn>25</mn></msup><mo>+</mo><msup><mi>x</mi><mn>50</mn></msup><mo>+</mo><msup><mi>x</mi><mn>75</mn></msup><mo>+</mo><mo>&ctdot;</mo></mrow><mo stretchy="false">)</mo></mrow></mtd></mtr></mtable></math>中<math><msup><mi>x</mi><mn>67</mn></msup></math>的系数, 即<math><mn>87</mn></math>.</p><p>如果我们用<math><msub><mi mathvariant="normal">C</mi><mi>E</mi></msub></math>代表&quot;<math><mi>E</mi></math>的系数&quot;, 那么问题的答案可以记为<math display="block"><mrow><msub><mi mathvariant="normal">C</mi><msup><mi>x</mi><mn>67</mn></msup></msub><mo>&af;</mo><mfrac><mn>1</mn><mrow><mrow><mo stretchy="false">(</mo><mrow><mn>1</mn><mo>&minus;</mo><mi>x</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mn>1</mn><mo>&minus;</mo><msup><mi>x</mi><mn>5</mn></msup></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mn>1</mn><mo>&minus;</mo><msup><mi>x</mi><mn>10</mn></msup></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mn>1</mn><mo>&minus;</mo><msup><mi>x</mi><mn>25</mn></msup></mrow><mo stretchy="false">)</mo></mrow></mrow></mfrac></mrow></math>以这种方式, 我们可以找出其他系数, 或者研究<math><mrow><mi>n</mi><mo lspace="0" rspace="0">&rarr;</mo><mi>&infin;</mi></mrow></math>时<math><msub><mi mathvariant="normal">C</mi><msup><mi>x</mi><mi>n</mi></msup></msub></math>的渐近性质.</p><p>这种方法的正确性是不言自明的. 在合并幂级数乘积的同类项之前, 每一项的系数都是<math><mn>1</mn></math>, 而且其都对应于从每一行的级数里各选出一个项来, 这就从概念上指出了一种挑选方式. 比如说, 项<math><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>&it;</mo><msup><mi>x</mi><mn>10</mn></msup><mo>&it;</mo><msup><mi>x</mi><mn>30</mn></msup><mo>&it;</mo><msup><mi>x</mi><mn>25</mn></msup></mrow></math>对应于使用<math><mn>2</mn></math>枚<math><mn>1</mn></math>分硬币, <math><mn>2</mn></math>枚<math><mn>5</mn></math>分硬币, <math><mn>3</mn></math>枚<math><mn>10</mn></math>分硬币, <math><mn>1</mn></math>枚<math><mn>25</mn></math>分硬币的方案. (译注: 当然, 更严格地说, 这里我们考虑的是项的内涵, 因为从外延看, 我们无法区分次数相同的项.) 在合并同类项之后, <math><msup><mi>x</mi><mi>n</mi></msup></math>的系数显然就等于付<math><mi>n</mi></math>分钱的方式数目.</p><h3>第2.2节 一个求和公式</h3><p>我们猜读者已经熟悉用<math><mrow><mo stretchy="false">|</mo><mi>S</mi><mo stretchy="false">|</mo></mrow></math>表示集合<math><mi>S</mi></math>的元素数目的记号了. 如果<math><mi>R</mi></math>和<math><mi>D</mi></math>是集合, 那么类型为<math><mrow><mi>D</mi><mo>&rarr;</mo><mi>R</mi></mrow></math>的所有映射构成的集合, 我们记作<math><msup><mi>R</mi><mi>D</mi></msup></math>. 公式<math><mrow><mrow><mo stretchy="false">|</mo><msup><mi>R</mi><mi>D</mi></msup><mo stretchy="false">|</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">|</mo></mrow><mrow><mo stretchy="false">|</mo><mi>D</mi><mo stretchy="false">|</mo></mrow></msup></mrow></math>是很好的助记方法.</p><div class="theorem"><b>定理.</b> 令<math><mi>K</mi></math>是一个含幺交换环, <math><mi>D</mi></math>和<math><mi>R</mi></math>是集合. 对于映射<math><mrow><mi>&phiv;</mi><mo>:</mo><mrow><mrow><mi>D</mi><mo>&times;</mo><mi>R</mi></mrow><mo>&rarr;</mo><mi>K</mi></mrow></mrow></math>, 我们有<math display="block"><mrow><mrow><munderover><mo>&sum;</mo><mrow><mi>f</mi><mo>&in;</mo><msup><mi>R</mi><mi>D</mi></msup></mrow><mrow/></munderover><mrow><munderover><mo>&prod;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mrow/></munderover><mrow><mi>&phiv;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mo>=</mo><mrow><munderover><mo>&prod;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mrow/></munderover><mrow><munderover><mo>&sum;</mo><mrow><mi>r</mi><mo>&in;</mo><mi>R</mi></mrow><mrow/></munderover><mrow><mi>&phiv;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><mi>r</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math></div><div class="proof"><b>证明.</b> 显然, 或许唯一值得注意的是边角情况. 若<math><mrow><mi>D</mi><mo>=</mo><mi>&empty;</mi></mrow></math>, 那么左右皆为<math><mn>1</mn></math>. 若<math><mrow><mi>D</mi><mo>&ne;</mo><mi>&empty;</mi></mrow></math>且<math><mrow><mi>R</mi><mo>=</mo><mi>&empty;</mi></mrow></math>, 那么左右皆为<math><mn>0</mn></math>.<div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><p>作为定理的应用, 令<math><mi>K</mi></math>是<math><mi>&Zopf;</mi></math>上的形式幂级数环, <math><mrow><mi>D</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mn>1</mn><mo>,</mo><mn>5</mn><mo>,</mo><mn>10</mn><mo>,</mo><mn>25</mn></mrow><mo stretchy="false">}</mo></mrow></mrow></math>, <math><mrow><mi>R</mi><mo>=</mo><msub><mi>&Nopf;</mi><mn>0</mn></msub></mrow></math>, <math><mrow><mrow><mi>&phiv;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><mi>r</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><msup><mi>x</mi><mrow><mi>d</mi><mo>&it;</mo><mi>r</mi></mrow></msup></mrow></math>, 那么<math display="block"><mrow><mrow><munderover><mo>&prod;</mo><mrow><mi>d</mi><mo>&in;</mo><mi>D</mi></mrow><mrow/></munderover><mrow><mi>&phiv;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>,</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><msup><mi>x</mi><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mtext>的总值</mtext></mrow><mo stretchy="false">)</mo></mrow></msup></mrow></math></p></body></html>