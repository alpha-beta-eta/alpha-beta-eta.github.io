<html><head><meta charset="utf-8"/><title>盲点</title><link href="styles.css" rel="stylesheet"/><link href="french.css" rel="stylesheet"/></head><body><h1>盲点: 逻辑学讲义</h1><p>本书可谓是逻辑学家Jean-Yves Girard的思想之大成.</p><h2>第1章 存在 vs. 本质</h2><h3>第1.1节 存在和本质的对立</h3><p>Kubrick著名的电影<q>2001</q>的开场简直就是智慧的创生, 其来自于从外太空坠落的巨石, 又被赐予了一群愚笨的猴子, 那时它们还无法对付狮子, 野猪, 等等. 我们观察到:<ol type="i"><li><q>伟大的银河族 (great galactics)</q>控制着这智慧, 其像病毒一样传播, 但是这个族群在其幼生期必然也像某种猴子一样, 因此...</li><li>(电影里的)智慧被视为一种绝对的属性, 独立于经验, 独立于互动, 就像是在某种预先存在的硬件之上实现的软件. 若是这巨石落在Galápagos之上的话, 爬虫或许就会统治世界: 开启乌龟时代...</li></ol>实际上, 如果忘掉作者 (Arthur C. Clarke) 那令人倍感折磨的科学主义, 这个开篇可以读作Fátima式的奇迹.</p><p>对于这样一种<q>解释</q>的反应是明显且本能性的: 人们认为这是启发性的还是愚蠢的, 取决于他是<em>本质主义者</em>还是<em>存在主义者</em>.</p><h3>第1.2节 本质主义和存在主义计划</h3><h4>第1.2.1小节 集合论</h4><h4>第1.2.2小节 Hilbert的计划 (the hilbertian project)</h4><p><q>Hilbert纲领</q>, 基本上刻画于1920年左右, 对应于数学的<em>形式主义</em>视角. 这种方式经常被简化为<q>数学是纯粹的symbol pushing, 其意义并不比象棋游戏更多, 唯一重要的只是游戏规则的一致性</q>. 不过, 这种挑衅不应该按照字面理解: Hilbert形式主义的背后是复杂的思考, 即便这种思考是归约主义式的. 尽管完全没有质疑集合论的旨趣, Hilbert对待集合论本质主义的方式却与集合论本身的精神背道而驰, 特别是在无限的方面. 以下是Hilbert想法的一个未经认证的版本. {译注: 大概就是作者并不能自信地声明这就是Hilbert的本意.}<ol type="i"><li>我们关于无限的直觉是具有误导性的; 人们讨论对象, 而人们并没有看见它们. 与之相对的是, 推理 (表达以逻辑形式化) 是真实可感的. 因此, 我们必须要明白什么是一个证明, 在其最数学的方面之下, 即形式化的; 诚然, 也就是理解<em>它有什么用</em>.</li><li>一个证明产生一个定理<math><mi>A</mi></math>, 其可以在另一个证明之中(作为引理)重用, 根据类似于<em>Modus Ponens</em>的规则:<math display="block"><mfrac displaystyle="true"><mrow><mi>A</mi><mspace width="8ex"/><mrow><mi>A</mi><mo>&Implies;</mo><mi>B</mi></mrow></mrow><mi>B</mi></mfrac><mtext>.</mtext></math>接着<math><mi>B</mi></math>可以作为引理用来产生<math><mi>C</mi></math> (给定<math><mrow><mi>B</mi><mo>&Implies;</mo><mi>C</mi></mrow></math>的话), 如此可以继续下去; 这没有带来什么新的东西, 诚然如此, <em>Modus Ponens</em>的一个变种可以产生<math display="block"><mfrac displaystyle="true"><mrow><mrow><mi>A</mi><mo>&Implies;</mo><mi>B</mi></mrow><mspace width="8ex"/><mrow><mi>B</mi><mo>&Implies;</mo><mi>C</mi></mrow></mrow><mrow><mi>A</mi><mo>&Implies;</mo><mi>C</mi></mrow></mfrac><mtext>,</mtext></math>换言之, 我们本可以在<math><mi>A</mi></math>和<math><mrow><mi>A</mi><mo>&Implies;</mo><mi>C</mi></mrow></math>之间作出一个<em>Modus Ponens</em>而直接得到<math><mi>C</mi></math>.</li><li></li></ol></p><h4>第1.2.3小节 Brouwer的计划</h4><p>与Poincaré反对形式主义者的批评 (有时不那么公平, 但总是切中要害) 同出一源, Brouwer提出了一种对于无限的反逻辑主义的重新解读. 如今人们可以辨认出Brouwer和Hilbert的共同之处, 但是我们必须承认, 1920年代他们的关系相当紧张, 类似于牧师Don Camillo (Brouwer) 和共产主义市长Peppone (Hilbert) 之间的对立, 不过没有丝毫隐藏的同情, 障碍在于科学主义. 顺便值得一提的是, Brouwer所建立的学派, 即<em>直觉主义</em>, 主张直觉先于语言. Brouwer并没有拒绝无限 (与Hilbert的有限主义相对, Hilbert只将无限视为一种<em>说话方式(façon de parler)</em>), 但是他拒绝了无限的最Thomist (<q>actual</q>) 的方面; 特别是集合论以及人们可以逐点逐值定义实变量函数的想法. 一些原则在有限的论域之中是有效的, 但是在无限的情形之下不再成立, 典型的例子是排中律<math><mrow><mi>A</mi><mo>&or;</mo><mrow><mo>&not;</mo><mi>A</mi></mrow></mrow></math>. 对于<em>tertium non datur(意即没有第三种情况,即排中律)</em>的通常澄清是一个公式<math><mi>A</mi></math>具有一个真值 (为真或者为假). 然而, 尽管人们可以在有限情形之下<em>计算</em>一个真值, 没有算法可以处理无限多步的验证: 这就是为什么Brouwer说无限的情形是可疑的. 这种方式是相当现代的, 意即真性 (truth) 并不独立于方法, 协议, 验证而存在; 我们应该将其与量子物理联系起来, 并忘掉主观主义, 甚至是唯我论, 有时Brouwer陷入了这歧途.</p><p>我们之后将有机会重访直觉主义, 通过线性逻辑, 其主要作为直觉主义(逻辑)的<q>对称化</q>版本出现. 让我们总结这次短暂的与Brouwer的相遇以两个(想象中的)对于Hilbert的驳论.</p><p><b>Modus Ponens: </b></p><p><b>Tertium non datur: </b>Hilbert接受了排中律; 并非是出于他相信<math><mi>A</mi></math>具有一个预先存在的真值, 而是因为这简化了情况: <q>一种性质, 其什么也不意味, 但也没有代价</q>. 从技术上说, 这种论证是可行的. 的确, 我们知道 (自1932: ) 经典逻辑可以被忠实地翻译为直觉主义逻辑: <q>每个地方 (everywhere)</q>加上双重否定就足够了. 特别地, 排中律, 一旦被翻译为<math><mrow><mo>&not;</mo><mrow><mo>&not;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>&or;</mo><mrow><mo>&not;</mo><mi>A</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, 其就变成直觉主义可证的了, 因而添加这个就不再是<q>有风险</q>的了. </p><h3>第1.3节 G&ouml;del和自此之后</h3><h4>第1.3.1小节 失败和衰落</h4><h3>第1.A节 本质主义 vs. Plato主义 (platonism)</h3><h2>第2章 不完备性</h2><h3>第2.1节 技术性陈述</h3><h4>第2.1.1小节 定理的困难</h4><h4>第2.1.2小节 对角线论证</h4><p>论证方式如下: 给定函数<math><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></mrow></math>和<math><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>, 我们构造<math><mrow><mrow><mi>h</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&colone;</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>x</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>; 如果碰巧<math><mi>h</mi></math>具有形式<math><mrow><mrow><mi>h</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>a</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, 那么我们就得到了<math><mrow><mrow><mi>h</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>,</mo><mi>a</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>,</mo><mi>a</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>; <math><mrow><mi>b</mi><mo>&colone;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>,</mo><mi>a</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>是<math><mi>g</mi></math>的一个不动点, 这显然是意料之外的. 依据上下文, 我们可以推出各种各样的结果, 其中绝大多数都是悖论性的.<ol><li><b>Cantor的paradox: </b><math><mi>&Nopf;</mi></math>和其幂集之间不存在双射. 如果<math><mrow><mo stretchy="false">(</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></math>枚举了<math><mi>&Nopf;</mi></math>的子集, 并且定义<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&colone;</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mn>1</mn></mtd><mtd columnalign="left"><mo>,</mo><mrow><mi>m</mi><mo>&in;</mo><msub><mi>X</mi><mi>n</mi></msub></mrow></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd columnalign="left"><mo>,</mo><mtext>otherwise</mtext></mtd></mtr></mtable></mrow></mrow></math>又定义<math><mrow><mrow><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>&colone;</mo><mn>1</mn></mrow><mo>,</mo><mrow><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mrow><mo>&colone;</mo><mn>0</mn></mrow></mrow></math>, 那么<math><mrow><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>b</mi></mrow></math>, 一个矛盾. {译注: 补充一下细节, 尽管可能人尽皆知. 根据序列<math><mrow><mo stretchy="false">(</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></math>, 我们可以定义一个<math><mi>&Nopf;</mi></math>的子集<math display="block"><mrow><mi>Y</mi><mo>&colone;</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>m</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow><mo stretchy="false">|</mo><mrow><mi>m</mi><mo>&notin;</mo><msub><mi>X</mi><mi>m</mi></msub></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>既然<math><mrow><mo stretchy="false">(</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></math>枚举了<math><mi>&Nopf;</mi></math>的子集, 所以存在<math><mrow><mi>a</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>满足<math><mrow><mi>Y</mi><mo>=</mo><msub><mi>X</mi><mi>a</mi></msub></mrow></math>, 那么<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>a</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mn>1</mn></mtd><mtd columnalign="left"><mo>,</mo><mrow><mi>x</mi><mo>&in;</mo><msub><mi>X</mi><mi>a</mi></msub></mrow></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd columnalign="left"><mo>,</mo><mtext>otherwise</mtext></mtd></mtr></mtable></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mn>1</mn></mtd><mtd columnalign="left"><mo>,</mo><mrow><mi>x</mi><mo>&notin;</mo><msub><mi>X</mi><mi>x</mi></msub></mrow></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd columnalign="left"><mo>,</mo><mrow><mi>x</mi><mo>&in;</mo><msub><mi>X</mi><mi>x</mi></msub></mrow></mtd></mtr></mtable></mrow></mrow></math><math display="block"><mrow><mrow><mi>h</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>x</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo>(</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mn>1</mn></mtd><mtd columnalign="left"><mo>,</mo><mrow><mi>x</mi><mo>&in;</mo><msub><mi>X</mi><mi>x</mi></msub></mrow></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd columnalign="left"><mo>,</mo><mrow><mi>x</mi><mo>&notin;</mo><msub><mi>X</mi><mi>x</mi></msub></mrow></mtd></mtr></mtable></mrow><mo>)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mn>1</mn></mtd><mtd columnalign="left"><mo>,</mo><mrow><mi>x</mi><mo>&notin;</mo><msub><mi>X</mi><mi>x</mi></msub></mrow></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd columnalign="left"><mo>,</mo><mrow><mi>x</mi><mo>&in;</mo><msub><mi>X</mi><mi>x</mi></msub></mrow></mtd></mtr></mtable></mrow></mrow></math>也就是说, <math><mrow><mrow><mi>h</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>a</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.}</li><li><b>Russell的antinomy: </b>相同的故事, <math><mi>&Nopf;</mi></math>被代之以所有集合之集合. 整数变成了任意的集合, 于是定义<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&colone;</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mn>1</mn></mtd><mtd columnalign="left"><mo>,</mo><mrow><mi>x</mi><mo>&in;</mo><mi>y</mi></mrow></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd columnalign="left"><mo>,</mo><mtext>otherwise</mtext></mtd></mtr></mtable></mrow></mrow></math>而<math><mi>g</mi></math>和之前一样, 那么<math><mrow><mi>a</mi><mo>&colone;</mo><mrow><mo stretchy="false">{</mo><mrow><mi>x</mi><mo stretchy="false">|</mo><mrow><mi>x</mi><mo>&notin;</mo><mi>x</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>而<math><mrow><mi>b</mi><mo>&colone;</mo><mrow><mi>a</mi><mo>&in;</mo><mi>a</mi></mrow></mrow></math>, 于是<math><mrow><mrow><mi>a</mi><mo>&in;</mo><mi>a</mi></mrow><mo>&hArr;</mo><mrow><mi>a</mi><mo>&notin;</mo><mi>a</mi></mrow></mrow></math>. {译注: 这里的<math><mn>1</mn></math>相当于真, <math><mn>0</mn></math>相当于假, <math><mi>g</mi></math>相当于否定. 以此解释, 1:相当于推出了<math><mrow><mrow><mi>a</mi><mo>&in;</mo><msub><mi>X</mi><mi>a</mi></msub></mrow><mo>&hArr;</mo><mrow><mi>a</mi><mo>&notin;</mo><msub><mi>X</mi><mi>a</mi></msub></mrow></mrow></math>.}</li><li><b>程序的不动点: </b>如果<math><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></math>枚举了所有将<math><mi>&Nopf;</mi></math>送往<math><mi>&Nopf;</mi></math>的程序, 如果<math><mi>g</mi></math>是<math><msub><mi>f</mi><mi>n</mi></msub></math>中的一个, 那么前述构造可以产生<math><mi>g</mi></math>的一个不动点. 鉴于绝大多数函数并不具有不动点, 我们可以断言不动点往往对应于发散的计算. 典型地, 从<math><mrow><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&colone;</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mrow></math>开始, <math><mrow><mi>a</mi><mo>=</mo><mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow><mo>=</mo><mrow><mi>a</mi><mo>+</mo><mn>2</mn></mrow><mo>=</mo><mo>&ctdot;</mo></mrow></math>, 这表明我们的确是在处理<em>部分</em>函数. {译注: 本来写的内容删掉了, 因为我感到存在细节问题. 对于这样一本被作者Jean-Yves Girard故意写得玄之又玄的书籍, 我只能对于缺失的细节妄加揣测. 似乎是这样, 这里的<math><mi>f</mi></math>是基于序列<math><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></math>的, 也就是<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&colone;</mo><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>. 然后, <math><mrow><mrow><mi>h</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&colone;</mo><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>g</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>x</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&colone;</mo><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>g</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msub><mi>f</mi><mi>x</mi></msub><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>. 或许我们来到了<b>可疑</b>的一步, 作者大概认为存在<math><mrow><mi>a</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>使得<math><mrow><mi>h</mi><mo>=</mo><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msub><mi>f</mi><mi>a</mi></msub><mo stretchy="false">&RightDoubleBracket;</mo></mrow></mrow></math>, 于是<math><mrow><mrow><mi>h</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msub><mi>f</mi><mi>a</mi></msub><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>a</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>. 那么, 可以推出<math><mrow><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>g</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>,</mo><mi>a</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>h</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>,</mo><mi>a</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, 即<math><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><msub><mi>f</mi><mi>a</mi></msub><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow></math>是<math><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>g</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow></math>的一个不动点?}</li><li><b><math><mi>&lambda;</mi></math>演算的不动点: </b>如果<math><mi>M</mi></math>是一个<math><mi>&lambda;</mi></math>项</li><li><b>第一不完备性定理: </b></li></ol></p><h4>第2.1.3小节 编码</h4><h2>第3章 经典相继式: LK</h2><h2>第4章 直觉逻辑: LJ, NJ</h2><h2>第5章 函数式解释</h2><h3>第5.1节 证明作为函数</h3><h4>第5.1.1小节 证明的<q>语义</q></h4><h4>第5.1.2小节 函数式解释</h4><p><b>原子: </b></p><p><b>合取: </b><math><mi>&theta;</mi></math>是<math><mrow><mi>A</mi><mo>&and;</mo><mi>B</mi></mrow></math>的一个证明当且仅当<math><mi>&theta;</mi></math>是一个序对<math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>&theta;</mi><mn>1</mn></msub><mo>,</mo><msub><mi>&theta;</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></math>, 其中<math><msub><mi>&theta;</mi><mn>1</mn></msub></math>是<math><mi>A</mi></math>的一个证明而<math><msub><mi>&theta;</mi><mn>2</mn></msub></math>是<math><mi>B</mi></math>的一个证明.</p><p><b>析取: </b></p><p><b>Implication: </b><math><mi>&theta;</mi></math>是<math><mrow><mi>A</mi><mo>&Implies;</mo><mi>B</mi></mrow></math>的一个证明当且仅当<math><mi>&theta;</mi></math>是一个应用, 其联系<math><mi>A</mi></math>的每个证明<math><msup><mi>&theta;</mi><mo>&prime;</mo></msup></math>以<math><mi>B</mi></math>的一个证明<math><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msup><mi>&theta;</mi><mo>&prime;</mo></msup><mo stretchy="false">)</mo></mrow></mrow></math>. {译注: 一般而言, 我们会将<math><mi>&theta;</mi></math>称为一个函数.}</p><h4>第5.1.3小节 盲点</h4><p>这定义留下了一些盲点. 例如, 既然</p><h3>第5.2节 纯<math><mi>&lambda;</mi></math>演算</h3><h3>第5.3节 Curry-Howard同构</h3><h2>第6章 系统F</h2><h3>第6.1节 系统F</h3><h2>第7章 范畴论式解释</h2><h2>第8章 coherent空间</h2><h2>第9章 线性逻辑</h2><h2>第10章 perfection vs. imperfection</h2><h2>第11章 证明网</h2><h2>第12章 一个假设: 极化</h2><h2>第13章 设计和行为</h2><h2>第14章 Ludics: 重构</h2></body></html>