<html><head><meta charset="utf-8"/><title>实用逻辑和自动推理手册</title><link href="styles.css" rel="stylesheet"/></head><body><h1>实用逻辑和自动推理手册</h1><h2>前言</h2><p>本书是关于可以执行<em>自动推理</em>的计算机程序的. </p><h2>第1章 引论</h2><p>本章我们引入了逻辑推理和机械化它的想法, 简要触及了重要的历史性发展. 我们通过讨论逻辑学中的一些最为基础的想法以及刻画符号方法是如何在计算机上实现的来为后续内容奠定基础.</p><h3>第1.1节 什么是逻辑推理?</h3><p>存在许多理由相信某个东西为真. 它或许似乎是显而易见的, 或许至少第一眼看上去是令人信服的, 可能我们的父母之前告诉过我们, 也可能是其与相关科学实现的结果达成了惊人的一致性. 尽管往往是可靠的, 但是这些判断的方法也并非万无一失, 其也曾被用于说服人们地球是平的, 圣诞老人是存在的, 原子不可被进一步划分为更小的粒子.</p><p><em>逻辑</em>推理相较于其他推理的不同之处在于其会避免任何未经澄清的假设, 并将自身限制于不会出错且超越理性置辩的推理. 为了避免作出任何无法保证的假设, 逻辑推理不能依赖于要被推理的对象或者概念的任何特殊性质. 这意味着逻辑推理必须从所有这样的特殊特征之中抽象出来, 并在应用于其他领域时同等有效 (valid). 论证之所以被接受为逻辑性的(论证), 在于其与某种一般<em>形式</em>的相合, 而非因为其所处理的特定<em>内容</em>. 例如, 将以下的传统例子:<blockquote><pre>所有人都是要死的
Socrates是一个人
因此Socrates是要死的</pre></blockquote>与下列从数学之中抽出的推理进行比较:<blockquote><pre>所有正整数都是四个整数的平方之和
<math><mn>15</mn></math>是一个正整数
因此<math><mn>15</mn></math>是四个整数的平方之和</pre></blockquote>这两个论证都是正确的, 并且具有共同的模式:<blockquote><pre>所有的<math><mi>X</mi></math>都是<math><mi>Y</mi></math>
<math><mi>a</mi></math>是<math><mi>X</mi></math>
因此<math><mi>a</mi></math>是<math><mi>Y</mi></math></pre></blockquote></p><p>这个推理模式是逻辑有效的, 因为其有效性并不依赖于内容: <q>正整数</q>和<q>要死的</q>的含义是无关紧要的. 我们可以将<math><mi>X</mi></math>, <math><mi>Y</mi></math>, <math><mi>a</mi></math>替换为任何我们喜欢的东西, 只要尊重语法范畴即可, 而语句仍然保持有效. 与之相对的是, 考虑以下推理:<blockquote><pre>所有的雅典人都是希腊人
Socrates是一个雅典人
因此Socrates是要死的</pre></blockquote></p><p>尽管这个结论是全然正确的, 但是这个论证并非逻辑有效的, 因为其依赖于所牵涉的项的内容. 其他的具有同样的似是而非形式的论证当然也可能是假的, 例如<blockquote><pre>所有的雅典人都是希腊人
Socrates是一个雅典人
因此Socrates没有胡须</pre></blockquote></p><p>然而, 第一个论证可以转变为一个逻辑有效的论证, 通过将隐式的假设<q>所有的希腊人都是要死的</q>显式化. 现在这个论证是以下一般的逻辑有效的形式的一个实例:<blockquote><pre>所有的<math><mi>G</mi></math>都是<math><mi>M</mi></math>
所有的<math><mi>A</mi></math>都是<math><mi>G</mi></math>
<math><mi>s</mi></math>是<math><mi>A</mi></math>
因此<math><mi>s</mi></math>是<math><mi>M</mi></math></pre></blockquote></p><p>第一眼看上去, 这种对于推理的法医鉴识式分析似乎并不令人印象非常深刻. 逻辑有效的推理从未告诉过我们任何关于世界的本质上新颖的东西&mdash;&mdash;正如Wittgenstein (1922) 所言, <q>当我知道天气要么下雨要么不下雨时, 我对于天气一无所知</q>. 换言之, 如果我们<em>的确</em>从推理的链条之中学到了关于世界的什么新东西, 那么它必然包含<em>并非</em>纯粹逻辑的步骤. Schilpp (1944) 中引用Russell所言:<blockquote>Hegel从纯粹逻辑之中推导出了世界的全部本质, 包括小行星的不存在性, 其之所以能够做到这点, 只是因为他逻辑无能.</blockquote>{原注: 为了对于Hegel公平一些, 我必须要说词汇<em>逻辑</em>直到相当的最近都常以更为宽泛的含义使用, 而我们所考虑的逻辑在那时应该被称为<em>演绎逻辑</em>, 用以和<em>归纳逻辑</em>进行区分, 后者从观察到的数据之中得出结论, 如在物质科学 (physical sciences) 里的那样.}</p><p>但是逻辑分析可以清晰地揭示关于真实世界的<em>事实</em>之间的必要关系, 直接地表明何处掺入了或许不能保证的假设. 例如, 根据<q>如果刚刚下过雨, 那么地面是潮湿的</q>可以逻辑推出<q>如果地面并非超市, 那么刚刚就不可能下过雨</q>. 这是被称为<em>逆否</em>的一般原理的一个实例: 从<q>如果<math><mi>P</mi></math>那么<math><mi>Q</mi></math></q>可以推出<q>如果非<math><mi>Q</mi></math>那么非<math><mi>P</mi></math></q>. 然而, 从<q>如果<math><mi>P</mi></math>那么<math><mi>Q</mi></math></q>到<q>如果<math><mi>Q</mi></math>那么<math><mi>P</mi></math></q>一般<em>并非</em>有效, 在这种情况下就是我们发现我们不能推出<q>如果地面是潮湿的, 那么刚刚下过雨</q>, 因为也可能是由于爆裂的水管或者灌溉设施什么的才导致了潮湿.</p><p>或许正如Locke (1689) 所言, 这样的例子可能是<em>琐碎的</em>, 不过这种初等的逻辑谬误我们也经常会遇到. 更为重要的是, 数学之中的演绎远非琐碎所能概括, 而是一直使人类历史之中的一些伟大智者深深着迷, 经常也使得他们感到挫败. 从简单而不可辩驳的假设出发, 经过漫长而复杂的逻辑演绎链条, 可以通往复杂且违反直觉的定理, 正如Hobbes所发现的 (Aubrey 1898):<blockquote>在一位绅士的私人书房里, Euclid的原本摊开着, 上面写着</blockquote></p><p>的确, Euclid的开创性作品<em>几何原本</em>建立了一种特定的推理风格, 其经完善之后构成了如今数学的脊骨. </p><h3>第1.2节 Calculemus!</h3><p><q>推理就是算账 (reckoning).</q> 在本书的卷首语中我们引用了Hobbes关于逻辑推理和数值计算之间的相似性的阐述. 尽管Hobbes应该因为使得这个想法更为广为人知而受到嘉奖, 这个想法本身即便在1651年也不是全新的. 的确由Plato和Aristotle所使用以代表推理或者逻辑思维的希腊词汇<em>logos</em>在其他上下文中也可能表示计算或者算账. 当古希腊哲学家的作品在中世纪的欧洲广为人知的时候, <em>logos</em>一般被翻译为<em>ratio</em>, 这是代表算账的拉丁词汇 (因而有了英语词汇rational, ratiocination, 等等). 即便在如今的英语里, 我们有时也能听到<q>I reckon that ...</q>, 这里的<q>reckon</q>指的是某种推理而并非字面意义上的要去计算.</p><p>然而, 推理和算账之间的联系在Gottfried Wilhelm von Leibniz (1646–1716) 的作品之前几乎只是一种暗示性的口号. Leibniz相信一个根据计算进行推理的系统必须包含两个基本组件:<ul><li>一种通用语言 (<em>characteristica universalis</em>), 由此可以表达任意的东西;</li><li>一种推理演算 (<em>calculus ratiocinator</em>), 用于判定以<em>characteristica</em>表达的断言的真假.</li></ul></p><p>Leibniz梦想着有朝一日不能达成一致意见的双方不会陷入徒劳的争辩, 而是将他们的不一致转换为<em>characteristica</em>, 然后彼此言称<q>calculemus</q> (让我们计算吧). </p><h3>第1.3节 符号化</h3><p>Leibniz将注意力放在建立合适的语言这一基本的首要步骤上是正确的. 然而, 他太过雄心壮志以至于想要表达人类思维的所有方面. 最终的进步来自于扩展已经在数学中所使用的符号记号的应用范围. 例如, 如今我们会说<q><math><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>&le;</mo><mrow><mi>y</mi><mo>+</mo><mi>z</mi></mrow></mrow></math></q>而非<q><math><mi>x</mi></math>乘上自身小于等于<math><mi>y</mi></math>与<math><mi>z</mi></math>之和</q>. 随着时间推移, 越来越多的数学开始以形式符号记号表达, 取代了自然语言渲染. 对此我们可以找到几个坚实的理由.</p><h3 id="algebra-of-logic">第1.4节 Boole的逻辑代数</h3><p>词汇<em>algebra</em>来源于阿拉伯语的<q>al-jabr</q>, </p><h4>第1.4.1小节 机械化</h4><h4>第1.4.2小节 逻辑形式</h4><h3>第1.5节 句法和语义</h3><h4>第1.5.1小节 对象语言和元语言</h4><h4>第1.5.2小节 抽象和具体句法</h4><h3 id="symbolic-computation-and-ocaml">第1.6节 符号计算和OCaml</h3><p>现代计算的早期人们普遍相信计算机基本上是用来进行数值计算的设备 (Ceruzzi 1983). 其输入和输出设备确实也在某种程度上偏向于这一方向: 当Samuels在1948年于IBM写下第一个跳棋程序时, 他不得不将输出编码为一个数字, 因为这就是唯一可以打印的内容了. 然而, 即便在</p><p>第一个任务是定义一个数据类型以表示代数表达式的抽象句法. 我们允许表达式由诸如<code>0</code>, <code>1</code>, <code>33</code>这样的数值常量以及诸如<code>x</code>和<code>y</code>这样的命名变量通过加法 (<q><code>+</code></q>) 和乘法 (<q><code>*</code></q>) 运算构筑而成. 以下是相应的递归数据类型声明:<pre><code>type expression =
   Var of string
 | Const of int
 | Add of expression * expression
 | Mul of expression * expression;;</code></pre></p><h3>第1.7节 句法分析 (parsing)</h3><h4>第1.7.1小节 词法分析</h4><h4>第1.7.2小节 句法分析</h4><h3>第1.8节 美观打印 (prettyprinting)</h3><h3>第1.9节 深入阅读</h3><h3>第1.10节 练习</h3><h2>第2章 命题逻辑</h2><p>我们将会仔细研究命题逻辑, 在OCaml之中定义其形式句法, 连带着句法分析和打印支持. 我们将会讨论一些关键性的命题算法, 并证明紧致性定理, 还会指明命题定理证明的丰富应用.</p><h3>第2.1节 命题逻辑的句法</h3><p>命题逻辑是<cite>第<a href="#algebra-of-logic">1.4</a>节</cite>所呈现的Boole的命题代数的一种现代版本. {原注: 诚然如此, 命题逻辑有时被称为<q>Boole代数</q>. 但是, 这容易令人感到困惑, 因为数学家将一切满足特定公理的代数结构都称为Boole代数, 大致上这些公理是通常的代数律连带着<math><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>=</mo><mi>x</mi></mrow></math> (Halmos 1963).} {译注: 这说的是Boole环, 可以被定义为含幺元的幂等环.} 其牵涉被称为<em>公式</em>的表达式, 而公式的意图是表示命题, 即可以被认为是真或者假的断言. {原注: 当查阅文献时, 读者或许会发现用的是术语<em>合式公式</em> (缩写为wff) 而非仅仅<q>公式</q>. 这是为了强调在具体句法之中, 我们仅仅关心具有句法合法形式的字符串, 而非任意的符号的(字符)串.} 这些公式可以由常量<q>true</q>和<q>false</q>以及一些基本的<em>原子命题</em> (或者说<em>原子</em>) 通过各种逻辑联结词 (<q>not</q>, <q>and</q>, <q>or</q>, 等等) 构筑而成. 原子命题类似于通常代数之中的变量, 有时我们将其称为<em>命题变量</em>或者<em>Boole变量</em>. 正如词汇<q>原子</q>所暗示的, 我们并不会分析其内在结构; 当我们在下一章中处理一阶逻辑时则要进行考虑.</p><h4>第2.1.1小节 OCaml中的表示</h4><p>我们使用一个OCaml数据类型来表示命题公式, 这可以类比于<cite>第<a href="#symbolic-computation-and-ocaml">1.6</a>节</cite>里的表达式类型. 我们允许<q>常量</q>命题<code>False</code>和<code>True</code>以及原子命题<code>Atom p</code>, 并且可以由它们通过使用幺元运算符<code>Not</code>以及二元联结词<code>And</code>, <code>Or</code>, <code>Imp</code> (<q>implies</q>), <code>Iff</code> (<q>if and only if</q>) 构筑公式. 我们将对于这些联结词的确切含义的讨论推后, 先来处理立即有用的部分.</p><p>原子命题的潜在集合很大程度上是任意的, 尽管对于某些目的而言其应该是无限的, 以避免限制我们所能考虑的公式的复杂度. 在抽象处理之中原始命题往往就是用数字索引的. 我们令原子命题的潜在类型<code>'a</code>为公式类型的定义的一个参数, 由此许多基本函数可以不管该类型为何而一样工作. 当我们考虑扩展至一阶逻辑时, 这种乍看上去空洞的泛化有助于避免重复工作. 出于相同的理由, 我们包含了两个额外的公式类型构造子<code>Forall</code>和<code>Exists</code>. 这些在本章中大致上会被忽略, 不过其作用将会在之后变得清晰.<pre><code>type ('a)formula = False
                 | True
                 | Atom of 'a
                 | Not of ('a)formula
                 | And of ('a)formula * ('a)formula
                 | Or of ('a)formula * ('a)formula
                 | Imp of ('a)formula * ('a)formula
                 | Iff of ('a)formula * ('a)formula
                 | Forall of string * ('a)formula
                 | Exists of string * ('a)formula;;</code></pre></p><h4>第2.1.2小节 具体句法</h4><p>正如我们之前所见, Boole对于逻辑联结词使用了传统的代数符号, 例如<q><math><mo>+</mo></math></q>. 这使得许多逻辑事实看起来令人迷惑地熟悉, 例如<math display="block"><mrow><mrow><mi>p</mi><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>q</mi><mo>+</mo><mi>r</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>p</mi><mo>&it;</mo><mi>q</mi></mrow><mo>+</mo><mrow><mi>p</mi><mo>&it;</mo><mi>r</mi></mrow></mrow></mrow></math></p><p>但是有些逻辑事实看起来就相当奇怪了, 例如若是将第一个公式中的<q>and</q>和<q>or</q>系统地交换, 则可以得到以下事实:<math display="block"><mrow><mrow><mi>p</mi><mo>+</mo><mrow><mi>q</mi><mo>&it;</mo><mi>r</mi></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>p</mi><mo>+</mo><mi>q</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>p</mi><mo>+</mo><mi>r</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>{译注: 注意这里遵循惯例, 乘法先于加法进行计算.}</p><p>以逻辑的伪装这是在说如果<math><mi>p</mi></math>成立或者<math><mi>q</mi></math>和<math><mi>r</mi></math>都成立, 那么<math><mi>p</mi></math>或<math><mi>q</mi></math>成立, 且<math><mi>p</mi></math>或<math><mi>r</mi></math>成立, 反之亦然. 稍加思考则可令读者确信的确如此; 回忆一下<q><math><mi>p</mi></math>或<math><mi>q</mi></math></q>是可兼的, 即包含同时成立的情况.</p><p>为了避免困惑或者是由通常代数产生误导性的类比, 我们将会对于联结词使用如今业已标准化了的特殊符号. 下表的每一行我们给出了每种构造的英语读法, 之后跟着的是我们在讨论中所采用的标准符号化, 然后是我们在程序中所支持的ASCII近似化, 相应的抽象句法构造, 以及其他一些可能会用到的符号化. (最后一列如果只是阅读本书则可以忽略, 但是在参考其他文献时则会很有用.)<table align="center" border="1" style="border-collapse: collapse;"><tr><td>英语</td><td>符号</td><td>ASCII</td><td>OCaml</td><td>其他符号</td></tr><tr><td>false</td><td><math><mi>&bottom;</mi></math></td><td><code>false</code></td><td><code>False</code></td><td><math><mrow><mn>0</mn><mo>,</mo><mi>F</mi></mrow></math></td></tr><tr><td>true</td><td><math><mi>&top;</mi></math></td><td><code>true</code></td><td><code>True</code></td><td><math><mrow><mn>1</mn><mo>,</mo><mi>T</mi></mrow></math></td></tr><tr><td><span>not <math><mi>p</mi></math></span></td><td><math><mrow><mo>&not;</mo><mi>p</mi></mrow></math></td><td><code>~p</code></td><td><code>Not p</code></td><td><math><mrow><mover><mi>p</mi><mo>&OverBar;</mo></mover><mo>,</mo><mrow><mo>&minus;</mo><mi>p</mi></mrow><mo>,</mo><mrow><mo>~</mo><mi>p</mi></mrow></mrow></math></td></tr><tr><td><span><math><mi>p</mi></math> and <math><mi>q</mi></math></span></td><td><math><mrow><mi>p</mi><mo>&and;</mo><mi>q</mi></mrow></math></td><td><code>p /\ q</code></td><td><code>And(p,q)</code></td><td><math><mrow><mrow><mi>p</mi><mo>&it;</mo><mi>q</mi></mrow><mo>,</mo><mrow><mi>p</mi><mo>&amp;</mo><mi>q</mi></mrow><mo>,</mo><mrow><mi>p</mi><mo>&sdot;</mo><mi>q</mi></mrow></mrow></math></td></tr><tr><td><span><math><mi>p</mi></math> or <math><mi>q</mi></math></span></td><td><math><mrow><mi>p</mi><mo>&or;</mo><mi>q</mi></mrow></math></td><td><code>p \/ q</code></td><td><code>Or(p,q)</code></td><td><math><mrow><mrow><mi>p</mi><mo>+</mo><mi>q</mi></mrow><mo>,</mo><mrow><mi>p</mi><mo>|</mo><mi>q</mi></mrow></mrow></math></td></tr><tr><td><span><math><mi>p</mi></math> implies <math><mi>q</mi></math></span></td><td><math><mrow><mi>p</mi><mo>&Implies;</mo><mi>q</mi></mrow></math></td><td><code>p ==> q</code></td><td><code>Imp(p,q)</code></td><td><math><mrow><mrow><mi>p</mi><mo>&rarr;</mo><mi>q</mi></mrow><mo>,</mo><mrow><mi>p</mi><mo>&sup;</mo><mi>q</mi></mrow></mrow></math></td></tr><tr><td><span><math><mi>p</mi></math> iff <math><mi>q</mi></math></span></td><td><math><mrow><mi>p</mi><mo>&hArr;</mo><mi>q</mi></mrow></math></td><td><code>p &lt;=> q</code></td><td><code>Iff(p,q)</code></td><td><math><mrow><mrow><mi>p</mi><mo>&harr;</mo><mi>q</mi></mrow><mo>,</mo><mrow><mi>p</mi><mo>&equiv;</mo><mi>q</mi></mrow><mo>,</mo><mrow><mi>p</mi><mo>~</mo><mi>q</mi></mrow></mrow></math></td></tr></table></p><p>符号<q><math><mo>&or;</mo></math></q>来源于拉丁词汇<q>vel</q>的首字母, 其意为可兼或. </p><h4>第2.1.3小节 Generic parsing and printing</h4><h4>第2.1.4小节 原始命题</h4><p>尽管许多函数将会是通用的 (generic), 但是如果我们固定在一个确定的原始命题类型上, 对于某些操作进行实验会更加简单. 据此我们定义了以下的原始命题类型, 其由名字索引 (即字符串):<pre><code>type prop = P of string;;</code></pre>我们定义以下函数来获取一个命题的名字:<pre><code>let pname(P s) = s;;</code></pre></p><h4>第2.1.5小节 句法操作</h4><p>如果我们能有对应于公式构造子的句法操作作为正常的OCaml函数可用是很方便的:<pre><code>let mk_and p q = And(p,q) and mk_or p q = Or(p,q)
and mk_imp p q = Imp(p,q) and mk_iff p q = Iff(p,q)
and mk_forall x p = Forall(x,p) and mk_exists x p = Exists(x,p);;</code></pre></p><p>对偶地, 往往能够解构公式而不需要显式的模式匹配也是方便的. 以下这个函数解构了一个<em>等价</em> (或者说<em>biimplication</em>, 或者说<em>biconditional</em>), 即将具有形式<math><mrow><mi>p</mi><mo>&hArr;</mo><mi>q</mi></mrow></math>的公式转换为序对<math><mrow><mo stretchy="false">(</mo><mrow><mi>p</mi><mo>,</mo><mi>q</mi></mrow><mo stretchy="false">)</mo></mrow></math>:<pre><code>let dest_iff fm =
  match fm with Iff(p,q) -> (p,q) | _ -> failwith &quot;dest_iff&quot;;;</code></pre></p><h3>第2.2节 命题逻辑的语义</h3><p>既然命题公式意在表示可能为真或者为假的断言, 一个公式的最终含义只是两个<em>真值</em><q>true</q>和<q>false</q>中的一个. 然而, 正如像<math><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mn>1</mn></mrow></math>这样的一个代数表达式当我们知道变量<math><mi>x</mi></math>和<math><mi>y</mi></math>所代表的东西之后只有一个确切的含义, 一个命题公式的含义依赖于被分配给其原子公式的真值. 这种分配在一个<em>赋值(valuation)</em>之中进行编码, 赋值是一个从原子的集合到真值的集合<math><mrow><mo stretchy="false">{</mo><mrow><mi>false</mi><mo>,</mo><mi>true</mi></mrow><mo stretchy="false">}</mo></mrow></math>的函数. 给定一个公式<math><mi>p</mi></math>和一个赋值<math><mi>v</mi></math>, 然后我们可以根据下列递归定义的函数求得总体的真值:<pre><code>let rec eval fm v =
  match fm with
    False -> false
  | True -> true
  | Atom(x) -> v(x)
  | Not(p) -> not(eval p v)
  | And(p,q) -> (eval p v) &amp; (eval q v)
  | Or(p,q) -> (eval p v) or (eval q v)
  | Imp(p,q) -> not(eval p v) or (eval q v)
  | Iff(p,q) -> (eval p v) = (eval q v);;</code></pre></p><p>这是我们对于命题逻辑的数学<em>定义</em>, 意在作为对于我们的直觉的自然形式化. {原注: 我们也可以选择将部分求值了的<code>eval p</code>, 即一个从赋值到值的函数, 视为公式<code>p</code>的语义, 而非将赋值当作额外的参数. 这主要只是一种术语问题.} (implication的语义并不显然, 之后我们将详细讨论.) 每个逻辑联结词都由OCaml的内置类型<code>bool</code>上的一个相应运算子所解释. </p><h4>第2.2.1小节 机械化了的真值表</h4><p>我们期望对于一个公式的求值独立于赋值如何给没有出现在公式之中的原子分配真值. 让我们通过定义一个提取公式之中所出现的原子命题的集合的函数来使得我们的表述精确化. 以抽象的数学术语来说, 我们将通过公式上的递归定义<code>atoms</code>如下:<math display="block"><mtable columnalign="right center left" displaystyle="true"><mtr><mtd><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&bottom;</mi><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mi>&empty;</mi></mtd></mtr><mtr><mtd><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>&top;</mi><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mi>&empty;</mi></mtd></mtr><mtr><mtd><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo></mrow></mtd></mtr><mtr><mtd><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mo>&not;</mo><mi>p</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mrow></mtd></mtr><mtr><mtd><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>p</mi><mo>&and;</mo><mi>q</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&cup;</mo><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>p</mi><mo>&or;</mo><mi>q</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&cup;</mo><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>p</mi><mo>&Implies;</mo><mi>q</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&cup;</mo><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>p</mi><mo>&hArr;</mo><mi>q</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&cup;</mo><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr></mtable></math></p><p>作为公式上的结构归纳证明的一个简单例子 (见附录1和2), 我们将会证明<math><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mrow></math>总是有限的, 因而我们可以基于ML的列表来解释它而并没有曲解其含义. (当然了, 我们需要记住一般情况下列表相等性和集合相等性并不相同.) {译注: 我的理解大概就是这里可以使用列表表示集合, 仅此而已.}</p><div class="theorem"><b>定理2.1. </b>对于任意的命题公式<math><mi>p</mi></math>, 集合<math><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mrow></math>是有限的.</div><div class="proof"><b>证明.</b> <div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><p>类似地, 我们可以形式化地澄清以上所提及的直觉上显然的事实.</p><div class="theorem"><b>定理2.2. </b>对于任意的命题公式<math><mi>p</mi></math>, 如果两个赋值<math><mi>v</mi></math>和<math><msup><mi>v</mi><mo>&prime;</mo></msup></math>在集合<math><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mrow></math>上相合, 即对于每个<math><mrow><mi>x</mi><mo>&in;</mo><mrow><ms>atoms</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>都有<math><mrow><mrow><mi>v</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msup><mi>v</mi><mo>&prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, 那么<math><mrow><mrow><ms>eval</ms><mspace width="2ex"/><mi>p</mi><mspace width="2ex"/><mi>v</mi></mrow><mo>=</mo><mrow><ms>eval</ms><mspace width="2ex"/><mi>p</mi><mspace width="2ex"/><msup><mi>v</mi><mo>&prime;</mo></msup></mrow></mrow></math>.</div><div class="proof"><b>证明.</b> <div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><p>以上<code>atoms</code>的定义可以被直接翻译为一个OCaml函数, 例如对于<q><math><mo>&cup;</mo></math></q>使用<code>union</code>而对于<q><math><mrow><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo></mrow></math></q>使用<code>[x]</code>. 然而, 我们更倾向于基于既有的迭代子<code>atom_union</code>:<pre><code>let atoms fm = atom_union (fun a -> [a]) fm;;</code></pre>例如:<pre><code># atoms &lt;&lt;p /\ q \/ s ==> ~p \/ (r &lt;=> s)>>;;
- : prop list = [P &quot;p&quot;; P &quot;q&quot;; P &quot;r&quot;; P &quot;s&quot;]</code></pre></p><p>鉴于对于一个命题公式<math><mi>p</mi></math>的解释</p><h4>第2.2.2小节 形式语言和自然语言</h4><h3>第2.3节 有效性, 可满足性, 重言</h3><h3>第2.4节 De Morgan律, 充分性, 对偶性</h3><h3>第2.5节 化简和否定范式</h3><h3>第2.6节 析取范式和合取范式</h3><h3>第2.7节 命题逻辑的应用</h3><h2>第3章 一阶逻辑</h2><p>我们现在从命题逻辑移至更为丰富的一阶逻辑, 其中命题可以牵涉全称或者存在量化的非命题变元. 我们将会展现一阶逻辑之中的证明是如何可以藉由Herbrand定理被朴素地机械化的. 接着我们将会引入诸多改进, 特别是合一 (unification), 其可以使得自动化证明更加高效.</p><h3>第3.1节 一阶逻辑及其实现</h3><p>命题逻辑只允许我们从原始命题构建公式, 原始命题本身或许是独立地为真或者为假. </p><h3>第3.2节 句法分析和打印</h3><h3>第3.3节 一阶逻辑的语义</h3><h3>第3.4节 句法操作</h3><h2>第4章 相等性</h2><h2>第5章 可判定问题</h2><h2>第6章 交互式定理证明</h2><h2>第7章 限制</h2></body></html>