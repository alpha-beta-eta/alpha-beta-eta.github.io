<html><head><meta charset="utf-8"/><title>拓扑via逻辑</title><link href="styles.css" rel="stylesheet"/></head><body><h1>拓扑via逻辑</h1><p>这是一本非主流拓扑入门教科书.</p><h2>序言</h2><p>目前已经有太多拓扑学导引书籍可看了, 那么新来者就必须澄清其存在的必要性. 本书基于在帝国理工所讲授的研究生课程, 并且其主题和方法来源于看待拓扑的特定角度, 而这种角度是受到理论计算机科学所启发的. 本书主要是需要学习拓扑的计算机科学家的. 然而, 数学家或许也会对此感兴趣, 因为其将不同的光投射到了这个领域.</p><h2>第1章 引论</h2><p>历史回顾</p><p>拓扑学的起源和我们将要工作的上下文相当不同, 我们最好在这里将关于拓扑是什么的一些不同想法进行比较.</p><ol type="I"><li>第一种想法是关于<em>橡皮膜几何(rubber sheet geometry)</em>的, 也就是说在这种几何里我们并不在意拉伸空间. 这种几何完全不在乎距离或者角度; 其想要回答这样的问题, <q>这个对象里有没有一个洞?</q> (尽管拉伸是允许的, 撕裂是不允许的.) Martin Gardner [66] 曾说, <q>拓扑学家无法区分咖啡杯和甜甜圈</q>, 原因在于它们每个都恰拥有一个贯穿的洞. 根据橡皮膜几何它们是等价的, 因为若是它们均由延展性足够好的材料制成, 那么其中一个可以变形为另一个. (咖啡杯算数的那个洞是你为了拿起杯子而把手指放进去的那个. 放咖啡的地方不过只是凹陷. 当然, 另外我们所想的甜甜圈是最经典的环状甜甜圈.)</li><li>对于边界的研究. 既然撕裂会在橡皮膜拓扑中产生变化, 既然撕裂会在橡皮膜中创造新的边界, 似乎边界是一种值得检视的重要东西. 边界点的特征是不论你如何凑近去看, 你总能看到有些邻近的点在集合里面, 又有些邻近的点在集合外面.</li><li>对于开集和闭集的抽象研究. 下一步是抽象的步骤. 我们忘记所有的几何, 只是取<q>点</q>的抽象集合, 即<em>拓扑空间</em>. 我们将一些特定的子集刻画为<em>开集</em>, 而开集的补为<em>闭集</em>, 并且要保证特定的公理 (应该归功于Hausdorff) 得到满足. 那么, 我们就将第II阶段的拓扑论证转换到了这一抽象场景之中.</li><li>locale理论. 接着的一步是甚至忘记点, 只是取<q>开集</q>的抽象集合, 其带有抽象的代数运算用以表示并和交. 这种结构是一个<em>frame</em>. 有时, 点可以由这开集的frame重构.<br/>这似乎是抽象的终极, 不过我们将会看到对于<em>逻辑</em>的考虑将会使其成为合适的起点, 自这个阶段我们往回探究.</li></ol><h3>Hausdorff空间</h3><p>开集的拓扑公理是极其一般的, 其所涵盖的情况远不止那些由橡皮膜几何的想法所生发的. 因此在实践中, 拓扑学家会应用额外的公理来限制所能考虑的空间. 一种非常常见的公理是<em>Hausdorff分离公理</em>, 其是说任意两个不同的点都可由两个不相交的开集所分别包裹. 主流拓扑学所处理的是这些<em>Hausdorff空间</em>.</p><p>然而在计算机科学里, 拓扑是用来解释信息的近似状态的: 一个点集既包含近似的点又包含更为精化 (refined) 的点. 其与拓扑相关的性质在于如果一个开集包含有某个近似点, 那么其也必然该点的任意精化. 因此, 近似点和其精化不可能由不相交的开集所分离, 也就是说这种拓扑空间不可能是Hausdorff的. 这意味着计算机科学中所使用的拓扑, 至少对于这里所描述的方法而言, 与主流方向相异, 尽管这仍然是拓扑.</p><p>本书以不同寻常的方式接近拓扑学, 从frame和基于逻辑的对于frame的解释开始, 而以不同寻常的应用作结&mdash;&mdash;计算机科学中所使用的非Hausdorff拓扑. 对于计算机科学家而言本书意在提供自足的导引, 但是作为通往更为传统的应用的一条路径, 其意在对于已有太多的标准导引书籍的内容进行补充.</p><h3>其他可读书籍</h3><p>对于橡皮膜几何, 可以浏览Martin Gardner的Scientific American专栏<q>Mathematical Puzzles and Diversions</q>的合集. Gardner [63] 和 [86] 都包含相关文章.</p><p>对于拓扑的传统方法, 其更注重于Hausdorff空间, 可选的材料是相当广泛的. 一种标准教材是Kelley的<q>General Topology</q> [55].</p><p>若要学习更多locale理论相关内容, 极好的书籍是Johnstone的<q>Stone Spaces</q> [82]. 不过, 这本书后面的章节需要对于传统拓扑相当熟悉.</p><h3>范畴论</h3><h2>第2章 肯定性和否定性断言</h2><p>本章我们将会见到一种有限观察的逻辑, 并且这将作为我们想要研究的概念.</p><p>关于拓扑是什么的最终想法是<em>一种信息理论</em>. 为了启发这种想法, 让我们检视断言可能拥有的一些性质, 断言的一个例子是<blockquote><q>我的宝宝拥有灰色的眼睛.</q></blockquote></p><p>显然的问题是, <q>这是对是错?</q> 嗯, 以下就是我的宝宝了, 所以让我们看看:</p><p>对于本书的精装版的读者而言, 不带犹豫即可同意她拥有灰色的眼睛. 但是对于单色版本的读者而言, 在等到足够买得起精装版之前, 可以考虑最终答案可能有哪些情况.</p><p>首先, 我们可能同意她的眼睛的确是灰色的&mdash;&mdash;我们可以<b>肯定 (affirm)</b>这个断言.</p><p>其次, 我们或许会同意她的眼睛是别的什么颜色, 例如棕色&mdash;&mdash;我们可以<b>否定 (refute)</b>这个断言.</p><p>接着, 我们可能什么也不能同意; 不过若是租一个足够强大的颜色分析仪, 它或许可以帮我们进行决定.</p><p>然后, 宝宝或许在爷爷奶奶家里, 所以说我们还要等.</p><p>..., 勤奋的读者或许还可以想出更多的可能.</p><p>以这些反刍思考为基础, 我们可以画一个Venn图, 其中每个点都是一种<b>情况</b>, 或者说实际的颜色. 所有的边缘情况都是具有争议的, 所以说对应于同意的集合&mdash;&mdash;不论肯定还是否定&mdash;&mdash;都是<em>开集</em> (没有边界点).</p><p>因此, 给定一个断言, 我们可以提问<ul><li>在何种情况下它可以被肯定?</li><li>在何种情况下它可以被否定?</li></ul></p><p>注意到这些肯定和否定应当以我们所能观察到的事实为基础. 一个观察必须要在有限时间内完成, 只需要有限的工作量. 为了强调这点, 我们将会称其为<em>有限</em>观察. 一个有限观察本身在其逻辑内容上是中立的. 其可以正面运用以肯定一个断言 (更具体地说, 即断言<q>这个观察可以作成</q>), 或者反面运用以否定一个断言 (<q>这个观察不可能作成</q>). 然而, 我们倾向于采取正面的观念以赋予观察隐式的逻辑内容.</p><p>既已建立了在何种情况下断言可以被肯定或者否定, 现在让我们问何时其为真或假. 在目前的情形之下, 断言得到了肯定 (的确毋庸置疑眼睛是灰色的), 因此确定为真. 然而, 在本书初稿的时候, 眼睛的颜色毋庸置疑是蓝色: 故之前的话断言应该被否定, 确定为假. 自那时起发生了什么? 何时断言由真变为假了呢?</p><p>答案依赖于我们如何对于所有的边界情形进行分类. 能做的方式有很多种, 但是我们可以看到两种极端情况. 如果我们称所有的边界情况断言为假, 那么<q>真</q>的含义就是<q>肯定为真 (affirmably true)</q>. 在Venn图中, 这意味着对应于为真的集合是开集. 让我们称这种解释为<em>肯定性的(affirmative)</em>:<blockquote>一个断言是肯定性的, 当且仅当其在恰是可以肯定的情况下为真.</blockquote></p><p>从另一方面来说, 我们可以将所有边界情况算作为真, 所以说此时<q>真</q>意味着<q>不可反驳 (否定)</q>, 对应于为真的集合是闭集. 让我们称这种解释为<em>否定性的(refutative)</em>:<blockquote>一个断言是否定性的, 当且仅当其恰在可以否定的情况下为假.</blockquote></p><p>注记: 不可反驳通常被视为和<q>确定为真</q>同意. 正如Popper [63] 所指出的, 其正确的含义应该是<q>永远不能表明肯定为假</q>, 这要弱得多. 用他的话来说, <q>不可反驳性不是一个理论的美德 (如人们通常所认为的), 而是罪恶.</q></p><h3>肯定性断言和否定性断言的逻辑</h3><p>我们看到, 对于简单断言<q>我的宝宝有灰色的眼睛</q>, 其真值是一个解释问题, 它可以被解释为肯定性的, 否定性的, 或以其他混合方式来理解. 一旦为简单断言确定了真值解释, 那么对于用<q>与</q>和<q>或</q>等逻辑联结词构造的复合断言, (其真值)就遵循经典逻辑的标准方式. 我们现在要做的是以一种非形式化但系统的方式来探究, 当你将这些逻辑联结词用于肯定性或否定性断言时会发生什么. 复合断言仍然是肯定性的还是否定性的吗?</p><ol><li>否定 (not, <math><mo>&not;</mo></math>)<br/>为了肯定<math><mrow><mo>&not;</mo><mi>P</mi></mrow></math>, 我们需要作成某个有限观察来表明<math><mi>P</mi></math>确定为假. 换言之, 我们必须否定<math><mi>P</mi></math>. 这就能推出<math><mrow><mo>&not;</mo><mi>P</mi></mrow></math>是肯定性的当且仅当<math><mi>P</mi></math>是否定性的. {译注: 这段话其实不容易理解, 但要义是肯定<math><mrow><mo>&not;</mo><mi>P</mi></mrow></math>这个断言与否定<math><mi>P</mi></math>这个断言是等价的. 也就是说, 边界情况不变, <math><mrow><mo>&not;</mo><mi>P</mi></mrow></math>将肯定和否定交换了位置. 但是, <math><mrow><mo>&not;</mo><mi>P</mi></mrow></math>的真值本身相当于一种补运算.} 因此, 否定将肯定性断言转换为否定性断言, 将否定性断言转换为肯定性断言.<br/>作为一个例子, 取<math><mi>P</mi></math>为陈述<q>有的渡鸦不是黑色的.</q> 这是肯定性的而非否定性的. </li><li></li></ol><h2>第3章 frame</h2><p>本章我们将建立一种有限观察逻辑的代数理论: 其代数(结构)为frame.</p><h3>第3.1节 将逻辑代数化</h3><p>我们将会应用逻辑学中一个相当标准的技术, 也就是将逻辑等价的公式等同起来, 或者说视为相等的. 如此这般逻辑联结词就成为了<em>服从法则的代数运算</em>, 并且我们可以使用代数方法来证明等价. 例如, 我们有<math display="block"><mrow><mrow><mi>y</mi><mo>&or;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>&or;</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>y</mi><mo>&or;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>y</mi><mo>&or;</mo><mi>x</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>y</mi><mo>&or;</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&or;</mo><mi>x</mi></mrow><mo>=</mo><mrow><mi>y</mi><mo>&or;</mo><mi>x</mi></mrow><mo>=</mo><mrow><mi>x</mi><mo>&or;</mo><mi>y</mi></mrow></mrow></math></p><p>想法在于, 例如, <math><mrow><mi>x</mi><mo>&or;</mo><mi>y</mi></mrow></math>和<math><mrow><mi>y</mi><mo>&or;</mo><mi>x</mi></mrow></math>真的只是言称相同东西的不同方式. 我们想要让我们只关心<em>我们可以说什么</em>, 而不是<em>我们可以怎么说</em>.</p><p>熟悉命题演算的读者或许已经在<em>Lindenbaum代数</em>的构造之中见过这种东西了. </p><h2>第4章 frame作为代数</h2><h2>第5章 拓扑: 定义</h2><h2>第6章 以旧换新</h2><h2>第7章 点逻辑</h2><h2>第8章 紧致性</h2></body></html>