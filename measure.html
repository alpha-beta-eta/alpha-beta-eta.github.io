<html><head><meta charset="utf-8"/><title>测度论</title><link href="styles.css" rel="stylesheet"/></head><body><h1>第1卷 不可归约的最小</h1><h2>第1.1章 测度空间</h2><h3>第1.1.1节 <math><mi>&sigma;</mi></math>-代数</h3><div class="definition" id="sigma-algebra"><b>1.1.1.A. 定义. </b>令<math><mi>X</mi></math>是一个集合. 一个<b><math><mi>X</mi></math>的子集的<math><mi>&sigma;</mi></math>-代数</b> (有时也被称为<b><math><mi>&sigma;</mi></math>-域</b>) 是一个<math><mi>X</mi></math>的子集的族<math><mi mathvariant="normal">&Sigma;</mi></math>, 满足<ol type="i"><li><math><mrow><mi>&empty;</mi><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>;</li><li>对于每个<math><mrow><mi>E</mi><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>, 其于<math><mi>X</mi></math>中的补<math><mrow><mi>X</mi><mo>\</mo><mi>E</mi></mrow></math>属于<math><mi mathvariant="normal">&Sigma;</mi></math>;</li><li>对于<math><mi mathvariant="normal">&Sigma;</mi></math>中的每个序列<math><msub><mrow><mo stretchy="false">&lang;</mo><msub><mi>E</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></msub></math>, 其并<math><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow></math>属于<math><mi mathvariant="normal">&Sigma;</mi></math>.</li></ol></div><div class="remark"><b>1.1.1.B. 评注. </b><ol type="a"><li>几乎所有数学主题的学习都是从定义开始的. 在这个阶段, 没有替代死记硬背的学习方法. 这些定义包裹了诸多人物数年 (有时甚至是数个世纪) 的巧思, 你不能期望它们总是可以与你熟悉的想法对应起来.</li><li>然而, 你永远应该立即去寻求使新的定义变得更加具体的方法, 一般是藉由你已有的数学经验寻找例子. 在这里<q><math><mi>&sigma;</mi></math>-代数</q>的情况下, 以下所要描述的真正的例子本质上来说是全新的&mdash;&mdash;也就是说, 你需要从根本上阅读本章. 然而, 你应该立即能够想到两个例子, 而之后你应该将这两个例子铭记在心:<ol type="i"><li>对于任意的<math><mi>X</mi></math>, <math><mrow><mi mathvariant="normal">&Sigma;</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mi>&empty;</mi><mo>,</mo><mi>X</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></math>是<math><mi>X</mi></math>的子集的一个<math><mi>&sigma;</mi></math>-代数.</li><li>对于任意的<math><mi>X</mi></math>, <math><mrow><mi mathvariant="script">P</mi><mo>&af;</mo><mi>X</mi></mrow></math>, 即<math><mi>X</mi></math>的所有子集构成的集合, 是<math><mi>X</mi></math>的子集的一个<math><mi>&sigma;</mi></math>-代数.</li></ol>这些当然是<math><mi>X</mi></math>的子集的<math><mi>&sigma;</mi></math>-代数中最小的和最大的. 而且, 尽管我们不会在这两个例子身上花多少时间, 实际上它们仍然是重要的.</li><li>术语<b>可测空间</b>经常用来指代一个序对<math><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>,</mo><mi mathvariant="normal">&Sigma;</mi></mrow><mo stretchy="false">)</mo></mrow></math>, 其中<math><mi>X</mi></math>是一个集合而<math><mi mathvariant="normal">&Sigma;</mi></math>是<math><mi>X</mi></math>的子集的一个<math><mi>&sigma;</mi></math>-代数. 然而, 就我个人而言, 除非时间紧迫, 否则我将避免使用这个术语, 因为实际上这种对象的许多最有趣的例子并无有用的测度与之关联.</li></ol></div><div class="entry"><b>1.1.1.C. 无穷并和交. </b>如果你还没有见过无穷并, 那么值得驻足观察一下式子<math><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow></math>. 这是属于集合<math><msub><mi>E</mi><mi>n</mi></msub></math>中的一个或多个的点构成的集合; 我们可以将其写为<math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mo stretchy="false">{</mo><mrow><mi>x</mi><mo stretchy="false">|</mo><mrow><mrow><mo>&exist;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></mrow><mo>,</mo><mrow><mi>x</mi><mo>&in;</mo><msub><mi>E</mi><mi>n</mi></msub></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><msub><mi>E</mi><mn>0</mn></msub><mo>&cup;</mo><msub><mi>E</mi><mn>1</mn></msub><mo>&cup;</mo><msub><mi>E</mi><mn>2</mn></msub><mo>&cup;</mo><mo>&ctdot;</mo></mrow></mtd></mtr></mtable></math>(我以<math><mi>&Nopf;</mi></math>代表自然数集<math><mrow><mo stretchy="false">{</mo><mrow><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mo>&hellip;</mo></mrow><mo stretchy="false">}</mo></mrow></math>.) 以相同的方式, 记<math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><mrow><munder><mo>&bigcap;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mo stretchy="false">{</mo><mrow><mi>x</mi><mo stretchy="false">|</mo><mrow><mrow><mi>x</mi><mo>&in;</mo><msub><mi>E</mi><mi>n</mi></msub></mrow><mo>,</mo><mrow><mo>&forall;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><msub><mi>E</mi><mn>0</mn></msub><mo>&cap;</mo><msub><mi>E</mi><mn>1</mn></msub><mo>&cap;</mo><msub><mi>E</mi><mn>2</mn></msub><mo>&cap;</mo><mo>&ctdot;</mo></mrow></mtd></mtr></mtable></math>测度空间的基本理论的一个特征在于, 与你之前的经验相比, 它可能需要更多地利用集合操作<math><mo>&cup;</mo></math>, <math><mo>&cap;</mo></math>, <math><mo>\</mo></math> (<q>集合差</q>: <math><mrow><mrow><mi>E</mi><mo>\</mo><mi>F</mi></mrow><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mi>x</mi><mo stretchy="false">|</mo><mrow><mrow><mi>x</mi><mo>&in;</mo><mi>E</mi></mrow><mo>,</mo><mrow><mi>x</mi><mo>&notin;</mo><mi>F</mi></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>), <math><mi mathvariant="normal">&Delta;</mi></math> (<q>对称差</q>: <math><mrow><mrow><mi>E</mi><mi mathvariant="normal">&Delta;</mi><mi>F</mi></mrow><mo>=</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>E</mi><mo>\</mo><mi>F</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&cup;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>F</mi><mo>\</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>E</mi><mo>&cup;</mo><mi>F</mi></mrow><mo stretchy="false">)</mo></mrow><mo>\</mo><mrow><mo stretchy="false">(</mo><mrow><mi>E</mi><mo>&cap;</mo><mi>F</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>), 并带有无穷并和交所增添的复杂. 我强烈建议在某个时间点花些时间做一做<cite><a href="#basicex11">1.1.1.H</a></cite>的练习a.</div><div class="entry"><b>1.1.1.D. <span><mi>&sigma;</mi>-代数的基本性质</span>. </b>如果<math><mi mathvariant="normal">&Sigma;</mi></math>是<math><mi>X</mi></math>的子集的一个<math><mi>&sigma;</mi></math>-代数, 那么其具有以下性质.<ol type="a"><li>对于任意的<math><mrow><mrow><mi>E</mi><mo>,</mo><mi>F</mi></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>, <math><mrow><mrow><mi>E</mi><mo>&cup;</mo><mi>F</mi></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>. <math><mi mathvariant="bold-script">P</mi></math> 因为如果<math><mrow><mrow><mi>E</mi><mo>,</mo><mi>F</mi></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>, 置<math><mrow><msub><mi>E</mi><mn>0</mn></msub><mo>=</mo><mi>E</mi></mrow></math>, 而<math><mrow><mi>n</mi><mo>&ge;</mo><mn>1</mn></mrow></math>时<math><mrow><msub><mi>E</mi><mi>n</mi></msub><mo>=</mo><mi>F</mi></mrow></math>, 那么<math><msub><mrow><mo stretchy="false">&lang;</mo><msub><mi>E</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></msub></math>是<math><mi mathvariant="normal">&Sigma;</mi></math>中的一个序列, 而<math><mrow><mrow><mrow><mi>E</mi><mo>&cup;</mo><mi>F</mi></mrow><mo>=</mo><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>. <math><mi mathvariant="bold-script">Q</mi></math></li><li>对于任意的<math><mrow><mrow><mi>E</mi><mo>,</mo><mi>F</mi></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>, <math><mrow><mrow><mi>E</mi><mo>&cap;</mo><mi>F</mi></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>. <math><mi mathvariant="bold-script">P</mi></math> 根据<cite><a href="#sigma-algebra">1.1.1.A</a></cite>的定义之ii, <math><mrow><mrow><mi>X</mi><mo>\</mo><mi>E</mi></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>且<math><mrow><mrow><mi>X</mi><mo>\</mo><mi>F</mi></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>; 根据本条目之a, <math><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>\</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&cup;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>\</mo><mi>F</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>; 再次根据<cite><a href="#sigma-algebra">1.1.1.A</a></cite>之ii, <math><mrow><mrow><mi>X</mi><mo>\</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>\</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&cup;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>\</mo><mi>F</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>; 但这就是<math><mrow><mrow><mi>E</mi><mo>&cap;</mo><mi>F</mi></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>. <math><mi mathvariant="bold-script">Q</mi></math></li><li>对于任意的<math><mrow><mrow><mi>E</mi><mo>,</mo><mi>F</mi></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>, <math><mrow><mrow><mi>E</mi><mo>\</mo><mi>F</mi></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>. <math><mi mathvariant="bold-script">P</mi></math> <math><mrow><mrow><mrow><mi>E</mi><mo>\</mo><mi>F</mi></mrow><mo>=</mo><mrow><mi>E</mi><mo>&cap;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>\</mo><mi>F</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>. <math><mi mathvariant="bold-script">Q</mi></math></li><li>现在设<math><msub><mrow><mo stretchy="false">&lang;</mo><msub><mi>E</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></msub></math>是<math><mi mathvariant="normal">&Sigma;</mi></math>中的一个序列, 并考虑<math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><mrow><munder><mo>&bigcap;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mo stretchy="false">{</mo><mrow><mi>x</mi><mo stretchy="false">|</mo><mrow><mrow><mi>x</mi><mo>&in;</mo><msub><mi>E</mi><mi>n</mi></msub></mrow><mo>,</mo><mrow><mo>&forall;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><msub><mi>E</mi><mn>0</mn></msub><mo>&cap;</mo><msub><mi>E</mi><mn>1</mn></msub><mo>&cap;</mo><msub><mi>E</mi><mn>2</mn></msub><mo>&cap;</mo><mo>&ctdot;</mo></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mi>X</mi><mo>\</mo><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>\</mo><msub><mi>E</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr></mtable></math>其也属于<math><mi mathvariant="normal">&Sigma;</mi></math>.</li></ol></div><div class="entry"><b>1.1.1.E. 更多关于无穷并和交的讨论. </b><ol type="a"><li>到目前为止, 我们只在由自然数集<math><mi>&Nopf;</mi></math>索引的序列<math><msub><mrow><mo stretchy="false">&lang;</mo><msub><mi>E</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></msub></math>的上下文中考虑了无穷并和交. 在前方的内容中, 诸多其他的形式也会以或多或少自然的方式出现. 例如, 可以考虑具有以下形式的集合<math display="block"><mrow><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>4</mn></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow><mo>=</mo><mrow><msub><mi>E</mi><mn>4</mn></msub><mo>&cup;</mo><msub><mi>E</mi><mn>5</mn></msub><mo>&cup;</mo><msub><mi>E</mi><mn>6</mn></msub><mo>&cup;</mo><mo>&ctdot;</mo></mrow></mrow></math><math display="block"><mrow><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Zopf;</mi></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mi>x</mi><mo stretchy="false">|</mo><mrow><mrow><mo>&exist;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Zopf;</mi></mrow></mrow><mo>,</mo><mrow><mi>x</mi><mo>&in;</mo><msub><mi>E</mi><mi>n</mi></msub></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow><mo>=</mo><mrow><mo>&ctdot;</mo><mo>&cup;</mo><msub><mi>E</mi><mrow><mo>&minus;</mo><mn>2</mn></mrow></msub><mo>&cup;</mo><msub><mi>E</mi><mrow><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>&cup;</mo><msub><mi>E</mi><mn>0</mn></msub><mo>&cup;</mo><msub><mi>E</mi><mn>1</mn></msub><mo>&cup;</mo><msub><mi>E</mi><mn>2</mn></msub><mo>&cup;</mo><mo>&ctdot;</mo></mrow></mrow></math><math display="block"><mrow><mrow><munder><mo>&bigcup;</mo><mrow><mi>q</mi><mo>&in;</mo><mi>&Qopf;</mi></mrow></munder><msub><mi>E</mi><mi>q</mi></msub></mrow><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mi>x</mi><mo stretchy="false">|</mo><mrow><mrow><mo>&exist;</mo><mrow><mi>q</mi><mo>&in;</mo><mi>&Qopf;</mi></mrow></mrow><mo>,</mo><mrow><mi>x</mi><mo>&in;</mo><msub><mi>E</mi><mi>q</mi></msub></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>其中我以<math><mi>&Zopf;</mi></math>代表由所有整数构成的集合, <math><mi>&Qopf;</mi></math>代表由所有有理数构成的集合. 如果每个<math><mrow><msub><mi>E</mi><mi>n</mi></msub><mo>,</mo><msub><mi>E</mi><mi>q</mi></msub></mrow></math>属于一个<math><mi>&sigma;</mi></math>-代数<math><mi mathvariant="normal">&Sigma;</mi></math>, 那么这些并也属于. 另一方面, 以下情形<math display="block"><mrow><mrow><munder><mo>&bigcup;</mo><mrow><mi>t</mi><mo>&in;</mo><mrow><mo stretchy="false">[</mo><mrow><mn>0</mn><mo>,</mo><mn>1</mn></mrow><mo stretchy="false">]</mo></mrow></mrow></munder><msub><mi>E</mi><mi>t</mi></msub></mrow><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mi>x</mi><mo stretchy="false">|</mo><mrow><mrow><mo>&exist;</mo><mrow><mi>t</mi><mo>&in;</mo><mrow><mo stretchy="false">[</mo><mrow><mn>0</mn><mo>,</mo><mn>1</mn></mrow><mo stretchy="false">]</mo></mrow></mrow></mrow><mo>,</mo><mrow><mi>x</mi><mo>&in;</mo><msub><mi>E</mi><mi>t</mi></msub></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>在一个<math><mi>&sigma;</mi></math>-代数包含每个<math><msub><mi>E</mi><mi>t</mi></msub></math>的情况下却可能并不属于该<math><mi>&sigma;</mi></math>-代数. 读者有必要对于特定的指标集建立直觉, 例如<math><mrow><mi>&Nopf;</mi><mo>,</mo><mi>&Zopf;</mi><mo>,</mo><mi>&Qopf;</mi></mrow></math>, 其在<math><mi>&sigma;</mi></math>-代数的上下文中是<q>安全</q>的, 也要记得那些并不安全的例子.</li><li>我希望你已经见过Cantor关于无限集合的理论了, 那么以下内容不过是对于熟悉材料的重述; 但如果没有, 我希望它可以作为对于这些想法的一个初次但非常不完整的导引. 要义在于, 对于(上一段的)前三个例子而言, 我们可以将所牵涉的集合族重排为简单的集合序列. 对于第一个例子, 这是相当初等的; 对于<math><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>, 令<math><mrow><msubsup><mi>E</mi><mi>n</mi><mo>&prime;</mo></msubsup><mo>=</mo><msub><mi>E</mi><mrow><mi>n</mi><mo>+</mo><mn>4</mn></mrow></msub></mrow></math>, 那么可以看到<math><mrow><mrow><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>4</mn></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow><mo>=</mo><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msubsup><mi>E</mi><mi>n</mi><mo>&prime;</mo></msubsup></mrow></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>. 对于其他两个例子, 我们则需要了解一点关于集合<math><mi>&Zopf;</mi></math>和<math><mi>&Qopf;</mi></math>的知识. 实际上, 我们可以找到整数的序列<math><msub><mrow><mo stretchy="false">&lang;</mo><msub><mi>k</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></msub></math>和有理数的序列<math><msub><mrow><mo stretchy="false">&lang;</mo><msub><mi>q</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></msub></math>使得每个整数都作为一个<math><msub><mi>k</mi><mi>n</mi></msub></math>出现(至少一次), 而每个有理数都作为一个<math><msub><mi>q</mi><mi>n</mi></msub></math>出现(至少一次); 换言之, 函数<math><mrow><mrow><mi>n</mi><mo>&mapsto;</mo><msub><mi>k</mi><mi>n</mi></msub></mrow><mo>,</mo><mrow><mi>&Nopf;</mi><mo>&rarr;</mo><mi>&Zopf;</mi></mrow></mrow></math>和<math><mrow><mrow><mi>n</mi><mo>&mapsto;</mo><msub><mi>q</mi><mi>n</mi></msub></mrow><mo>,</mo><mrow><mi>&Nopf;</mi><mo>&rarr;</mo><mi>&Qopf;</mi></mrow></mrow></math>都是满射的. <math><mi mathvariant="bold-script">P</mi></math> 存在许多不同的方式可以达成这点; 其中一种如下, 置<math display="block"><mrow><msub><mi>k</mi><mi>n</mi></msub><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mfrac><mi>n</mi><mn>2</mn></mfrac></mtd><mtd columnalign="left"><mo>,</mo><mi>n</mi><mtext>为偶数</mtext></mtd></mtr><mtr><mtd><mrow><mo>&minus;</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow></mtd><mtd columnalign="left"><mo>,</mo><mi>n</mi><mtext>为奇数</mtext></mtd></mtr></mtable></mrow></mrow></math><math display="block"><mrow><msub><mi>q</mi><mi>n</mi></msub><mo>=</mo><mfrac><mrow><mi>n</mi><mo>&minus;</mo><msup><mi>m</mi><mn>3</mn></msup><mo>&minus;</mo><msup><mi>m</mi><mn>2</mn></msup></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><mtext>, 如果</mtext><mrow><mi>m</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow><mtext>且</mtext><mrow><mrow><msup><mi>m</mi><mn>3</mn></msup><mo>&le;</mo><mi>n</mi></mrow><mo>&lt;</mo><msup><mrow><mo stretchy="false">(</mo><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow><mn>3</mn></msup></mrow></math>(你应该仔细检查这些公式以确保它们的确能做到我所声明的事情.) <math><mi mathvariant="bold-script">Q</mi></math> 现在, 为了处理<math><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Zopf;</mi></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow></math>, 我们可以对于每个<math><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>置<math display="block"><mrow><mrow><msubsup><mi>E</mi><mi>n</mi><mo>&prime;</mo></msubsup><mo>=</mo><msub><mi>E</mi><msub><mi>k</mi><mi>n</mi></msub></msub></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>那么就有<math display="block"><mrow><mrow><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Zopf;</mi></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow><mo>=</mo><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>E</mi><msub><mi>k</mi><mi>n</mi></msub></msub></mrow><mo>=</mo><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msubsup><mi>E</mi><mi>n</mi><mo>&prime;</mo></msubsup></mrow></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>如法炮制, 我们也有<math display="block"><mrow><mrow><mrow><munder><mo>&bigcup;</mo><mrow><mi>q</mi><mo>&in;</mo><mi>&Qopf;</mi></mrow></munder><msub><mi>E</mi><mi>q</mi></msub></mrow><mo>=</mo><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>E</mi><msub><mi>q</mi><mi>n</mi></msub></msub></mrow></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>注意到第一个例子<math><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>4</mn></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow></math>也可以想成是相同原理的一个应用; 映射<math><mrow><mi>n</mi><mo>&mapsto;</mo><mrow><mi>n</mi><mo>+</mo><mn>4</mn></mrow></mrow></math>是从<math><mi>&Nopf;</mi></math>到<math><mrow><mo stretchy="false">{</mo><mrow><mn>4</mn><mo>,</mo><mn>5</mn><mo>,</mo><mn>6</mn><mo>,</mo><mn>7</mn><mo>,</mo><mo>&hellip;</mo></mrow><mo stretchy="false">}</mo></mrow></math>的一个满射.</li></ol></div><div class="entry"><b>1.1.1.F. 可数集合. </b><ol type="a"><li>集合<math><mrow><mo stretchy="false">{</mo><mrow><mi>n</mi><mo stretchy="false">|</mo><mrow><mi>n</mi><mo>&ge;</mo><mn>4</mn></mrow></mrow><mo stretchy="false">}</mo></mrow></math>, <math><mi>&Zopf;</mi></math>, <math><mi>&Qopf;</mi></math>使得这样的过程能够成立的共同特征在于它们都是<q>可数的</q>. 为了我们这里的目的, 对于可数性的最自然定义如下: 一个集合<math><mi>K</mi></math>是<b>可数的</b>, 要么其为空, 要么存在一个从<math><mi>&Nopf;</mi></math>到<math><mi>K</mi></math>的满射. </li></ol></div><div class="entry"><b>1.1.1.G. Borel集合. </b>这里我可以描述一类非平凡的<math><mi>&sigma;</mi></math>-代数; 其构造是抽象的, 但是这样的技术是重要的, 并且这个术语也是测度论的基本词汇的一部分.<ol type="a"><li>令<math><mi>X</mi></math>是一个集合, 令<math><mi mathvariant="fraktur">S</mi></math>是任意的<math><mi>X</mi></math>的子集的<math><mi>&sigma;</mi></math>-代数的非空的族. (因此, <math><mi mathvariant="fraktur">S</mi></math>的每个<em>成员</em>本身就是一个集合的<em>族</em>; <math><mrow><mi mathvariant="fraktur">S</mi><mo>&sube;</mo><mrow><mi mathvariant="script">P</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="script">P</mi><mo>&af;</mo><mi>X</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.) 那么<math display="block"><mrow><mrow><mo>&bigcap;</mo><mi mathvariant="fraktur">S</mi></mrow><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mi>E</mi><mo stretchy="false">|</mo><mrow><mrow><mi>E</mi><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow><mo>,</mo><mrow><mo>&forall;</mo><mrow><mi mathvariant="normal">&Sigma;</mi><mo>&in;</mo><mi mathvariant="fraktur">S</mi></mrow></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>即所有属于<math><mi mathvariant="fraktur">S</mi></math>的<math><mi>&sigma;</mi></math>-代数之交, 是<math><mi>X</mi></math>的子集的一个<math><mi>&sigma;</mi></math>-代数. <math><mi mathvariant="bold-script">P</mi></math><ol type="i"><li>根据假设, <math><mi mathvariant="fraktur">S</mi></math>非空; 取<math><mrow><msub><mi mathvariant="normal">&Sigma;</mi><mn>0</mn></msub><mo>&in;</mo><mi mathvariant="fraktur">S</mi></mrow></math>; 那么<math><mrow><mrow><mo>&bigcap;</mo><mi mathvariant="fraktur">S</mi></mrow><mo>&sube;</mo><msub><mi mathvariant="normal">&Sigma;</mi><mn>0</mn></msub><mo>&sube;</mo><mrow><mi mathvariant="script">P</mi><mo>&af;</mo><mi>X</mi></mrow></mrow></math>, 故<math><mrow><mo>&bigcap;</mo><mi mathvariant="fraktur">S</mi></mrow></math>的每个成员都是<math><mi>X</mi></math>的一个子集.</li><li>因为对于每个<math><mrow><mi mathvariant="normal">&Sigma;</mi><mo>&in;</mo><mi mathvariant="fraktur">S</mi></mrow></math>, <math><mrow><mi>&empty;</mi><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>, 故<math><mrow><mi>&empty;</mi><mo>&in;</mo><mrow><mo>&bigcap;</mo><mi mathvariant="fraktur">S</mi></mrow></mrow></math>.</li><li>如果<math><mrow><mi>E</mi><mo>&in;</mo><mrow><mo>&bigcap;</mo><mi mathvariant="fraktur">S</mi></mrow></mrow></math>, 那么对于每个<math><mrow><mi mathvariant="normal">&Sigma;</mi><mo>&in;</mo><mi mathvariant="fraktur">S</mi></mrow></math>有<math><mrow><mi>E</mi><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>, 故对于每个<math><mrow><mi mathvariant="normal">&Sigma;</mi><mo>&in;</mo><mi mathvariant="fraktur">S</mi></mrow></math>有<math><mrow><mrow><mi>X</mi><mo>\</mo><mi>E</mi></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>, 因而<math><mrow><mrow><mi>X</mi><mo>\</mo><mi>E</mi></mrow><mo>&in;</mo><mrow><mo>&bigcap;</mo><mi mathvariant="fraktur">S</mi></mrow></mrow></math>.</li><li>令<math><msub><mrow><mo stretchy="false">&lang;</mo><msub><mi>E</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></msub></math>是<math><mrow><mo>&bigcap;</mo><mi mathvariant="fraktur">S</mi></mrow></math>中的任意序列, 那么对于每个<math><mrow><mi mathvariant="normal">&Sigma;</mi><mo>&in;</mo><mi mathvariant="fraktur">S</mi></mrow></math>, <math><msub><mrow><mo stretchy="false">&lang;</mo><msub><mi>E</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></msub></math>都是<math><mi mathvariant="normal">&Sigma;</mi></math>中的一个序列, 故<math><mrow><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>; 鉴于<math><mi mathvariant="normal">&Sigma;</mi></math>是任意的, 所以<math><mrow><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow><mo>&in;</mo><mrow><mo>&bigcap;</mo><mi mathvariant="fraktur">S</mi></mrow></mrow></math>. <math><mi mathvariant="bold-script">Q</mi></math></li></ol></li><li>现在令<math><mi mathvariant="script">A</mi></math>是任意的一个<math><mi>X</mi></math>的子集的族, 考虑<math display="block"><mrow><mi mathvariant="fraktur">S</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mi mathvariant="normal">&Sigma;</mi><mo stretchy="false">|</mo><mrow><mi mathvariant="normal">&Sigma;</mi><mtext>是</mtext><mi>X</mi><mtext>的子集的一个</mtext><mi>&sigma;</mi><mtext>-代数, 而且</mtext><mrow><mi mathvariant="script">A</mi><mo>&sube;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow><mtext>.</mtext></math>根据定义, <math><mi mathvariant="fraktur">S</mi></math>是<math><mi>X</mi></math>的子集的<math><mi>&sigma;</mi></math>-代数的一个族; 而且, 其是非空的, 因为<math><mrow><mrow><mi mathvariant="script">P</mi><mo>&af;</mo><mi>X</mi></mrow><mo>&in;</mo><mi mathvariant="fraktur">S</mi></mrow></math>. 因此, <math><mrow><msub><mi mathvariant="normal">&Sigma;</mi><mi mathvariant="script">A</mi></msub><mo>=</mo><mrow><mo>&bigcap;</mo><mi mathvariant="fraktur">S</mi></mrow></mrow></math>是<math><mi>X</mi></math>的子集的一个<math><mi>&sigma;</mi></math>-代数. 鉴于对于每个<math><mrow><mi mathvariant="normal">&Sigma;</mi><mo>&in;</mo><mi mathvariant="fraktur">S</mi></mrow></math>都有<math><mrow><mi mathvariant="script">A</mi><mo>&sube;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>, <math><mrow><mi mathvariant="script">A</mi><mo>&sube;</mo><msub><mi mathvariant="normal">&Sigma;</mi><mi mathvariant="script">A</mi></msub></mrow></math>; 因此, <math><msub><mi mathvariant="normal">&Sigma;</mi><mi mathvariant="script">A</mi></msub></math>自身就属于<math><mi mathvariant="fraktur">S</mi></math>; 其为包含<math><mi mathvariant="script">A</mi></math>的最小的<math><mi>X</mi></math>的子集的<math><mi>&sigma;</mi></math>-代数. 我们称<math><msub><mi mathvariant="normal">&Sigma;</mi><mi mathvariant="script">A</mi></msub></math>是<b>由<math><mi mathvariant="script">A</mi></math>生成</b>的<math><mi>X</mi></math>的子集的<math><mi>&sigma;</mi></math>-代数. 以下是两个例子.<ol type="i"><li>对于任意的集合<math><mi>X</mi></math>, 由<math><mi>&empty;</mi></math>生成的<math><mi>X</mi></math>的子集的<math><mi>&sigma;</mi></math>-代数为<math><mrow><mo stretchy="false">{</mo><mrow><mi>&empty;</mi><mo>,</mo><mi>X</mi></mrow><mo stretchy="false">}</mo></mrow></math>.</li><li>由<math><mrow><mo stretchy="false">{</mo><mrow><mrow><mo stretchy="false">{</mo><mi>n</mi><mo stretchy="false">}</mo></mrow><mo stretchy="false">|</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></math>生成的<math><mi>&Nopf;</mi></math>的子集的<math><mi>&sigma;</mi></math>-代数是<math><mrow><mi mathvariant="script">P</mi><mo>&af;</mo><mi>&Nopf;</mi></mrow></math>.</li></ol></li><li><ol type="i"><li>我们称一个集合<math><mrow><mi>G</mi><mo>&sube;</mo><mi>&Ropf;</mi></mrow></math>是<b>开</b>的, 如果对于每个<math><mrow><mi>x</mi><mo>&in;</mo><mi>G</mi></mrow></math>, 存在<math><mrow><mi>&delta;</mi><mo>></mo><mn>0</mn></mrow></math>使得开区间<math><mrow><mo>]</mo><mrow><mi>x</mi><mo>&minus;</mo><mi>&delta;</mi></mrow><mo>,</mo><mrow><mi>x</mi><mo>+</mo><mi>&delta;</mi></mrow><mo>[</mo></mrow></math>被包含于<math><mi>G</mi></math>.</li><li>类似地, 对于任意的<math><mrow><mi>r</mi><mo>&ge;</mo><mn>1</mn></mrow></math>, 我们称一个集合<math><mrow><mi>G</mi><mo>&sube;</mo><msup><mi>&Ropf;</mi><mi>r</mi></msup></mrow></math>在<math><msup><mi>&Ropf;</mi><mi>r</mi></msup></math>中是<b>开</b>的, 如果对于每个<math><mrow><mi>x</mi><mo>&in;</mo><mi>G</mi></mrow></math>, 存在<math><mrow><mi>&delta;</mi><mo>></mo><mn>0</mn></mrow></math>使得<math><mrow><mrow><mo stretchy="false">{</mo><mrow><mi>y</mi><mo stretchy="false">|</mo><mrow><mrow><mo stretchy="false">&Vert;</mo><mrow><mi>y</mi><mo>&minus;</mo><mi>x</mi></mrow><mo stretchy="false">&Vert;</mo></mrow><mo>&lt;</mo><mi>&delta;</mi></mrow></mrow><mo stretchy="false">}</mo></mrow><mo>&sube;</mo><mi>G</mi></mrow></math>, 其中对于<math><mrow><mrow><mi>z</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>&zeta;</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>&zeta;</mi><mi>r</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&in;</mo><msup><mi>&Ropf;</mi><mi>r</mi></msup></mrow></math>, 我记<math><mrow><mrow><mo stretchy="false">&Vert;</mo><mi>z</mi><mo stretchy="false">&Vert;</mo></mrow><mo>=</mo><msqrt><mrow><munderover><mo>&sum;</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>r</mi></munderover><msup><mrow><mo stretchy="false">|</mo><msub><mi>&zeta;</mi><mi>i</mi></msub><mo stretchy="false">|</mo></mrow><mn>2</mn></msup></mrow></msqrt></mrow></math>; 因此, <math><mrow><mo stretchy="false">&Vert;</mo><mrow><mi>y</mi><mo>&minus;</mo><mi>x</mi></mrow><mo stretchy="false">&Vert;</mo></mrow></math>不过就是从<math><mi>y</mi></math>到<math><mi>x</mi></math>的通常的Euclid距离.</li></ol></li><li>现在<math><mi>&Ropf;</mi></math>的<b>Borel集合</b>不过就是由<math><mi>&Ropf;</mi></math>的所有开集构成的族所生成的<math><mi>&Ropf;</mi></math>的子集的<math><mi>&sigma;</mi></math>-代数的成员; <math><mi>&sigma;</mi></math>-代数本身则被称为<b>Borel <math><mi>&sigma;</mi></math>-代数</b>. <math><msup><mi>&Ropf;</mi><mi>r</mi></msup></math>的Borel集合和Borel <math><mi>&sigma;</mi></math>-代数以类似的方式定义.</li><li>一些读者可能会感到这里的构建并没有给出一个Borel集合到底长什么样子的想法. (开集要远为简单; 见<cite><a href="#furtherex11">1.1.1.I</a></cite>的练习e.) 实际上, 这个概念的重要性在很大程度上来源于存在另外更加显式且在某种意义上更加具体的描述Borel集合的方式. 我将于第4卷的第4.2章回到这个话题上来.</li></ol></div><div class="entry" id="basicex11"><b>1.1.1.H. 基本练习. </b><ol type="a"><li>练习无穷并和交的代数, 直至你能够自信地解释诸如</li></ol></div><div class="entry" id="furtherex11"><b>1.1.1.I. 深入练习. </b><ol type="a"><li>在<math><msup><mi>&Ropf;</mi><mi>r</mi></msup></math>中, 其中<math><mrow><mi>r</mi><mo>&ge;</mo><mn>1</mn></mrow></math>, 表明当<math><mrow><mi>G</mi><mo>&sube;</mo><msup><mi>&Ropf;</mi><mi>r</mi></msup></mrow></math>是开的且<math><mrow><mi>a</mi><mo>&in;</mo><msup><mi>&Ropf;</mi><mi>r</mi></msup></mrow></math>时, <math><mrow><mrow><mi>G</mi><mo>+</mo><mi>a</mi></mrow><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>x</mi><mo>+</mo><mi>a</mi></mrow><mo stretchy="false">|</mo><mrow><mi>x</mi><mo>&in;</mo><mi>G</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>也是开的. 基于这个结果, 证明当<math><mrow><mi>E</mi><mo>&sube;</mo><msup><mi>&Ropf;</mi><mi>r</mi></msup></mrow></math>是一个Borel集合且<math><mrow><mi>a</mi><mo>&in;</mo><msup><mi>&Ropf;</mi><mi>r</mi></msup></mrow></math>时, <math><mrow><mi>E</mi><mo>+</mo><mi>a</mi></mrow></math>也是一个Borel集合. (提示: 表明<math><mrow><mo stretchy="false">{</mo><mrow><mi>E</mi><mo stretchy="false">|</mo><mrow><mrow><mi>E</mi><mo>+</mo><mi>a</mi></mrow><mtext>是一个Borel集合</mtext></mrow></mrow><mo stretchy="false">}</mo></mrow></math>是一个包含所有开集的<math><mi>&sigma;</mi></math>-代数.)</li><li>令<math><mi>X</mi></math>是一个集合, <math><mi mathvariant="normal">&Sigma;</mi></math>是一个<math><mi>X</mi></math>的子集的<math><mi>&sigma;</mi></math>-代数, 而<math><mi>A</mi></math>是<math><mi>X</mi></math>的任意一个子集. 证明<math><mrow><mo stretchy="false">{</mo><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>E</mi><mo>&cap;</mo><mi>A</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&cup;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>F</mi><mo>\</mo><mi>A</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">|</mo><mrow><mrow><mi>E</mi><mo>,</mo><mi>F</mi></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></math>是一个<math><mi>X</mi></math>的子集的<math><mi>&sigma;</mi></math>-代数, 而且是由<math><mrow><mi mathvariant="normal">&Sigma;</mi><mo>&cup;</mo><mrow><mo stretchy="false">{</mo><mi>A</mi><mo stretchy="false">}</mo></mrow></mrow></math>生成的<math><mi>&sigma;</mi></math>-代数.</li><li>令<math><mrow><mi>G</mi><mo>&sube;</mo><msup><mi>&Ropf;</mi><mn>2</mn></msup></mrow></math>是一个开集. 证明<math><mi>G</mi></math>的所有水平截线和垂直截线<math display="block"><mrow><mrow><mo stretchy="false">{</mo><mrow><mi>&xi;</mi><mo stretchy="false">|</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>&xi;</mi><mo>,</mo><mi>&eta;</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi>G</mi></mrow></mrow><mo stretchy="false">}</mo></mrow><mo>,</mo><mrow><mo stretchy="false">{</mo><mrow><mi>&xi;</mi><mo stretchy="false">|</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>&eta;</mi><mo>,</mo><mi>&xi;</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi>G</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>都是<math><mi>&Ropf;</mi></math>的开子集.</li><li>令<math><mrow><mi>E</mi><mo>&sube;</mo><msup><mi>&Ropf;</mi><mn>2</mn></msup></mrow></math>是一个Borel集合. 证明<math><mi>E</mi></math>的所有水平截线和垂直截线<math display="block"><mrow><mrow><mo stretchy="false">{</mo><mrow><mi>&xi;</mi><mo stretchy="false">|</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>&xi;</mi><mo>,</mo><mi>&eta;</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi>E</mi></mrow></mrow><mo stretchy="false">}</mo></mrow><mo>,</mo><mrow><mo stretchy="false">{</mo><mrow><mi>&xi;</mi><mo stretchy="false">|</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>&eta;</mi><mo>,</mo><mi>&xi;</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi>E</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>都是<math><mi>&Ropf;</mi></math>的Borel子集. (提示: 证明由所有截线均为Borel集合的<math><msup><mi>&Ropf;</mi><mn>2</mn></msup></math>的子集构成的族是一个包含所有开集的<math><msup><mi>&Ropf;</mi><mn>2</mn></msup></math>的子集的<math><mi>&sigma;</mi></math>-代数.)</li><li>令<math><mrow><mi>G</mi><mo>&sube;</mo><mi>&Ropf;</mi></mrow></math>是一个开集. 证明<math><mi>G</mi></math>可以唯一地表示为开区间 (<math><mi>G</mi></math>的<q>分量</q>) 的一个可数族<math><mi mathvariant="script">I</mi></math> (可能为空) 之并, 其中我们要求这个族内的诸开区间两两不相交. (提示: 对于<math><mrow><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo>&in;</mo><mi>G</mi></mrow></math>, 称<math><mrow><mi>x</mi><mo>~</mo><mi>y</mi></mrow></math>如果<math><mi>x</mi></math>和<math><mi>y</mi></math>之间的每个点都属于<math><mi>G</mi></math>. 表明<math><mo>~</mo></math>是一个等价关系. 令<math><mi mathvariant="script">I</mi></math>是其等价类的集合.)</li></ol></div><div class="entry"><b>1.1.1.J. 注记和评论. </b></div><h3>第1.1.2节 测度空间</h3><p>我希望我们已经准备好迎来第二个定义了, 这个定义是此专著所有工作之基础.</p><div class="definition"><b>1.1.2.A. 定义. </b>一个<b>测度空间</b>是一个三元组<math><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>,</mo><mi mathvariant="normal">&Sigma;</mi><mo>,</mo><mi>&mu;</mi></mrow><mo stretchy="false">)</mo></mrow></math>, 其中<ol type="i"><li><math><mi>X</mi></math>是一个集合;</li><li><math><mi mathvariant="normal">&Sigma;</mi></math>是<math><mi>X</mi></math>的子集的一个<math><mi>&sigma;</mi></math>-代数;</li><li><math><mrow><mi>&mu;</mi><mo>:</mo><mrow><mi mathvariant="normal">&Sigma;</mi><mo>&rarr;</mo><mrow><mo stretchy="false">[</mo><mrow><mn>0</mn><mo>,</mo><mi>&infin;</mi></mrow><mo stretchy="false">]</mo></mrow></mrow></mrow></math>是一个函数, 满足<ol style="list-style-type: lower-greek;"><li><math><mrow><mrow><mi>&mu;</mi><mo>&af;</mo><mi>&empty;</mi></mrow><mo>=</mo><mn>0</mn></mrow></math>;</li><li>如果<math><msub><mrow><mo stretchy="false">&lang;</mo><msub><mi>E</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></msub></math>是<math><mi mathvariant="normal">&Sigma;</mi></math>中的一个互不相交 (disjoint) 的序列, 那么<math><mrow><mrow><mi>&mu;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munderover><mo>&sum;</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mi>&infin;</mi></munderover><mrow><mi>&mu;</mi><mo>&af;</mo><msub><mi>E</mi><mi>n</mi></msub></mrow></mrow></mrow></math>.</li></ol></li></ol>在此上下文之中, <math><mi mathvariant="normal">&Sigma;</mi></math>的成员被称为<b>可测</b>集合, 而<math><mi>&mu;</mi></math>被称为<b><math><mi>X</mi></math>上的一个测度</b>.</div><div class="remark"><b>1.1.2.B. 评注. </b><ol type="a"><li><b><math><mi>&infin;</mi></math>的使用: </b>在以上定义的iii之中, 我声明<math><mi>&mu;</mi></math>是一个取值于<q><math><mrow><mo stretchy="false">[</mo><mrow><mn>0</mn><mo>,</mo><mi>&infin;</mi></mrow><mo stretchy="false">]</mo></mrow></math></q>之中的函数, 此即由非负实数构成的集合但又加入了<q><math><mi>&infin;</mi></math></q>. 我期望你已经在分析学中遇到对于符号<math><mi>&infin;</mi></math>的各种各样的运用了; 我希望你意识到这个符号在不同的上下文之中有着相当不同的意思, 而每次使用都有必要建立清晰的约定. <q>测度的<math><mi>&infin;</mi></math></q>对应于无限长度或者面积或者体积的概念. 我们需要于其上执行的基本操作是加法: 对于<math><mrow><mi>a</mi><mo>&in;</mo><mrow><mo>[</mo><mn>0</mn><mo>,</mo><mi>&infin;</mi><mo>[</mo></mrow></mrow></math> (也就是对于每个实数<math><mrow><mi>a</mi><mo>&ge;</mo><mn>0</mn></mrow></math>), <math><mrow><mrow><mi>&infin;</mi><mo>+</mo><mi>a</mi></mrow><mo>=</mo><mrow><mi>a</mi><mo>+</mo><mi>&infin;</mi></mrow><mo>=</mo><mi>&infin;</mi></mrow></math>, 另外<math><mrow><mrow><mi>&infin;</mi><mo>+</mo><mi>&infin;</mi></mrow><mo>=</mo><mi>&infin;</mi></mrow></math>. 这将<math><mrow><mo stretchy="false">[</mo><mrow><mn>0</mn><mo>,</mo><mi>&infin;</mi></mrow><mo stretchy="false">]</mo></mrow></math>渲染为了一个加法下的半群. 声明对于每个<math><mrow><mi>a</mi><mo>&in;</mo><mi>&Ropf;</mi></mrow></math>都有<math><mrow><mrow><mi>&infin;</mi><mo>&minus;</mo><mi>a</mi></mrow><mo>=</mo><mi>&infin;</mi></mrow></math>是相当安全的; 但是我们必须绝对抵制解释公式<math><mrow><mi>&infin;</mi><mo>&minus;</mo><mi>&infin;</mi></mrow></math>. 至于乘法, 实际上对于<math><mrow><mi>a</mi><mo>></mo><mn>0</mn></mrow></math>而言通常将公式<math><mrow><mi>&infin;</mi><mo>&sdot;</mo><mi>&infin;</mi></mrow></math>, <math><mrow><mi>a</mi><mo>&sdot;</mo><mi>&infin;</mi></mrow></math>, <math><mrow><mi>&infin;</mi><mo>&sdot;</mo><mi>a</mi></mrow></math>都解释为<math><mi>&infin;</mi></math>是正确的, 而一般来说<math><mrow><mrow><mn>0</mn><mo>&sdot;</mo><mi>&infin;</mi></mrow><mo>=</mo><mrow><mi>&infin;</mi><mo>&sdot;</mo><mn>0</mn></mrow></mrow></math>可以取为<math><mn>0</mn></math>.<br/><math><mrow><mo stretchy="false">[</mo><mrow><mn>0</mn><mo>,</mo><mi>&infin;</mi></mrow><mo stretchy="false">]</mo></mrow></math>上我们也有一个自然的全序, 对于每个<math><mrow><mi>a</mi><mo>&in;</mo><mrow><mo>[</mo><mi>a</mi><mo>,</mo><mi>&infin;</mi><mo>[</mo></mrow></mrow></math>记<math><mrow><mi>a</mi><mo>&lt;</mo><mi>&infin;</mi></mrow></math>. 这给出了<math><mrow><mo stretchy="false">[</mo><mrow><mn>0</mn><mo>,</mo><mi>&infin;</mi></mrow><mo stretchy="false">]</mo></mrow></math>的任意(非空)子集的上确界和下确界的想法; 并且将<math><mrow><mi>inf</mi><mo>&af;</mo><mi>&empty;</mi></mrow></math>解释为<math><mi>&infin;</mi></math>常常是正确的, 但是每次相关情况时我都将尽量提示读者以这条特别的约定. 我们也有极限的概念; 如果<math><msub><mrow><mo stretchy="false">&lang;</mo><msub><mi>u</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></msub></math>是<math><mrow><mo stretchy="false">[</mo><mrow><mn>0</mn><mo>,</mo><mi>&infin;</mi></mrow><mo stretchy="false">]</mo></mrow></math>中的一个序列, 那么其收敛至<math><mrow><mi>u</mi><mo>&in;</mo><mrow><mo stretchy="false">[</mo><mrow><mn>0</mn><mo>,</mo><mi>&infin;</mi></mrow><mo stretchy="false">]</mo></mrow></mrow></math>, 如果<ul><li>对于每个<math><mrow><mi>v</mi><mo>&lt;</mo><mi>u</mi></mrow></math>, 存在一个<math><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>使得对于每个<math><mrow><mi>n</mi><mo>&ge;</mo><msub><mi>n</mi><mn>0</mn></msub></mrow></math>都有<math><mrow><mi>v</mi><mo>&le;</mo><msub><mi>u</mi><mi>n</mi></msub></mrow></math>;</li><li>对于每个<math><mrow><mi>v</mi><mo>></mo><mi>u</mi></mrow></math>, 存在一个<math><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>使得对于每个<math><mrow><mi>n</mi><mo>&ge;</mo><msub><mi>n</mi><mn>0</mn></msub></mrow></math>都有<math><mrow><mi>v</mi><mo>&ge;</mo><msub><mi>u</mi><mi>n</mi></msub></mrow></math>.</li></ul>当然, 如果<math><mrow><mi>u</mi><mo>=</mo><mn>0</mn></mrow></math>或者<math><mrow><mi>u</mi><mo>=</mo><mi>&infin;</mi></mrow></math>, 其中之一的条件将虚空地成立.</li><li></li></ol></div><div class="entry" id="measure-space-basic-properties"><b>1.1.2.C. 测度空间的基本性质. </b>令<math><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>,</mo><mi mathvariant="normal">&Sigma;</mi><mo>,</mo><mi>&mu;</mi></mrow><mo stretchy="false">)</mo></mrow></math>是一个测度空间.<ol type="a"><li>如果<math><mrow><mrow><mi>E</mi><mo>,</mo><mi>F</mi></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>且<math><mrow><mrow><mi>E</mi><mo>&cap;</mo><mi>F</mi></mrow><mo>=</mo><mi>&empty;</mi></mrow></math>, 那么<math><mrow><mrow><mi>&mu;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>E</mi><mo>&cup;</mo><mi>F</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>&mu;</mi><mo>&af;</mo><mi>E</mi></mrow><mo>+</mo><mrow><mi>&mu;</mi><mo>&af;</mo><mi>F</mi></mrow></mrow></mrow></math>.</li><li>如果<math><mrow><mrow><mi>E</mi><mo>,</mo><mi>F</mi></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>且<math><mrow><mi>E</mi><mo>&sube;</mo><mi>F</mi></mrow></math>, 那么<math><mrow><mrow><mi>&mu;</mi><mo>&af;</mo><mi>E</mi></mrow><mo>&le;</mo><mrow><mi>&mu;</mi><mo>&af;</mo><mi>F</mi></mrow></mrow></math>.</li><li>对于任意的<math><mrow><mrow><mi>E</mi><mo>,</mo><mi>F</mi></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>, <math><mrow><mrow><mi>&mu;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>E</mi><mo>&cup;</mo><mi>F</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&le;</mo><mrow><mrow><mi>&mu;</mi><mo>&af;</mo><mi>E</mi></mrow><mo>+</mo><mrow><mi>&mu;</mi><mo>&af;</mo><mi>F</mi></mrow></mrow></mrow></math>.</li><li>如果<math><msub><mrow><mo stretchy="false">&lang;</mo><msub><mi>E</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></msub></math>是<math><mi mathvariant="normal">&Sigma;</mi></math>中任意的序列, 那么<math><mrow><mrow><mi>&mu;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&le;</mo><mrow><munderover><mo>&sum;</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mi>&infin;</mi></munderover><mrow><mi>&mu;</mi><mo>&af;</mo><msub><mi>E</mi><mi>n</mi></msub></mrow></mrow></mrow></math>.</li><li>如果<math><msub><mrow><mo stretchy="false">&lang;</mo><msub><mi>E</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></msub></math>是<math><mi mathvariant="normal">&Sigma;</mi></math>中的一个非降序列 (也就是说, 对于每个<math><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>, <math><mrow><msub><mi>E</mi><mi>n</mi></msub><mo>&sube;</mo><msub><mi>E</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></math>), 那么<math display="block"><mrow><mrow><mi>&mu;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>lim</mo><mrow><mi>n</mi><mo lspace="0" rspace="0">&rarr;</mo><mi>&infin;</mi></mrow></munder><mrow><mi>&mu;</mi><mo>&af;</mo><msub><mi>E</mi><mi>n</mi></msub></mrow></mrow><mo>=</mo><mrow><munder><mi>sup</mi><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><mo>&af;</mo><mrow><mi>&mu;</mi><mo>&af;</mo><msub><mi>E</mi><mi>n</mi></msub></mrow></mrow></mrow><mtext>.</mtext></math></li><li>如果<math><msub><mrow><mo stretchy="false">&lang;</mo><msub><mi>E</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></msub></math>是<math><mi mathvariant="normal">&Sigma;</mi></math>中的一个非升序列 (也就是说, 对于每个<math><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>, <math><mrow><msub><mi>E</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&sube;</mo><msub><mi>E</mi><mi>n</mi></msub></mrow></math>), 并且某个<math><mrow><mi>&mu;</mi><mo>&af;</mo><msub><mi>E</mi><mi>n</mi></msub></mrow></math>是有限的, 那么<math display="block"><mrow><mrow><mi>&mu;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigcap;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo>lim</mo><mrow><mi>n</mi><mo lspace="0" rspace="0">&rarr;</mo><mi>&infin;</mi></mrow></munder><mrow><mi>&mu;</mi><mo>&af;</mo><msub><mi>E</mi><mi>n</mi></msub></mrow></mrow><mo>=</mo><mrow><munder><mi>inf</mi><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><mo>&af;</mo><mrow><mi>&mu;</mi><mo>&af;</mo><msub><mi>E</mi><mi>n</mi></msub></mrow></mrow></mrow><mtext>.</mtext></math></li></ol></div><div class="proof"><b>证明.</b> <ol type="a"><li></li></ol><div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><div class="entry"><b>1.1.2.D. 可忽略集合. </b>令<math><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>,</mo><mi mathvariant="normal">&Sigma;</mi><mo>,</mo><mi>&mu;</mi></mrow><mo stretchy="false">)</mo></mrow></math>是任意的测度空间.<ol type="a"><li>一个集合<math><mrow><mi>A</mi><mo>&sube;</mo><mi>X</mi></mrow></math>是<b>可忽略的</b> (或者说<b>null</b>), 如果存在一个集合<math><mrow><mi>E</mi><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>满足<math><mrow><mi>A</mi><mo>&sube;</mo><mi>E</mi></mrow></math>且<math><mrow><mrow><mi>&mu;</mi><mo>&af;</mo><mi>E</mi></mrow><mo>=</mo><mn>0</mn></mrow></math>. (若是对于涉及的是哪一个测度存疑, 我会写下<b><math><mi>&mu;</mi></math>-可忽略的</b>.)</li><li>令<math><mi mathvariant="script">N</mi></math>是<math><mi>X</mi></math>的可忽略子集的族, 那么i. <math><mrow><mi>&empty;</mi><mo>&in;</mo><mi mathvariant="script">N</mi></mrow></math>. ii. 如果<math><mrow><mi>A</mi><mo>&sube;</mo><mrow><mi>B</mi><mo>&in;</mo><mi mathvariant="script">N</mi></mrow></mrow></math>, 那么<math><mrow><mi>A</mi><mo>&in;</mo><mi mathvariant="script">N</mi></mrow></math>. iii. 如果<math><msub><mrow><mo stretchy="false">&lang;</mo><msub><mi>A</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></msub></math>是<math><mi mathvariant="script">N</mi></math>中的任意序列, 那么<math><mrow><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>A</mi><mi>n</mi></msub></mrow><mo>&in;</mo><mi mathvariant="script">N</mi></mrow></math>. <math><mi mathvariant="bold-script">P</mi></math> i. <math><mrow><mrow><mi>&mu;</mi><mo>&af;</mo><mi>&empty;</mi></mrow><mo>=</mo><mn>0</mn></mrow></math>. ii. 存在一个<math><mrow><mi>E</mi><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>满足<math><mrow><mrow><mi>&mu;</mi><mo>&af;</mo><mi>E</mi></mrow><mo>=</mo><mn>0</mn></mrow></math>且<math><mrow><mi>B</mi><mo>&sube;</mo><mi>E</mi></mrow></math>; 现在<math><mrow><mi>A</mi><mo>&sube;</mo><mi>E</mi></mrow></math>. iii. 对于每个<math><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>, 选择一个<math><mrow><msub><mi>E</mi><mi>n</mi></msub><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>满足<math><mrow><msub><mi>A</mi><mi>n</mi></msub><mo>&sube;</mo><msub><mi>E</mi><mi>n</mi></msub></mrow></math>且<math><mrow><mrow><mi>&mu;</mi><mo>&af;</mo><msub><mi>E</mi><mi>n</mi></msub></mrow><mo>=</mo><mn>0</mn></mrow></math>. 现在<math><mrow><mi>E</mi><mo>=</mo><mrow><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></mrow></math>而<math><mrow><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>A</mi><mi>n</mi></msub></mrow><mo>&sube;</mo><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow></mrow></math>, 并且根据<cite><a href="#measure-space-basic-properties">1.1.2.C</a></cite>的d有<math><mrow><mrow><mi>&mu;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&le;</mo><mrow><munderover><mo>&sum;</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mi>&infin;</mi></munderover><mrow><mi>&mu;</mi><mo>&af;</mo><msub><mi>E</mi><mi>n</mi></msub></mrow></mrow></mrow></math>, 故<math><mrow><mrow><mi>&mu;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mn>0</mn></mrow></math>. <math><mi mathvariant="bold-script">Q</mi></math><br/>我将称<math><mi mathvariant="script">N</mi></math>为<math><mi>&mu;</mi></math>的<b>零理想 (null ideal)</b>. (满足这里条件i-iii的一个集族被称为一个集合的<b><math><mi>&sigma;</mi></math>-理想</b>.)</li><li>一个集合<math><mrow><mi>A</mi><mo>&sube;</mo><mi>X</mi></mrow></math>是<b>conegligible</b>的, 如果<math><mrow><mi>X</mi><mo>\</mo><mi>A</mi></mrow></math>是可忽略的; 换言之, 存在一个可测集合<math><mrow><mi>E</mi><mo>&sube;</mo><mi>A</mi></mrow></math>使得<math><mrow><mrow><mi>&mu;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>\</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mn>0</mn></mrow></math>. 注意到i. <math><mi>X</mi></math>是conegligible的. ii. 如果<math><mrow><mi>A</mi><mo>&sube;</mo><mi>B</mi><mo>&sube;</mo><mi>X</mi></mrow></math>而<math><mi>A</mi></math>是conegligible的, 那么<math><mi>B</mi></math>是conegligible的. iii. 如果<math><msub><mrow><mo stretchy="false">&lang;</mo><msub><mi>A</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></msub></math>是conegligible集合的序列, 那么<math><mrow><munder><mo>&bigcap;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>A</mi><mi>n</mi></msub></mrow></math>是conegligible的.</li><li></li></ol></div><h3>第1.1.3节 外测度和Carathéodory构造</h3><p>这里我将引入构造测度的最重要方法.</p><div class="definition"><b>1.1.3.A. 定义. </b>现在我们来到本章的第三个基本定义.<br/>令<math><mi>X</mi></math>是一个集合. <math><mi>X</mi></math>上的一个<b>外测度</b>是一个函数<math><mrow><mi>&theta;</mi><mo>:</mo><mrow><mrow><mi mathvariant="script">P</mi><mo>&af;</mo><mi>X</mi></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">[</mo><mrow><mn>0</mn><mo>,</mo><mi>&infin;</mi></mrow><mo stretchy="false">]</mo></mrow></mrow></mrow></math>, 满足<ol type="i"><li><math><mrow><mrow><mi>&theta;</mi><mo>&af;</mo><mi>&empty;</mi></mrow><mo>=</mo><mn>0</mn></mrow></math>;</li><li>如果<math><mrow><mi>A</mi><mo>&sube;</mo><mi>B</mi><mo>&sube;</mo><mi>X</mi></mrow></math>, 那么<math><mrow><mrow><mi>&theta;</mi><mo>&af;</mo><mi>A</mi></mrow><mo>&le;</mo><mrow><mi>&theta;</mi><mo>&af;</mo><mi>B</mi></mrow></mrow></math>;</li><li>对于<math><mi>X</mi></math>的子集的每个序列<math><msub><mrow><mo stretchy="false">&lang;</mo><msub><mi>A</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></msub></math>, <math><mrow><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>A</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&le;</mo><mrow><munderover><mo>&sum;</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mi>&infin;</mi></munderover><mrow><mi>&theta;</mi><mo>&af;</mo><msub><mi>A</mi><mi>n</mi></msub></mrow></mrow></mrow></math>.</li></ol></div><div class="remark" id="outer-measure-remarks"><b>1.1.3.B. 评注. </b><ol type="a"><li></li></ol></div><div class="entry"><b>1.1.3.C. Carathéodory的方法: 定理. </b>令<math><mi>X</mi></math>是一个集合而<math><mi>&theta;</mi></math>是<math><mi>X</mi></math>上的一个外测度, 置<math display="block"><mrow><mi mathvariant="normal">&Sigma;</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mi>E</mi><mo stretchy="false">|</mo><mrow><mrow><mi>E</mi><mo>&sube;</mo><mi>X</mi></mrow><mtext>, 对于每个</mtext><mrow><mi>A</mi><mo>&sube;</mo><mi>X</mi></mrow><mtext>, 都有</mtext><mrow><mrow><mi>&theta;</mi><mo>&af;</mo><mi>A</mi></mrow><mo>=</mo><mrow><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>&cap;</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>\</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>那么<math><mi mathvariant="normal">&Sigma;</mi></math>是<math><mi>X</mi></math>的子集的一个<math><mi>&sigma;</mi></math>-代数. 通过对于<math><mrow><mi>E</mi><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>记<math><mrow><mrow><mi>&mu;</mi><mo>&af;</mo><mi>E</mi></mrow><mo>=</mo><mrow><mi>&theta;</mi><mo>&af;</mo><mi>E</mi></mrow></mrow></math>定义<math><mrow><mi>&mu;</mi><mo>:</mo><mrow><mi mathvariant="normal">&Sigma;</mi><mo>&rarr;</mo><mrow><mo stretchy="false">[</mo><mrow><mn>0</mn><mo>,</mo><mi>&infin;</mi></mrow><mo stretchy="false">]</mo></mrow></mrow></mrow></math>; 那么<math><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>,</mo><mi mathvariant="normal">&Sigma;</mi><mo>,</mo><mi>&mu;</mi></mrow><mo stretchy="false">)</mo></mrow></math>是一个测度空间.</div><div class="proof"><b>证明.</b> <ol type="a"><li>第一步是注意到对于任何<math><mrow><mrow><mi>E</mi><mo>,</mo><mi>A</mi></mrow><mo>&sube;</mo><mi>X</mi></mrow></math>, 根据<cite><a href="#outer-measure-remarks">1.1.3.B</a></cite>的c, 我们有<math><mrow><mrow><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>&cap;</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>\</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&ge;</mo><mrow><mi>&theta;</mi><mo>&af;</mo><mi>A</mi></mrow></mrow></math>; 于是<math display="block"><mrow><mi mathvariant="normal">&Sigma;</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mi>E</mi><mo stretchy="false">|</mo><mrow><mrow><mi>E</mi><mo>&sube;</mo><mi>X</mi></mrow><mtext>, 对于每个</mtext><mrow><mi>A</mi><mo>&sube;</mo><mi>X</mi></mrow><mtext>, 都有</mtext><mrow><mrow><mi>&theta;</mi><mo>&af;</mo><mi>A</mi></mrow><mo>&ge;</mo><mrow><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>&cap;</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>\</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math></li><li>显然<math><mrow><mi>&empty;</mi><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>, 因为<math display="block"><mrow><mrow><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>&cap;</mo><mi>&empty;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>\</mo><mi>&empty;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mrow><mi>&theta;</mi><mo>&af;</mo><mi>&empty;</mi></mrow><mo>+</mo><mrow><mi>&theta;</mi><mo>&af;</mo><mi>A</mi></mrow></mrow><mo>=</mo><mrow><mi>&theta;</mi><mo>&af;</mo><mi>A</mi></mrow></mrow></math>对于每个<math><mrow><mi>A</mi><mo>&sube;</mo><mi>X</mi></mrow></math>都成立. 如果<math><mrow><mi>E</mi><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>, 那么<math><mrow><mrow><mi>X</mi><mo>\</mo><mi>E</mi></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>, 因为<math display="block"><mrow><mrow><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>&cap;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>\</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>\</mo><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>\</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>\</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>&cap;</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mi>&theta;</mi><mo>&af;</mo><mi>A</mi></mrow></mrow></math>对于每个<math><mrow><mi>A</mi><mo>&sube;</mo><mi>X</mi></mrow></math>都成立.</li><li>现在设<math><mrow><mrow><mi>E</mi><mo>,</mo><mi>F</mi></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>而<math><mrow><mi>A</mi><mo>&sube;</mo><mi>X</mi></mrow></math>, 那么<svg width="320" height="160" stroke="black" style="display: block; margin: auto;"><path x="0" y="0" d="M 0 0 h 320 v 160 h -320 z" fill="none"/><text x="130" y="80">欠一张图</text></svg><math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><mrow><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>&cap;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>E</mi><mo>&cup;</mo><mi>F</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>\</mo><mrow><mo stretchy="false">(</mo><mrow><mi>E</mi><mo>&cup;</mo><mi>F</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>&cap;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>E</mi><mo>&cup;</mo><mi>F</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>&cap;</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>&cap;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>E</mi><mo>&cup;</mo><mi>F</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>\</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>\</mo><mrow><mo stretchy="false">(</mo><mrow><mi>E</mi><mo>&cup;</mo><mi>F</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>&cap;</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>\</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&cap;</mo><mi>F</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>\</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow><mo>\</mo><mi>F</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>&cap;</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>&theta;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>\</mo><mi>E</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mi>&theta;</mi><mo>&af;</mo><mi>A</mi></mrow></mtd></mtr></mtable></math>鉴于<math><mi>A</mi></math>是任意的, 故<math><mrow><mrow><mi>E</mi><mo>&cup;</mo><mi>F</mi></mrow><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>.</li><li>因此, <math><mi mathvariant="normal">&Sigma;</mi></math>在简单并和补下封闭, 并且包含<math><mi>&empty;</mi></math>. 现在设<math><msub><mrow><mo stretchy="false">&lang;</mo><msub><mi>E</mi><mi>n</mi></msub><mo stretchy="false">&rang;</mo></mrow><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></msub></math>是<math><mi mathvariant="normal">&Sigma;</mi></math>中的一个序列, 并且<math><mrow><mi>E</mi><mo>=</mo><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>E</mi><mi>n</mi></msub></mrow></mrow></math>, 置<math display="block"><mrow><msub><mi>G</mi><mi>n</mi></msub><mo>=</mo><mrow><munder><mo>&bigcup;</mo><mrow><mi>m</mi><mo>&le;</mo><mi>n</mi></mrow></munder><msub><mi>E</mi><mi>m</mi></msub></mrow></mrow><mtext>;</mtext></math>那么根据<math><mi>n</mi></math>上的归纳, 对于每个<math><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>有<math><mrow><msub><mi>G</mi><mi>n</mi></msub><mo>&in;</mo><mi mathvariant="normal">&Sigma;</mi></mrow></math>. 置<math display="block"><mrow><mrow><msub><mi>F</mi><mn>0</mn></msub><mo>=</mo><msub><mi>G</mi><mn>0</mn></msub><mo>=</mo><msub><mi>E</mi><mn>0</mn></msub></mrow><mo>,</mo><mrow><msub><mi>F</mi><mi>n</mi></msub><mo>=</mo><mrow><msub><mi>G</mi><mi>n</mi></msub><mo>\</mo><msub><mi>G</mi><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><mo>=</mo><mrow><msub><mi>E</mi><mi>n</mi></msub><mo>\</mo><msub><mi>G</mi><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow></mrow></mrow><mtext>&nbsp;for&nbsp;</mtext><mrow><mi>n</mi><mo>&ge;</mo><mn>1</mn></mrow><mtext>;</mtext></math>那么<math><mrow><mi>E</mi><mo>=</mo><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>F</mi><mi>n</mi></msub></mrow><mo>=</mo><mrow><munder><mo>&bigcup;</mo><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></munder><msub><mi>G</mi><mi>n</mi></msub></mrow></mrow></math>.<br/>取任意的<math><mrow><mi>n</mi><mo>&ge;</mo><mn>1</mn></mrow></math></li></ol><div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><div class="remark"><b>1.1.3.D. 评注. </b></div><h3>第1.1.4节 <math><mi>&Ropf;</mi></math>上的Lebesgue测度</h3><h3>第1.1.5节 <math><msup><mi>&Ropf;</mi><mi>r</mi></msup></math>上的Lebesgue测度</h3><h2>第1.2章 积分</h2><h3>第1.2.1节 可测函数</h3><h3>第1.2.2节 积分的定义</h3><h1>第2卷 广阔的基础</h1><h1>第3卷 测度代数</h1><h1>第4卷 拓扑测度空间</h1><h1>第5卷 集合论式测度论</h1><h1>第6卷 随机分析</h1></body></html>