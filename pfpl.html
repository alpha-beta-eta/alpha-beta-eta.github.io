<html><head><meta charset="utf-8"/><title>PFPL笔记</title><link href="styles.css" rel="stylesheet"/></head><body><h1>PFPL笔记</h1><p>千里之行, 始于足下.</p><h2>第1章 抽象句法</h2><p>抽象绑定树 (abstract binding tree) 这个概念最初令我非常困惑, 后来我意识到我本来就理解了这个概念, 只是Robert Harper故意使用了一种让人混淆的记号.</p><h3>第1.1节 抽象句法树</h3><h3>第1.2节 抽象绑定树</h3><h3>第1.3节 注记</h3><h2>第2章 归纳定义</h2><h2>第3章 假言判断和一般判断</h2><h2>第4章 静态(语义)</h2><p>绝大多数语言都呈现出一种阶段的划分, 即静态阶段和动态阶段. 静态阶段进行(句法分析和)类型检查, 确保程序是良形式的 (well-formed). 动态阶段是对于良形式的程序进行执行. 语言的安全性指的是良形式的程序在执行过程之中是良表现的 (well-behaved).</p><p>实际上, 良表现取决于定义. 例如, 一般而言, 无限执行下去而不终止并不视为非良表现的. 我认为Robert Harper在这里定义的所谓安全显然是对于类型安全表述的化用. 类型安全性指的是良类型的程序在执行过程之中不会出现类型错误. 当然, 类型错误也取决于定义.</p><h2>第5章 动态(语义)</h2><h2>第6章 类型安全</h2><h2>第7章 求值动态</h2><h2>第8章 函数定义和值</h2><h2>第9章 高阶递归的System T</h2><h3>第9.1节 静态语义</h3><p><math><mi mathvariant="sans-serif">T</mi></math>的句法由以下语法给出:<math display="block"><mtable columnalign="center right center left left left"><mtr><mtd><mi mathvariant="sans-serif">Typ</mi></mtd><mtd><mi>&tau;</mi></mtd><mtd><mo>&Colone;</mo></mtd><mtd><mi>nat</mi></mtd><mtd><mi>nat</mi></mtd><mtd><mtext>naturals</mtext></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mrow><mi>arr</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>&tau;</mi><mn>1</mn></msub><mo>;</mo><msub><mi>&tau;</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mrow><msub><mi>&tau;</mi><mn>1</mn></msub><mo>&rarr;</mo><msub><mi>&tau;</mi><mn>2</mn></msub></mrow></mtd><mtd><mtext>function</mtext></mtd></mtr><mtr><mtd><mi mathvariant="sans-serif">Exp</mi></mtd><mtd><mi>e</mi></mtd><mtd><mo>&Colone;</mo></mtd><mtd><mi>x</mi></mtd><mtd><mi>x</mi></mtd><mtd><mtext>variable</mtext></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mi mathvariant="normal">z</mi></mtd><mtd><mi mathvariant="normal">z</mi></mtd><mtd><mtext>zero</mtext></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mrow><mi mathvariant="normal">s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mrow><mi mathvariant="normal">s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mtext>successor</mtext></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mrow><mrow><mi>rec</mi><mo>&af;</mo><mrow><mo stretchy="false">{</mo><mi>&tau;</mi><mo stretchy="false">}</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>e</mi><mo>;</mo><msub><mi>e</mi><mn>0</mn></msub><mo>;</mo><mrow><mi>x</mi><mo>.</mo><mi>y</mi><mo>.</mo><msub><mi>e</mi><mn>1</mn></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mrow><mi>rec</mi><mi>e</mi><mrow><mo stretchy="false">{</mo><mrow><mrow><mi mathvariant="normal">z</mi><mo>&rarrhk;</mo><msub><mi>e</mi><mn>0</mn></msub></mrow><mo>|</mo><mrow><mrow><mi mathvariant="normal">s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mi>with</mi><mrow><mi>y</mi><mo>&rarrhk;</mo><msub><mi>e</mi><mn>1</mn></msub></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></mtd><mtd><mtext>recursion</mtext></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mrow><mrow><mi>&lambda;</mi><mo>&af;</mo><mrow><mo stretchy="false">{</mo><mi>&tau;</mi><mo stretchy="false">}</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>.</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mrow><mi>&lambda;</mi><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>:</mo><mi>&tau;</mi></mrow><mo stretchy="false">)</mo></mrow><mi>e</mi></mrow></mtd><mtd><mtext>abstraction</mtext></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mrow><mi>ap</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>e</mi><mn>1</mn></msub><mo>;</mo><msub><mi>e</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mrow><msub><mi>e</mi><mn>1</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mtext>application</mtext></mtd></mtr></mtable></math></p><p>对于表达式<math><mrow><mi mathvariant="normal">s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mo>&hellip;</mo><mrow><mi mathvariant="normal">s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">z</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>我们记<math><mover><mi>n</mi><mo>&OverBar;</mo></mover></math>, 其中后继被应用<math><mrow><mi>n</mi><mo>&ge;</mo><mn>0</mn></mrow></math>次于零. 表达式<math><mrow><mrow><mi>rec</mi><mo>&af;</mo><mrow><mo stretchy="false">{</mo><mi>&tau;</mi><mo stretchy="false">}</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>e</mi><mo>;</mo><msub><mi>e</mi><mn>0</mn></msub><mo>;</mo><mrow><mi>x</mi><mo>.</mo><mi>y</mi><mo>.</mo><msub><mi>e</mi><mn>1</mn></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>被称为<em>递归子(recursor)</em>. 其代表了自<math><msub><mi>e</mi><mn>0</mn></msub></math>开始的变换<math><mrow><mi>x</mi><mo>.</mo><mi>y</mi><mo>.</mo><msub><mi>e</mi><mn>1</mn></msub></mrow></math>的<math><mi>e</mi></math>重迭代. 绑定变量<math><mi>x</mi></math>代表着前继而绑定变量<math><mi>y</mi></math>代表着<math><mi>x</mi></math>重迭代的结果.</p><p>有时<em>迭代子(iterator)</em>会被考虑作为递归子的替代, 即<math><mrow><mrow><mi>iter</mi><mo>&af;</mo><mrow><mo stretchy="false">{</mo><mi>&tau;</mi><mo stretchy="false">}</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>e</mi><mo>;</mo><msub><mi>e</mi><mn>0</mn></msub><mo>;</mo><mrow><mi>y</mi><mo>.</mo><msub><mi>e</mi><mn>1</mn></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>. 其基本上和递归子同义, 只是仅有递归调用的结果在<math><msub><mi>e</mi><mn>1</mn></msub></math>中被绑定为<math><mi>y</mi></math>, 而前继则没有绑定. 显然递归子可以被视为迭代子的特殊情形, 因为我们总是可以忽略前继的绑定. 反过来, 只要我们有了积类型, 递归子也可由迭代子定义. {译注: 这是The Little Typer的作者在无意间犯下的疏忽, 即他们认为递归子比迭代子的表达力严格更强.} 为了由迭代子定义递归子, 在迭代指定计算时我们还要计算前继.</p><p><math><mi mathvariant="sans-serif">T</mi></math>的静态语义由以下定型规则给出:<math display="block"><mtable columnalign="left center right" width="100%" displaystyle="true"><mtr><mtd><mphantom><mtext>(9.1a)</mtext></mphantom></mtd><mtd><mfrac displaystyle="true"><mrow/><mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>,</mo><mrow><mi>x</mi><mo>:</mo><mi>&tau;</mi></mrow></mrow><mo>&vdash;</mo><mrow><mi>x</mi><mo>:</mo><mi>&tau;</mi></mrow></mrow></mfrac></mtd><mtd><mtext>(9.1a)</mtext></mtd></mtr></mtable></math><math display="block"><mtable columnalign="left center right" width="100%" displaystyle="true"><mtr><mtd><mphantom><mtext>(9.1b)</mtext></mphantom></mtd><mtd><mfrac displaystyle="true"><mrow/><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mi mathvariant="normal">z</mi><mo>:</mo><mi>nat</mi></mrow></mrow></mfrac></mtd><mtd><mtext>(9.1b)</mtext></mtd></mtr></mtable></math><math display="block"><mtable columnalign="left center right" width="100%" displaystyle="true"><mtr><mtd><mphantom><mtext>(9.1c)</mtext></mphantom></mtd><mtd><mfrac displaystyle="true"><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mi>e</mi><mo>:</mo><mi>nat</mi></mrow></mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mrow><mi mathvariant="normal">s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><mi>nat</mi></mrow></mrow></mfrac></mtd><mtd><mtext>(9.1c)</mtext></mtd></mtr></mtable></math><math display="block"><mtable columnalign="left center right" width="100%" displaystyle="true"><mtr><mtd><mphantom><mtext>(9.1d)</mtext></mphantom></mtd><mtd><mfrac displaystyle="true"><mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mi>e</mi><mo>:</mo><mi>nat</mi></mrow></mrow><mspace width="8ex"/><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><msub><mi>e</mi><mn>0</mn></msub><mo>:</mo><mi>&tau;</mi></mrow></mrow><mspace width="8ex"/><mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>,</mo><mrow><mi>x</mi><mo>:</mo><mi>nat</mi></mrow><mo>,</mo><mrow><mi>y</mi><mo>:</mo><mi>&tau;</mi></mrow></mrow><mo>&vdash;</mo><mrow><msub><mi>e</mi><mn>1</mn></msub><mo>:</mo><mi>&tau;</mi></mrow></mrow></mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mrow><mrow><mi>rec</mi><mo>&af;</mo><mrow><mo stretchy="false">{</mo><mi>&tau;</mi><mo stretchy="false">}</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>e</mi><mo>;</mo><msub><mi>e</mi><mn>0</mn></msub><mo>;</mo><mrow><mi>x</mi><mo>.</mo><mi>y</mi><mo>.</mo><msub><mi>e</mi><mn>1</mn></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><mi>&tau;</mi></mrow></mrow></mfrac></mtd><mtd><mtext>(9.1d)</mtext></mtd></mtr></mtable></math><math display="block"><mtable columnalign="left center right" width="100%" displaystyle="true"><mtr><mtd><mphantom><mtext>(9.1e)</mtext></mphantom></mtd><mtd><mfrac displaystyle="true"><mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>,</mo><mrow><mi>x</mi><mo>:</mo><msub><mi>&tau;</mi><mn>1</mn></msub></mrow></mrow><mo>&vdash;</mo><mrow><mi>e</mi><mo>:</mo><msub><mi>&tau;</mi><mn>2</mn></msub></mrow></mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mrow><mrow><mi>&lambda;</mi><mo>&af;</mo><mrow><mo stretchy="false">{</mo><msub><mi>&tau;</mi><mn>1</mn></msub><mo stretchy="false">}</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>.</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><mrow><mi>arr</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>&tau;</mi><mn>1</mn></msub><mo>;</mo><msub><mi>&tau;</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mfrac></mtd><mtd><mtext>(9.1e)</mtext></mtd></mtr></mtable></math><math display="block"><mtable columnalign="left center right" width="100%" displaystyle="true"><mtr><mtd><mphantom><mtext>(9.1f)</mtext></mphantom></mtd><mtd><mfrac displaystyle="true"><mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><msub><mi>e</mi><mn>1</mn></msub><mo>:</mo><mrow><mi>arr</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>&tau;</mi><mn>2</mn></msub><mo>;</mo><mi>&tau;</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mspace width="8ex"/><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><msub><mi>&tau;</mi><mn>2</mn></msub></mrow></mrow></mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mrow><mi>ap</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>e</mi><mn>1</mn></msub><mo>;</mo><msub><mi>e</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><mi>&tau;</mi></mrow></mrow></mfrac></mtd><mtd><mtext>(9.1f)</mtext></mtd></mtr></mtable></math></p><p>和往常一样, 替换的结构规则的兼容性是特别重要的.</p><div class="lemma"><b>引理9.1. </b>如果<math><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mi>e</mi><mo>:</mo><mi>&tau;</mi></mrow></mrow></math>且<math><mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>,</mo><mrow><mi>x</mi><mo>:</mo><mi>&tau;</mi></mrow></mrow><mo>&vdash;</mo><mrow><msup><mi>e</mi><mo>&prime;</mo></msup><mo>:</mo><msup><mi>&tau;</mi><mo>&prime;</mo></msup></mrow></mrow></math>, 那么<math><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mrow><mrow><mo stretchy="false">[</mo><mrow><mi>e</mi><mo lspace="0" rspace="0">/</mo><mi>x</mi></mrow><mo stretchy="false">]</mo></mrow><msup><mi>e</mi><mo>&prime;</mo></msup></mrow><mo>:</mo><msup><mi>&tau;</mi><mo>&prime;</mo></msup></mrow></mrow></math>.</div><h3>第9.2节 动态语义</h3><p><math><mi mathvariant="sans-serif">T</mi></math>的封闭值由以下规则定义:<math display="block"><mtable columnalign="left center right" width="100%" displaystyle="true"><mtr><mtd><mphantom><mtext>(9.2a)</mtext></mphantom></mtd><mtd><mfrac displaystyle="true"><mrow/><mrow><mi mathvariant="normal">z</mi><mi mathvariant="sans-serif">val</mi></mrow></mfrac></mtd><mtd><mtext>(9.2a)</mtext></mtd></mtr></mtable></math><math display="block"><mtable columnalign="left center right" width="100%" displaystyle="true"><mtr><mtd><mphantom><mtext>(9.2b)</mtext></mphantom></mtd><mtd><mfrac displaystyle="true"><mrow><mo stretchy="false">[</mo><mrow><mi>e</mi><mi mathvariant="sans-serif">val</mi></mrow><mo stretchy="false">]</mo></mrow><mrow><mrow><mi mathvariant="normal">s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow></mrow><mi mathvariant="sans-serif">val</mi></mrow></mfrac></mtd><mtd><mtext>(9.2b)</mtext></mtd></mtr></mtable></math><math display="block"><mtable columnalign="left center right" width="100%" displaystyle="true"><mtr><mtd><mphantom><mtext>(9.2c)</mtext></mphantom></mtd><mtd><mfrac displaystyle="true"><mrow/><mrow><mrow><mrow><mi>&lambda;</mi><mo>&af;</mo><mrow><mo stretchy="false">{</mo><mi>&tau;</mi><mo stretchy="false">}</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>.</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mi mathvariant="sans-serif">val</mi></mrow></mfrac></mtd><mtd><mtext>(9.2c)</mtext></mtd></mtr></mtable></math>(9.2b)的前提对于后继的<em>急切</em>解释是包含在内的, 对于<em>惰性</em>解释是排除在外的.</p><p><math><mi mathvariant="sans-serif">T</mi></math>的动态语义的转换规则如下:<math display="block"><mtable columnalign="left center right" width="100%" displaystyle="true"><mtr><mtd><mphantom><mtext>(9.3a)</mtext></mphantom></mtd><mtd><mrow><mo>[</mo><mfrac displaystyle="true"><mrow><mi>e</mi><mo>&mapsto;</mo><msup><mi>e</mi><mo>&prime;</mo></msup></mrow><mrow><mrow><mi mathvariant="normal">s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&mapsto;</mo><mrow><mi mathvariant="normal">s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msup><mi>e</mi><mo>&prime;</mo></msup><mo stretchy="false">)</mo></mrow></mrow></mrow></mfrac><mo>]</mo></mrow></mtd><mtd><mtext>(9.3a)</mtext></mtd></mtr></mtable></math><math display="block"><mtable columnalign="left center right" width="100%" displaystyle="true"><mtr><mtd><mphantom><mtext>(9.3b)</mtext></mphantom></mtd><mtd><mfrac displaystyle="true"><mrow><msub><mi>e</mi><mn>1</mn></msub><mo>&mapsto;</mo><msubsup><mi>e</mi><mn>1</mn><mo>&prime;</mo></msubsup></mrow><mrow><mrow><mi>ap</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>e</mi><mn>1</mn></msub><mo>;</mo><msub><mi>e</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&mapsto;</mo><mrow><mi>ap</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msubsup><mi>e</mi><mn>1</mn><mo>&prime;</mo></msubsup><mo>;</mo><msub><mi>e</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mfrac></mtd><mtd><mtext>(9.3b)</mtext></mtd></mtr></mtable></math><math display="block"><mtable columnalign="left center right" width="100%" displaystyle="true"><mtr><mtd><mphantom><mtext>(9.3c)</mtext></mphantom></mtd><mtd><mrow><mo>[</mo><mfrac displaystyle="true"><mrow><mrow><msub><mi>e</mi><mn>1</mn></msub><mi mathvariant="sans-serif">val</mi></mrow><mspace width="8ex"/><mrow><msub><mi>e</mi><mn>2</mn></msub><mo>&mapsto;</mo><msubsup><mi>e</mi><mn>2</mn><mo>&prime;</mo></msubsup></mrow></mrow><mrow><mrow><mi>ap</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>e</mi><mn>1</mn></msub><mo>;</mo><msub><mi>e</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&mapsto;</mo><mrow><mi>ap</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>e</mi><mn>1</mn></msub><mo>;</mo><msubsup><mi>e</mi><mn>2</mn><mo>&prime;</mo></msubsup></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mfrac><mo>]</mo></mrow></mtd><mtd><mtext>(9.3c)</mtext></mtd></mtr></mtable></math><math display="block"><mtable columnalign="left center right" width="100%" displaystyle="true"><mtr><mtd><mphantom><mtext>(9.3d)</mtext></mphantom></mtd><mtd><mfrac displaystyle="true"><mrow><mo stretchy="false">[</mo><mrow><msub><mi>e</mi><mn>2</mn></msub><mi mathvariant="sans-serif">val</mi></mrow><mo stretchy="false">]</mo></mrow><mrow><mrow><mi>ap</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mrow><mi>&lambda;</mi><mo>&af;</mo><mrow><mo stretchy="false">{</mo><mi>&tau;</mi><mo stretchy="false">}</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>.</mo><mi>e</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>;</mo><msub><mi>e</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&mapsto;</mo><mrow><mrow><mo stretchy="false">[</mo><mrow><msub><mi>e</mi><mn>2</mn></msub><mo lspace="0" rspace="0">/</mo><mi>x</mi></mrow><mo stretchy="false">]</mo></mrow><mi>e</mi></mrow></mrow></mfrac></mtd><mtd><mtext>(9.3d)</mtext></mtd></mtr></mtable></math><math display="block"><mtable columnalign="left center right" width="100%" displaystyle="true"><mtr><mtd><mphantom><mtext>(9.3e)</mtext></mphantom></mtd><mtd><mfrac displaystyle="true"><mrow><mi>e</mi><mo>&mapsto;</mo><msup><mi>e</mi><mo>&prime;</mo></msup></mrow><mrow><mrow><mrow><mi>rec</mi><mo>&af;</mo><mrow><mo stretchy="false">{</mo><mi>&tau;</mi><mo stretchy="false">}</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>e</mi><mo>;</mo><msub><mi>e</mi><mn>0</mn></msub><mo>;</mo><mrow><mi>x</mi><mo>.</mo><mi>y</mi><mo>.</mo><msub><mi>e</mi><mn>1</mn></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&mapsto;</mo><mrow><mrow><mi>rec</mi><mo>&af;</mo><mrow><mo stretchy="false">{</mo><mi>&tau;</mi><mo stretchy="false">}</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>e</mi><mo>&prime;</mo></msup><mo>;</mo><msub><mi>e</mi><mn>0</mn></msub><mo>;</mo><mrow><mi>x</mi><mo>.</mo><mi>y</mi><mo>.</mo><msub><mi>e</mi><mn>1</mn></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mfrac></mtd><mtd><mtext>(9.3e)</mtext></mtd></mtr></mtable></math><math display="block"><mtable columnalign="left center right" width="100%" displaystyle="true"><mtr><mtd><mphantom><mtext>(9.3f)</mtext></mphantom></mtd><mtd><mfrac displaystyle="true"><mrow/><mrow><mrow><mrow><mi>rec</mi><mo>&af;</mo><mrow><mo stretchy="false">{</mo><mi>&tau;</mi><mo stretchy="false">}</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">z</mi><mo>;</mo><msub><mi>e</mi><mn>0</mn></msub><mo>;</mo><mrow><mi>x</mi><mo>.</mo><mi>y</mi><mo>.</mo><msub><mi>e</mi><mn>1</mn></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&mapsto;</mo><msub><mi>e</mi><mn>0</mn></msub></mrow></mfrac></mtd><mtd><mtext>(9.3f)</mtext></mtd></mtr></mtable></math><math display="block"><mtable columnalign="left center right" width="100%" displaystyle="true"><mtr><mtd><mphantom><mtext>(9.3g)</mtext></mphantom></mtd><mtd><mfrac displaystyle="true"><mrow><mrow><mi mathvariant="normal">s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow></mrow><mi mathvariant="sans-serif">val</mi></mrow><mrow><mrow><mrow><mi>rec</mi><mo>&af;</mo><mrow><mo stretchy="false">{</mo><mi>&tau;</mi><mo stretchy="false">}</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi mathvariant="normal">s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow></mrow><mo>;</mo><msub><mi>e</mi><mn>0</mn></msub><mo>;</mo><mrow><mi>x</mi><mo>.</mo><mi>y</mi><mo>.</mo><msub><mi>e</mi><mn>1</mn></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&mapsto;</mo><mrow><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>e</mi><mo>,</mo><mrow><mrow><mi>rec</mi><mo>&af;</mo><mrow><mo stretchy="false">{</mo><mi>&tau;</mi><mo stretchy="false">}</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>e</mi><mo>;</mo><msub><mi>e</mi><mn>0</mn></msub><mo>;</mo><mrow><mi>x</mi><mo>.</mo><mi>y</mi><mo>.</mo><msub><mi>e</mi><mn>1</mn></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo lspace="0" rspace="0">/</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow><msub><mi>e</mi><mn>1</mn></msub></mrow></mrow></mfrac></mtd><mtd><mtext>(9.3g)</mtext></mtd></mtr></mtable></math>用括号包裹起来的规则和前提只是针对急切后继和按值应用的, 对于惰性后继和按名调用则是省略的. </p><div class="lemma"><b>引理9.2. </b><b>(Canonical Forms). </b>如果<math><mrow><mi>e</mi><mo>:</mo><mi>&tau;</mi></mrow></math>而<math><mrow><mi>e</mi><mi mathvariant="sans-serif">val</mi></mrow></math>, 那么<ol><li>如果<math><mrow><mi>&tau;</mi><mo>=</mo><mi>nat</mi></mrow></math>, 那么要么<math><mrow><mi>e</mi><mo>=</mo><mi mathvariant="normal">z</mi></mrow></math>, 要么对于某个<math><msup><mi>e</mi><mo>&prime;</mo></msup></math>有<math><mrow><mi>e</mi><mo>=</mo><mrow><mi mathvariant="normal">s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msup><mi>e</mi><mo>&prime;</mo></msup><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.</li><li>如果<math><mrow><mi>&tau;</mi><mo>=</mo><mrow><msub><mi>&tau;</mi><mn>1</mn></msub><mo>&rarr;</mo><msub><mi>&tau;</mi><mn>2</mn></msub></mrow></mrow></math>, 那么对于某个<math><msub><mi>e</mi><mn>2</mn></msub></math>有<math><mrow><mi>e</mi><mo>=</mo><mrow><mi>&lambda;</mi><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>:</mo><msub><mi>&tau;</mi><mn>1</mn></msub></mrow><mo stretchy="false">)</mo></mrow><msub><mi>e</mi><mn>2</mn></msub></mrow></mrow></math>.</li></ol></div><div class="theorem"><b>定理9.3. </b><b>(Safety). </b><ol><li>如果<math><mrow><mi>e</mi><mo>:</mo><mi>&tau;</mi></mrow></math>而<math><mrow><mi>e</mi><mo>&mapsto;</mo><msup><mi>e</mi><mo>&prime;</mo></msup></mrow></math>, 那么<math><mrow><msup><mi>e</mi><mo>&prime;</mo></msup><mo>:</mo><mi>&tau;</mi></mrow></math>.</li><li>如果<math><mrow><mi>e</mi><mo>:</mo><mi>&tau;</mi></mrow></math>, 那么要么<math><mrow><mi>e</mi><mi mathvariant="sans-serif">val</mi></mrow></math>, 要么对于某个<math><msup><mi>e</mi><mo>&prime;</mo></msup></math>有<math><mrow><mi>e</mi><mo>&mapsto;</mo><msup><mi>e</mi><mo>&prime;</mo></msup></mrow></math>.</li></ol></div><p>此即经典的类型安全的保持进展判则. 一个无聊但隐式的注意点是定义的谓词<math><mi mathvariant="sans-serif">val</mi></math>应该与转换规则兼容, 也就是若<math><mrow><mi>e</mi><mo>:</mo><mi>&tau;</mi></mrow></math>且<math><mrow><mi>e</mi><mi mathvariant="sans-serif">val</mi></mrow></math>, 那么不存在<math><msup><mi>e</mi><mo>&prime;</mo></msup></math>使得<math><mrow><mi>e</mi><mo>&mapsto;</mo><msup><mi>e</mi><mo>&prime;</mo></msup></mrow></math>. 换言之, 值应该是不可再转换/归约的表达式的一个子集. 有人将其称为finality of values.</p><h3>第9.3节 可定义性</h3><p>一个自然数上的数学函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>&Nopf;</mi><mo>&rarr;</mo><mi>&Nopf;</mi></mrow></mrow></math>在<math><mi mathvariant="sans-serif">T</mi></math>之中是<em>可定义的</em>, 当且仅当存在一个具有类型<math><mrow><mi>nat</mi><mo>&rarr;</mo><mi>nat</mi></mrow></math>的表达式<math><msub><mi>e</mi><mi>f</mi></msub></math>满足对于每个<math><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>, 我们有<math display="block"><mtable columnalign="left center right" width="100%" displaystyle="true"><mtr><mtd><mphantom><mtext>(9.4)</mtext></mphantom></mtd><mtd><mrow><mrow><mrow><msub><mi>e</mi><mi>f</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mover><mi>n</mi><mo>&OverBar;</mo></mover><mo stretchy="false">)</mo></mrow></mrow><mo>&equiv;</mo><mover><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&OverBar;</mo></mover></mrow><mo>:</mo><mi>nat</mi></mrow></mtd><mtd><mtext>(9.4)</mtext></mtd></mtr></mtable></math>也就是说, 数值函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>&Nopf;</mi><mo>&rarr;</mo><mi>&Nopf;</mi></mrow></mrow></math>是可定义的, 当且仅当存在一个具有类型<math><mrow><mi>nat</mi><mo>&rarr;</mo><mi>nat</mi></mrow></math>的表达式<math><msub><mi>e</mi><mi>f</mi></msub></math>满足, 当其被应用于参数<math><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>的数码表示时, 应用本身和<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>所对应的数码表示定义相等 (definitionally equal).</p><p><math><mi mathvariant="sans-serif">T</mi></math>的定义相等记作<math><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mrow><mi>e</mi><mo>&equiv;</mo><msup><mi>e</mi><mo>&prime;</mo></msup></mrow><mo>:</mo><mi>&tau;</mi></mrow></mrow></math>, 是包含以下公理的最强congruence关系:<math display="block"><mtable columnalign="left center right" width="100%" displaystyle="true"><mtr><mtd><mphantom><mtext>(9.5a)</mtext></mphantom></mtd><mtd><mfrac displaystyle="true"><mrow><mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>,</mo><mrow><mi>x</mi><mo>:</mo><msub><mi>&tau;</mi><mn>1</mn></msub></mrow></mrow><mo>&vdash;</mo><mrow><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><msub><mi>&tau;</mi><mn>2</mn></msub></mrow></mrow><mspace width="8ex"/><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><msub><mi>e</mi><mn>1</mn></msub><mo>:</mo><msub><mi>&tau;</mi><mn>1</mn></msub></mrow></mrow></mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mrow><mrow><mi>ap</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mrow><mi>&lambda;</mi><mo>&af;</mo><mrow><mo stretchy="false">{</mo><msub><mi>&tau;</mi><mn>1</mn></msub><mo stretchy="false">}</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>.</mo><msub><mi>e</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>;</mo><msub><mi>e</mi><mn>1</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&equiv;</mo><mrow><mrow><mo stretchy="false">[</mo><mrow><msub><mi>e</mi><mn>1</mn></msub><mo lspace="0" rspace="0">/</mo><mi>x</mi></mrow><mo stretchy="false">]</mo></mrow><msub><mi>e</mi><mn>2</mn></msub></mrow></mrow><mo>:</mo><msub><mi>&tau;</mi><mn>2</mn></msub></mrow></mrow></mfrac></mtd><mtd><mtext>(9.5a)</mtext></mtd></mtr></mtable></math></p><h3>第9.4节 不可定义性</h3><p>你无法在<math><mi mathvariant="sans-serif">T</mi></math>中定义一个无限循环.</p><div class="theorem"><b>定理9.4. </b>如果<math><mrow><mi>e</mi><mo>:</mo><mi>&tau;</mi></mrow></math>, 那么存在<math><mrow><mi>v</mi><mi mathvariant="sans-serif">val</mi></mrow></math>满足<math><mrow><mrow><mi>e</mi><mo>&equiv;</mo><mi>v</mi></mrow><mo>:</mo><mi>&tau;</mi></mrow></math>.</div><h2>第10章 </h2><h2>第11章 </h2><h2>第12章 </h2><h2>第13章 </h2><h2>第14章 </h2><h2>第15章 </h2><h2>第16章 </h2><h2>第17章 </h2><h2>第18章 </h2><h2>第19章 </h2><h2>第20章 </h2><h2>第21章 </h2><h2>第22章 </h2><h2>第23章 </h2><h2>第24章 </h2><h2>第25章 </h2><h2>第26章 </h2><h2>第27章 </h2><h2>第28章 </h2><h2>第29章 </h2><h2>第30章 </h2><h2>第31章 </h2><h2>第32章 </h2><h2>第33章 </h2><h2>第34章 </h2><h2>第35章 </h2><h2>第36章 </h2><h2>第37章 </h2><h2>第38章 </h2><h2>第39章 </h2><h2>第40章 </h2><h2>第41章 </h2><h2>第42章 </h2><h2>第43章 </h2><h2>第44章 </h2><h2>第45章 </h2><h2>第46章 System T的相等性</h2><p>函数式编程的优美之处在于函数式语言中的表达式相等遵循着令人熟悉的数学推理模式. 例如, 在第9章的语言<math><mi mathvariant="sans-serif">T</mi></math>之中 (这个语言里我们可以将加法表达为函数<math><mi>plus</mi></math>), 表达式<math display="block"><mrow><mi>&lambda;</mi><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>:</mo><mi>nat</mi></mrow><mo stretchy="false">)</mo></mrow><mrow><mi>&lambda;</mi><mrow><mo stretchy="false">(</mo><mrow><mi>y</mi><mo>:</mo><mi>nat</mi></mrow><mo stretchy="false">)</mo></mrow><mrow><mrow><mi>plus</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>和<math display="block"><mrow><mi>&lambda;</mi><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>:</mo><mi>nat</mi></mrow><mo stretchy="false">)</mo></mrow><mrow><mi>&lambda;</mi><mrow><mo stretchy="false">(</mo><mrow><mi>y</mi><mo>:</mo><mi>nat</mi></mrow><mo stretchy="false">)</mo></mrow><mrow><mrow><mi>plus</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>是相等的. 换言之, <em>在<math><mi mathvariant="sans-serif">T</mi></math>中所编写的</em>加法函数是交换的.</p><p>加法的交换性似乎是自明的, 但是<em>为什么</em>这是真的呢? 两个表达式相等又是什么意思呢? 这两个表达式并非<em>定义</em>相等; 其相等性需要证明, 而不仅仅是算术. 尽管如此, 这两个表达式是可互换的, 因为它们当被应用于相同的数字时总能给出相同的结果. 一般地, 两个函数是<em>逻辑等价的</em>, 如果它们对于相等的参数给出相等的结果. 我们或许会期望逻辑等价的函数在任意程序中都是可以互换的, 因为逻辑等价是关于函数唯一重要的事情了. 如果我们将包含这些函数的程序想成是对于函数行为的<em>观察</em>, 那么这些函数被称为是<em>观察等价的</em>. 本章的主要结果是观察等价和逻辑等价对于<math><mi mathvariant="sans-serif">T</mi></math>的一个变种是相合的, 这个变种里后继的求值是急切的, 于是类型<math><mi>nat</mi></math>的一个值是一个数码 (numeral).</p><h3>第46.1节 观察等价</h3><p>何时两个表达式是相等的? 每当我们不能区分它们的时候! 似乎这么说是一种冗余重复, 但是实际上并不是, 因为这取决于我们所考虑的用以区分表达式的手段. 什么<q>实验</q>是我们被允许在表达式上执行以区分它们的呢? 什么样的观察 (如果对于两个表达式而言并不相同) 可以算作表达式不同的确定标志呢?</p><p>如果我们允许我们自己考虑表达式的句法细节, 那么很少的表达式可以被认为是相等的. </p><h3>第46.2节 </h3><h3>第46.3节 </h3><h3>第46.4节 </h3><h3>第46.5节 注记</h3><p><em>逻辑关系</em>方法将类型解释为关系 (这里指的是等价关系), 通过将每个类型构造子联系以一个关系作用, 这个作用将解释(类型构造子的)参数的关系转变为解释被构造的类型的关系. 逻辑关系 (Statman, 1985) 在类型论之中是一种基本工具, 并为NuPRL类型论 (Constable, 1986; Allen, 1987; Harper, 1992) 的语义提供了基础. 使用逻辑关系刻画观察等价是将NuPRL的语义转换为应用在G&ouml;del的System T这一更简单的场景.</p><p>对于类型构造子<math><mi>T</mi></math>, 对于类型<math><mi>A</mi></math>和<math><mi>B</mi></math>, 如果<math><msub><mi>R</mi><mi>A</mi></msub></math>和<math><msub><mi>R</mi><mi>B</mi></msub></math>分别是<math><mi>A</mi></math>和<math><mi>B</mi></math>所对应的关系, 那么<math><mi>T</mi></math>的关系动作将<math><msub><mi>R</mi><mi>A</mi></msub></math>和<math><msub><mi>R</mi><mi>B</mi></msub></math>变换为<math><mrow><mi>T</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>所对应的关系<math><msub><mi>R</mi><mrow><mi>T</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></msub></math>.</p><h2>第47章 </h2><h2>第48章 </h2><h2>第49章 </h2></body></html>