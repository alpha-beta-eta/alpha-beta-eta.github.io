<html><head><meta charset="utf-8"/><title>函数式编程的domain论基础</title><link href="styles.css" rel="stylesheet"/></head><body><h1>函数式编程的domain论基础</h1><h2>前言</h2><p>这本小书是我过去十年间为Technical University Darmstadt的数学系和计算机系学生开设的一门课程的产物. 这门课程的目的在于为想要撰写指称语义领域的硕士论文或者想要在这个领域开始PhD生涯的学生提供坚实的基础. 对于后一个目的而言, 本书也在University of Birmingham (UK) 由Martin Escard&oacute;的学生成功地运用.</p><p>因此, 我认为这本小册子很好地满足了预想的目标, 即填补介绍性教科书 (例如[Winskel 1993]) 和指称语义领域的诸多研究性论文之间的沟壑. 我有意专注于基于<em>domain论</em>的指称语义, 而忽略了近来的<em>博弈语义(Game Semantics)</em> (见[Hyland and Ong 2000; Abramsky et al. 2000]), 在某种意义上其坐落于操作语义和指称语义之间. 这种选择的理由一方面在于博弈语义在[McCusker 1998]里已经很好地涵盖了, 另一方面在于我发现基于domain的语义在数学上相比其他方法更加简单, 因为其本质更加抽象而更少组合 (combinatorial). 当然, 这种偏好是有些主观性的, 但是我的借口在于我们写书应该写人们更不熟悉的领域, 而不是写那些已经广为人知的领域.</p><p>我们建立我们的主题的方式是研究为人熟知的函数式的内核语言PCF, 其由Dana Scott于1960年代末引入. 第2章和第3章中我们设置了本书的场景 (scene), 这两章分别引入了PCF的操作语义和domain语义. 之后我们专注于以越来越精细的<em>逻辑关系</em>技术来研究操作语义和domain语义之间的关系, 而这在第11章和第12章中对于PCF的完全抽象模型的构造里达到顶峰. 我认为我们对于完全抽象模型的构造比既有文献中的记述更加优雅和简明, 然而当然其也是基于那些文献的. 稍微偏离了主线地, 我们也呈现了如何以Scott domain解释递归类型 (第9章) 以及给出了基于Scott domain对于可计算性的描述 (第13章), 其中我们证明了[Plotkin 1977]的经典定理, </p><h2>第1章 引论</h2><p>函数式编程语言基本上和更为人熟知的命令式语言 (例如FORTRAN, PASCAL, C, 等等) 一样古老. 最古老的函数式语言是LISP, 其由John McCarthy于1950年代建立, 即基本上和FORTRAN同时. 尽管像FORTRAN这样的<em>命令式</em>或者说<em>面向状态</em>语言是为了<em>数值计算</em>的目的而建立的, 诸如LISP这样的函数式编程语言的意图应用领域是 (并且至今仍然是) 对于诸如列表, 树等<em>符号性数据</em>的算法性操纵.</p><p>命令式语言的基本构造是修改状态的命令 (例如赋值<math><mrow><mi>x</mi><mo>&colone;</mo><mi>E</mi></mrow></math>) 和命令的条件性迭代 (例如<math><ms>while</ms></math>循环). 而且, 命令式语言对于诸如数组这样的<em>随机访问</em>数据结构有着强力的支持, 这在数值计算中是重要的.</p><p>然而, 在<em>纯函数式语言</em>之中, 并不存在状态或者状态改变指称的概念. 其基本概念是<ul><li>一个函数之于一个参数的应用</li><li>函数的定义, 要么<em>显式地</em> (例如<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>x</mi><mo>&#8270;</mo><mi>x</mi></mrow><mo>+</mo><mn>1</mn></mrow></mrow></math>), 要么<em>递归地</em> (例如<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><ms>if</ms><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><ms>then</ms><mn>1</mn><ms>else</ms><mrow><mi>x</mi><mo>&#8270;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>&minus;</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><ms>fi</ms></mrow></mrow></math>).</li></ul>这些例子表明除了除了函数的应用和定义, 我们还需要基本数据类型 (例如自然数或者布尔) 上的基本操作以及用于分类讨论定义的条件式. 而且, 所有常见的函数式编程语言 (例如LISP, Scheme, (S)ML, Haskell, 等等) 都提供了通过显式列举构造子来定义<em>递归数据类型</em>的机制, 例如在以下对于二叉树的数据类型的定义里<math display="block"><mrow><ms>tree</ms><mo>=</mo><mrow><mrow><ms>empty</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow/><mo stretchy="false">)</mo></mrow></mrow><mo>|</mo><mrow><ms>mk_tree</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><ms>tree</ms><mo>,</mo><ms>tree</ms></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math><math><ms>empty</ms></math>是对于没有儿子的空树的一个<math><mn>0</mn></math>元构造子, 而<math><ms>mk_tree</ms></math>是一个二元构造子, 其取两个树<math><msub><mi>t</mi><mn>1</mn></msub></math>和<math><msub><mi>t</mi><mn>2</mn></msub></math>, 然后构造一个新的树, 其根的左右儿子分别是<math><msub><mi>t</mi><mn>1</mn></msub></math>和<math><msub><mi>t</mi><mn>2</mn></msub></math>. 因此, 函数式语言不仅支持函数的递归定义, 也支持数据类型的递归定义. 后一个特点应该被认为是相较于PASCAL这样的命令式语言的一大优势, 其中的递归数据类型需要通过指针来实现, 这是精细的工作, 也是引入难以消除的微妙错误的一个源头.</p><p>命令式程序开发的典型方法是设计<em>流程图(flow chart)</em>, 其描述并可视化了程序的<em>动态行为</em>. 因此, 命令式语言编程的主要任务是组合<em>复杂的动态行为</em>, 也就是所谓的<em>控制流</em>.</p><p>然而, 在函数式编程语言里, 程序的动态行为无需显式描述. 转而, 人们只需要<em>定义</em>要被实现的函数. 当然, 在实践中, 这些函数定义是相当层次性的, 即基于一整个预先定义的辅助函数的级联. 然后, 一个<em>程序</em> (与一个函数定义相对) 通常具有应用<math><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>e</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>e</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></math>的形式, 其会由解释器<em>求值</em>. 鉴于在函数式语言中编程基本上由定义函数 (显式地或者递归地) 构成, 我们无需担心执行的动态方面, 因为这项任务被解释器完全接管了. 因此, 在函数式语言中编程时我们可以专注于<em>what</em>而忘记<em>how</em>. 然而, 当在函数式编程语言中定义函数时, 我们不得不拘泥于 (stick to) 由语言所提供的<em>定义形式</em>, 而不能使用日常数学中通常的集合论语言.</p><p>在这个课程讲义之中, 我们将分别就以下三个方面探究函数式的(内核)语言.<svg width="320" height="160" stroke="black" style="display: block; margin: auto;"><path x="0" y="0" d="M 0 0 h 320 v 160 h -320 z" fill="none"/><text x="130" y="80">欠一张图</text></svg>或者<svg width="320" height="160" stroke="black" style="display: block; margin: auto;"><path x="0" y="0" d="M 0 0 h 320 v 160 h -320 z" fill="none"/><text x="130" y="80">欠一张图</text></svg>特别是, 这些方面时如何交互的.</p><p>首先, 我们将会引入一个最简单的函数式编程语言, 即带有自然数作为基类型但没有一般性的递归类型的PCF (Programming Computable Functionals).</p><p>PCF的<em>操作语义</em>将由一个<em>归纳</em>定义的<em>求值关系</em><math display="block"><mrow><mi>E</mi><mo>&dArr;</mo><mi>V</mi></mrow></math>给出, 其刻画了哪个表达式<math><mi>E</mi></math>会<em>求值</em>至哪个<em>值</em>, 而值是不能被进一步求值的特定表达式. 例如, 如果<math><mrow><mi>E</mi><mo>&dArr;</mo><mi>V</mi></mrow></math>而<math><mi>E</mi></math>是一个具有自然数类型<math><ms>nat</ms></math>的封闭项, 那么<math><mi>V</mi></math>会是一个具有形式<math><munder><mi>n</mi><mo>&UnderBar;</mo></munder></math>的表达式, 即自然数<math><mi>n</mi></math>的一个canonical表达式 (通常其被称为<em>数码(numeral)</em>). 实际上求值关系<math><mo>&dArr;</mo></math>应该具有一个性质, 即每当<math><mrow><mi>E</mi><mo>&dArr;</mo><msub><mi>V</mi><mn>1</mn></msub></mrow></math>且<math><mrow><mi>E</mi><mo>&dArr;</mo><msub><mi>V</mi><mn>2</mn></msub></mrow></math>, 那么<math><mrow><msub><mi>V</mi><mn>1</mn></msub><mo>=</mo><msub><mi>V</mi><mn>2</mn></msub></mrow></math>. 这意味着关系<math><mo>&dArr;</mo></math>是<em>确定性</em>的, 意即<math><mo>&dArr;</mo></math>分配给一个给定的表达式<math><mi>E</mi></math>以至多一个值. 由(归纳定义的)求值关系<math><mo>&dArr;</mo></math>所给出的操作语义通常被称为<q>大步语义</q>, 因为其抽象掉了由<math><mi>E</mi></math>得到<math><mi>V</mi></math>的计算的中间步骤. 我们注意到一般情况下对于任意的表达式<math><mi>E</mi></math>, 可能并不存在一个值<math><mi>V</mi></math>使得<math><mrow><mi>E</mi><mo>&dArr;</mo><mi>V</mi></mrow></math>, 即不是每个程序都会终止. {译注: 其实还有另外的可能, 例如产生了运行时异常, 其并非类型错误.} 这 {译注: 指不能保证终止} 是由于<em>一般递归</em>在我们语言PCF中的存在, 其保证了<em>所有</em>的可计算函数都可以由PCF程序所表达.</p><p>基于由<math><mo>&dArr;</mo></math>所给出的PCF的大步语义, 我们将会引入具有相同类型的封闭PCF表达式的<em>观察性相等(observational equality)</em>的概念, 其中<math><msub><mi>E</mi><mn>1</mn></msub></math>和<math><msub><mi>E</mi><mn>2</mn></msub></math>被认为是观察性相等的当且仅当对于所有具有基类型<math><ms>nat</ms></math>的上下文<math><mrow><mi>C</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow/><mo stretchy="false">]</mo></mrow></mrow></math>, 都有<math display="block"><mrow><mrow><mrow><mi>C</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><msub><mi>E</mi><mn>1</mn></msub><mo stretchy="false">]</mo></mrow></mrow><mo>&dArr;</mo><munder><mi>n</mi><mo>&UnderBar;</mo></munder></mrow><mo>&hArr;</mo><mrow><mrow><mi>C</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><msub><mi>E</mi><mn>2</mn></msub><mo stretchy="false">]</mo></mrow></mrow><mo>&dArr;</mo><munder><mi>n</mi><mo>&UnderBar;</mo></munder></mrow></mrow></math>对于每个自然数<math><mrow><mi>n</mi><mo>&in;</mo><mi>&Nopf;</mi></mrow></math>成立. 从直觉上来说, 表达式<math><msub><mi>E</mi><mn>1</mn></msub></math>和<math><msub><mi>E</mi><mn>2</mn></msub></math>是观察性相等的当且仅当对于<math><msub><mi>E</mi><mn>1</mn></msub></math>和<math><msub><mi>E</mi><mn>2</mn></msub></math>可以作出相同的观察, 其中一个对于<math><mi>E</mi></math>的<em>观察</em>由观察到对于某个具有基类型<math><ms>nat</ms></math>的上下文<math><mrow><mi>C</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mrow/><mo stretchy="false">]</mo></mrow></mrow></math>和某个自然数<math><mi>n</mi></math>有<math><mrow><mrow><mi>C</mi><mo>&af;</mo><mrow><mo stretchy="false">[</mo><mi>E</mi><mo stretchy="false">]</mo></mrow></mrow><mo>&dArr;</mo><munder><mi>n</mi><mo>&UnderBar;</mo></munder></mrow></math>. 这种观察的概念是对于以下通常实践的数学形式化, 即对于程序进行测试并秉持着程序是(观察性)相等的当且仅当其通过了相同的测试这一观念.</p><p>然而, 这个观察性相等的概念并不容易使用, 因为其牵涉所有上下文上的量化, 而这所有上下文构成的集合并不容易抓住 (grasp). 因此, 我们想要找到更为方便的判则, 其可以用来推出观察性相等, 但又避免了诉诸于(有些复杂的)句法概念, 例如求值关系和上下文.</p><p>为此目的, 我们引入了所谓的PCF的<em>指称语义</em>, 其为每个具有类型<math><mi>&sigma;</mi></math>的封闭表达式<math><mi>E</mi></math>赋予一个元素<math><mrow><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>E</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mo>&in;</mo><msub><mi>D</mi><mi>&sigma;</mi></msub></mrow></math>, 其被称为<math><mi>E</mi></math>的<em>指称</em>或者<em>意义</em>或者<em>语义</em>, 其中<math><msub><mi>D</mi><mi>&sigma;</mi></msub></math>是一个预先定义的结构化集合 (称为<q>语义domain</q>), 在这里面具有类型<math><mi>&sigma;</mi></math>的封闭表达式可以找到它们的解释.</p><p>指称语义的想法于1960年代末由Christopher Strachey和Dana Scott引入. 当然了, 一个自然的问题是我们应该给语义domain施加什么样的数学结构性质. 尽管实际上语义domain作为特定的拓扑空间来考虑是合适的, 然而其又和分析学和几何学中出现的拓扑空间在风味上相当不同. {原注: 特别地, 语义domain不是Hausdorff空间.} 合适的语义domain概念由Dana Scott引入, 其也发展了语义domain的基本数学理论到相当成熟的程度. 自1970年代初起, 全世界的诸多研究小组都在发展语义domain的理论上投入了相当的能量, 自那时起这个学科被简称为<em>domain论</em>, 其既可以从纯粹数学的观点出发, 也可以从计算机科学的观点出发, 作为编程语言的语义理论的一种.</p><p>尽管之后还将远为细致地进行讨论, 现在我们将给出预备性的陈述, 关于如何构造domain <math><msub><mi>D</mi><mi>&sigma;</mi></msub></math>, 其中具有类型<math><mi>&sigma;</mi></math>的封闭项可以找到它们的指称. 对于自然数类型<math><ms>nat</ms></math>, 我们置<math><mrow><msub><mi>D</mi><ms>nat</ms></msub><mo>=</mo><mrow><mi>&Nopf;</mi><mo>&cup;</mo><mrow><mo stretchy="false">{</mo><mi>&bottom;</mi><mo stretchy="false">}</mo></mrow></mrow></mrow></math>, 其中的<math><mi>&bottom;</mi></math> (称为<q>底 (bottom)</q>) 代表具有类型<math><ms>nat</ms></math>的项中那些求值<q>发散 (diverge)</q>的项的指称, 发散意即并不终止. {译注: 正如我之前已经提到的, 一般情况下抛出异常什么的也是发散.} 我们将<math><msub><mi>D</mi><ms>nat</ms></msub></math>视为装备了<q>信息序</q>, 相对于这个序<math><mi>&bottom;</mi></math>是最小元素, 而其他的元素 (即自然数) 之间均不可比较. {译注: 这构成了所谓的扁平格 (flat lattice).} PCF的类型从基类型<math><ms>nat</ms></math>开始由二元构成运算符<math><mo>&rarr;</mo></math>构筑而成, 其中<math><msub><mi>D</mi><mrow><mi>&sigma;</mi><mo>&rarr;</mo><mi>&tau;</mi></mrow></msub></math>被认为是从<math><msub><mi>D</mi><mi>&sigma;</mi></msub></math>到<math><msub><mi>D</mi><mi>&tau;</mi></msub></math>的(可计算或者说连续)函数的类型 {译注: 我怀疑这里是笔误, 其实是domain而非type}, 即<math><mrow><msub><mi>D</mi><mrow><mi>&sigma;</mi><mo>&rarr;</mo><mi>&tau;</mi></mrow></msub><mo>&sube;</mo><mrow><msup><msub><mi>D</mi><mi>&tau;</mi></msub><msub><mi>D</mi><mi>&sigma;</mi></msub></msup><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mi>f</mi><mo stretchy="false">|</mo><mrow><mi>f</mi><mo>:</mo><mrow><msub><mi>D</mi><mi>&sigma;</mi></msub><mo>&rarr;</mo><msub><mi>D</mi><mi>&tau;</mi></msub></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></mrow></math>. 特别地, domain <math><msub><mi>D</mi><mrow><ms>nat</ms><mo>&rarr;</mo><ms>nat</ms></mrow></msub></math>由从<math><msub><mi>D</mi><ms>nat</ms></msub></math>到自身的特定函数构成. </p><h2>第2章 PCF及其操作语义</h2><p>本章我们引入原型性质的函数式编程语言PCF及其操作语义.</p><p>PCF是一个有类型的语言, 其类型的集合<math><ms>Type</ms></math>归纳定义如下<ul><li>基类型<math><ms>nat</ms></math>是一个类型, 而</li><li>每当<math><mi>&sigma;</mi></math>和<math><mi>&tau;</mi></math>是类型, 那么<math><mrow><mo stretchy="false">(</mo><mrow><mi>&sigma;</mi><mo>&rarr;</mo><mi>&tau;</mi></mrow><mo stretchy="false">)</mo></mrow></math>也是一个类型.</li></ul>我们经常将基类型<math><ms>nat</ms></math>记为<math><mi>&iota;</mi></math>, 而记<math><mrow><mo stretchy="false">(</mo><mrow><mi>&sigma;</mi><mo>&rarr;</mo><mi>&tau;</mi></mrow><mo stretchy="false">)</mo></mrow></math>为<math><mrow><mi>&sigma;</mi><mo>&rarr;</mo><mi>&tau;</mi></mrow></math>, 其中<math><mo>&rarr;</mo></math>被理解为一个<math><ms>Type</ms></math>上的右结合二元运算, 例如<math><mrow><msub><mi>&sigma;</mi><mn>1</mn></msub><mo>&rarr;</mo><msub><mi>&sigma;</mi><mn>2</mn></msub><mo>&rarr;</mo><msub><mi>&sigma;</mi><mn>3</mn></msub></mrow></math>应该读作<math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>&sigma;</mi><mn>1</mn></msub><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>&sigma;</mi><mn>2</mn></msub><mo>&rarr;</mo><msub><mi>&sigma;</mi><mn>3</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></math>. 根据<math><ms>Type</ms></math>的归纳定义, 每个类型<math><mi>&sigma;</mi></math>都以唯一的方式具有形式<math><mrow><msub><mi>&sigma;</mi><mn>1</mn></msub><mo>&rarr;</mo><mo>&ctdot;</mo><mo>&rarr;</mo><msub><mi>&sigma;</mi><mi>n</mi></msub><mo>&rarr;</mo><mi>&iota;</mi></mrow></math>.</p><p>鉴于PCF的项可能包含自由变量, 我们将相对于<em>类型上下文(type context)</em>来定义项, 在类型上下文之中有限多个变量和其类型一起声明, 即类型上下文是具有形式<math display="block"><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&equiv;</mo><mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>:</mo><msub><mi>&sigma;</mi><mn>1</mn></msub></mrow><mo>,</mo><mo>&hellip;</mo><mo>,</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>:</mo><msub><mi>&sigma;</mi><mi>n</mi></msub></mrow></mrow></mrow></math>的表达式, 其中<math><msub><mi>&sigma;</mi><mi>i</mi></msub></math>是类型而<math><msub><mi>x</mi><mi>i</mi></msub></math>是两两互异的变量. 因为变量无法出现于类型表达式之中, 那么<math><mi mathvariant="normal">&Gamma;</mi></math>之中单个变量声明<math><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>:</mo><msub><mi>&sigma;</mi><mi>i</mi></msub></mrow></math>的顺序就是不重要的. 据此, 如果<math><msup><mi mathvariant="normal">&Gamma;</mi><mo>&prime;</mo></msup></math>是由<math><mi mathvariant="normal">&Gamma;</mi></math>通过置换得到的, 那么我们就将它们视为等同的.</p><p>具有形式<math display="block"><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mi>M</mi><mo>:</mo><mi>&sigma;</mi></mrow></mrow></math>的合法判断在图2.1中由归纳定义, 其意即<math><mi>M</mi></math>在上下文<math><mi mathvariant="normal">&Gamma;</mi></math>之中是一个具有类型<math><mi>&sigma;</mi></math>的项.</p><table align="center" style="border-spacing: 3em 1em;"><tr><td><math><mfrac displaystyle="true"><mrow/><mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>,</mo><mrow><mi>x</mi><mo>:</mo><mi>&sigma;</mi></mrow><mo>,</mo><mi mathvariant="normal">&Delta;</mi></mrow><mo>&vdash;</mo><mrow><mi>x</mi><mo>:</mo><mi>&sigma;</mi></mrow></mrow></mfrac></math></td><td><math><mfrac displaystyle="true"><mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>,</mo><mrow><mi>x</mi><mo>:</mo><mi>&sigma;</mi></mrow></mrow><mo>&vdash;</mo><mrow><mi>M</mi><mo>:</mo><mi>&tau;</mi></mrow></mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>&lambda;</mi><mrow><mi>x</mi><mo>:</mo><mi>&sigma;</mi></mrow><mo lspace="0" rspace="0">.</mo><mi>M</mi></mrow><mo stretchy="false">)</mo></mrow><mo>:</mo><mrow><mi>&sigma;</mi><mo>&rarr;</mo><mi>&tau;</mi></mrow></mrow></mrow></mfrac></math></td></tr><tr><td><math><mfrac displaystyle="true"><mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mi>M</mi><mo>:</mo><mrow><mi>&sigma;</mi><mo>&rarr;</mo><mi>&tau;</mi></mrow></mrow></mrow><mspace width="8ex"/><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mi>N</mi><mo>:</mo><mi>&sigma;</mi></mrow></mrow></mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mrow><mi>M</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><mi>&tau;</mi></mrow></mrow></mfrac></math></td><td><math><mfrac displaystyle="true"><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mi>M</mi><mo>:</mo><mrow><mi>&sigma;</mi><mo>&rarr;</mo><mi>&sigma;</mi></mrow></mrow></mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mrow><msub><ms>Y</ms><mi>&sigma;</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><mi>&sigma;</mi></mrow></mrow></mfrac></math></td></tr><tr><td><math><mfrac displaystyle="true"><mrow/><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><ms>zero</ms><mo>:</mo><ms>nat</ms></mrow></mrow></mfrac></math></td><td><math><mfrac displaystyle="true"><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mi>M</mi><mo>:</mo><ms>nat</ms></mrow></mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mrow><ms>succ</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><ms>nat</ms></mrow></mrow></mfrac></math></td></tr><tr><td><math><mfrac displaystyle="true"><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mi>M</mi><mo>:</mo><ms>nat</ms></mrow></mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mrow><ms>pred</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><ms>nat</ms></mrow></mrow></mfrac></math></td><td><math><mfrac displaystyle="true"><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mrow><msub><mi>M</mi><mi>i</mi></msub><mo>:</mo><ms>nat</ms></mrow><mspace width="4ex"/><mrow><mo stretchy="false">(</mo><mrow><mi>i</mi><mo>=</mo><mrow><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mrow><ms>ifz</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>M</mi><mn>1</mn></msub><mo>,</mo><msub><mi>M</mi><mn>2</mn></msub><mo>,</mo><msub><mi>M</mi><mn>3</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><ms>nat</ms></mrow></mrow></mfrac></math></td></tr><tr><td colspan="2" align="center">图2.1 PCF的定型规则</td></tr></table><p>根据推导结构上的归纳, 我们很容易证明每当<math><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mi>M</mi><mo>:</mo><mi>&sigma;</mi></mrow></mrow></math>可以被推导出来, 那么<math><mrow><mrow><mi>&pi;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">&Gamma;</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&vdash;</mo><mrow><mi>M</mi><mo>:</mo><mi>&sigma;</mi></mrow></mrow></math>也可以被推导出来, 其中<math><mi>&pi;</mi></math>是任意对于<math><mi mathvariant="normal">&Gamma;</mi></math>的置换.</p><p>鉴于每个PCF的语言构造只有一条定型规则与之对应, 那么我们很容易证明<math><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mi>M</mi><mo>:</mo><mi>&sigma;</mi></mrow></mrow></math>中的<math><mi>&sigma;</mi></math>由<math><mi mathvariant="normal">&Gamma;</mi></math>和<math><mi>&sigma;</mi></math>唯一确定 (练习!). {译注: 唯一确定意即如果<math><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mi>M</mi><mo>:</mo><msub><mi>&sigma;</mi><mn>1</mn></msub></mrow></mrow></math>和<math><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mi>M</mi><mo>:</mo><msub><mi>&sigma;</mi><mn>2</mn></msub></mrow></mrow></math>都是可推导的, 那么<math><mrow><msub><mi>&sigma;</mi><mn>1</mn></msub><mo>=</mo><msub><mi>&sigma;</mi><mn>2</mn></msub></mrow></math>.} 因此, 反向应用定型规则产生了一个递归的<em>类型检查(type checking)</em>算法, 其给出<math><mi>M</mi></math>和<math><mi mathvariant="normal">&Gamma;</mi></math>即可计算满足<math><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mi>M</mi><mo>:</mo><mi>&sigma;</mi></mrow></mrow></math>的类型<math><mi>&sigma;</mi></math>, 只要这个类型的确存在, 否则的话也能够报错. {译注: 满足<math><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mi>M</mi><mo>:</mo><mi>&sigma;</mi></mrow></mrow></math>的意思是<math><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mi>M</mi><mo>:</mo><mi>&sigma;</mi></mrow></mrow></math>是可推导的. 也就是说, 如果存在类型<math><mi>&sigma;</mi></math>使得<math><mrow><mi mathvariant="normal">&Gamma;</mi><mo>&vdash;</mo><mrow><mi>M</mi><mo>:</mo><mi>&sigma;</mi></mrow></mrow></math>是可推导的, 那么算法就能计算出这个类型, 并且我们还知道这个类型是唯一的, 不存在这种类型的话算法也能够主动报错.} (我们邀请读者对于一些简单的例子测试这个算法!)</p><p>接下来我们不拘泥于PCF项的<q>官方 (offcial)</q>句法. 经常我们记<math><mrow><mi>M</mi><mo>&af;</mo><mi>N</mi></mrow></math>或<math><mrow><mo stretchy="false">(</mo><mrow><mi>M</mi><mo>&af;</mo><mi>N</mi></mrow><mo stretchy="false">)</mo></mrow></math>而非<math><mrow><mi>M</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></math>. 为了与<math><mo>&rarr;</mo></math>的右结合性保持一致, 我们将由并置给出的应用视为左结合的, 意即<math><mrow><msub><mi>M</mi><mn>1</mn></msub><mo>&hellip;</mo><msub><mi>M</mi><mi>n</mi></msub></mrow></math>应该读作<math><mrow><mo stretchy="false">(</mo><mrow><mo>&hellip;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>M</mi><mn>1</mn></msub><mo>&af;</mo><msub><mi>M</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&hellip;</mo><msub><mi>M</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></math>或者<math><mrow><mrow><mrow><msub><mi>M</mi><mn>1</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>M</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>&af;</mo><mo>&hellip;</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>M</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></math>.</p><p>对于由<math><mi>&lambda;</mi></math>所绑定的变量, 我们采取通常的<em><math><mi>&alpha;</mi></math>转换</em>的约定, 即项被认为是相等的, 如果它们互相可以通过对于绑定变量进行适当换名得到. {译注: 换言之, 更技术性地说, 在某种意义上我们要考虑的是<math><mi>&lambda;</mi></math>项的<math><mi>&alpha;</mi></math>等价类.} 而且, 当替换项<math><mi>M</mi></math>中的变量<math><mi>x</mi></math>为项<math><mi>N</mi></math>时, 我们首先会对于<math><mi>M</mi></math>的绑定变量进行换名以使得<math><mi>N</mi></math>的自由变量不会被<math><mi>M</mi></math>中的<em>lambda抽象</em>绑定, 也就是说我们所用的是<em>无捕获替换(capture-free substitution)</em>.</p><p>在我们定义PCF的操作语义之前, 我们先引入PCF的<q>原项 (raw term)</q>的概念, 根据以下的BNF语法:<math display="block"><mrow><mi>M</mi><mo>&Colone;</mo><mrow><mi>x</mi><mo>|</mo><mrow><mo stretchy="false">(</mo><mrow><mi>&lambda;</mi><mrow><mi>x</mi><mo>:</mo><mi>&sigma;</mi></mrow><mo lspace="0" rspace="0">.</mo><mi>M</mi></mrow><mo stretchy="false">)</mo></mrow><mo>|</mo><mrow><mi>M</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow><mo>|</mo><ms>zero</ms><mo>|</mo><mrow><ms>succ</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow><mo>|</mo><mrow><ms>pred</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow><mo>|</mo><mrow><ms>ifz</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>M</mi><mo>,</mo><mi>M</mi><mo>,</mo><mi>M</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>当然了, 不是每个原项都可定型, 例如<math><mrow><mi>&lambda;</mi><mrow><mi>x</mi><mo>:</mo><ms>nat</ms></mrow><mo lspace="0" rspace="0">.</mo><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, 其中第一个<math><mi>x</mi></math>的出现显然应该具有函数类型以使得<math><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math>是良类型的.</p><p>现在我们呈现PCF的一个<q>大步</q>语义, 其由一个原项上的二元关系<math><mo>&dArr;</mo></math>给出, 而这个关系是根据图2.2中的规则归纳定义的. 这里的<math><munder><mi>n</mi><mo>&UnderBar;</mo></munder></math>是自然数<math><mi>n</mi></math>的canonical<em>数码</em>, 其被递归地定义为<math><mrow><munder><mn>0</mn><mo>&UnderBar;</mo></munder><mo>&equiv;</mo><ms>zero</ms></mrow></math>而<math><mrow><munder><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mo>&UnderBar;</mo></munder><mo>&equiv;</mo><mrow><ms>succ</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><munder><mi>k</mi><mo>&UnderBar;</mo></munder><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.</p><table align="center" style="border-spacing: 3em 1em;"><tr><td><math><mfrac displaystyle="true"><mrow/><mrow><mi>x</mi><mo>&dArr;</mo><mi>x</mi></mrow></mfrac></math></td><td><math><mfrac displaystyle="true"><mrow/><mrow><mrow><mi>&lambda;</mi><mrow><mi>x</mi><mo>:</mo><mi>&sigma;</mi></mrow><mo lspace="0" rspace="0">.</mo><mi>M</mi></mrow><mo>&dArr;</mo><mrow><mi>&lambda;</mi><mrow><mi>x</mi><mo>:</mo><mi>&sigma;</mi></mrow><mo lspace="0" rspace="0">.</mo><mi>M</mi></mrow></mrow></mfrac></math></td></tr><tr><td><math><mfrac displaystyle="true"><mrow><mrow><mi>M</mi><mo>&dArr;</mo><mrow><mi>&lambda;</mi><mrow><mi>x</mi><mo>:</mo><mi>&sigma;</mi></mrow><mo lspace="0" rspace="0">.</mo><mi>E</mi></mrow></mrow><mspace width="8ex"/><mrow><mrow><mi>E</mi><mrow><mo stretchy="false">[</mo><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mi>x</mi></mrow><mo stretchy="false">]</mo></mrow></mrow><mo>&dArr;</mo><mi>V</mi></mrow></mrow><mrow><mrow><mi>M</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&dArr;</mo><mi>V</mi></mrow></mfrac></math></td><td><math><mfrac displaystyle="true"><mrow><mrow><mi>M</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><ms>Y</ms><mi>&sigma;</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&dArr;</mo><mi>V</mi></mrow><mrow><mrow><msub><ms>Y</ms><mi>&sigma;</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&dArr;</mo><mi>V</mi></mrow></mfrac></math></td></tr><tr><td><math><mfrac displaystyle="true"><mrow/><mrow><munder><mn>0</mn><mo>&UnderBar;</mo></munder><mo>&dArr;</mo><munder><mn>0</mn><mo>&UnderBar;</mo></munder></mrow></mfrac></math></td><td><math><mfrac displaystyle="true"><mrow><mi>M</mi><mo>&dArr;</mo><munder><mi>n</mi><mo>&UnderBar;</mo></munder></mrow><mrow><mrow><ms>succ</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&dArr;</mo><munder><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo>&UnderBar;</mo></munder></mrow></mfrac></math></td></tr><tr><td><math><mfrac displaystyle="true"><mrow><mi>M</mi><mo>&dArr;</mo><munder><mn>0</mn><mo>&UnderBar;</mo></munder></mrow><mrow><mrow><ms>pred</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&dArr;</mo><munder><mn>0</mn><mo>&UnderBar;</mo></munder></mrow></mfrac></math></td><td><math><mfrac displaystyle="true"><mrow><mi>M</mi><mo>&dArr;</mo><munder><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo>&UnderBar;</mo></munder></mrow><mrow><mrow><ms>pred</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&dArr;</mo><munder><mi>n</mi><mo>&UnderBar;</mo></munder></mrow></mfrac></math></td></tr><tr><td><math><mfrac displaystyle="true"><mrow><mrow><mi>M</mi><mo>&dArr;</mo><munder><mn>0</mn><mo>&UnderBar;</mo></munder></mrow><mspace width="8ex"/><mrow><msub><mi>M</mi><mn>1</mn></msub><mo>&dArr;</mo><mi>V</mi></mrow></mrow><mrow><mrow><ms>ifz</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>M</mi><mo>,</mo><msub><mi>M</mi><mn>1</mn></msub><mo>,</mo><msub><mi>M</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&dArr;</mo><mi>V</mi></mrow></mfrac></math></td><td><math><mfrac displaystyle="true"><mrow><mrow><mi>M</mi><mo>&dArr;</mo><munder><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo>&UnderBar;</mo></munder></mrow><mspace width="8ex"/><mrow><msub><mi>M</mi><mn>2</mn></msub><mo>&dArr;</mo><mi>V</mi></mrow></mrow><mrow><mrow><ms>ifz</ms><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>M</mi><mo>,</mo><msub><mi>M</mi><mn>1</mn></msub><mo>,</mo><msub><mi>M</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&dArr;</mo><mi>V</mi></mrow></mfrac></math></td></tr><tr><td colspan="2" align="center">图2.2 PCF的大步语义</td></tr></table><p>每当<math><mrow><mi>E</mi><mo>&dArr;</mo><mi>V</mi></mrow></math>, 那么<math><mi>V</mi></math>是一个变量, 数码, 或者<math><mi>&lambda;</mi></math>抽象. 根据推导<math><mrow><mi>E</mi><mo>&dArr;</mo><mi>V</mi></mrow></math>的结构上的归纳, <math><mi>V</mi></math>的自由变量包含于<math><mi>E</mi></math>的自由变量之中. 因此, 如果<math><mi>E</mi></math>是一个封闭表达式, 那么<math><mi>V</mi></math>要么是一个数码, 要么是一个没有自由变量的<math><mi>&lambda;</mi></math>抽象. 这样的项被称为(句法)<em>值</em>, 并且很容易看出对于每个这样的值<math><mi>V</mi></math>我们都有<math><mrow><mi>V</mi><mo>&dArr;</mo><mi>V</mi></mrow></math>. </p><h2>第3章 PCF的Scott模型</h2><h3>第3.1节 基本的domain论</h3><h3>第3.2节 PCF的domain模型</h3><h3>第3.3节 LCF&mdash;&mdash;可计算函数逻辑</h3></body></html>