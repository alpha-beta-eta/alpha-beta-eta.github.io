<html><head><meta charset="utf-8"/><title>可计算性和计算复杂度</title><link href="styles.css" rel="stylesheet"/></head><body><h1>可计算性和计算复杂度</h1><h2>第1章 引论</h2><h2>第2章 WHILE语言</h2><h3>第2.1节 WHILE数据和程序的句法</h3><h4>第2.1.1小节 二叉树作为数据值</h4><div class="definition"><b>定义2.1.1. </b>树的集合<math><mi>&Dopf;</mi></math>定义如下:<ol><li>原子<math><mi mathvariant="monospace">nil</mi></math>是<math><mi>&Dopf;</mi></math>的一个元素;</li><li>每当<math><msub><mi mathvariant="monospace">d</mi><mn>1</mn></msub></math>和<math><msub><mi mathvariant="monospace">d</mi><mn>2</mn></msub></math>是<math><mi>&Dopf;</mi></math>的元素, 那么<math><mrow><mo mathvariant="monospace">(</mo><msub><mi mathvariant="monospace">d</mi><mn>1</mn></msub><mo mathvariant="monospace" lspace="0" rspace="0">.</mo><msub><mi mathvariant="monospace">d</mi><mn>2</mn></msub><mo mathvariant="monospace">)</mo></mrow></math>也是; 并且</li><li><math><mi>&Dopf;</mi></math>是满足前述两点的最小集合.</li></ol></div><div class="definition"><b>定义2.1.2. </b>函数<math><mrow><mrow><mo stretchy="false">|</mo><mi>&bull;</mi><mo stretchy="false">|</mo></mrow><mo>:</mo><mrow><mi>&Dopf;</mi><mo>&rarr;</mo><mi mathvariant="double-struck" style="font-style: italic;">N</mi></mrow></mrow></math>定义如下:<math display="block"><mrow><mrow><mo stretchy="false">|</mo><mi mathvariant="monospace">d</mi><mo stretchy="false">|</mo></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mn>1</mn></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi mathvariant="monospace">d</mi><mo>&in;</mo><mi>A</mi></mrow></mtd></mtr><mtr><mtd><mrow><mrow><mo stretchy="false">|</mo><msub><mi mathvariant="monospace">d</mi><mn>1</mn></msub><mo stretchy="false">|</mo></mrow><mo>+</mo><mrow><mo stretchy="false">|</mo><msub><mi mathvariant="monospace">d</mi><mn>2</mn></msub><mo stretchy="false">|</mo></mrow></mrow></mtd><mtd columnalign="left"><mtext>, 如果</mtext><mrow><mi mathvariant="monospace">d</mi><mo>=</mo><mrow><mo mathvariant="monospace">(</mo><msub><mi mathvariant="monospace">d</mi><mn>1</mn></msub><mo mathvariant="monospace" lspace="0" rspace="0">.</mo><msub><mi mathvariant="monospace">d</mi><mn>2</mn></msub><mo mathvariant="monospace">)</mo></mrow></mrow></mtd></mtr></mtable></mrow></mrow></math>其代表了一个数据值<math><mrow><mi mathvariant="monospace">d</mi><mo>&in;</mo><mi>&Dopf;</mi></mrow></math>的<em>大小(size)</em>.</div><h4>第2.1.2小节 WHILE程序的句法</h4><div class="definition"><b>定义2.1.3. </b>令<math><mrow><mi mathvariant="monospace">Vars</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><msub><mi mathvariant="monospace">V</mi><mn>0</mn></msub><mo>,</mo><msub><mi mathvariant="monospace">V</mi><mn>1</mn></msub><mo>,</mo><mo>&hellip;</mo></mrow><mo stretchy="false">}</mo></mrow></mrow></math>是不同的变量. 我们使用约定<math><mrow><mrow><mi mathvariant="monospace">d</mi><mo>,</mo><mi mathvariant="monospace">e</mi><mo>,</mo><mi mathvariant="monospace">f</mi><mo>,</mo><mo>&hellip;</mo></mrow><mo>&in;</mo><mi>&Dopf;</mi></mrow></math>和<math><mrow><mrow><mi mathvariant="monospace">X</mi><mo>,</mo><mi mathvariant="monospace">Y</mi><mo>,</mo><mi mathvariant="monospace">Z</mi><mo>,</mo><mo>&hellip;</mo></mrow><mo>&in;</mo><mi mathvariant="monospace">Vars</mi></mrow></math>. 那么, WHILE的句法由以下语法给出:<math display="block"><mtable columnalign="left center left center left left"><mtr><mtd><mi mathvariant="monospace">Expressions</mi></mtd><mtd><mo>&ni;</mo></mtd><mtd><mrow><mi mathvariant="monospace">E</mi><mo>,</mo><mi mathvariant="monospace">F</mi></mrow></mtd><mtd><mo>&Colone;</mo></mtd><mtd><mi mathvariant="monospace">X</mi></mtd><mtd><mrow><mo stretchy="false">(</mo><mrow><mtext>对于</mtext><mrow><mi mathvariant="monospace">X</mi><mo>&in;</mo><mi mathvariant="monospace">Vars</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mo>|</mo></mtd><mtd><mi mathvariant="monospace">d</mi></mtd><mtd><mrow><mo stretchy="false">(</mo><mrow><mtext>对于原子</mtext><mi mathvariant="monospace">d</mi></mrow><mo stretchy="false">)</mo></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mo>|</mo></mtd><mtd><mrow><mi mathvariant="monospace">cons</mi><mspace width="2ex"/><mi mathvariant="monospace">E</mi><mspace width="2ex"/><mi mathvariant="monospace">F</mi></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mo>|</mo></mtd><mtd><mrow><mi mathvariant="monospace">hd</mi><mspace width="2ex"/><mi mathvariant="monospace">E</mi></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mo>|</mo></mtd><mtd><mrow><mi mathvariant="monospace">tl</mi><mspace width="2ex"/><mi mathvariant="monospace">E</mi></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mo>|</mo></mtd><mtd><mrow><mi mathvariant="monospace">=?</mi><mspace width="2ex"/><mi mathvariant="monospace">E</mi><mspace width="2ex"/><mi mathvariant="monospace">F</mi></mrow></mtd></mtr><mtr><mtd><mi mathvariant="monospace">Commands</mi></mtd><mtd><mo>&ni;</mo></mtd><mtd><mrow><mi mathvariant="monospace">C</mi><mo>,</mo><mi mathvariant="monospace">D</mi></mrow></mtd><mtd><mo>&Colone;</mo></mtd><mtd><mrow><mi mathvariant="monospace">X</mi><mspace width="2ex"/><mi mathvariant="monospace">:=</mi><mspace width="2ex"/><mi mathvariant="monospace">E</mi></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mo>|</mo></mtd><mtd><mrow><mi mathvariant="monospace">C</mi><mspace width="2ex"/><mi mathvariant="monospace">;</mi><mspace width="2ex"/><mi mathvariant="monospace">D</mi></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mo>|</mo></mtd><mtd><mrow><mi mathvariant="monospace">while</mi><mspace width="2ex"/><mi mathvariant="monospace">E</mi><mspace width="2ex"/><mi mathvariant="monospace">do</mi><mspace width="2ex"/><mi mathvariant="monospace">C</mi></mrow></mtd></mtr><mtr><mtd><mi mathvariant="monospace">Programs</mi></mtd><mtd><mo>&ni;</mo></mtd><mtd><mi mathvariant="monospace">P</mi></mtd><mtd><mo>&Colone;</mo></mtd><mtd><mrow><mi mathvariant="monospace">read</mi><mspace width="2ex"/><mi mathvariant="monospace">X</mi><mspace width="2ex"/><mi mathvariant="monospace">;</mi><mspace width="2ex"/><mi mathvariant="monospace">C</mi><mspace width="2ex"/><mi mathvariant="monospace">;</mi><mspace width="2ex"/><mi mathvariant="monospace">write</mi><mspace width="2ex"/><mi mathvariant="monospace">Y</mi></mrow></mtd></mtr></mtable></math>这里的<math><mi mathvariant="monospace">X</mi></math>和<math><mi mathvariant="monospace">Y</mi></math>是不需要相异的<em>输入变量</em>和<em>输出变量</em>.</div><p>我们使用缩进来指明<math><mi mathvariant="monospace">while</mi></math>和其他命令的作用域. 例如, 考虑以下两个命令:<pre><code>while E do
  C;
D</code></pre><pre><code>while E do
  C;
  D</code></pre></p><h4>第2.1.3小节 非形式化的语义</h4><h4>第2.1.4小节 真值和if-then-else</h4><h4>第2.1.5小节 列表</h4><h4>第2.1.6小节 数字</h4><h4>第2.1.7小节 句法糖: 一些有用的宏记号</h4><h3>第2.2节 WHILE程序的语义</h3><h4>第2.2.1小节 存储</h4><h4>第2.2.2小节 对于表达式的求值</h4><h4>第2.2.3小节 命令的执行</h4><h4>第2.2.4小节 WHILE程序的语义</h4><h4>第2.2.5小节 计算语义值</h4><h3>第2.3节 相等性与原子相等性的对比</h3><h4>第2.3.1小节 更多的句法糖</h4><h3>练习</h3><h3>引用</h3><h2>第3章 程序作为数据对象</h2><h3>第3.1节 编程语言和模拟</h3><div class="definition"><b>定义3.1.1. </b>一个<em>编程语言</em><math><mi mathvariant="monospace">L</mi></math>由以下资料构成:<ol><li>两个集合, <math><mrow><mi mathvariant="monospace">L</mi><mtext style="font-family: KaiTi;">-程序</mtext></mrow></math>和<math><mrow><mi mathvariant="monospace">L</mi><mtext style="font-family: KaiTi">-数据</mtext></mrow></math>;</li><li>一个函数<math><mrow><msup><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>&bull;</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mi mathvariant="monospace">L</mi></msup><mo>:</mo><mrow><mrow><mi mathvariant="monospace">L</mi><mtext style="font-family: KaiTi;">-程序</mtext></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi mathvariant="monospace">L</mi><mtext style="font-family: KaiTi">-数据</mtext></mrow><mo>&rarr;</mo><msub><mrow><mi mathvariant="monospace">L</mi><mtext style="font-family: KaiTi">-数据</mtext></mrow><mi>&bottom;</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.</li></ol>这里<math><msup><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi>&bull;</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mi mathvariant="monospace">L</mi></msup></math>是<math><mi mathvariant="monospace">L</mi></math>的<em>语义函数</em>, 其将每个<math><mi mathvariant="monospace">L</mi></math>-程序<math><mrow><mi mathvariant="monospace">p</mi><mo>&in;</mo><mrow><mi mathvariant="monospace">L</mi><mtext style="font-family: KaiTi;">-程序</mtext></mrow></mrow></math>与一个相应的部分函数<math><mrow><msup><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi mathvariant="monospace">p</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mi mathvariant="monospace">L</mi></msup><mo>:</mo><mrow><mrow><mi mathvariant="monospace">L</mi><mtext style="font-family: KaiTi">-数据</mtext></mrow><mo>&rarr;</mo><msub><mrow><mi mathvariant="monospace">L</mi><mtext style="font-family: KaiTi">-数据</mtext></mrow><mi>&bottom;</mi></msub></mrow></mrow></math>联系起来.<br/>如果<math><mrow><mrow><mi mathvariant="monospace">L</mi><mtext style="font-family: KaiTi;">-程序</mtext></mrow><mo>&sube;</mo><mrow><mi mathvariant="monospace">L</mi><mtext style="font-family: KaiTi">-数据</mtext></mrow></mrow></math>, 那么我们称<math><mi mathvariant="monospace">L</mi></math>具有<em>程序作为数据(programs-as-data)</em>的性质. 另外, 如果<math><mrow><mrow><mrow><mi mathvariant="monospace">L</mi><mtext style="font-family: KaiTi">-数据</mtext></mrow><mo>&times;</mo><mrow><mi mathvariant="monospace">L</mi><mtext style="font-family: KaiTi">-数据</mtext></mrow></mrow><mo>&sube;</mo><mrow><mi mathvariant="monospace">L</mi><mtext style="font-family: KaiTi">-数据</mtext></mrow></mrow></math>, 那么我们称<math><mi mathvariant="monospace">L</mi></math>具有<em>结对(pairing)</em>性质.</div><div class="definition"><b>定义3.1.2. </b>设<math><mrow><mrow><mi mathvariant="monospace">L</mi><mtext style="font-family: KaiTi">-数据</mtext></mrow><mo>=</mo><mrow><mi mathvariant="monospace">M</mi><mtext style="font-family: KaiTi">-数据</mtext></mrow></mrow></math>. 语言<math><mi mathvariant="monospace">M</mi></math><em>可以模拟</em><math><mi mathvariant="monospace">L</mi></math>, 如果对于每个<math><mrow><mi mathvariant="monospace">p</mi><mo>&in;</mo><mrow><mi mathvariant="monospace">L</mi><mtext style="font-family: KaiTi;">-程序</mtext></mrow></mrow></math>, 存在一个<math><mi mathvariant="monospace">M</mi></math>-程序<math><mi mathvariant="monospace">q</mi></math>使得对于每个<math><mrow><mi mathvariant="monospace">d</mi><mo>&in;</mo><mrow><mi mathvariant="monospace">L</mi><mtext style="font-family: KaiTi">-数据</mtext></mrow></mrow></math>, 我们有<math display="block"><mrow><mrow><msup><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi mathvariant="monospace">p</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mi mathvariant="monospace">L</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi mathvariant="monospace">d</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&simeq;</mo><mrow><msup><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi mathvariant="monospace">q</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mi mathvariant="monospace">M</mi></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi mathvariant="monospace">d</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>.</mtext></math>等价地: <math><mi mathvariant="monospace">M</mi></math>可以模拟<math><mi mathvariant="monospace">L</mi></math>当且仅当存在一个完全函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mrow><mi mathvariant="monospace">L</mi><mtext style="font-family: KaiTi;">-程序</mtext></mrow><mo>&rarr;</mo><mrow><mi mathvariant="monospace">M</mi><mtext style="font-family: KaiTi;">-程序</mtext></mrow></mrow></mrow></math>满足对于每个<math><mi mathvariant="monospace">L</mi></math>-程序<math><mi mathvariant="monospace">p</mi></math>都有<math display="block"><mrow><msup><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mi mathvariant="monospace">p</mi><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mi mathvariant="monospace">L</mi></msup><mo>=</mo><msup><mrow><mo stretchy="false">&LeftDoubleBracket;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi mathvariant="monospace">p</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">&RightDoubleBracket;</mo></mrow><mi mathvariant="monospace">M</mi></msup></mrow><mtext>.</mtext></math>语言<math><mi mathvariant="monospace">L</mi></math><em>等价于</em>语言<math><mi mathvariant="monospace">M</mi></math>, 记作<math><mrow><mi mathvariant="monospace">L</mi><mo>&equiv;</mo><mi mathvariant="monospace">M</mi></mrow></math>, 如果语言<math><mi mathvariant="monospace">L</mi></math>和语言<math><mi mathvariant="monospace">M</mi></math>可以互相模拟.</div><p>这个定义表达了<math><mi mathvariant="monospace">L</mi></math>和<math><mi mathvariant="monospace">M</mi></math>可以计算相同函数的事实; 但是其并没有断言存在任何<em>构造性</em>的方式来获得一个等价于给定<math><mi mathvariant="monospace">L</mi></math>-程序的<math><mi mathvariant="monospace">M</mi></math>-程序. 本章的剩余部分关心的是模拟是如何计算性地完成的, 要么通过转换 (应用一个编译函数), 要么是通过解释. 然而, 首先我们需要一种方式来将程序视为数据对象.</p><h3>第3.2节 在<math><mi>&Dopf;</mi></math>中表示<math><mi mathvariant="monospace">WHILE</mi></math>程序</h3><p>之前我们已经给过了<math><mrow><mi mathvariant="monospace">WHILE</mi><mtext style="font-family: KaiTi;">-程序</mtext></mrow></math>和<math><mrow><mi mathvariant="monospace">WHILE</mi><mtext style="font-family: KaiTi">-数据</mtext></mrow></math>的句法. 假设我们想要将一个WHILE程序喂给另外一个WHILE程序作为输入. 目前这是不可行的, 仅仅是因为<math><mrow><mi mathvariant="monospace">WHILE</mi><mtext style="font-family: KaiTi;">-程序</mtext></mrow></math>的元素并非<math><mrow><mi mathvariant="monospace">WHILE</mi><mtext style="font-family: KaiTi">-数据</mtext></mrow></math>中的对象. 因此, 我们现在需要对于WHILE程序给出一种<em>程序作为数据表示</em>.</p><div class="definition"><b>定义3.2.1. </b>令<math><mrow><mo stretchy="false">{</mo><mrow><mi mathvariant="monospace">:=</mi><mo>,</mo><mi mathvariant="monospace">;</mi><mo>,</mo><mi mathvariant="monospace">while</mi><mo>,</mo><mi mathvariant="monospace">var</mi><mo>,</mo><mi mathvariant="monospace">quote</mi><mo>,</mo><mi mathvariant="monospace">cons</mi><mo>,</mo><mi mathvariant="monospace">hd</mi><mo>,</mo><mi mathvariant="monospace">tl</mi><mo>,</mo><mi mathvariant="monospace">=?</mi><mo>,</mo><mi mathvariant="monospace">nil</mi></mrow><mo stretchy="false">}</mo></mrow></math>代表<math><mi>&Dopf;</mi></math>的<math><mn>10</mn></math>个相异元素. WHILE程序<math><mi mathvariant="monospace">p</mi></math>的表示</div><h2>第4章 自解释: <math><mi mathvariant="monospace">WHILE</mi></math>和<math><mi mathvariant="monospace">I</mi></math>的通用程序</h2><h2>第5章 可计算理论的基本</h2><h2>第6章 元编程, 自应用, 和编译器生成</h2><h2>第7章 其他顺序计算模型</h2><h2>第8章 可计算概念的健壮性</h2><h2>第9章 函数式语言所施行的计算</h2><h2>第10章 一些自然的不可解问题</h2><h2>第11章 Hilbert第十问题</h2><h2>第12章 推理系统和G&ouml;del不完备性定理</h2><h2>第13章 基于数字的可计算理论</h2><h2>第14章 更多可计算性的抽象方式</h2></body></html>