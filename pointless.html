<html><head><meta charset="utf-8"/><title>无点拓扑笔记</title><link href="styles.css" rel="stylesheet"/></head><body><h1>无点拓扑笔记</h1><h2>第1章 空间和开集格</h2><p>我们的意图在于尽可能地忘掉关于空间的点的事情. 转而, 我们想要与<q>places of non-trivial extent</q>打交道.</p><p>为了开始, 让我们想象由一个开集系统给出的一个标准拓扑空间. 现在回忆一下经典Euclid几何, 其中我们将一条直线<math><mi>p</mi></math>视为一个基本实体, 而不是与<math><mi>p</mi></math>接触的那些点构成的集合, 我们也要试着用类似的方式来看待我们的空间: 将开集<math><mi>U</mi></math>视为基本实体, 而坐落于<math><mi>U</mi></math>之内的点视为另一种类型的实体, 其以某种方式与<math><mi>U</mi></math>接触.</p><div class="comment"><b>注记.</b> 实际上, 转而将一个点想成是一个由开集构成的集合是相当实际的, 这个集合也就是由这个点的所有邻域构成的集合, 我们可以将其想成是通过越来越小的spot来对于理想点进行近似.</div><p>在这简短的一章里, 我们将会讨论这样的问题, 即究竟从开集的抽象结构之中可以还原多少关于空间本身的信息. 实际上, 对于很多空间 (例如<math><msub><mi>T</mi><mn>1</mn></msub></math>空间), 什么信息也不会丢失.</p><p>让我们从现在开始进行约定, 从此往后, 默认<blockquote><em>所有讨论的空间都是<math><msub><mi>T</mi><mn>0</mn></msub></math>的</em></blockquote>不仅是本章, 整本书都是: 这是容易理解的, 因为如果点不能以任何方式进行分离, 那么我们就不可能基于对于开集的推理来还原点的差异.</p><div class="notation"><b>记号.</b> 整本书里, 一个空间<math><mi>X</mi></math>的开集的(完全)格将会记作<math display="block"><mrow><mi mathvariant="normal">&Omega;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mrow></math>当然了, 这个约定并不会阻止我们偶尔使用这样的表达, <q>一个拓扑空间<math><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>,</mo><mi>&tau;</mi></mrow><mo stretchy="false">)</mo></mrow></math></q>, 诸如此类.</div><p>这个阶段所有我们想要告诉读者的东西都包含在第1-3节里了. 第4节包含了关于某个特别的拓扑性质的一些技术性事实. 我们在这里写下第4节的原因在于否则的话, 这些事实就要散布于之后的文本里了, 尽管它们最好一起处理. 暂时读者应该跳过第4节, 而在之后需要时本书肯定会回顾其内容.</p><h3>第1.1节 sober空间</h3><h4>第1.1.1小节 </h4><p>在开集格<math><mrow><mi mathvariant="normal">&Omega;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mrow></math>之中, 具有形式<math display="block"><mrow><mi>X</mi><mo>&Backslash;</mo><mover><mrow><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo></mrow><mo>&OverBar;</mo></mover></mrow></math>的元素具有以下性质:<blockquote>如果<math><mrow><mrow><mi>U</mi><mo>&cap;</mo><mi>V</mi></mrow><mo>&sube;</mo><mrow><mi>X</mi><mo>&Backslash;</mo><mover><mrow><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo></mrow><mo>&OverBar;</mo></mover></mrow></mrow></math>, 那么<math><mrow><mi>U</mi><mo>&sube;</mo><mrow><mi>X</mi><mo>&Backslash;</mo><mover><mrow><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo></mrow><mo>&OverBar;</mo></mover></mrow></mrow></math>或者<math><mrow><mi>V</mi><mo>&sube;</mo><mrow><mi>X</mi><mo>&Backslash;</mo><mover><mrow><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo></mrow><mo>&OverBar;</mo></mover></mrow></mrow></math>成立. (的确如此, 我们不得不有<math><mrow><mi>x</mi><mo>&notin;</mo><mi>U</mi></mrow></math>或者<math><mrow><mi>x</mi><mo>&notin;</mo><mi>V</mi></mrow></math>, 比如说第一种情况成立, 那么<math><mrow><mi>x</mi><mo>&in;</mo><mrow><mi>X</mi><mo>&Backslash;</mo><mi>U</mi></mrow></mrow></math>, 因而<math><mrow><mover><mrow><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo></mrow><mo>&OverBar;</mo></mover><mo>&sube;</mo><mrow><mi>X</mi><mo>&Backslash;</mo><mi>U</mi></mrow></mrow></math>, 故<math><mrow><mi>U</mi><mo>&sube;</mo><mrow><mi>X</mi><mo>&Backslash;</mo><mover><mrow><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo></mrow><mo>&OverBar;</mo></mover></mrow></mrow></math>.)</blockquote></p><p>这通常被表述为它们是<em>meet不可归约的开集</em> (而读者可以看出如果我们将交集视为某种乘法, 那么这些开集表现得就像素数一样).</p><p>一个空间<math><mi>X</mi></math>被称为是sober的, 如果<math><mrow><mi mathvariant="normal">&Omega;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mrow></math>之中没有除了<math><mi>X</mi></math>之外的meet不可归约开集.</p><h4>第1.1.2小节 注记</h4><p>Grothendieck所陈述的原始定义是基于闭集的语言表达的: 一个(<math><msub><mi>T</mi><mn>0</mn></msub></math>)空间是sober的, 如果点闭包<math><mover><mrow><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo></mrow><mo>&OverBar;</mo></mover></math>恰为<em>join不可归约闭集</em>. 这种表述或许更加简单, 但是我们的兴趣在于开集格. </p></body></html>