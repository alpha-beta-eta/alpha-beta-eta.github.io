<html><head><meta charset="utf-8"/><title>格与序导论</title><link href="styles.css" rel="stylesheet"/></head><body><h1>格与序导论</h1><h2>第1章 有序集</h2><p>序, 序, 序&mdash;&mdash;其渗透着整个数学和日常生活, 以至于我们将序视为理所当然的存在. 序以各种伪装出现: 第一, 第二, 第三, ...; 更大vs更小; 更好vs更坏. 进展, 先后, 倾向都可以被归结为序的概念. 我们的首要任务在于打磨这些不够精确的想法, 形式化&quot;小于等于&quot;这种关系. 除了呈现有序集的例子和基本性质, 本章也引入了图表, 其使得序理论生动形象起来.</p><h3>有序集</h3><p>究竟何谓序? 或者更数学地说, 何谓有序集?</p><div class="example"><b>例子1.1.</b> </div><div class="definition"><b>定义1.2.</b> 令<math><mi>P</mi></math>是一个集合. <math><mi>P</mi></math>上的一个<b>序</b> (或者说<b>偏序</b>) 是<math><mi>P</mi></math>上的一个二元关系<math><mo>&le;</mo></math>满足对于所有的<math><mrow><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi></mrow><mo>&in;</mo><mi>P</mi></mrow></math>有<ol type="i"><li><math><mrow><mi>x</mi><mo>&le;</mo><mi>x</mi></mrow></math>;</li><li><math><mrow><mi>x</mi><mo>&le;</mo><mi>y</mi></mrow></math>和<math><mrow><mi>y</mi><mo>&le;</mo><mi>x</mi></mrow></math>可以推出<math><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow></math>;</li><li><math><mrow><mi>x</mi><mo>&le;</mo><mi>y</mi></mrow></math>和<math><mrow><mi>y</mi><mo>&le;</mo><mi>z</mi></mrow></math>可以推出<math><mrow><mi>x</mi><mo>&le;</mo><mi>z</mi></mrow></math>.</li></ol>以上的条件分别被称为<b>自反性</b>, <b>反对称性</b>和<b>传递性</b>. 一个装备有序关系<math><mo>&le;</mo></math>的集合<math><mi>P</mi></math>就成为了一个<b>有序集</b> (或者说<b>偏序集</b>). 有些作者使用缩略词<b>poset</b>. 在任意集合上, <math><mo>=</mo></math>是一个序, 即<b>离散序</b>. 集合<math><mi>P</mi></math>上满足自反和传递但不必然满足反对称性的关系被称为一个<b>半序</b>, 或者有些作者称为<b>预序</b>. <math><mi>P</mi></math>上的一个序关系<math><mo>&le;</mo></math>导出了<math><mi>P</mi></math>上的一个<b>严格不等</b>的关系<math><mo>&lt;</mo></math>: <math><mi>P</mi></math>中<math><mrow><mi>x</mi><mo>&lt;</mo><mi>y</mi></mrow></math>当且仅当<math><mrow><mi>x</mi><mo>&le;</mo><mi>y</mi></mrow></math>并且<math><mrow><mi>x</mi><mo>&ne;</mo><mi>y</mi></mrow></math>. 基于<math><mo>&lt;</mo></math>而不是<math><mo>&le;</mo></math>重述以上三个条件也是有可能的. 其他与<math><mo>&le;</mo></math>相关的记号是可以预见到的, 例如我们交换地使用<math><mrow><mi>x</mi><mo>&le;</mo><mi>y</mi></mrow></math>和<math><mrow><mi>y</mi><mo>&ge;</mo><mi>x</mi></mrow></math>. <math><mrow><mi>x</mi><mo>&nle;</mo><mi>y</mi></mrow></math>的意思是'<math><mrow><mi>x</mi><mo>&le;</mo><mi>y</mi></mrow></math>为假'. [译注: 换言之, <math><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&notin;</mo><mo lspace="0" rspace="0">&le;</mo></mrow></math>.] 我们使用不那么常见的符号<math><mo>&par;</mo></math>表示不可比较性, 记<math><mrow><mi>x</mi><mo>&par;</mo><mi>y</mi></mrow></math>如果<math><mrow><mi>x</mi><mo>&nle;</mo><mi>y</mi></mrow></math>且<math><mrow><mi>y</mi><mo>&nle;</mo><mi>x</mi></mrow></math>. 如果<math><mi>P</mi></math>是一个有序集而<math><mi>Q</mi></math>是其一个子集, 那么<math><mi>Q</mi></math>从<math><mi>P</mi></math>那里<b>继承</b>了自然的序关系, 我们将其称为<b>导出序</b> [译注: 也有人将其翻译成诱导序].</div><div class="definition"><b>定义1.3. 链和反链.</b> 令<math><mi>P</mi></math>是一个有序集, 那么<math><mi>P</mi></math>被称为一个<b>链</b>, 如果对于所有的<math><mrow><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo>&in;</mo><mi>P</mi></mrow></math>都有<math><mrow><mi>x</mi><mo>&le;</mo><mi>y</mi></mrow></math>或<math><mrow><mi>y</mi><mo>&le;</mo><mi>x</mi></mrow></math>, 即任意两个元素都是可以比较的. 链也被称为<b>线序集</b>或者<b>全序集</b>. 反链是另一个极端. 有序集<math><mi>P</mi></math>被称为一个<b>反链</b>, 如果<math><mrow><mi>x</mi><mo>&le;</mo><mi>y</mi></mrow></math>仅当<math><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow></math>. 显然, 在导出序下, 链的子集是链, 反链的子集是反链. 令<math><mi>P</mi></math>是<math><mi>n</mi></math>元素集<math><mrow><mo stretchy="false">{</mo><mrow><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mo>&hellip;</mo><mo>,</mo><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow><mo stretchy="false">}</mo></mrow></math>, 我们用<math><mi mathvariant="bold">n</mi></math>表示赋予了集合<math><mi>P</mi></math>序<math><mrow><mn>0</mn><mo>&lt;</mo><mn>1</mn><mo>&lt;</mo><mo>&ctdot;</mo><mo>&lt;</mo><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></mrow></math>的链, 而<math><mover><mi mathvariant="bold">n</mi><mo>&OverBar;</mo></mover></math>表示作为反链的<math><mi>P</mi></math>. 任何集合<math><mi>S</mi></math>都可以被赋予离散序而成为反链<math><mover><mi>S</mi><mo>&OverBar;</mo></mover></math>.</div><div class="definition"><b>定义1.4. 序同构.</b> 我们称<math><mi>P</mi></math>和<math><mi>Q</mi></math>是<b>序同构的</b>, 如果存在一个保持序关系的双射<math><mrow><mi>&phi;</mi><mo>:</mo><mrow><mi>P</mi><mo>&rarr;</mo><mi>Q</mi></mrow></mrow></math>. 换言之, 对于任意的<math><mrow><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo>&in;</mo><mi>P</mi></mrow></math>, <math><mrow><mi>x</mi><mo>&le;</mo><mi>y</mi></mrow></math>当且仅当<math><mrow><mrow><mi>&phi;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&le;</mo><mrow><mi>&phi;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>. 实际上, 保持序关系的映射必然是单射, 因为<math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><mrow><mrow><mi>&phi;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>&phi;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd><mo>&DoubleLongLeftRightArrow;</mo></mtd><mtd><mrow><mrow><mrow><mi>&phi;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&le;</mo><mrow><mi>&phi;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&amp;</mo><mrow><mrow><mi>&phi;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&le;</mo><mrow><mi>&phi;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>&DoubleLongLeftRightArrow;</mo></mtd><mtd><mrow><mrow><mi>x</mi><mo>&le;</mo><mi>y</mi></mrow><mo>&amp;</mo><mrow><mi>y</mi><mo>&le;</mo><mi>x</mi></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>&DoubleLongLeftRightArrow;</mo></mtd><mtd><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow></mtd></mtr></mtable></math>当然, 双射并非都是保持序关系的. 一旦我们有了一个序同构<math><mrow><mi>&phi;</mi><mo>:</mo><mrow><mi>P</mi><mo>&rarr;</mo><mi>Q</mi></mrow></mrow></math>, 那么逆映射<math><mrow><msup><mi>&phi;</mi><mrow><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>:</mo><mrow><mi>Q</mi><mo>&rarr;</mo><mi>P</mi></mrow></mrow></math>也是一个序同构.</div><div class="example"><b>例子1.5.</b> 实数集<math><mi>&Ropf;</mi></math>在通常序下形成了一个链. <math><mrow><mi>&Nopf;</mi><mo>&colone;</mo><mrow><mo stretchy="false">{</mo><mrow><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mo>&hellip;</mo></mrow><mo stretchy="false">}</mo></mrow></mrow></math>, <math><mi>&Zopf;</mi></math>, <math><mi>&Qopf;</mi></math>也都在通常序下成为了链. 这些序关系都与其上的运算相协调. 我们记<math><mrow><msub><mi>&Nopf;</mi><mn>0</mn></msub><mo>&colone;</mo><mrow><mi>&Nopf;</mi><mo>&cup;</mo><mrow><mo stretchy="false">{</mo><mn>0</mn><mo stretchy="false">}</mo></mrow></mrow></mrow></math>. </div><h2>第2章 格与完全格</h2><div class="definition"><b>定义2.1.</b> 令<math><mi>P</mi></math>是一个有序集而<math><mrow><mi>S</mi><mo>&sube;</mo><mi>P</mi></mrow></math>. 一个元素<math><mrow><mi>x</mi><mo>&in;</mo><mi>P</mi></mrow></math>被称为<math><mi>S</mi></math>的一个<b>上界</b>, 如果对于每个<math><mrow><mi>s</mi><mo>&in;</mo><mi>S</mi></mrow></math>有<math><mrow><mi>s</mi><mo>&le;</mo><mi>x</mi></mrow></math>. <b>下界</b>可以被对偶地定义. <math><mi>S</mi></math>的所有上界构成的集合记作<math><msup><mi>S</mi><mi>u</mi></msup></math> (读作'<math><mi>S</mi></math> <b>upper</b>'), 而其所有下界构成的集合记作<math><msup><mi>S</mi><mi>l</mi></msup></math> (读作'<math><mi>S</mi></math> <b>lower</b>'):<math display="block"><mrow><mrow><msup><mi>S</mi><mi>u</mi></msup><mo>&colone;</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>x</mi><mo>&in;</mo><mi>P</mi></mrow><mo stretchy="false">|</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mo>&forall;</mo><mrow><mi>s</mi><mo>&in;</mo><mi>S</mi></mrow></mrow><mo stretchy="false">)</mo></mrow><mrow><mi>s</mi><mo>&le;</mo><mi>x</mi></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow><mo>,</mo><mrow><msup><mi>S</mi><mi>l</mi></msup><mo>&colone;</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>x</mi><mo>&in;</mo><mi>P</mi></mrow><mo stretchy="false">|</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mo>&forall;</mo><mrow><mi>s</mi><mo>&in;</mo><mi>S</mi></mrow></mrow><mo stretchy="false">)</mo></mrow><mrow><mi>s</mi><mo>&ge;</mo><mi>x</mi></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></mrow><mtext>.</mtext></math>既然<math><mo>&le;</mo></math>是传递的, <math><msup><mi>S</mi><mi>u</mi></msup></math>总是一个up-set而<math><msup><mi>S</mi><mi>l</mi></msup></math>总是一个down-set. 如果<math><msup><mi>S</mi><mi>u</mi></msup></math>拥有最小元<math><mi>x</mi></math>, 那么<math><mi>x</mi></math>被称为<math><mi>S</mi></math>的<b>最小上界</b>. 等价地, <math><mi>x</mi></math>是<math><mi>S</mi></math>的最小上界, 如果<ol type="i"><li><math><mi>x</mi></math>是<math><mi>S</mi></math>的一个上界;</li><li>对于所有<math><mi>S</mi></math>的上界<math><mi>y</mi></math>, <math><mrow><mi>x</mi><mo>&le;</mo><mi>y</mi></mrow></math>.</li></ol><math><mi>S</mi></math>的最小上界存在当且仅当存在<math><mrow><mi>x</mi><mo>&in;</mo><mi>P</mi></mrow></math>满足<math display="block"><mrow><mo stretchy="false">(</mo><mrow><mo>&forall;</mo><mrow><mi>y</mi><mo>&in;</mo><mi>P</mi></mrow></mrow><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">[</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mo>&forall;</mo><mrow><mi>s</mi><mo>&in;</mo><mi>S</mi></mrow></mrow><mo stretchy="false">)</mo></mrow><mrow><mi>s</mi><mo>&le;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>&DoubleLongLeftRightArrow;</mo><mrow><mi>x</mi><mo>&le;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">]</mo></mrow></math>并且这就刻画了<math><mi>S</mi></math>的最小上界. 对偶地, 如果<math><msup><mi>S</mi><mi>l</mi></msup></math>拥有最大元, 那么其被称为<math><mi>S</mi></math>的<b>最大下界</b>. 既然最小元和最大元都是唯一的, 那么最小上界和最大下界也是唯一的. <math><mi>S</mi></math>的最小上界也被称为<math><mi>S</mi></math>的<b>上确界</b>, 记作<math><mrow><mi>sup</mi><mo>&af;</mo><mi>S</mi></mrow></math>. <math><mi>S</mi></math>的最大下界也被称为<math><mi>S</mi></math>的<b>下确界</b>, 记作<math><mrow><mi>inf</mi><mo>&af;</mo><mi>S</mi></mrow></math>.</div><div class="remark"><b>评注2.2. 顶和底.</b> 在上确界和下确界的定义中, 存在两种极端的情况, 即空集和有序集本身, 这值得单独一说. 回忆一下, 当<math><mi>P</mi></math>的顶和底元素存在时, 其被分别记为<math><mi>&top;</mi></math>和<math><mi>&bottom;</mi></math>. 很容易看出来, 如果<math><mi>P</mi></math>具有顶元素, 那么<math><mrow><msup><mi>P</mi><mi>u</mi></msup><mo>=</mo><mrow><mo stretchy="false">{</mo><mi>&top;</mi><mo stretchy="false">}</mo></mrow></mrow></math>而此时<math><mrow><mrow><mi>sup</mi><mo>&af;</mo><mi>P</mi></mrow><mo>=</mo><mi>&top;</mi></mrow></math>. 若<math><mi>P</mi></math>没有顶元素, 那么<math><mrow><msup><mi>P</mi><mi>u</mi></msup><mo>=</mo><mi>&empty;</mi></mrow></math>, 因而<math><mrow><mi>sup</mi><mo>&af;</mo><mi>P</mi></mrow></math>并不存在. 根据对偶性, 当<math><mi>P</mi></math>具有底元素时, <math><mrow><mrow><mi>inf</mi><mo>&af;</mo><mi>P</mi></mrow><mo>=</mo><mi>&bottom;</mi></mrow></math>. 现在考虑空集的情况, 此时每个<math><mrow><mi>x</mi><mo>&in;</mo><mi>P</mi></mrow></math>都是其上界, 因此<math><mrow><msup><mi>&empty;</mi><mi>u</mi></msup><mo>=</mo><mi>P</mi></mrow></math>而<math><mrow><mi>sup</mi><mo>&af;</mo><mi>&empty;</mi></mrow></math>存在当且仅当<math><mi>P</mi></math>具有底元素, 若存在则有<math><mrow><mrow><mi>sup</mi><mo>&af;</mo><mi>&empty;</mi></mrow><mo>=</mo><mi>&bottom;</mi></mrow></math>. 对偶地, 若<math><mi>P</mi></math>有顶元素, 则<math><mrow><mrow><mi>inf</mi><mo>&af;</mo><mi>&empty;</mi></mrow><mo>=</mo><mi>&top;</mi></mrow></math>.</div><div class="notation"><b>记号2.3.</b> 我们记<math><mrow><mi>sup</mi><mo>&af;</mo><mrow><mo stretchy="false">{</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></math>为<math><mrow><mi>x</mi><mo>&or;</mo><mi>y</mi></mrow></math> (读作'<b><math><mi>x</mi></math> join <math><mi>y</mi></math></b>'), <math><mrow><mi>inf</mi><mo>&af;</mo><mrow><mo stretchy="false">{</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></math>为<math><mrow><mi>x</mi><mo>&and;</mo><mi>y</mi></mrow></math> (读作'<b><math><mi>x</mi></math> meet <math><mi>y</mi></math></b>'). 类似的, 我们记<math><mrow><mo>&bigvee;</mo><mi>S</mi></mrow></math> (即'<b>join of <math><mi>S</mi></math></b>') 和<math><mrow><mo>&bigwedge;</mo><mi>S</mi></mrow></math> (即'<b>meet of <math><mi>S</mi></math></b>') 而不是<math><mrow><mi>sup</mi><mo>&af;</mo><mi>S</mi></mrow></math>和<math><mrow><mi>inf</mi><mo>&af;</mo><mi>S</mi></mrow></math>. 若有必要指出join和meet在某一个特定的有序集<math><mi>P</mi></math>中寻找, 那么记<math><mrow><msub><mo>&bigvee;</mo><mi>P</mi></msub><mi>S</mi></mrow></math>和<math><mrow><msub><mo>&bigwedge;</mo><mi>P</mi></msub><mi>S</mi></mrow></math>. 我们也经常遇到<math><mrow><mi>S</mi><mo>=</mo><msub><mrow><mo stretchy="false">{</mo><msub><mi>A</mi><mi>i</mi></msub><mo stretchy="false">}</mo></mrow><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></msub></mrow></math>的情形, 其中<math><mi>I</mi></math>是一个指标集, 那么<math><mrow><msub><mo>&bigvee;</mo><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></msub><msub><mi>A</mi><mi>i</mi></msub></mrow></math>是比<math><mrow><mo>&bigvee;</mo><mrow><mo stretchy="false">{</mo><mrow><msub><mi>A</mi><mi>i</mi></msub><mo stretchy="false">|</mo><mrow><mi>i</mi><mo>&in;</mo><mi>I</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>更紧凑的记号.</div><div class="definition"><b>定义2.4.</b> 令<math><mi>P</mi></math>是一个非空的有序集.<ol type="i"><li>若<math><mrow><mi>x</mi><mo>&or;</mo><mi>y</mi></mrow></math>和<math><mrow><mi>x</mi><mo>&and;</mo><mi>y</mi></mrow></math>对于任意的<math><mrow><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo>&in;</mo><mi>P</mi></mrow></math>均存在, 那么<math><mi>P</mi></math>被称为一个<b>格</b>.</li><li>若<math><mrow><mo>&bigvee;</mo><mi>S</mi></mrow></math>和<math><mrow><mo>&bigwedge;</mo><mi>S</mi></mrow></math>对于任意的<math><mrow><mi>S</mi><mo>&sube;</mo><mi>P</mi></mrow></math>均存在, 那么<math><mi>P</mi></math>被称为一个<b>完全格</b>.</li></ol></div><div class="remark"><b>评注2.5.</b> <ol><li>令<math><mi>P</mi></math>是任意的有序集. 如果<math><mrow><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo>&in;</mo><mi>P</mi></mrow></math>而<math><mrow><mi>x</mi><mo>&le;</mo><mi>y</mi></mrow></math>, 那么<math><mrow><msup><mrow><mo stretchy="false">{</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">}</mo></mrow><mi>u</mi></msup><mo>=</mo><mrow><mo lspace="0" rspace="0">&uarr;</mo><mi>y</mi></mrow></mrow></math>且<math><mrow><msup><mrow><mo stretchy="false">{</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">}</mo></mrow><mi>l</mi></msup><mo>=</mo><mrow><mo lspace="0" rspace="0">&darr;</mo><mi>x</mi></mrow></mrow></math>. 因为<math><mrow><mo lspace="0" rspace="0">&uarr;</mo><mi>y</mi></mrow></math>的最小元是<math><mi>y</mi></math>而<math><mrow><mo lspace="0" rspace="0">&darr;</mo><mi>x</mi></mrow></math>的最大元是<math><mi>x</mi></math>, 我们有<math><mrow><mrow><mi>x</mi><mo>&or;</mo><mi>y</mi></mrow><mo>=</mo><mi>y</mi></mrow></math>和<math><mrow><mrow><mi>x</mi><mo>&and;</mo><mi>y</mi></mrow><mo>=</mo><mi>x</mi></mrow></math>. 特别地, 鉴于<math><mo>&le;</mo></math>是自反的, <math><mrow><mrow><mi>x</mi><mo>&or;</mo><mi>x</mi></mrow><mo>=</mo><mi>x</mi></mrow></math>且<math><mrow><mrow><mi>x</mi><mo>&and;</mo><mi>x</mi></mrow><mo>=</mo><mi>x</mi></mrow></math>.</li><li>在有序集<math><mi>P</mi></math>中, <math><mrow><mo stretchy="false">{</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">}</mo></mrow></math>的最小上界<math><mrow><mi>x</mi><mo>&or;</mo><mi>y</mi></mrow></math>可能出于两种原因并不存在:<ol type="a"><li>因为<math><mi>x</mi></math>和<math><mi>y</mi></math>没有共同的上界;</li><li>因为它们没有&quot;最小的&quot;上界.</li></ol></li><li></li><li>令<math><mi>P</mi></math>是一个格, 对于<math><mrow><mrow><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>d</mi></mrow><mo>&in;</mo><mi>P</mi></mrow></math>,<ol type="i"><li><math><mrow><mi>a</mi><mo>&le;</mo><mi>b</mi></mrow></math>可以推出<math><mrow><mrow><mi>a</mi><mo>&or;</mo><mi>c</mi></mrow><mo>&le;</mo><mrow><mi>b</mi><mo>&or;</mo><mi>c</mi></mrow></mrow></math>和<math><mrow><mrow><mi>a</mi><mo>&and;</mo><mi>c</mi></mrow><mo>&le;</mo><mrow><mi>b</mi><mo>&and;</mo><mi>c</mi></mrow></mrow></math>.</li><li><math><mrow><mi>a</mi><mo>&le;</mo><mi>b</mi></mrow></math>且<math><mrow><mi>c</mi><mo>&le;</mo><mi>d</mi></mrow></math>可以推出<math><mrow><mrow><mi>a</mi><mo>&or;</mo><mi>c</mi></mrow><mo>&le;</mo><mrow><mi>b</mi><mo>&or;</mo><mi>d</mi></mrow></mrow></math>和<math><mrow><mrow><mi>a</mi><mo>&and;</mo><mi>c</mi></mrow><mo>&le;</mo><mrow><mi>b</mi><mo>&and;</mo><mi>d</mi></mrow></mrow></math>.</li></ol></li><li>令<math><mi>P</mi></math>是一个格. 令<math><mrow><mrow><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi></mrow><mo>&in;</mo><mi>P</mi></mrow></math>并假定<math><mrow><mi>b</mi><mo>&le;</mo><mi>a</mi><mo>&le;</mo><mrow><mi>b</mi><mo>&or;</mo><mi>c</mi></mrow></mrow></math>. 既然<math><mrow><mi>c</mi><mo>&le;</mo><mrow><mi>b</mi><mo>&or;</mo><mi>c</mi></mrow></mrow></math>, 我们有<math><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>b</mi><mo>&or;</mo><mi>c</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&or;</mo><mi>c</mi></mrow><mo>=</mo><mrow><mi>b</mi><mo>&or;</mo><mi>c</mi></mrow></mrow></math>. 因此, <math display="block"><mrow><mrow><mi>b</mi><mo>&or;</mo><mi>c</mi></mrow><mo>&le;</mo><mrow><mi>a</mi><mo>&or;</mo><mi>c</mi></mrow><mo>&le;</mo><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>b</mi><mo>&or;</mo><mi>c</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&or;</mo><mi>c</mi></mrow><mo>=</mo><mrow><mi>b</mi><mo>&or;</mo><mi>c</mi></mrow></mrow></mrow></math>即<math><mrow><mrow><mi>a</mi><mo>&or;</mo><mi>c</mi></mrow><mo>=</mo><mrow><mi>b</mi><mo>&or;</mo><mi>c</mi></mrow></mrow></math>. 这个简单的观察及其对偶在计算图上的join和meet时是特别有用的.</li></ol></div><div class="remark"><b>评注2.6.</b> <ol><li>令<math><mi>P</mi></math>是非空有序集. 如果<math><mrow><mi>x</mi><mo>&le;</mo><mi>y</mi></mrow></math>, 那么<math><mrow><mrow><mi>x</mi><mo>&or;</mo><mi>y</mi></mrow><mo>=</mo><mi>y</mi></mrow></math>且<math><mrow><mrow><mi>x</mi><mo>&and;</mo><mi>y</mi></mrow><mo>=</mo><mi>x</mi></mrow></math>, 因此为了证明<math><mi>P</mi></math>是一个格, 只需要考虑不可比较的元素是否拥有join和meet即可. 特别地, 每个(非空)链是一个格. 显然, <math><mrow><mi>&Ropf;</mi><mo>,</mo><mi>&Qopf;</mi><mo>,</mo><mi>&Zopf;</mi><mo>,</mo><mi>&Nopf;</mi></mrow></math>在其通常的序关系下是一个格. 它们都不是完全格, 每个都缺失顶元素, 而一个完全格必然拥有顶和底. 然而, 对于实数<math><mrow><mi>x</mi><mo>&lt;</mo><mi>y</mi></mrow></math>, 闭区间<math><mrow><mo stretchy="false">[</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">]</mo></mrow></math>是一个完全格. </li></ol></div><h2>第3章 形式概念分析</h2><h2>第4章 模格, 分配格, 布尔格</h2><h2>第5章 表示: 有限情形</h2><h2>第6章 Congruences</h2><h2>第7章 完全格与Galois连接</h2><h2>第8章 完全偏序 (CPO) 和不动点定理</h2><h2>第9章 域 (domain) 和信息系统</h2><h2>第10章 极大原理</h2><h2>第11章 表示: 一般情形</h2></body></html>