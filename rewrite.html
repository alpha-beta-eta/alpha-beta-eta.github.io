<html><head><meta charset="utf-8"/><title>项重写</title><link href="styles.css" rel="stylesheet"/></head><body><h1>项重写</h1><h2>翻译勘误</h2><p>原书第1页, 作者将<math display="block"><mrow><mrow><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&asymp;</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&asymp;</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mn>0</mn></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&asymp;</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>误写为了<math display="block"><mrow><mrow><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&asymp;</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&asymp;</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mn>0</mn></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&asymp;</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math></p><h2>前言</h2><p>项重写是理论计算机科学的分支, 其结合了逻辑学, 泛代数, 自动定理证明, 以及函数式编程的元素. 其基础是等式性逻辑. 项重写与等式性逻辑的不同之处在于等式被用作<em>具有方向</em>的替换规则, 即左侧可以被右侧替换, 但相反方向不行. 这构成了一种Turing完备的计算模型, 其非常接近函数式编程. 其有着于代数 (例如布尔代数, 群论, 环论), 递归论 (特定重写规则集合之下的可计算与否), 软件工程 (对于诸如数字, 列表, 集合这样的等式性定义数据类型进行推理), 以及编程语言 (特别是函数式编程和逻辑编程) 之中的应用. 从一般角度来说, 项重写可以应用于任何需要等式推理的有效方法的上下文.</p><h2>第1章 启发性的例子</h2><p>等式性推理所关心的是相当受限的一类一阶语言: 唯一的谓词符号是相等. 然而, 其位于数学和计算机科学的诸多问题的核心, 这解释了为什么建立对于这种推理的特化方法和工具是非常流行且重要的. 例如, 数学之中人们经常通过给出定义等式 (其陈述了群运算的结合性, 诸如此类) 来定义代数的种类. 在这种上下文之中, 明白哪些其他的等式可由定义等式推导出来是重要的. 在代数规格之中, 新运算是由既有的运算定义的, 其方法在于陈述对于被定义运算而言必须满足的特征性等式. 作为一种特殊的情形, 我们有函数式程序, 其函数由递归等式所定义.</p><p>例如, 假定我们想要使用常量<math><mn>0</mn></math>和后继函数<math><mi>s</mi></math>定义自然数的加法. 这可由以下等式完成:<math display="block"><mtable columnalign="right center left" displaystyle="true"><mtr><mtd><mrow><mi>x</mi><mo>+</mo><mn>0</mn></mrow></mtd><mtd><mo>&asymp;</mo></mtd><mtd><mi>x</mi></mtd></mtr><mtr><mtd><mrow><mi>x</mi><mo>+</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd><mo>&asymp;</mo></mtd><mtd><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd></mtr></mtable></math>通过这些等式, 我们可以计算<math><mn>1</mn></math> (编码为<math><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow></math>) 和<math><mn>2</mn></math> (编码为<math><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>) 之和:<math display="block"><mrow><mrow><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&asymp;</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&asymp;</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mn>0</mn></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&asymp;</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>在这个计算之中, 我们将等式解释为了重写规则, 其告诉我们一个给定项的某个子项是如何可以被替换为另一个项的.</p><p>这将我们带至了本书的关键概念之一, 即<b>项重写系统</b>. 何谓<b>项</b>? 它们是由<b>变量</b>, <b>常量符号</b>, 以及<b>函数符号</b>构筑而成的. 在上述例子之中, <math><mo>+</mo></math>是一个二元函数符号, <math><mi>s</mi></math>是一个幺元函数符号, <math><mn>0</mn></math>是一个常量符号, 而<math><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow></math>是变量. 这些符号之上的项的例子有<math><mn>0</mn></math>, <math><mi>x</mi></math>, <math><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>, <math><mrow><mi>x</mi><mo>+</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, <math><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>s</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mn>0</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></math>. 在我们的示例计算之中, 我们只以从左到右的方式使用等式. 但是一般而言, 等式可以在两个方向上运用.</p><p>以下我们将给出两个例子用于刻画等式与项重写系统的联系之中出现的一些关键议题, 而其也将会在本书之中得到详细处理. 在第一个例子里, 重写规则只意图以一个方向使用 (这表达以写作<math><mo>&rarr;</mo></math>而非<math><mo>&asymp;</mo></math>). 这是重写作为计算机制的实例. 在第二个例子里, 我们考虑了定义群的等式, 其意图以两个方向使用. 这是重写作为演绎机制的实例.</p><h3>第1.1节 符号微分</h3><p>我们考虑由运算<math><mrow><mo>+</mo><mo>,</mo><mo>&#8270;</mo></mrow></math>, 未定元<math><mrow><mi>X</mi><mo>,</mo><mi>Y</mi></mrow></math>, 以及数字<math><mrow><mn>0</mn><mo>,</mo><mn>1</mn></mrow></math>所构成的算术表达式的符号微分. 例如, <math><mrow><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>+</mo><mi>X</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&#8270;</mo><mi>Y</mi></mrow><mo stretchy="false">)</mo></mrow><mo>+</mo><mn>1</mn></mrow></math>是一个可容许的表达式. 这些表达式可以被视为由常量符号<math><mrow><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mi>X</mi><mo>,</mo><mi>Y</mi></mrow></math>和二元函数符号<math><mrow><mo>+</mo><mo>,</mo><mo>&#8270;</mo></mrow></math>构筑而成的项. 对于相对于<math><mi>X</mi></math>而言的偏导数, 我们引入了额外的(幺元)函数符号<math><msub><mi>D</mi><mi>X</mi></msub></math>. 以下是计算导数的(其中一些)著名规则:<math display="block"><mtable columnalign="left right center left"><mtr><mtd><mtext>(R1)</mtext></mtd><mtd><mrow><msub><mi>D</mi><mi>X</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>&rarr;</mo></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mtext>(R2)</mtext></mtd><mtd><mrow><msub><mi>D</mi><mi>X</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>&rarr;</mo></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mtext>(R3)</mtext></mtd><mtd><mrow><msub><mi>D</mi><mi>X</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>u</mi><mo>+</mo><mi>v</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>&rarr;</mo></mtd><mtd><mrow><mrow><msub><mi>D</mi><mi>X</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><msub><mi>D</mi><mi>X</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mtext>(R4)</mtext></mtd><mtd><mrow><msub><mi>D</mi><mi>X</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>u</mi><mo>&#8270;</mo><mi>v</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>&rarr;</mo></mtd><mtd><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>u</mi><mo>&#8270;</mo><mrow><msub><mi>D</mi><mi>X</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>+</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><msub><mi>D</mi><mi>X</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&#8270;</mo><mi>v</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd></mtr></mtable></math>在诸如<math><mrow><msub><mi>D</mi><mi>X</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>u</mi><mo>+</mo><mi>v</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>这样的项之中, 符号<math><mi>u</mi></math>和<math><mi>v</mi></math>是变量, 其意图的含义在于它们可以被任意的表达式所替换. 因此, 规则(R3)可以被应用于任何具有和其左侧相同模式的项, 即一个<math><msub><mi>D</mi><mi>X</mi></msub></math>后面跟着一个<math><mo>+</mo></math>表达式.</p><p>从项<math><mrow><msub><mi>D</mi><mi>X</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>&#8270;</mo><mi>X</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>, 规则(R1)-(R4)将会导致如图1.1中所描绘的可能归约. 我们使用这个例子来刻画项重写系统的两个最为重要的性质:</p><p><b>终止性 (termination): </b>是否总是在有限多次规则应用之后我们将会抵达一个没有规则可以应用的表达式? {译注: 实际上这句话有点歧义, 既可以理解为是否存在一个有限的归约/重写序列到达所谓的规范形式, 也可以理解为是否所有归约/重写序列都只能是有限的, 以至于最终必然到达一个规范形式. 以术语来说, 即弱规范化性质和强规范化性质.} 然后, 这样一个表达式被称为一个<b>规范形式</b>.<br/>对于规则(R1)-(R4)而言的确如此. 然而, 表明这项性质并非全然平凡, 因为规则(R4)会导致表达式体积的相当膨胀.<br/>一个非终止规则的例子是<math display="block"><mrow><mrow><mi>u</mi><mo>+</mo><mi>v</mi></mrow><mo>&rarr;</mo><mrow><mi>v</mi><mo>+</mo><mi>u</mi></mrow></mrow></math>其表达了加法的可交换性质. 序列<math display="block"><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>&#8270;</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow><mo>+</mo><mrow><mo stretchy="false">(</mo><mrow><mn>1</mn><mo>&#8270;</mo><mi>X</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&rarr;</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mn>1</mn><mo>&#8270;</mo><mi>X</mi></mrow><mo stretchy="false">)</mo></mrow><mo>+</mo><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>&#8270;</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&rarr;</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>&#8270;</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow><mo>+</mo><mrow><mo stretchy="false">(</mo><mrow><mn>1</mn><mo>&#8270;</mo><mi>X</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&rarr;</mo><mo>&ctdot;</mo></mrow></math>是一条该规则应用的无限的链. 当然了, 非终止性不一定非得是由单独一条规则所导致的; 其可以来源于多条规则的交互作用.</p><p><b>合流性 (confluence): </b>如果对于给定的项<math><mi>t</mi></math>而言存在应用规则的不同方法, 那么将会导致不同的导出项<math><msub><mi>t</mi><mn>1</mn></msub></math>和<math><msub><mi>t</mi><mn>2</mn></msub></math></p><h3>第1.2节 群论</h3><h2>第2章 抽象归约系统</h2><h2>第3章 泛代数</h2><h2>第4章 等式性问题</h2><h2>第5章 终止性</h2><h2>第6章 合流性</h2></body></html>