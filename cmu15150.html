<html><head><meta charset="utf-8"/><title>CMU 15-150笔记</title><link href="styles.css" rel="stylesheet"/></head><body><h1>CMU 15-150笔记</h1><p>主要是对于CMU 15-150课程的幻灯片等材料的翻译.</p><h2>第1章 求值和定型, 绑定和作用域</h2><h3>第1.1节 引入</h3><p>今天我们给出了课程的大纲及其目标, 包括引用透明, 外延等价, 以及并行. 我们从观察其类型开始探索SML语言.</p><p><b>关键概念</b><ul><li>计算是函数式的</li><li>编程作为阐释性的过程</li><li>类型, 值, 表达式</li><li>定型规则和求值规则</li><li>integer, real, boolean, product</li><li>并行, work, span</li><li>外延等价</li></ul></p><h3>第1.2节 幻灯片</h3><h4>第1.2.1小节 课程哲学</h4><ul><li><b>计算</b>是函数式的</li><li><b>编程</b>是阐释性的语言过程</li></ul><h4>第1.2.2小节 计算是函数式的</h4><ul><li><b>值</b>相对于<b>类型</b>被分类</li><li><b>表达式</b>{译注: 也有类型}</li><li><b>函数</b>将值映射为值</li></ul><h4>第1.2.3小节 命令式 vs. 函数式</h4><table><tr><td>命令</td><td>表达式</td></tr><tr><td>被执行</td><td>被求值</td></tr><tr><td>具有副作用</td><td>无副作用</td></tr><tr><td><code>x := 5</code></td><td><code>3 + 5</code></td></tr><tr><td>(新状态)</td><td>(新值)</td></tr></table><h4>第1.2.4小节 编程作为阐释</h4><ul><li>问题陈述<ul><li>不变量</li><li>规格</li><li>正确性证明</li></ul></li><li>分析, 分解和适应, 证明</li></ul><h4>第1.2.5小节 并行</h4><math display="block"><mtable><mtr><mtd><mrow><mo stretchy="false">&lang;</mo><mrow><mn>1</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn></mrow><mo stretchy="false">&rang;</mo></mrow></mtd><mtd><mo>&rarr;</mo></mtd><mtd><mn>3</mn></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">&lang;</mo><mrow><mn>1</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>1</mn></mrow><mo stretchy="false">&rang;</mo></mrow></mtd><mtd><mo>&rarr;</mo></mtd><mtd><mn>3</mn></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">&lang;</mo><mrow><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn></mrow><mo stretchy="false">&rang;</mo></mrow></mtd><mtd><mo>&rarr;</mo></mtd><mtd><mn>4</mn></mtd></mtr><mtr><mtd><mrow><mo stretchy="false">&lang;</mo><mrow><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn></mrow><mo stretchy="false">&rang;</mo></mrow></mtd><mtd><mo>&rarr;</mo></mtd><mtd><mn>2</mn></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mo>&darr;</mo></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mrow/></mtd><mtd><mn>12</mn></mtd></mtr></mtable></math><pre><code>sum: int sequence -> int
type row = int sequence
type room = row sequence
fun count (class: room): int = sum (map sum class)</code></pre><h4>第1.2.6小节 分析</h4><ul><li>做这个计算需要多长时间?</li><li>如何改进<code>count</code>的运行时间?<blockquote>分而治之</blockquote></li></ul><h4>第1.2.7小节 代价分析</h4><p><b>work</b><ul><li>顺序计算</li><li>总顺序时间; 操作数目</li></ul></p><p><b>span</b><ul><li>并行计算</li><li>在可用处理器数目不受限制时的所需时间; 最长关键 (critical) 路径的长度</li></ul></p><h4>第1.2.8小节 介绍ML</h4><ul><li>类型<math><mi>t</mi></math></li><li>表达式<math><mi>e</mi></math></li><li>值<math><mi>v</mi></math> (作为表达式的子集)</li></ul><h4>第1.2.9小节 例子</h4><pre><code>     (3 + 4) * 2
=1=> 7 * 2
=1=> 14</code></pre><pre><code>     (3 + 4) * (2 + 1)
=3=> 21</code></pre><p>如果使用并行, 第二个需要多少步骤?</p><pre><code>    &quot;the &quot; ^ &quot;walrus&quot;
==> &quot;the walrus&quot;</code></pre><pre><code>&quot;the walrus&quot; ^ 1
ill-typed</code></pre><p>SML从不会求值病态类型表达式!</p><h4>第1.2.10小节 类型, 表达式, 值</h4><ul><li>类型是对于表达式的值的<q>预测</q>, 如果表达式最终确有一个值的话 {译注: 求值过程可能因为无限进行而发散}</li><li>一个表达式是<b>良类型</b>的, 如果其至少具有一个类型, 否则就是<b>病态类型</b>的.</li><li>良类型表达式具有一个类型, 可能具有一个值, 可能具有一个副作用 (但是现在的effect-free部分当然是没有的)</li></ul><p>每个良形式的ML表达式<math><mi>e</mi></math><ul><li>具有类型<math><mi>t</mi></math>, 记作<math><mrow><mi>e</mi><mo>:</mo><mi>t</mi></mrow></math></li><li>可能具有一个值, 记作<math><mrow><mi>e</mi><mo>&rarrhk;</mo><mi>v</mi></mrow></math>, 或者<math><mrow><mi>e</mi><mo>&xrArr;</mo><mi>v</mi></mrow></math></li><li>可能具有一个副作用 (但是现在的effect-free部分当然是没有的)</li></ul></p><p>例子:<pre><code>(3 + 4) * 2 : int</code></pre><pre><code>(3 + 4) * 2 ==> 14</code></pre></p><p>{译注: 结合前文, 看起来<math><mo>&xrArr;</mo></math>是归约关系而非求值至的关系.}</p><h4>第1.2.11小节 ML中的类型</h4><ul><li>基本类型<ul><li><code>int</code>, <code>real</code>, <code>bool</code>, <code>char</code>, <code>string</code></li></ul></li><li>构造类型<ul><li>积类型</li><li>函数类型</li><li>用户定义的类型</li></ul></li></ul><h4>第1.2.12小节 整数(类型), 表达式</h4><ul><li>类型: <code>int</code></li><li>值: ..., <code>~1</code>, <code>0</code>, <code>1</code>, ...</li><li>表达式: <code><math><msub><mi>e</mi><mn>1</mn></msub></math> + <math><msub><mi>e</mi><mn>2</mn></msub></math></code>, <code><math><msub><mi>e</mi><mn>1</mn></msub></math> - <math><msub><mi>e</mi><mn>2</mn></msub></math></code>, <code><math><msub><mi>e</mi><mn>1</mn></msub></math> * <math><msub><mi>e</mi><mn>2</mn></msub></math></code>, <code><math><msub><mi>e</mi><mn>1</mn></msub></math> div <math><msub><mi>e</mi><mn>2</mn></msub></math></code>, <code><math><msub><mi>e</mi><mn>1</mn></msub></math> mod <math><msub><mi>e</mi><mn>2</mn></msub></math></code>, ...</li><li>例子: <code>~4 * 3</code></li></ul><h4>第1.2.13小节 整数, 定型</h4><ul><li>定型规则<ul><li><code><math><mi>n</mi></math>: int</code></li><li><code><math><msub><mi>e</mi><mn>1</mn></msub></math> + <math><msub><mi>e</mi><mn>2</mn></msub></math>: int</code>, 如果<code><math><msub><mi>e</mi><mn>1</mn></msub></math>: int</code>且<code><math><msub><mi>e</mi><mn>2</mn></msub></math>: int</code></li><li>其他运算也是类似的</li></ul></li></ul><pre><code>(3 + 4) * 2 : int
because (3 + 4): int and 2: int
(3 + 4): int because 3: int and 4: int</code></pre><h4>第1.2.14小节 整数, 求值</h4><h2>第2章 函数</h2><h3>第2.1节 引入</h3><h3>第2.2节 幻灯片</h3><h4>第2.2.1小节 上次内容</h4><ul><li>类型, 表达式, 值</li><li>外延等价</li><li>声明</li></ul><h4>第2.2.2小节 今天的目标</h4><ul><li>编写匿名函数 (lambda表达式)</li><li>声明有名字的函数</li><li>陈述什么是一个函数闭包</li><li>对于牵涉函数应用的表达式进行求值</li><li>使用模式<ul><li>clausal的函数声明</li><li>case表达式</li></ul></li></ul><h4>第2.2.3小节 声明</h4><pre><code>val     pi :       real = 3.14
keyword identifier type   value</code></pre><p>这引入了一个绑定, 将<code>pi</code>绑定至<code>3.14</code>, 也可以写成<code>[3.14/pi]</code>. {译注: 其实就是替换的写法.}</p><p>词法静态作用域 (lexically statically scoped)</p><h4>第2.2.4小节 绑定</h4><pre><code>val x : int = 8 - 5 [3/x] 
val y : int = x + 1 [4/y]</code></pre><h4>第2.2.5小节 绑定</h4><h2>第3章 递归和归纳</h2><h2>第4章 列表上的递归和结构归纳, 尾递归</h2><h2>第5章 数据类型, 树上的递归和结构归纳</h2><p>我们将数据类型声明作为抽象形式引入, 其旨在将程序员从跟踪低级hacking约定的细节之中解放出来.</p><p>我们考虑了预先定义了的数据类型<code>int option</code>, 其有一个常量构造子<code>None</code>和一个非常量构造子<code>Some</code>, 其接受一个<code>i : int</code>以构造出<code>Some i : int option</code>. 我们也作成了一些我们自己的数据类型, 包括用于模拟颜色的类型, 多返回值类型, 以及一个二叉树类型.</p><p>我们展示了如何使用结构归纳证明关于树的定理.</p><p><b>关键概念</b><ul><li>数据类型声明</li><li>常量构造子</li><li>接受参数的构造子</li><li>递归定义类型</li><li>树类型</li><li></li></ul></p><h2>第6章 渐进分析</h2><h2>第7章 渐进分析</h2><h2>第8章 排序列表</h2><h2>第9章 多态和类型推导</h2><h2>第10章 高阶函数</h2></body></html>