<html><head><meta charset="utf-8"/><title>Topos: 逻辑的范畴分析</title><link href="styles.css" rel="stylesheet"/></head><body><h1>Topos: 逻辑的范畴分析</h1><h2>第1章 数学=集合论?</h2><blockquote>无人可将我们从Cantor创造的天堂之中驱离. &mdash;&mdash; David Hilbert</blockquote><h3>第1.1节 集合论</h3><p>被称为集合论的这个领域所坐落于的基本概念是集合成员所属. 一个集合最初可简单地被认为是一个对象的合集, 而这些对象被称为是这个合集的元素. </p><h4>子集</h4><h4>Russell悖论</h4><h4>NBG</h4><h4>ZF</h4><p><b>分离原理.</b> 给定一个集合<math><mi>A</mi></math>和一个条件<math><mrow><mi>&phi;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math>, 存在一个集合其元素恰是<math><mi>A</mi></math>中那些满足<math><mrow><mi>&phi;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math>的成员.</p><p>该集合被记作</p><h4>一致性</h4><h3>第1.2节 数学基础</h3><h3>第1.3节 作为集合论的数学</h3><h2>第2章 范畴是什么</h2><h3>第2.1节 函数作为集合?</h3><h3>第2.2节 函数的复合</h3><h3>第2.3节 范畴: 最初的例子</h3><div class="definition"><b>定义.</b> 一个范畴<math><mi mathvariant="script">C</mi></math>由以下资料构成.<ol><li>一个被称为<math><mi mathvariant="script">C</mi></math>对象的东西的合集;</li><li>一个被称为<math><mi mathvariant="script">C</mi></math>箭头的东西的合集;</li><li>赋予每个<math><mi mathvariant="script">C</mi></math>箭头<math><mi>f</mi></math>一个<math><mi mathvariant="script">C</mi></math>对象<math><mrow><mi>dom</mi><mo>&af;</mo><mi>f</mi></mrow></math> (<math><mi>f</mi></math>的&quot;domain&quot;) 和一个<math><mi mathvariant="script">C</mi></math>对象<math><mrow><mi>cod</mi><mo>&af;</mo><mi>f</mi></mrow></math> (<math><mi>f</mi></math>的&quot;codomain&quot;) 的运算. 如果<math><mrow><mi>a</mi><mo>=</mo><mrow><mi>dom</mi><mo>&af;</mo><mi>f</mi></mrow></mrow></math>而<math><mrow><mi>b</mi><mo>=</mo><mrow><mi>cod</mi><mo>&af;</mo><mi>f</mi></mrow></mrow></math>, 我们将其呈现为<math display="block"><mrow><mi>f</mi><mo>:</mo><mrow><mi>a</mi><mo>&rarr;</mo><mi>b</mi></mrow></mrow><mtext>或者</mtext><mrow><mi>a</mi><mover><mo>&rarr;</mo><mi>f</mi></mover><mi>b</mi></mrow><mtext>;</mtext></math></li><li>一个运算, 其赋予每对<math><mi mathvariant="script">C</mi></math>箭头<math><mrow><mo stretchy="false">&lang;</mo><mrow><mi>g</mi><mo>,</mo><mi>f</mi></mrow><mo stretchy="false">&rang;</mo></mrow></math>, 若满足<math><mrow><mrow><mi>dom</mi><mo>&af;</mo><mi>g</mi></mrow><mo>=</mo><mrow><mi>cod</mi><mo>&af;</mo><mi>f</mi></mrow></mrow></math>, 以一个<math><mi mathvariant="script">C</mi></math>箭头<math><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow></math>, 即<math><mi>f</mi></math>和<math><mi>g</mi></math>的复合, 并且有<math><mrow><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>dom</mi><mo>&af;</mo><mi>f</mi></mrow></mrow></math>和<math><mrow><mrow><mi>cod</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>cod</mi><mo>&af;</mo><mi>g</mi></mrow></mrow></math>, 换句话说就是<math><mrow><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow><mo>:</mo><mrow><mrow><mi>dom</mi><mo>&af;</mo><mi>f</mi></mrow><mo>&rarr;</mo><mrow><mi>cod</mi><mo>&af;</mo><mi>g</mi></mrow></mrow></mrow></math>. 而且, 如此可得以下条件:<blockquote>结合律: 给定<math><mi mathvariant="script">C</mi></math>对象和<math><mi mathvariant="script">C</mi></math>箭头的配置<math display="block"><mrow><mi>a</mi><mover><mo>&rarr;</mo><mi>f</mi></mover><mrow><mi>b</mi><mover><mo>&rarr;</mo><mi>g</mi></mover><mrow><mi>c</mi><mover><mo>&rarr;</mo><mi>h</mi></mover><mi>d</mi></mrow></mrow></mrow></math>那么<math><mrow><mrow><mi>h</mi><mo>&compfn;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>h</mi><mo>&compfn;</mo><mi>g</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&compfn;</mo><mi>f</mi></mrow></mrow></math>.</blockquote>结合律断言了具有以下形式的图<div><svg width="240" height="135" stroke="black"><defs><marker id="arrow" viewbox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 3 L 5 5 L 0 7 z"/></marker></defs></svg></div>交换.</li></ol></div><h2>第3章 箭头而不是Epsilon</h2><blockquote>思想的世界并不会一下子就向我们敞开. 我们必须持续不断地在我们的意识之中重新创造它. &mdash;&mdash; Ren&eacute; Thom</blockquote><h3>第3.1节 单态的箭头</h3><p>一个集合函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow></math>被称为是<em>单射的</em>, 或者<em>一一的</em>, 如果没有两个不同的输入会给出相同的输出, 即对于输入<math><mrow><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo>&in;</mo><mi>A</mi></mrow></math>,<blockquote>如果<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, 那么<math><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow></math>.</blockquote>现在让我们取一个单射<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow></math>和两个&quot;平行&quot;的函数<math><mrow><mrow><mi>g</mi><mo>,</mo><mi>h</mi></mrow><mo>:</mo><mrow><mi>C</mi><mo>&rrarr;</mo><mi>A</mi></mrow></mrow></math>使得<div>(还没画的交换图)</div>交换, 即<math><mrow><mrow><mi>f</mi><mo>&compfn;</mo><mi>g</mi></mrow><mo>=</mo><mrow><mi>f</mi><mo>&compfn;</mo><mi>h</mi></mrow></mrow></math>.</p><p>那么, 对于<math><mrow><mi>x</mi><mo>&in;</mo><mi>C</mi></mrow></math>, 我们有<math><mrow><mrow><mrow><mi>f</mi><mo>&compfn;</mo><mi>g</mi></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>f</mi><mo>&compfn;</mo><mi>h</mi></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, 即<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>h</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>. 但是因为<math><mi>f</mi></math>是单射的, 这意味着<math><mrow><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>h</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>. 因此<math><mi>g</mi></math>和<math><mi>h</mi></math>, 对于每个输入给出了相同的输出, 是相同的函数. 我们证明了单射的<math><mi>f</mi></math>是&quot;左可消去的&quot;, 即<blockquote>每当<math><mrow><mrow><mi>f</mi><mo>&compfn;</mo><mi>g</mi></mrow><mo>=</mo><mrow><mi>f</mi><mo>&compfn;</mo><mi>h</mi></mrow></mrow></math>, 那么<math><mrow><mi>g</mi><mo>=</mo><mi>h</mi></mrow></math>.</blockquote>从另一方面来说, 如果<math><mi>f</mi></math>具有左可消去性质, 那么它必然是单射的. 为了看出这点, 我们取<math><mi>A</mi></math>中<math><mi>x</mi></math>和<math><mi>y</mi></math>满足<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.<div>(图还没画)</div>指令&quot;<math><mrow><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>x</mi></mrow></math>&quot;和&quot;<math><mrow><mrow><mi>h</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>y</mi></mrow></math>&quot;建立了一对从<math><mrow><mo stretchy="false">{</mo><mn>0</mn><mo stretchy="false">}</mo></mrow></math> (即序数<math><mn>1</mn></math>) 到<math><mi>A</mi></math>的函数<math><mi>g</mi></math>和<math><mi>h</mi></math>满足<math><mrow><mrow><mi>f</mi><mo>&compfn;</mo><mi>g</mi></mrow><mo>=</mo><mrow><mi>f</mi><mo>&compfn;</mo><mi>h</mi></mrow></mrow></math>. 根据左可消去律, <math><mrow><mi>g</mi><mo>=</mo><mi>h</mi></mrow></math>, 于是<math><mrow><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>h</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, 即<math><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow></math>.</p><p>因此我们看到<math><mi mathvariant="bold">Set</mi></math>中的单射箭头恰是那些左可消去的箭头. 要义在于后一种性质在陈述时仅需引用箭头, 而这导向了以下的抽象定义:</p><p>一个范畴<math><mi mathvariant="script">C</mi></math>中的箭头<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>a</mi><mo>&rarr;</mo><mi>b</mi></mrow></mrow></math>在<math><mi mathvariant="script">C</mi></math>中是单态的, 如果对于任意一对平行的<math><mi mathvariant="script">C</mi></math>箭头<math><mrow><mrow><mi>g</mi><mo>,</mo><mi>h</mi></mrow><mo>:</mo><mrow><mi>c</mi><mo>&rrarr;</mo><mi>a</mi></mrow></mrow></math>, </p><h3>第3.2节 满态的箭头</h3><h2>第4章 介绍Topos</h2></body></html>