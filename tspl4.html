<html><head><meta charset="utf-8"/><title>Scheme编程语言</title><link href="styles.css" rel="stylesheet"/></head><body><h1>Scheme编程语言</h1><p>在某种意义上, 我的确没有时间翻译这本书. 不过, 鉴于Scheme是我学习编程的起点, 我总是感到翻译TSPL4对于我个人而言具有特别的意义.</p><h2>前言</h2><h2>第1章 引论</h2><h2>第2章 开始</h2><h2>第3章 深入</h2><h2>第4章 过程和变量绑定</h2><h2>第5章 控制操作</h2><h3>第5.1节 过程应用</h3><h3>第5.2节 顺序 (sequencing)</h3><h3>第5.3节 条件式 (conditionals)</h3><h3>第5.4节 递归和迭代</h3><h3>第5.5节 map和fold操作</h3><h3>第5.6节 延续 (continuations)</h3><h3>第5.7节 延迟求值</h3><h3>第5.8节 多值</h3><h3>第5.9节 eval</h3><h2>第6章 对象上的操作</h2><h2>第7章 输入和输出</h2><h2>第8章 句法扩展</h2><h3>第8.1节 关键词绑定</h3><h3>第8.2节 syntax-rules转换器</h3><h3>第8.3节 syntax-case转换器</h3><h3>第8.4节 例子</h3><h2>第9章 记录</h2><h2>第10章 库和顶层程序</h2><h3>第10.1节 标准库</h3><h3>第10.2节 定义新库</h3><h3>第10.3节 顶层程序</h3><h3>第10.4节 例子</h3><h2>第11章 异常和条件</h2><h2>第12章 扩展例子</h2><h3>第12.1节 矩阵和向量乘法</h3><p>这个示例程序牵涉最为基本的编程技术. 其刻画了简单算术和向量操作, 使用<code>do</code>句法形式的循环, 基于对象类型的分派, 以及引起异常.</p><p>标量和标量, 标量和矩阵, 或者矩阵和矩阵的乘法, 都是由一个被称为<code>mul</code>的单一<em>通用(generic)</em>过程所执行的. <code>mul</code>被调用以两个参数, 而其根据参数的类型来决定应该执行的操作. 鉴于标量操作使用了Scheme的乘法过程<code>*</code>, <code>mul</code>的标量可以是任意内置的数值类型 (精确或非精确的复数, 实数, 有理数, 或整数).</p><p>一个<math><mrow><mi>m</mi><mo>&times;</mo><mi>n</mi></mrow></math>的矩阵<math><mi>A</mi></math>和一个<math><mrow><mi>n</mi><mo>&times;</mo><mi>p</mi></mrow></math>的矩阵<math><mi>B</mi></math>之积是<math><mrow><mi>m</mi><mo>&times;</mo><mi>p</mi></mrow></math>的矩阵<math><mi>C</mi></math>, 其元素由以下公式定义:<math display="block"><mrow><msub><mi>C</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>=</mo><mrow><munderover><mo>&sum;</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mrow><msub><mi>A</mi><mrow><mi>i</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>&it;</mo><msub><mi>B</mi><mrow><mi>k</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow></mrow></mrow><mtext>.</mtext></math>一个标量<math><mi>x</mi></math>和一个<math><mrow><mi>m</mi><mo>&times;</mo><mi>n</mi></mrow></math>的矩阵<math><mi>A</mi></math>之积是<math><mrow><mi>m</mi><mo>&times;</mo><mi>n</mi></mrow></math>的矩阵<math><mi>C</mi></math>, 其元素由以下等式定义:<math display="block"><mrow><msub><mi>C</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>=</mo><mrow><mi>x</mi><mo>&it;</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow></mrow><mtext>.</mtext></math>也就是说, <math><mi>C</mi></math>的每个元素都是<math><mi>x</mi></math>和<math><mi>A</mi></math>的相应元素之积. </p><h3>第12.2节 排序</h3><h3>第12.3节 一个集合构造器</h3><h3>第12.4节 词频统计</h3><h3>第12.5节 Scheme打印器</h3><h3>第12.6节 格式化输出</h3><h3>第12.7节 一个Scheme的元循环解释器</h3><h3>第12.8节 定义抽象对象</h3><h3>第12.9节 快速Fourier变换</h3><p>本节所描述的过程利用了Scheme的复数算术来计算一个值的序列的<em>离散Fourier变换(DFT)</em>. 离散Fourier变换在诸如模式识别, 带宽压缩, 雷达目标探测, 天气监视等广阔的数字电子应用中被用来分析和处理采样的信号序列.</p><p>一个由<math><mi>N</mi></math>个输入值构成的序列<math display="block"><msubsup><mrow><mo stretchy="false">{</mo><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">}</mo></mrow><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></msubsup></math>的DFT是由<math><mi>N</mi></math>个输出值构成的序列<math display="block"><msubsup><mrow><mo stretchy="false">{</mo><mrow><mi>X</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">}</mo></mrow><mrow><mi>m</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></msubsup></math>而这每一项由以下等式定义:<math display="block"><mrow><mrow><mi>X</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munderover><mo>&sum;</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mrow><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&it;</mo><msup><mi>e</mi><mrow><mrow><mo>&minus;</mo><mi>i</mi></mrow><mo>&it;</mo><mfrac><mrow><mn>2</mn><mo>&it;</mo><mi>&pi;</mi><mo>&it;</mo><mi>m</mi><mo>&it;</mo><mi>n</mi></mrow><mi>N</mi></mfrac></mrow></msup></mrow></mrow></mrow></math>一般而言(对于给定的<math><mi>N</mi></math>)抽象出常量是方便的, 即<math display="block"><mrow><msub><mi>W</mi><mi>N</mi></msub><mo>=</mo><msup><mi>e</mi><mrow><mrow><mo>&minus;</mo><mi>i</mi></mrow><mo>&it;</mo><mfrac><mrow><mn>2</mn><mo>&it;</mo><mi>&pi;</mi></mrow><mi>N</mi></mfrac></mrow></msup></mrow></math>这让我们得到了更加简明但是等价的等式<math display="block"><mrow><mrow><mi>X</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munderover><mo>&sum;</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mrow><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&it;</mo><msubsup><mi>W</mi><mi>N</mi><mrow><mi>m</mi><mo>&it;</mo><mi>n</mi></mrow></msubsup></mrow></mrow></mrow></math>直接将<math><mi>N</mi></math>个输出值每个计算为<math><mi>N</mi></math>个中间值之和的话, 需要阶为<math><msup><mi>N</mi><mn>2</mn></msup></math>的操作量. 若使用<em>快速</em>Fourier变换 (FFT), 其可应用于<math><mi>N</mi></math>为<math><mn>2</mn></math>的幂次的情形, 那么就仅需阶为<math><mrow><mi>N</mi><mo>&it;</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>&af;</mo><mi>N</mi></mrow></mrow></math>的操作量. 尽管其通常被呈现为一个复杂的迭代算法, 快速Fourier变换以递归算法表达最为简明和优雅.</p><p>这个递归算法应该归功于Sam Daniel, 其可由按以下方式操作前缀和 (preceding summation) 推导出来. 我们首先将求和分为两半, 然后将其重新组合为一个从<math><mn>0</mn></math>到<math><mrow><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow><mo>&minus;</mo><mn>1</mn></mrow></math>的求和.<math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><mrow><mi>X</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mrow><munderover><mo>&sum;</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow><mo>&minus;</mo><mn>1</mn></mrow></munderover><mrow><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&it;</mo><msubsup><mi>W</mi><mi>N</mi><mrow><mi>m</mi><mo>&it;</mo><mi>n</mi></mrow></msubsup></mrow></mrow><mo>+</mo><mrow><munderover><mo>&sum;</mo><mrow><mi>n</mi><mo>=</mo><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow></mrow><mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mrow><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&it;</mo><msubsup><mi>W</mi><mi>N</mi><mrow><mi>m</mi><mo>&it;</mo><mi>n</mi></mrow></msubsup></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><munderover><mo>&sum;</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow><mo>&minus;</mo><mn>1</mn></mrow></munderover><mrow><mo stretchy="false">[</mo><mrow><mrow><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&it;</mo><msubsup><mi>W</mi><mi>N</mi><mrow><mi>m</mi><mo>&it;</mo><mi>n</mi></mrow></msubsup></mrow><mo>+</mo><mrow><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>+</mo><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&it;</mo><msubsup><mi>W</mi><mi>N</mi><mrow><mi>m</mi><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>+</mo><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></msubsup></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow></mtd></mtr></mtable></math>然后, 我们可以将共同的因子<math><msubsup><mi>W</mi><mi>N</mi><mrow><mi>m</mi><mo>&it;</mo><mi>n</mi></mrow></msubsup></math>提取出来, 即<math display="block"><mrow><mrow><mi>X</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munderover><mo>&sum;</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow><mo>&minus;</mo><mn>1</mn></mrow></munderover><mrow><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>+</mo><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&it;</mo><msubsup><mi>W</mi><mi>N</mi><mrow><mi>m</mi><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></msubsup></mrow></mrow><mo stretchy="false">]</mo></mrow><mo>&it;</mo><msubsup><mi>W</mi><mi>N</mi><mrow><mi>m</mi><mo>&it;</mo><mi>n</mi></mrow></msubsup></mrow></mrow></mrow></math>我们可以在<math><mi>m</mi></math>为偶数时将<math><msubsup><mi>W</mi><mi>N</mi><mrow><mi>m</mi><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></msubsup></math>规约为<math><mn>1</mn></math>, 而在<math><mi>m</mi></math>为奇数时规约为<math><mrow><mo>&minus;</mo><mn>1</mn></mrow></math>, 因为<math display="block"><mrow><msubsup><mi>W</mi><mi>N</mi><mrow><mi>m</mi><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></msubsup><mo>=</mo><msubsup><mi>W</mi><mn>2</mn><mi>m</mi></msubsup><mo>=</mo><msup><mi>e</mi><mrow><mo>&minus;</mo><mrow><mi>i</mi><mo>&it;</mo><mi>&pi;</mi><mo>&it;</mo><mi>m</mi></mrow></mrow></msup><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mn>1</mn></mtd><mtd columnalign="left"><mo>,</mo><mi>m</mi><mtext>为偶数</mtext></mtd></mtr><mtr><mtd><mrow><mo>&minus;</mo><mn>1</mn></mrow></mtd><mtd columnalign="left"><mo>,</mo><mi>m</mi><mtext>为奇数</mtext></mtd></mtr></mtable></mrow></mrow></math>这允许我们分别对于偶数和奇数的情形特化求和. 对于<math><mrow><mn>0</mn><mo>&le;</mo><mi>k</mi><mo>&le;</mo><mrow><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow><mo>&minus;</mo><mn>1</mn></mrow></mrow></math>, 我们有<math display="block"><mtable columnalign="right center left" displaystyle="true"><mtr><mtd><mrow><mi>X</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mn>2</mn><mo>&it;</mo><mi>k</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><munderover><mo>&sum;</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow><mo>&minus;</mo><mn>1</mn></mrow></munderover><mrow><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>+</mo><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow><mo>&it;</mo><msubsup><mi>W</mi><mi>N</mi><mrow><mn>2</mn><mo>&it;</mo><mi>k</mi><mo>&it;</mo><mi>n</mi></mrow></msubsup></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><munderover><mo>&sum;</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow><mo>&minus;</mo><mn>1</mn></mrow></munderover><mrow><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>+</mo><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow><mo>&it;</mo><msubsup><mi>W</mi><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow><mrow><mi>k</mi><mo>&it;</mo><mi>n</mi></mrow></msubsup></mrow></mrow></mtd></mtr><mtr><mtd><mrow><mi>X</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mn>2</mn><mo>&it;</mo><mi>k</mi></mrow><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><munderover><mo>&sum;</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow><mo>&minus;</mo><mn>1</mn></mrow></munderover><mrow><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&minus;</mo><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>+</mo><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow><mo>&it;</mo><msubsup><mi>W</mi><mi>N</mi><mrow><mrow><mo stretchy="false">(</mo><mrow><mrow><mn>2</mn><mo>&it;</mo><mi>k</mi></mrow><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mi>n</mi></mrow></msubsup></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><munderover><mo>&sum;</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow><mo>&minus;</mo><mn>1</mn></mrow></munderover><mrow><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&minus;</mo><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>+</mo><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow><mo>&it;</mo><msubsup><mi>W</mi><mi>N</mi><mi>n</mi></msubsup><mo>&it;</mo><msubsup><mi>W</mi><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow><mrow><mi>k</mi><mo>&it;</mo><mi>n</mi></mrow></msubsup></mrow></mrow></mtd></mtr></mtable></math>作为结果的求和分别是具有<math><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow></math>个元素的序列<math display="block"><msubsup><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>+</mo><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow><mo>&minus;</mo><mn>1</mn></mrow></msubsup></math>和<math display="block"><msubsup><mrow><mo stretchy="false">{</mo><mrow><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&minus;</mo><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>+</mo><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow><mo>&it;</mo><msubsup><mi>W</mi><mi>N</mi><mi>n</mi></msubsup></mrow><mo stretchy="false">}</mo></mrow><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow><mo>&minus;</mo><mn>1</mn></mrow></msubsup></math>的DFT的第<math><mi>k</mi></math>项. 因此, 一个具有<math><mi>N</mi></math>个元素的序列的DFT可以被递归地计算为两个具有<math><mrow><mi>N</mi><mo lspace="0" rspace="0">/</mo><mn>2</mn></mrow></math>个元素的序列的DFT的交织. 如果我们将具有<math><mn>2</mn></math>个元素的序列作为基本情形, 那么我们就可以按照以下方式描述一个递归的FFT算法 (RFFT). 对于<math><mrow><mi>N</mi><mo>=</mo><mn>2</mn></mrow></math>的情形, 我们有<math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><mrow><mi>RFFT</mi><mo>&af;</mo><msubsup><mrow><mo stretchy="false">{</mo><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">}</mo></mrow><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mn>1</mn></msubsup></mrow></mtd><mtd><mo>=</mo></mtd><mtd><msubsup><mrow><mo stretchy="false">{</mo><mrow><mi>X</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">}</mo></mrow><mrow><mi>m</mi><mo>=</mo><mn>0</mn></mrow><mn>1</mn></msubsup></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mo stretchy="false">{</mo><mrow><mrow><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>,</mo><mrow><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>&minus;</mo><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">]</mo></mrow><mo>&it;</mo><msubsup><mi>W</mi><mn>2</mn><mn>0</mn></msubsup></mrow></mrow><mo stretchy="false">}</mo></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mo stretchy="false">{</mo><mrow><mrow><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>,</mo><mrow><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>&minus;</mo><mrow><mi>x</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mtd></mtr></mtable></math>鉴于<math><mrow><mi>N</mi><mo>=</mo><mn>1</mn></mrow></math>时的DFT是恒等变换, 以及<math><mrow><msubsup><mi>W</mi><mn>2</mn><mn>0</mn></msubsup><mo>=</mo><msup><mi>e</mi><mn>0</mn></msup><mo>=</mo><mn>1</mn></mrow></math>. </p><h3>第12.10节 一个合一算法</h3><p>合一是一种模式匹配的技术, 用于自动定理证明, 类型推导系统, 计算机代数, 以及逻辑编程 (例如Prolog).</p><h3>第12.11节 使用engine的多任务</h3></body></html>