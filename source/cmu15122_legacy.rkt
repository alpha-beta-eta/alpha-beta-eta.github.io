#lang racket
(provide cmu15122.html)
(require SMathML)
(define $<-> (Mo "&harr;"))
(define-infix*
  (&<-> $<->)
  )
(define $~ (Mo "~"))
(define (&~ x) (: $~ x))
(define $% (Mo "%"))
(define (&% a b) (: a $% b))
(define (vref A i)
  (ap A (bra0 i)))
(define (vseg A i j)
  (ap A (: $lb0 i $..h j $rp0)))
(define (swap A i j)
  (&<-> (vref A i) (vref A j)))
(define cmu15122.html
  (TmPrelude
   #:title "CMU 15-122"
   #:css "styles.css"
   (H1 "CMU 15-122")
   (P "这是CMU 15-122的笔记(和翻译). 这个课程的名字是Principles of Imperative Computation, "
      "即命令式计算原理, 实际上就是教如何在C语言中进行编程的课程, 但却是按照"
      "编程语言学家所认为的正确方式教授. 从一开始学生就需要学习如何对于"
      "命令式程序进行推理.")
   (P "最开始学生使用一门叫做C0的编程语言进行编程, 大致上它可以算是C语言的"
      "一个精心设计的安全子集, 有着良定义的句法和语义. 之后, 学生从C0过渡到"
      "真正的C语言. 课程的内容大致上是计算机科学常识, 基本的(命令式)编程常识, "
      "以及(命令式)算法和数据结构.")
   (P "当然, 在上这门课之前, 还是要把C0语言先安装好. 课程提供了deb格式的安装包.")
   (H2 "讲座1")
   (P "这节课比较简单, 但主要是为了说明基本的风格. 其检视了一个函数的定义, "
      "似乎是一个施行幂运算的函数. 然而, 也有一点小问题. 之后, 引入了循环不变量, "
      "前条件, 后条件来对于程序进行推理, 并最终证明了修改之后的程序的正确性. "
      "C0语言支持用某种形式来表达循环不变量, 前条件, 后条件, 其他的断言等内容. "
      "并可进行执行程序时的动态检查. 一方面, 它可以供人阅读. 另一方面, 它"
      "也可供机器执行. 当然, 有些东西不可能在其中表达, 比如说终止性. "
      "这必须另外说明并证明. 本课的最后, 还提示了一下关于模算术的一点内容, 即"
      "该函数的正确性是在模算术意义下的.")
   (H2 "讲座2")
   (P "讲座2是关于整数的表示的. 首先, 介绍了自然数的二进制表示, 以及进制的转换. "
      "鉴于将二进制表示转换为整数值其实就是多项式求值, 所以介绍了Horner规则, "
      "中国人也将其称为秦九韶算法. 将一个自然数值转换为二进制表示当然就是通过"
      "不断做带余除法. 在C0语言中, int的值用32bit来表示, 其实就是"
      "two's complement表示的带符号整数, 所以是模" (^ 2 32) "的算术, 取值范围是从"
      (&- (^ 2 31)) "到" (&- (^ 2 31) 1) ". 两个这样的表示相加其实就是小学的竖式加法, "
      "当然实际机器不是这么实现的. 经过简单的思考可知, 加逆 (也就是相反数) 可以是"
      "bitwise complement再加上一: " (&= (&- $x) (&+ (&~ $x) $1)) ". 并且, "
      -1 "的表示不论是多少位的版本, 都会是全为" 1 "的串. 十六进制表示的话, "
      "不论C0还是C在词法上前面都会加上0x. " (&= (^ 2 10) (: 1 $K)) ". "
      (&= (^ 2 20) (: 1 $M)) ". " (&= (^ 2 30) (: 1 $G)) ". "
      (&= (^ 2 40) (: 1 $T)) ". ")
   (P "除法或许是要特别注意的, 不像加法或乘法即便当成无符号数计算也是一样. "
      "鉴于" 2 "的大于" 1 "的幂次都不是素数, 所以非零元不一定都有逆, 于是我们考虑"
      "带余除法. 我们用" (&/ $x $y) "表示整数除法, " (&% $x $y)
      "表示整数模 (modulus) 运算, 其中" (&!= $y $0) ". 我们希望它们满足"
      (MB (&= (&+ (&* (@ (&/ $x $y)) $y) (@ (&% $x $y))) $x) ".")
      "当然, 这还不足以刻画两种运算. 另外, 我们希望"
      (&< (&<= $0 (&abs (&% $x $y))) (&abs $y)) ". 不过, 在" $y "不整除" $x
      "的情况下, 这仍然留下了modulus是正是负的不确定性, 所以需要进一步的规定"
      "来限制. 一种方式是约定整数除法运算永远向着零的方向截断. 这会导致一个现象, "
      "就是在" $x "为负的情况下整数模运算的结果永远都是负的, 而" $x
      "为正的情况下整数模运算的结果永远都是正的. 另一种约定是整数除法永远"
      "向下取整. 这会导致整数模运算的正负和" $y "的正负是一致的. C0语言使用第一种约定.")
   (P "我们不仅用整数来进行数字运算, 很多时候整数也用来表示其他种类的数据, 因此"
      "所谓的按位运算也是很有用的. 按位与: " (Code "&amp;") ". 按位或: "
      (Code "|") ". 按位非: " (Code "~") ". 按位不可兼或 (异或): "
      (Code "^") ". 除了按位运算, 左移和右移也是常见的运算. " (Code "x &lt;&lt; k")
      "代表" (Code "x") "左移" (Code "k") "位, " (Code "x >> k") "代表"
      (Code "x") "右移动" (Code "k") "位. 鉴于C0的(带符号)整数是32bit的, 所以"
      (&< (&<= $0 $k) 32) ". 左移的时候, 空出来的位填0, 这相当于乘" (^ 2 $k)
      ". 右移的时候, 空出来的位填充最高位, 此即所谓算术右移. 这样做之后, 首先我们看出来"
      $x "将保持符号. 其次, 它相当于除以" (^ 2 $k) ", 向下取整. (这个可以通过计算证明.)")
   (P "作为一个位的例子, 整数可以用来表示颜色. 这是所谓的ARGB表示. 用3个8bit分别表示RGB, "
      "还剩8bit表示不透明度, 顺序就是ARGB. 如果" (Code "p") "表示颜色, 那么"
      (Code "(p >> 16) &amp; 0xFF") "可以用来获得红色分量的值. 这其实就是把红色分量"
      "移到最右边的位置, 然后用掩码给其他位都填0. 反过来, 如果想修改某个分量的值, 比如绿色, 设"
      (Code "g") "包含了我们所想修改到的值, 那么"
      (Code "(p & 0xFFFF00FF) | (g &lt;&lt; 8)") "就是我们所想要的答案.")
   
   (H2 "讲座3")
   (P "讲座3是关于数组的. "
      )
   (H2 "讲座4")
   (P "讲座4是关于在数组中进行线性搜索的. 在未排序的数组里, 因为没有能够利用的什么信息, "
      "按顺序搜索是一个自然的选择. 当然, 对于已排序的数组, 我们可以使用所谓的"
      "二分查找 (binary search). 不过讲座4实际上还没有涉及二分查找, "
      "而是介绍了在已排序的数组中施行线性搜索. 读者可以看到, 即便是线性查找"
      "这一看似简单的主题, 也并非那么容易."
      (CodeB "bool is_sorted(int[] A, int lo, int hi)
//@requires 0 &lt;= lo &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= \\length(A);
{
  for (int i = lo; i &lt; hi-1; i++)
    //@loop_invariant lo &lt;= i;
    if (!(A[i] &lt;= A[i+1])) return false;
  return true;
}")
      "当然, 首先我们需要编写一个函数以表达何为已排序的数组 (sorted array). "
      )
   (H2 "讲座4")
   
   (H2 "讲座5 排序")
   (H3 "第1节 大" $O "记号")
   (P "在设计和分析算法的过程中, 我们试图使得函数的运行时间在数学上精确, "
      "这是通过推导所谓的算法的" (Em "渐进复杂度度量")
      "完成的. 除了想要数学上的精确性, 还要两条基本原则指导着我们的数学分析."
      (Ol (Li "我们想要我们的分析" (Em "实际有用") ", 这导致了两个结果." (Br)
              "首先, 我们观察到我们关心的问题总是随着输入的变大而变得更加困难, "
              "因而我们对于大" $O "的定义捕获了我们只关心" (Em "大输入下")
              "算法的行为的想法, 即当算法的所用时间很长时. 正是大输入下"
              "算法之间的差异变得真正显著起来." (Br)
              "第二, 还存在着另外一种数学概念, 大" $Theta
              ", 你们可以自己了解, 并且这实际上经常是我们真正想要在课上"
              "讨论的概念. 但是, 计算机科学家肯定是倾向于基于大" $O
              "记号进行思考和交流. 我们教授大" $O
              "的一部分原因是为了帮助你们能够与其他计算机科学家进行交流!")
          (Li ""
              )
          )
      )
   ((definition)
    "如果" $f "和" $g "是函数, 其以输入大小 (自然数) 为参数, 以对于代价的度量为结果, 那么"
    (∈ $f (app $O $g)) ", 如果存在常量" (&> $c $0) "和某个自然数" $n_0
    "使得对于每个" (&>= $n $n_0) ", " (&<= (app $f $n) (&c* $c (app $g $n)))
    ". [并不要求" $f "和" $g "在每个自然数上都有定义, 但要保证从某个自然数开始都有定义.]")
   (P "如果说大" $O "记号刻画了渐进上界的概念, 那么大" $Theta "记号刻画了渐进紧界的概念.")
   ((definition)
    "如果" $f "和" $g "是两个度量代价的函数, 那么" (∈ $f (app $Theta $g))
    ", 如果存在常量" (&> $c_1 $0) "和" (&> $c_2 $0) ", 以及某个自然数" $n_0
    ", 使得对于每个" (&>= $n $n_0) ", "
    (&<= (&c* $c_1 (app $g $n)) (app $f $n) (&c* $c_2 (app $g $n))) ".")
   (H3 "第2节 排序算法")
   (P "排序算法多种多样: 桶排序, 冒泡排序, 插入排序, 选择排序, 堆排序, ...")
   (H3 "第3节 选择排序")
   (P "选择排序基于这样的想法, 每次迭代都将未排序部分的最小元素移至开头. "
      "更具体地说, 每当我们找到未排序部分的最小元素, 则将其与首元素进行交换 (swap).")
   (P "交换是一种很好的操作, 因为我们期望我们的排序结果要是原本序列的一个置换. "
      "如果我们只对于序列进行交换元素的操作, 则能保证这点.")
   (P "设数组" $A "的长度为" $n ". 接着, 我们置" (&= $i $0)
      ". 变量" $i "代表了未排序部分的第一个元素, 以及最小元要交换至的位置. "
      "换言之, " (vseg $A $0 $i) "是已排序的部分, " (vseg $A $i $n)
      "是未排序的部分.")
   (P "现在我们应该寻找能够帮助我们证明选择排序的正确性的不变量. "
      "首先, 也是容易想到的, 就是" (vseg $A $0 $i) "已排序. 其次, "
      "同样也很容易想到, 就是" (vseg $A $0 $i) "的每个元素都小于等于"
      (vseg $A $i $n) "的任意元素. 对于这个性质, 我们记成是"
      (MB (&<= (vseg $A $0 $i) (vseg $A $i $n)) ".")
      "最终, 当" (&= $i $n) "时, " (vseg $A $0 $n)
      "是排序好了的, 也就是说整个数组" $A "是排序好了的. "
      (&= $i $n) "是迭代终止的条件.")
   (P "至于为什么这两个不变量在迭代中得到保持, 应该说是很简单的. "
      "假设" (&= $i $i_0) "时进入循环, 其中" (&<= $0 (&< $i_0 $n))
      ", 那么" (vseg $A $0 $i_0) "是已排序的, 并且"
      (&<= (vseg $A $0 $i_0) (vseg $A $i_0 $n))
      ". 对于" (vseg $A $i_0 $n) "中的某个最小元, 假设其下标是"
      $j ", 我们交换第" $i_0 "个元素和第" $j "个元素, 即"
      (swap $A $i_0 $j) ". 然后, 我们可以断言"
      (vseg $A $0 (&+ $i_0 $1)) "已排序, "
      "因为即便是后段最小的元素也应该大于等于前段的每个元素, 再加上"
      (vseg $A $0 $i_0) "已排序, 故可以推出"
      (vseg $A $0 (&+ $i_0 $1)) "已排序. 而且, "
      (&<= (vseg $A $0 (&+ $i_0 $1)) (vseg $A (&+ $i_0 $1) $n))
      "也是成立的, 这是因为本来根据初条件就有"
      (&<= (vseg $A $0 $i_0) (vseg $A (&+ $i_0 $1) $n))
      ", 而且根据交换的元素的性质, 可以断言"
      (&<= (vref $A $i_0) (vseg $A (&+ $i_0 $1) $n))
      ", 故可以推出"
      (&<= (vseg $A $0 $i_0) (vseg $A (&+ $i_0 $1) $n))
      ". 不要忘了, " $i "也要加上" $1 ", 所以新的"
      (&= $i (&+ $i_0 $1)) ". 换言之, 经过了一轮迭代之后, "
      "(假设循环不变量成立的情况下)循环不变量仍然成立.")
   (P "起始情况下循环不变量成立, 需要迭代" $n
      "次, 迭代结束之后循环不变量仍然成立, 由此可知选择排序的正确性. "
      "不仅如此, 算法复杂度也是容易估计的.")
   (H3 "第4节 编写选择排序")
   (CodeB "int find_min(int[] A, int lo, int hi) {
    int m = lo;
    for (int i = lo+1; i &lt; hi; i++) {
        if (A[i] &lt; A[m]) {
            m = i;
        }
    }
    return m;
}")
   (CodeB "void swap(int[] A, int i, int j) {
    int t = A[i];
    A[i] = A[j];
    A[j] = t;
}")
   (CodeB "void sort(int[] A, int lo, int hi) {
    for(int i = lo; i &lt; hi; i++) {
        int m = find_min(A, i, hi);
        swap(A, i, m);
    }
}")
   (H3 "第6节 渐进复杂度分析")
   
   (H2 "讲座6 二分搜索")
   (P "计算机科学中一个基础并且反复出现的问题是寻找搜集 (collection) 中的元素, "
      "例如集合中的元素. 这种问题的一个重要算法" (Em "二分搜索")
      ". 我们使用二分搜索以寻找一个已排序的数组中的整数并指出其位置. "
      "之前的讲座中我们已经讨论过了" (Em "线性搜索")
      ", 并给出了这个问题的一些背景. 本讲座清晰地刻画了算法设计中" (Em "序")
      "的力量: 如果一个数组已经排好序了, 那么我们可以非常高效地搜索整个数组, "
      "比无序的状态下要高效得多.")
   (P "我们也将又一次看到循环不变量在编写正确代码方面的重要性. "
      )
   (H2 "讲座7 快速排序")
   (P "本次讲座我们考虑两个相关的排序算法, 其运行效率要比之前讲座介绍的选择排序要好得多: "
      "归并排序和快速排序. 我们细致地建立了快速排序及其不变量. "
      "和往常一样, 契约和循环不变量将会弥合算法的抽象想法以及其实现之间的差距.")
   (H3 "第1节 快速排序算法")
   (P "快速排序以不同的方式运用了分而治之的技巧. 我们按照以下方式处理:"
      (Ol (Li "选择数组中的任意一个元素 (即所谓的" (Em "主元(pivot)") ").")
          (Li "将数组分为两段, 其中一段的元素均小于主元, 而另一段则均大于主元, "
              "主元夹在这两段之间 (即所谓的" (Em "划分") "阶段).")
          (Li "递归地排序主元左边和右边的两段."))
      "在快速排序之中, 将问题分为子问题的过程是线性时间的, 但是将结果放回是立即的. "
      "这种取舍经常在算法设计中出现.")
   (P "让我们来分析这个算法的划分阶段的渐进复杂度, 例如我们有数组"
      (MB (&cm $3 $1 $4 $4 $7 $2 $8))
      "并且选取" $3 "作为我们的主元, 那么我们需要将这个(未排序的!)数组的每个元素"
      "与主元进行比较, 然后得到划分, 其中" (&cm $2 $1) "是在左侧的, "
      (&cm $4 $7 $8 $4) "是在右侧的. "
      )
   (H3 "第2节 快速排序函数")
   
   (H3 "第3节 划分")
   (P "快速排序的代码的最厚部分实际上就是在划分步骤. 一个朴素的想法是"
      "挑选主元然后将输入数组的其他所有元素复制到一个临时数组的两端, "
      "小于主元的元素自左开始放置, 大于等于主元的元素自右开始放置. "
      "当结束的时候, 临时数组中必定还会留下一个空位, 而那个位置"
      "就是我们应该放置主元的地方. 最后, 我们将临时数组的内容复制回"
      "输入的数组之中.")
   (P "译注: 也可以只把大于主元的元素自右开始放置, 然后空下来的位置"
      "的元素都应该等于主元. 如果等于主元的元素不止一个, "
      "那么这将减少递归排序左右两侧的工作量.")
   (P "这种方法需要分配新的数组. 与之相对的是, 选择排序在排序过程中"
      "就不需要分配新的数组. 一个算法若是至多只会分配常量空间, "
      "则将其称为" (Em "原地的(in-place)") ". 选择排序是原地的, "
      "因为它并不需要分配任何临时空间. 若是我们采用以上想法进行划分, "
      "那么快速排序也不是原地算法, 因为每个对于划分的调用都需要分配"
      "等于其输入数组长度的新数组.")
   (P "译注: 原地算法有多种多样的含义. 其实, 如果直接分配一个"
      "等于最初输入长度的临时数组, 似乎也可以满足这里的原地的要求. "
      "不过, 另外一点值得注意的是, 快速排序不会是尾递归的, "
      "所以说它其实不太能满足极端严格意义上的原地要求. "
      "随着数组长度的增大, 快速排序有可能使用更多的栈空间.")
   (P "但是若是有点小聪明, 我们可以写出原地版本的划分算法! "
      "也就是说, 不需要分配额外内存空间的划分算法. "
      "让我们来考虑划分调用时的情况:" (Br)
      "或许我们应该首先注意到的事情在于我们并不知道主元在"
      "划分完了的数组里的最终位置! 这是因为我们并不知道"
      "有多少元素比主元小. "
      )
   (H3 "第4节 实现划分")
   
   (H3 "第5节 稳定性")
   (H3 "第6节 归并排序")
   (H3 "第7节 练习")
   
   (H2 "讲座8 库")
   (H2 "讲座9 栈和队列")
   (H2 "讲座10 链表")
   (H2 "讲座11 无界数组")
   
   ))