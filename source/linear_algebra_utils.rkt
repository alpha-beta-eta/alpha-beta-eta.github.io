#lang racket
(provide (all-defined-out))
(require SMathML)
(define @inv (@lize inv))
(define pminor
  (case-lambda
    ((A) (app (_ $Delta:normal $k) A))
    ((A k) (app (_ $Delta:normal k) A))))
(define usim
  (case-lambda
    ((A) (&i* (&* $P) A $P))
    ((A P) (&i* (&* P) A P))))
(define osim
  (case-lambda
    ((A) (&i* $P^t A $P))
    ((A P) (&i* (^ P $t) A P))))
(define @* (@lize &*))
(define (Lorentz^2 u)
  (_^ (&norm u) $L $2))
(define (Lorentz u) (_ (&norm u) $L))
(define iaut
  (case-lambda
    ((T) (&i* $U T (inv $U)))
    ((T U) (&i* U T (inv U)))))
(define @iaut (@lize iaut))
(define $phiv (Mi "&phiv;"))
(define $T^+ (^ $T $+))
(define (&T^+ n) (app $T^+ n))
(define $GL (Mi "GL"))
(define (&GL n) (app $GL n))
(define (normalize u)
  (~ u (&norm u)))
(define (normalize0 u)
  (&/ u (&norm u)))
(define e^iθ (^ $e (&i* $i $theta)))
(define TmDiv (compose Tm Div))
(define $perp (Mo "&perp;"))
(define (&perp W) (^ W $perp))
(define (@perp W) (@ (&perp W)))
(define (orthoproj u v)
  (&i* (~ (inner* u v) (sqrnorm v)) v))
(define $VerticalBar
  (Mo "|"
      #:attr*
      '((lspace "0") (rspace "0") (stretchy "true"))))
(define (Inner* a b)
  (angb (Mrow a $VerticalBar b)))
(define &Abs
  (let ((vert (Mo "|" #:attr* '((stretchy "true")))))
    (lambda (x)
      (Mrow vert x vert))))
(define (in* a b)
  (bra0
   (Mrow a
         (Mo "|" #:attr* '((lspace "0") (rspace "0")))
         b)))
(define (&sqr x) (^ x $2))
(define (sqrnorm x) (&sqr (&norm x)))
(define (Complex a b)
  (&+ a (&i* $i b)))
(define (uintegral f)
  (integral $0 $1 f $t))
(define (linear & c a b)
  (&= (& (LC c a b)) (LC c (& a) (& b))))
(define (linear+ & a b)
  (&= (& (&+ a b)) (&+ (& a) (& b))))
(define (linear* & c a)
  (&= (& (&i* c a)) (&i* c (& a))))
(define (csym & a b)
  (&= (& a b) (OverBar (& b a))))
(define (clinear & c a b)
  (&= (& (LC c a b))
      (LC (OverBar c) (& a) (& b))))
(define-syntax MatR
  (syntax-rules ()
    ((_ (x ...) ...)
     (brac
      (set-right
       (&Table (x ...) ...))))))
(define-syntax BigMat
  (syntax-rules ()
    ((_ (x ...) ...)
     (brac
      (set-attr*
       (&Table (x ...) ...)
       'displaystyle "true")))))
(define (subdetC J . a*)
  (apply appl (_ $D J) a*))
(define (subdet I J M)
  (app (_ $D (&cm I J)) M))
(define (&delta_k M)
  (app $delta_k M))
(define Func
  (case-lambda
    ((A) A)
    ((A f . B*) (: A (^^ $-> f) (apply Func B*)))))
(define $uarr (Mo "&uarr;"))
(define $darr (Mo "&darr;"))
(define <αβ> (inner* $alpha $beta))
(define $n-1 (&- $n $1))
(define (&J n)
  (_^ $J n (@ $i)))
(define (insert-before-last x lst)
  (let r ((a (car lst)) (d (cdr lst)))
    (if (null? (cdr d))
        (cons a (cons x d))
        (cons a (r (car d) (cdr d))))))
(define (..lize &)
  (lambda arg*
    (apply & (insert-before-last $..c arg*))))
(define (set-left d)
  (set-attr* d 'columnalign "left"))
(define (set-right d)
  (set-attr* d 'columnalign "right"))
(define maxi
  (case-lambda
    ((S) (ap $max S))
    ((c S) (ap (__ $max c) S))))
(define $min (Mi "min"))
(define (&min . x*)
  (apply appl $min x*))
(define mini
  (case-lambda
    ((S) (ap $min S))
    ((c S) (ap (__ $min c) S))))
(define ((tcomment #:n [n ""]) . x*)
  (keyword-apply
   Div '(#:attr*) '(((class "tcomment")))
   (B (format "译者注记~a." n)) " " x*))
(define (ann v T)
  (app $M (&\; v T)))
(define (cyc v T)
  (app $Z (&\; v T)))
(define @cap (@lize &cap))
(define (decomp c1 r1 ck rk)
  (&i* (^ (@- $x c1) r1) $..c (^ (@- $x ck) rk)))
(define $diff (Mo "d" #:attr* '((lspace "0") (rspace "0"))))
(define $BBB_1 (_ $BBB $1))
(define $BBB_k (_ $BBB $k))
(define $FFF_i (_ $FFF $i))
(define pconduct
  (lambda (a W)
    (app $s (&\; a W))))
(define conduct
  (case-lambda
    ((T a W) (ap (_ $S T) (@ (&\; a W))))
    ((a W) (ap $S (@ (&\; a W))))))
(define eqnderiv (compose MB deriv))
(define $d+ (Mo "&CirclePlus;"))
(define (&pi r . L*)
  (app (_ $pi r) (apply &t* L*)))
(define (stable f A)
  (&sube (ap f A) A))
(define (cosetN . x*)
  (~ (&fact (apply @+ x*))
     (apply &i* (map &fact x*))))
(define (&part . x*)
  (apply appl $part x*))
(define $wedge (Mo "&wedge;"))
(define Alt
  (case-lambda
    ((r V) (app (^ $Lambda:normal r) V))
    ((r) (Alt r $V))))
(define AltV (app $Lambda:normal $V))
(define Multi
  (case-lambda
    ((r V) (app (^ $M r) V))
    ((r) (Multi r $V))))
(define &poly
  (case-lambda
    ((F) (ap F (bra0 $x)))
    ((F x) (ap F (bra0 x)))))
(define $gcd (Mi "gcd"))
(define (&gcd . x*)
  (apply appl $gcd x*))
(define $~ (Mo "~"))
(define (&~ x) (^ x $~))
(define (&~~ x) (^^ x $~))
(define (conv i n f g)
  (sum (&= i $0) n (&i* (_ f i) (_ g (&- n i)))))
(define (@conv i n f g)
  (pare (conv i n f g)))
(define polyF (ap $F (bra0 $x)))
(define $F^inf (^ $F $inf))
(define $mod (Mi "mod"))
(define (@mod p) (@ap $mod p))
(define-infix*
  (&wedge $wedge)
  (&d+ $d+)
  
  )
(define @t* (@lize &t*))
(define equivmod
  (case-lambda
    ((f g p) (: (&equiv f g) (&space 2) (@mod p)))
    ((f g) (equivmod f g $p))))
(define $00 (Mo "00"))
(define (&00 S) (^ S $00))
(define basis:def
  (&= $BBB (setE $alpha_1 $..h $alpha_n)))
(define $** (Mo "&#8270;&#8270;"))
(define (&** V) (^ V $**))
(define V* (&* $V))
(define V** (&** $V))
(define W* (&* $W))
(define (preserve f x * y)
  (&= (f (* x y)) (* (f x) (f y))))
(define (&E p q) (^ $E (&cm p q)))
(define (@sum a b e)
  (pare (sum a b e)))
(define sim
  (case-lambda
    ((A) (&i* (inv $P) A $P))
    ((A P) (&i* (inv P) A P))))
(define $ker (Mi "ker"))
(define (&ker T)
  (ap $ker T))
(define $img (Mi "img"))
(define (&img T)
  (ap $img T))
(define &L
  (case-lambda
    ((V) (app $L V))
    ((V W) (appl $L V W))))
(define $nullity (Mi "nullity"))
(define (&nullity T)
  (app $nullity T))
(define alpha_1..n
  (&cm $alpha_1 $..h $alpha_n))
(define $BBB^ (&prime $BBB))
(define $BBB^^ (&Prime $BBB))
(define $BBB_i (_ $BBB $i))
(define $column-rank (Mi "column-rank"))
(define (&column-rank A)
  (app $column-rank A))
(define $row-rank (Mi "row-rank"))
(define (&row-rank A)
  (app $row-rank A))
#;
(define (coordm u b)
  (_ (bra0 u) b))
(define coordm
  (case-lambda
    ((u b) (_ (bra0 u) b))
    ((u) (_ (bra0 u) $BBB))))
(define (LE A X Y)
  (&= (&i* A X) Y))
(define AX=0 (LE $A $X $0))
(define AX=Y (LE $A $X $Y))
(define RX=0 (LE $R $X $0))
(define RX=Z (LE $R $X $Z))
(define m*n
  (&c* $m $n))
(define n*p
  (&c* $n $p))
(define n*n
  (&c* $n $n))
(define n*1
  (&c* $n $1))
(define m*m
  (&c* $m $m))
(define 2*2
  (&c* $2 $2))
(define (&delta i j)
  (_ $delta (&cm i j)))
(define δij (&delta $i $j))
(define (subm A i j)
  (ap A
      (par0
       (Mrow i
             (Mo "|" #:attr* '((lspace "0") (rspace "0")))
             j))))
(define $det (Mi "det"))
(define (&det A) (app $det A))
(define detA (&det $A))
(define (&det0 A) (@ (ap $det A)))
(define $adj (Mi "adj"))
(define (&adj A) (@ (ap $adj A)))
(define $sgn (Mi "sgn"))
(define (&sgn x)
  (ap $sgn x))
(define $deg (Mi "deg"))
(define (&deg f)
  (ap $deg f))
(define $sin (Mi "sin"))
(define $cos (Mi "cos"))
(define (&sin x) (ap $sin x))
(define (&cos x) (ap $cos x))
(define $rank (Mi "rank"))
(define (&rank A)
  (app $rank A))
(define $trace (Mi "trace"))
(define (&trace A)
  (app $trace A))
(define (preserve* f x y)
  (&= (app f (&i* x y))
      (&i* (app f x) (app f y))))
(define (Ttlines t)
  (set-attr*
   (set-attr* t 'rowlines "solid")
   'columnlines "solid"))
(define-syntax &LE
  (syntax-rules ()
    ((_ (x ...) ...)
     (: $lc
        (Ttle (&Table (x ...) ...))))))
(define LC
  (case-lambda
    ((u) u)
    ((k u) (&i* k u))
    ((k u . arg*) (&+ (&i* k u) (apply LC arg*)))))
(define (@LC . arg*)
  (@ (apply LC arg*)))
(define LC0
  (case-lambda
    ((k u) (&+ $..c (&i* k u)))
    ((k u . arg*) (&+ (&i* k u) (apply LC0 arg*)))))
(define (@LC0 . arg*)
  (@ (apply LC0 arg*)))
(define $dim (Mi "dim"))
(define (&dim V)
  (ap $dim V))
(define (&dim0 V)
  (app $dim V))
(define (&seq x #:from [from $1] #:to [to $n])
  (&cm (_ x from) $..h (_ x to)))
(define (@seq x #:from [from $1] #:to [to $n])
  (@ (&cm (_ x from) $..h (_ x to))))
(define eA (app $e $A))
(define Aij (mref $A $i $j))
(define AB (&i* $A $B))
(define @AB (@ AB))
(define σ1 (ap $sigma $1))
(define σ2 (ap $sigma $2))
(define σr (ap $sigma $r))
(define σn (ap $sigma $n))
(define sgnσ (&sgn $sigma))
(define (@sgn x)
  (@ (&sgn x)))
(define @sgnσ (@sgn $sigma))
(define $10 (Mn "10"))
(define $1/2 (~ $1 $2))
(define $1/3 (~ $1 $3))
(define (&label x . t*)
  (Table #:attr* '((align "center"))
         (Tr (Td #:attr* '((align "center")) x))
         (Tr (keyword-apply
              Td '(#:attr*) '(((align "center")))
              t*))))
(define $F^n*1 (^ $F n*1))
(define m*1 (&c* $m $1))
(define $F^m*1 (^ $F m*1))
(define-@lized-op*
  (@d* &d*)
  (@wedge &wedge)
  
  )
(define &..+ (..lize &+))
(define &..i* (..lize &i*))
(define &..d+ (..lize &d+))
(define @..d+ (@lize &..d+))
(define (&..cm . arg*)
  (apply &cm (insert-before-last $..h arg*)))
(define &..< (..lize &<))
(define &..>= (..lize &>=))
(define (n2s n)
  (format "~s" (exact-round n)))
(define (s2n s)
  (string->number s))
(define (make-frame o x y z) (vector 'frame o x y z))
(define (frame-o frame) (vector-ref frame 1))
(define (frame-x frame) (vector-ref frame 2))
(define (frame-y frame) (vector-ref frame 3))
(define (frame-z frame) (vector-ref frame 4))
(define (make-pt2 x y) (vector 'pt2 x y))
(define (pt2-x pt2) (vector-ref pt2 1))
(define (pt2-y pt2) (vector-ref pt2 2))
(define (make-pt3 x y z) (vector 'pt3 x y z))
(define (pt3-x pt3) (vector-ref pt3 1))
(define (pt3-y pt3) (vector-ref pt3 2))
(define (pt3-z pt3) (vector-ref pt3 3))
(define (make-vec2 x y) (vector 'vec2 x y))
(define (vec2-x vec2) (vector-ref vec2 1))
(define (vec2-y vec2) (vector-ref vec2 2))
(define (make-vec3 x y z) (vector 'vec3 x y z))
(define (vec3-x vec3) (vector-ref vec3 1))
(define (vec3-y vec3) (vector-ref vec3 2))
(define (vec3-z vec3) (vector-ref vec3 3))
(define pt2+
  (let ((plus (lambda (pt2 vec2)
                (make-pt2 (+ (pt2-x pt2) (vec2-x vec2))
                          (+ (pt2-y pt2) (vec2-y vec2))))))
    (lambda (pt2 . vec2*)
      (let iter ((pt2 pt2) (vec2* vec2*))
        (if (null? vec2*)
            pt2
            (iter (plus pt2 (car vec2*))
                  (cdr vec2*)))))))
(define (pt3+ pt3 vec3)
  (make-pt3 (+ (pt3-x pt3) (vec3-x vec3))
            (+ (pt3-y pt3) (vec3-y vec3))
            (+ (pt3-z pt3) (vec3-z vec3))))
(define (vec2* k vec2)
  (make-vec2 (* k (vec2-x vec2))
             (* k (vec2-y vec2))))
(define (vec3* k vec3)
  (make-vec3 (* k (vec3-x vec3))
             (* k (vec3-y vec3))
             (* k (vec3-z vec3))))
(define (pt3->2 frame)
  (define o (frame-o frame))
  (define x (frame-x frame))
  (define y (frame-y frame))
  (define z (frame-z frame))
  (lambda (pt3)
    (define a (pt3-x pt3))
    (define b (pt3-y pt3))
    (define c (pt3-z pt3))
    (pt2+ o
          (vec2* a x)
          (vec2* b y)
          (vec2* c z))))
(define (&line p1 p2)
  (define x1 (n2s (pt2-x p1)))
  (define y1 (n2s (pt2-y p1)))
  (define x2 (n2s (pt2-x p2)))
  (define y2 (n2s (pt2-y p2)))
  `(line ((x1 ,x1) (y1 ,y1) (x2 ,x2) (y2 ,y2))))
(define (&line:vec p v)
  (define q (pt2+ p v))
  (define x1 (n2s (pt2-x p)))
  (define y1 (n2s (pt2-y p)))
  (define x2 (n2s (pt2-x q)))
  (define y2 (n2s (pt2-y q)))
  `(line ((x1 ,x1) (y1 ,y1) (x2 ,x2) (y2 ,y2))))
(define (&frame frame)
  (define o (frame-o frame))
  (define x (frame-x frame))
  (define y (frame-y frame))
  (define z (frame-z frame))
  (G (&line:vec o x)
     (&line:vec o y)
     (&line:vec o z)))
(define (&line:pt3 frame)
  (define 3->2 (pt3->2 frame))
  (lambda (p1 p2)
    (&line (3->2 p1) (3->2 p2))))
(define marker0
  (Marker
   #:attr*
   '((id "arrow")
     (viewbox "0 0 10 10")
     (refX "5")
     (refY "5")
     (markerWidth "6")
     (markerHeight "6")
     (orient "auto-start-reverse"))
   (Path #:attr* '((d "M 0 3 L 5 5 L 0 7 z")))))
(define pt3-origin (make-pt3 0 0 0))
(define (&vec3 frame)
  (lambda (vec3)
    (set-attr*
     ((&line:pt3 frame)
      pt3-origin (pt3+ pt3-origin vec3))
     'marker-end "url(#arrow)"
     'stroke-width "2")))
(define frame0
  (make-frame
   (make-pt2 180 150)
   (make-vec2 -180 180)
   (make-vec2 300 0)
   (make-vec2 0 -300)))