#lang racket
(provide 3imp.html)
(require SMathML)
(define (Mid str) (Mi #:attr* '((mathvariant "italic")) str))
(define-syntax-rule (define-mid* (id str) ...)
  (begin
    (define id (Mid str))
    ...))
(define-mid*
  (:v "v")
  (:var "var")
  (:obj "obj")
  (:vars "vars")
  (:body "body")
  (:then "then")
  (:else "else")
  (:ret "ret")
  (:next "next"))
(define (C exp #:constant* [constant* '(zero nil vecnil Nat Atom)]
           #:special* [special* '(U l l-1)])
  (define (T exp)
    (match exp
      (,x (guard (symbol? x))
          (define s (symbol->string x))
          (list
           (cond ((memq x constant*) s)
                 ((memq x special*)
                  (Mi s #:attr* '((mathvariant "script"))))
                 (else
                  (if (= (string-length s) 1)
                      (Mi s)
                      (Mid s))))))
      (,n (guard (number? n)) (list (number->string n)))
      ((,op . ,arg*)
       `("("
         ,@(if (symbol? op)
               (list (symbol->string op))
               (T op))
         ,@(if (null? arg*) '()
               (apply
                append
                (cons
                 '(" ")
                 (add-between
                  (map T arg*) '(" ")))))
         ")"))))
  (define (optimize lst)
    (if (null? lst)
        '()
        (let loop ((head (car lst))
                   (tail (cdr lst)))
          (cond ((null? tail) (list head))
                ((string? head)
                 (cond ((string? (car tail))
                        (loop (string-append head (car tail))
                              (cdr tail)))
                       (else
                        (cons head (optimize tail)))))
                (else
                 (cons head (optimize tail)))))))
  (apply Code (optimize (T exp))))
(define 3imp.html
  (TnTmPrelude
   #:title "Scheme的三种实现模型"
   #:css "styles.css"
   (H1. "Scheme的三种实现模型")
   (P "这是本人对于Kent Dybvig博士论文的试译. 除了一些笔误之外, "
      "影响读者阅读这篇论文的主要因素在于这篇论文的发表时间是1987年. "
      "那个时间点别说R5RS标准了, 连R4RS标准都还没有问世, "
      "因而这篇论文里的Scheme和现在的Scheme有一些不同之处. "
      "例如, 这篇论文里的空表被视为假, 而自R5RS开始空表则被视为真.")
   (H2. "引论")
   (H2. "Scheme语言")
   (H2. "基于堆的模型")
   (P "本章描述了Scheme的一个基于堆的实现模型. "
      "基于堆的模型已经被用在诸多Scheme实现之中, 包括"
      "Scheme84 [Fri84], C-Scheme [Dyb83] 和Scheme-311 [Cli84]. "
      "这些系统与关于Scheme的第一份报告 [Sus75] "
      "中所描述的系统在本质上都是相同的, "
      "尽管每个都使用了不同的编译和解释策略.")
   (P "本章的第一节描述了基于堆的模型背后的动机以及其问题. "
      "第二节呈现了支持基于堆的模型所需要的数据结构, "
      "第三节描述了这个模型的操作. "
      "接着在第四节中的是一个生成基于堆的模型的代码的编译器和"
      "一个描述这种代码如何被执行的虚拟机. "
      "最后第五节呈现了一种常见的优化, "
      "其可以极大地削减大多数程序的执行开销, "
      "并且也呈现了修改之后的编译器和虚拟机, "
      "作为之后章节的所呈现的其他编译器和虚拟机的基础.")
   (P "本章和之后的两章描述了一系列模型, "
      "以及实现这些模型的转换器 (编译器) 和求值器. "
      "每个模型都建立在之前的模型之上, "
      "而每个转换器和求值器都可以使用"
      "之前的转换器和求值器所用到的过程. "
      "对于每个转换器而言, 能够运行的Scheme代码都有给出, "
      "而对于求值器, 本章和下一章的可运行Scheme代码每个也都有给出 "
      "(第5章使用了不同的方法来描述其低层次代码的意义). "
      "不是所有的模型都支持完整的Scheme语言; "
      "不支持的模型也有呈现, "
      "因为其有助于将读者的注意力集中在最重要的细节上, "
      "其有助于强调为了支持特定的特性所遇到的问题, "
      "并且其或许也对于在特定方面与Scheme不同的语言有用.")
   (H3. "动机和问题")
   (P "在诸如Algol 60, C或者Pascal这样的词法作用域语言的典型实现之中, "
      "一个真实的栈 (true stack) 用于记录调用帧 [Aho 77, Ran64]. "
      "每个调用帧里都包含了一个返回地址, 变量绑定, 一个指向前一个帧的链接, "
      "有时还有一些额外的信息. 变量绑定是被调用例程的实际参数和"
      "被调用例程所使用的局部变量. 一个调用帧通常是由调用例程所建立的, "
      "或者说调用者 (caller). 调用者将实际参数压到栈上, "
      "连同一个指向其栈帧的链接以及返回地址, 然后跳转至被调用例程, "
      "或者说被调用者 (callee). 被调用者可以通过压入局部变量的值来扩充帧. "
      "如果这个被调用者又调用了另外一个例程, "
      "那么其会通过压入实际参数, 帧链接, 返回地址等东西来创建一个新的栈帧. "
      "当被调用者抵达其代码的终点时, 其会通过重设帧链接, "
      "移除帧, 并跳转至被保存的返回地址来返回到调用者那里. "
      "{译注: 新人对于" (Q "重设帧链接") "这种表达可能有点困惑. "
      "实际上, 它指的是指向当前帧的链接会保存在某个地方, "
      "而返回时既然当前帧被移除了, 那么指向当前帧的链接也需要随之更新.} "
      "通过这种方式, 每个活跃调用的状态都被记录在栈上, "
      "而一旦调用完成之后这个状态又会被销毁.")
   (P "因为Scheme的第一级闭包和延续, 这种结构还不足够. "
      "第一级闭包能够半无限地保持参数绑定. 特别是, "
      "闭包和被保存的绑定甚至能够在创建绑定的调用已经返回且"
      "其栈帧已经被从栈上移除的情况下被保持在系统之中. "
      "出于这种原因, 将参数绑定存储在栈帧里并不可能. "
      "转而, 一个堆上分配的" (Em "环境")
      "被创建出来以存放实际参数, "
      "而一个指向这个环境的指针被放置在调用帧的绑定的位置上. "
      "当一个闭包被创建时, "
      "一个指向这环境的指针被置于这闭包对象之中.")
   (P "将变量绑定移入堆中使得绑定免于因为栈的收缩和成长而被覆写. "
      "鉴于调用帧 (减去之前所说的变量绑定) 仍然被保存在栈上, "
      "施行一个函数调用的唯一额外开销是环境的分配. "
      "然而, 第一级延续要求调用帧要和环境一样在堆上分配. "
      "这是因为延续的自然实现就是保持一个指向调用栈内部位置的指针 "
      "(a pointer into the call stack). "
      "回忆一下, 一个延续是一个闭包, 当被调用时, "
      "将控制返回至延续获得的那个点. "
      "因为延续是一种第一级对象, "
      "对于其何时被调用则没有限制. "
      "特别是, 甚至在控制已经从其被获得的那个点返回之后, "
      "其仍然有可能被调用. "
      "如果是这样的话, 栈有可能自那时起又已经成长了, "
      "覆写了延续中的一些栈帧. "
      "{译注: 作者的想法是这样的, 一般来说, "
      "返回的时候可以不用强行移除栈上的内容, "
      "因为我们已经将其视为了垃圾. "
      "而如果从那个点返回了又返回之后, "
      "新的栈帧就要覆盖原本延续里所涉及的栈帧的内容了.} "
      "因此, 自然的解决方案是要维护一个堆分配的栈帧的链表. "
      "当栈成长时, 新的帧在堆中未被使用的位置上分配, "
      "于是旧的栈帧仍然完好无缺.")
   (P "堆上分配调用帧和环境的主要问题与使用堆相关的开销. "
      "这种开销包括在构建调用帧和环境时在堆中寻找空间的代价, "
      "也包括访问帧或者环境的片段时沿着链接而非"
      "自栈或者帧指针进行索引 "
      "(indexing a stack or frame pointer) 的代价. "
      
      )
   (H3. "数据结构的表示")
   (P "在基于堆的系统之中, 基本上需要五种不同的数据结构来支持核心语言. "
      "这些结构分别是" (Em "环境") ", " (Em "调用帧")
      ", " (Em "控制栈") ", " (Em "闭包") ", 以及" (Em "延续")
      ". 这些对象的结构在设计Scheme系统时是关键的, "
      "因为其在Scheme系统所施行的每个计算中都有涉及. "
      "这些结构在这里被描述, 连带着其在Scheme之中的表示.")
   (H4. "环境")
   (P "一个环境由" (Code "cons") "创建的序对构建出来. "
      "一个环境的结构类似于一个" (Em "肋骨笼(rib cage)")
      ", 因为环境是列表序对的列表. "
      
      )
   (H4. "帧和控制栈")
   (P "帧是用来在施行另一个计算时记录待处理计算的状态的. "
      "它们最常在一个函数调用另一个函数时被创建; "
      "第一个函数(的执行)被推迟了, 等待着第二个函数(的调用)的值. "
      "任何对于第一个函数的继续求值而言必要的信息都必须记录在帧里. "
      "取决于实现, 或许其他操作也可能需要帧, "
      "尽管这种帧在这篇论文里没有用到.")
   (P "调用帧的使用贯穿了本章和下一章, "
      "而特定的格式则随模型而变. "
      "{译注: 所谓格式, 另一个说法大概是栈帧布局.} "
      "然而, 一个调用帧总是必须包含一个" (Q "返回地址")
      "或者说接下来要被求值的表达式, "
      "环境或者对于活跃变量绑定的等价描述, "
      "一个指向前一个帧的指针, "
      "以及任意其他对于继续计算而言所必要的状态.")
   (P "在基于堆的系统之中, 调用帧不过就是包含四个域的列表. "
      "第一个域是" (Em "表达式")
      "域. 这个域确定了接下来要被求值的表达式. "
      "其对应于一个标准计算机架构中的一个返回地址 "
      "(被保存的程序计数器或者指令计数器(的值)). "
      "第二个域是" (Em "环境") "域. 这包含了当前活跃的环境. "
      "第三个域是" (Code "rib")
      "域. 在对于一个应用的求值过程中, "
      "这个域包含了已经被求值的参数的列表. "
      "{译注: 更准确地说, " (Code "rib")
      "域是已经求值过了的实际参数的值的列表.} "
      "第四个域, 也是最后一个域, 存放了下一个帧.")
   (P "在基于堆的系统之中, "
      "控制栈就是一个由当前帧, 之前的帧, 再之前的帧"
      "等东西构成的链接结构 (linked structure). "
      "其类似于一个链表, 以每个帧的域为元素而"
      "链接是在内部通过" (Q "下一个帧") "指针完成的. "
      "{译注: 准确来说, 这里所谓的元素排除了下一个帧域.} "
      "将栈结构化以使得链接外部于帧也是合理的, "
      "只要不引入额外的存储开销或者沿着链接(行进)的开销. "
      "{译注: 这里所谓的外部, "
      "大概指的是将除了下一个帧域之外的信息打包, "
      "形成一个链表结构.}")
   (H4. "闭包和延续")
   (P "基于堆的系统之中的闭包是简单的对象, "
      "其将一个函数的文本或者可执行部分与当前环境组合起来. "
      "除非使用" (Ref "variable-access")
      "的优化, 不然的话变量也是需要的. "
      "{译注: 这里的变量指的是函数的形式参数.} "
      "因此, 在" (Ref "heap-model-impl")
      "的系统之中, 一个闭包对象是由三个元素构成的列表: "
      "一个函数体, 一个环境, 以及一个变量列表. "
      "例如, 由表达式"
      (CodeB "((lambda (x)
   (lambda (y) (cons x y)))
 'a)")
      "返回的闭包看起来类似于"
      (CodeB "((cons x y) ((x) . (a)) (y))")
      "除了实际的体 (body) 会是" (Code "(cons x y)")
      "的编译后版本. 在" (Ref "variable-access")
      ", 一个闭包仅是由两个元素构成的列表, "
      "一个是环境, 另一个是函数体.")
   (P "一个延续是一个闭包, "
      "其包含了足够多的信息用以从一个给定继续进行计算. "
      
      )
   (H3. "实现策略")
   (P "本节描述了一种基于堆的系统的实现策略, "
      "其利用了前一节所描述的数据结构. "
      "许多实现策略都是可行的; "
      "这里给出的意在容易理解并可简单推广至之后章节的系统. "
      "它并没有精确模仿本章开头所提及的任何实现所使用的策略.")
   (P "计算以迭代的方式施行, 其使用了一集寄存器来存放计算的状态. "
      "迭代方法是必要的, "
      "因为第2章所呈现的所呈现的更直接的元循环解释器的递归方法"
      "并不能正确 (properly) 支持延续或者尾调用. "
      "求值器必须要能够显式访问计算的状态"
      "以将这状态保存在一个延续之中, "
      "而递归使得这状态的某些部分隐式起来; "
      "这状态位于" (Em "元(meta)")
      "层次, 并不对于实现直接可用. "
      "除非(元层次上的)实现正确支持尾调用, "
      "否则的话尾调用也不能被正确支持. "
      "{译注: 这里说的是, 如果是采用直接递归的元循环解释器, "
      "那么其是否能够正确支持尾调用依赖于实现语言 (宿主语言) "
      "能否正确支持尾调用.}")
   (P "本章的策略使用了五个寄存器:"
      (Ul (Li $a ": 累积器,")
          (Li $x ": 下一个表达式,")
          (Li $e ": 当前环境,")
          (Li $r ": 当前值肋骨,")
          (Li $s ": 当前栈."))
      "之后的内容描述了这些寄存器的使用(方式).")
   (P (Em "累积器")
      "存放着由一个值返回 (value-returning) "
      "操作所计算的最后一个值, "
      "这样的操作诸如加载一个常量或者引用一个变量. "
      "在函数应用期间, 其在参数的值被保存在值肋骨之前"
      "依次存放着每个参数的值, 并且在应用之前"
      "存放着函数(位置表达式)的值. "
      "在对于" (Code "if") "表达式求值期间, "
      "其存放着测试 (test) 表达式的值; " (Code "if")
      "用这个值来决定要对两个其他子表达式中的哪一个进行求值. "
      "当一个计算完成时, 累积器里的值应该是这个计算的值.")
   (P (Em "下一个表达式")
      "刻画了接下来要求值的表达式, "
      )
   (P (Em "当前环境")
      "存放着活跃的词法绑定. "
      )
   (P "在一个应用的求值期间, " (Em "当前值肋骨")
      "存放着已经被求值了的参数(的值)的列表. "
      
      )
   (H3. "实现基于堆的模型" #:id "heap-model-impl")
   (H4. "汇编代码")
   (P "本节所描述的VM汇编代码由12种指令构成, "
      "每个指令有零或更多个参数 (operand). "
      "以下是对于这些指令的描述.")
   (Ol (Li (C '(halt))
           "终止了虚拟机器. 累积器里的值是计算的(最终)结果.")
       (Li (C '(refer var x))
           "找出当前环境里变量" :var
           "的值, 然后将这个值放到累积器里, "
           "并将下一个表达式置为" $x ".")
       (Li (C '(constant obj x))
           "将" :obj "放到累积器里, "
           "并将下一个表达式置为" $x ".")
       (Li (C '(close vars body x))
           "根据" :body ", " :vars
           "以及当前环境创建一个闭包, "
           "然后将这个闭包放到累积器里, "
           "并将下一个表达式置为" $x ".")
       (Li (C '(test then else))
           "对于累积器进行测试, 如果累积器是nonnull的 "
           "(意即测试(表达式)返回真), 置下一个表达式为"
           :then ". 否则的话, " (Code "test")
           "置下一个表达式为" :else
           ". {译注: 在作者写下论文的时候, Scheme里的"
           (Code "#f") "和空表实际上是相同的, "
           "所以不要见怪.}")
       (Li (C '(assign var x))
           "将当前环境中对于变量" :var
           "的绑定改变为累积器里的值, "
           "并将下一个表达式置为" $x ".")
       (Li (C '(conti x))
           "根据当前的栈创建一个延续, "
           "将这个延续置于累积器之中, "
           "最后将下一个表达式置为" $x ".")
       (Li (C '(nuate s var))
           "将" $s "恢复为当前的栈, "
           "将累积器置为当前环境中"
           :var "的值, 然后将下一个表达式置为"
           (Code "(return)")
           " (见之后的说明).")
       (Li (C '(frame ret x))
           "由当前环境, 当前值肋骨, 以及作为下一个表达式的"
           :ret "构造出一个新的帧, 然后将这个帧加入到当前的栈里, "
           "并将当前值肋骨置为空表, 下一个表达式置为" $x
           ". {译注: 原文存在笔误, 将参数顺序弄反了.}")
       (Li (C '(argument x))
           "将累积器里的值加入到当前值肋骨里, "
           "然后置下一个表达式为" $x ".")
       (Li (C '(apply))
           "应用累积器里的闭包于当前值肋骨里的值列表. "
           "精确地说, 这个指令扩展闭包的环境以"
           "闭包的变量 (也就是形式参数) 列表和当前值肋骨, "
           "然后将当前环境设置为这个新的环境, "
           "当前值肋骨置为空表, 下一个表达式置为闭包的体.")
       (Li (C '(return))
           "移除(当前)栈的第一个帧, 重设当前环境, "
           "当前值肋骨, 下一个表达式, 以及当前栈. "
           "{译注: 实际上, 对于当前栈的变动就是移除其第一个帧.}"))
   (H4. "转换")
   (P "编译器将Scheme表达式转换为上述汇编语言指令. "
      "一些表达式, 诸如变量和常量, 被转换为一条汇编语言指令. "
      "另一些表达式, 例如应用, 被转换为多条指令.")
   (P "编译器依次寻求每种类型的表达式, 然后将其转换为相应的指令. "
      "编译器的输入是要被编译的表达式和在表达式(求值)完成之后"
      "接下来要执行的指令. 这接下来的指令可以想成是表达式的延续 "
      "(不要将其与" (Code "call/cc") "所返回的延续对象相混淆).")
   (P "出现在下方的编译器的代码. 注意到我们使用" (Code "cond")
      "和" (Code "record-case") "来parse表达式; "
      "并且这篇论文里的所有编译器都会用到它们. "
      "它们在第2章里和其他Scheme句法形式一起被描述了."
      (CodeB "(define compile
  (lambda (x next)
    (cond
      [(symbol? x)
       (list 'refer x next)]
      [(pair? x)
       (record-case x
         [quote (obj)
          (list 'constant obj next)]
         [lambda (vars body)
          (list 'close vars (compile body '(return)) next)]
         [if (test then else)
          (let ([thenc (compile then next)]
                [elsec (compile else next)])
            (compile test (list 'test thenc elsec)))]
         [set! (var x)
          (compile x (list 'assign var next))]
         [call/cc (x)
          (let ([c (list 'conti
                         (list 'argument
                               (compile x '(apply))))])
            (if (tail? next)
                c
                (list 'frame next c)))]
         [else
          (recur loop ([args (cdr x)]
                       [c (compile (car x) '(apply))])
            (if (null? args)
                (if (tail? next)
                    c
                    (list 'frame next c))
                (loop (cdr args)
                      (compile (car args)
                               (list 'argument c)))))])]
      [else
       (list 'constant x next)])))")
      "这个编译器并没有进行任何错误检查, "
      "尽管任何意在实用的编译器至少应该验证参数的数目和结构. "
      "整篇论文里出现的编译器和虚拟机都几乎不进行错误检查, "
      "这是为了缩短代码和简化呈现.")
   (P "对于变量 (符号), " (Code "quote")
      "表达式, 常量表达式 (刻画于" (Code "cond")
      "的" (Code "else") "子句之中) "
      "的处理都是直接的. 一个变量" :v
      "和接下来的指令" :next "会被转换为"
      (C '(refer v next)) ". 类似地, " (C '(quote obj))
      "和简单的" :obj "会被转换为"
      (C '(constant obj next)) ".")
   (P "对于" (Code "lambda") "表达式的处理也是同样直接的. "
      )
   (H4. "求值")
   (P "虚拟机器, 也就是VM, 解释上述编译器所产生的指令, "
      "使用之前所描述的数据结构和寄存器. "
      "它的结构和SECD机器 [Lan64, Lan65] 类似; "
      "寄存器状态的改变由一个尾递归函数所模拟. "
      "这个函数的参数即是寄存器本身. "
      "每次对于VM的递归调用都象征着一次新的机器循环的开始; "
      "VM寄存器的新值由其参数刻画. "
      "这种结构避免了赋值的使用, "
      "使得对于VM及其状态变化的更为清晰紧凑的描述成为可能.")
   (P "以下是VM的代码:"
      (CodeB "(define VM
  (lambda (a x e r s)
    (record-case x
      [halt () a]
      [refer (var x)
       (VM (car (lookup var e)) x e r s)]
      [constant (obj x)
       (VM obj x e r s)]
      [close (vars body x)
       (VM (closure body e vars) x e r s)]
      [test (then else)
       (VM a (if a then else) e r s)]
      [assign (var x)
       (set-car! (lookup var e) a)
       (VM a x e r s)]
      [conti (x)
       (VM (continuation s) x e r s)]
      [nuate (s var)
       (VM (car (lookup var e)) '(return) e r s)]
      [frame (ret x)
       (VM a x e '() (call-frame ret e r s))]
      [argument (x)
       (VM a x e (cons a r) s)]
      [apply ()
       (record a (body e vars)
         (VM a body (extend e vars r) '() s))]
      [return ()
       (record s (x e r s)
         (VM a x e r s))])))"))
   (P "VM的操作遵循着前述对于指令的描述. "
      "注意到绝大多数指令只会修改一两个寄存器. "
      "只有一种指令执行了副作用, 那就是"
      (Code "assign") ", 其破坏性地修改当前的环境. "
      "辅助函数" (Code "lookup") ", "
      (Code "closure") ", " (Code "continuation")
      ", " (Code "call-frame") "和"
      (Code "extend") "之后均有呈现.")
   (P "函数" (Code "lookup") "寻找变量" :var "在环境" $e
      "中的值. 其做法是依次在每个变量肋骨里搜寻, "
      "直至找到变量. 在找到变量的时候, 其会返回一个列表, "
      "这个列表的car部分是(变量)相应的值. "
      "其返回列表而非值本身的原因在于其既被" (Code "refer")
      "使用也被" (Code "assign") "使用. " (Code "assign")
      "通过修改列表结构来执行赋值."
      (CodeB "(define lookup
  (lambda (var e)
    (recur nxtrib ([e e])
      (recur nxtelt ([vars (caar e)] [vals (cdar e)])
        (cond
          [(null? vars) (nxtrib (cdr e))]
          [(eq? (car vars) var) vals]
          [else (nxtelt (cdr vars) (cdr vals))])))))")
      "两层循环是必要的, 一层施行于环境的肋骨之上, "
      "另一层施行于变量肋骨的变量之上. "
      "第二层循环也携带着值肋骨, "
      "以使得正确的位置被找到时值可以立即取出. "
      "注意到鉴于循环是尾递归的, 所以说搜索是迭代性的.")
   (P "函数" (Code "closure") "创建一个新的闭包对象, "
      "其不过就是由一个体, 一个环境, 一个变量列表构成的一个列表:"
      (CodeB "(define closure
  (lambda (body e vars)
    (list body e vars)))"))
   (P "函数" (Code "continuation") "创建一个新的延续对象. "
      "一个延续是一个闭包, "
      )
   (H3. "改进变量访问" #:id "variable-access")
   (H2. "基于栈的模型")
   (H2. "基于字符串的模型")
   (H2. "总结")
   ))