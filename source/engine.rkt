#lang racket
(provide engine.html)
(require SMathML)
(define (h5-heading-cite %heading)
  (define id (%heading-id %heading))
  (define href (string-append "#" id))
  (define section (%heading-section %heading))
  (define level (%heading-level %heading))
  (define ref
    `(a ((href ,href)) ,(format-section section)))
  (Cite ref))
(define (h5-present %heading attr* . html*)
  (define auto? (%heading-auto? %heading))
  (define id (%heading-id %heading))
  (if auto?
      (let ((section (%heading-section %heading)))
        `(h5 ,(attr*-set attr* 'id id)
             ,(format "~a " (format-section section))
             . ,html*))
      `(h5 ,(attr*-set attr* 'id id) . ,html*)))
(define (H5. #:attr* [attr* '()] #:id [id #f]
             #:switch? [switch? #t] #:auto? [auto? #t] . html*)
  `(,(build-%heading #:present h5-present #:cite h5-heading-cite
                     #:level 5 #:id id #:switch? switch?
                     #:auto? auto?)
    ,attr* . ,html*))
(define (Δ x) (: $Delta:normal x))
(define engine.html
  (TnTmPrelude
   #:title "游戏引擎架构笔记"
   #:css "styles.css"
   (H1. "游戏引擎架构笔记")
   (H2. "引论")
   (H2. "工具")
   (H2. "游戏软件工程基础")
   (H2. "并行和并发编程")
   (H2. "游戏3D数学")
   (H2. "引擎支持系统")
   (H2. "资源以及文件系统")
   (H2. "游戏循环和实时模拟")
   (P "游戏是实时的, 动态的, 交互性的计算机模拟. "
      )
   (H3. "渲染循环")
   (H3. "游戏循环")
   (H4. "一个简单的例子: Pong")
   (H3. "游戏循环架构风格")
   (H4. "Windows消息泵")
   (H4. "回调驱动的框架")
   (P "大多数游戏引擎子系统和第三方游戏中间件包以库的形式结构化. "
      )
   (P "与之相对的是, 一些游戏引擎和游戏中间件包以框架的形式结构化. "
      "一个框架是一个部分完成的应用. "
      "程序员通过提供缺失机能的实现或者覆盖默认的行为以完成应用. "
      )
   (P "在基于框架的渲染引擎或者游戏引擎之中, "
      "主游戏循环已经写给我们了, 只是它大致上是空的. "
      "游戏程序员可以编写回调函数来填充缺失的细节. "
      "OGRE渲染引擎是库包裹于框架的一个例子. "
      "在最低层次上, OGRE提供了可由游戏引擎程序员直接调用的函数. "
      "然而, OGRE也提供了一个框架, "
      "其包裹了如何有效使用低层次的OGRE库的知识. "
      "如果程序员选择使用OGRE框架, "
      "那么其需要从" (Code "Ogre:FrameListener")
      "导出一个类并覆盖两个虚函数: "
      (Code "frameStarted()") "和" (Code "frameEnded()")
      ". 正如你可能会猜想到的, "
      "这些函数分别在主3D场景由OGRE渲染之前和之后调用. "
      "OGRE框架对于其内部游戏循环的实现看起来像是以下的伪代码."
      (CodeB "while (true)
{
    for (each frameListener)
    {
        frameListener.frameStarted();
    }

    renderCurrentScene();

    for (each frameListener)
    {
        frameListener.frameEnded();
    }

    finalizeSceneAndSwapBuffers();
}")
      "一个特定游戏的帧监听器实现看起来可能像以下这样."
      (CodeB "class GameFrameListener : public Ogre::FrameListener
{
public:
    virtual void frameStarted(const FrameEvent& event)
    {
        // Do things that must happen before the 3D scene
        // is rendered (i.e., service all game engine
        // subsystems).
        pollJoypad(event);
        updatePlayerControls(event);
        updateDynamicsSimulation(event);
        resolveCollisions(event);
        updateCamera(event);
        
        // etc.
    }

    virtual void frameEnded(const FrameEvent& event)
    {
        // Do things that must happen after the 3D scene
        // has been rendered.
        drawHud(event);

        // etc.
    }
};"))
   (H4. "基于事件的更新")
   (P "在游戏之中, 事件是游戏或其环境的状态的任何有趣改变. "
      "大多数游戏引擎有着一个事件系统, "
      "其允许诸引擎子系统订阅特定种类的事件, "
      "并在那些事件发生时进行反应. "
      "游戏的事件系统往往也非常类似于作为GUI基础的事件/消息系统.")
   (H3. "抽象时间线")
   (P "在游戏编程中, 基于抽象时间线进行思考可能是极其有用的. "
      "一个时间线是一个连续的一维的轴, "
      "其原点可以坐落于相对于系统内的其他时间线的任何位置. "
      "时间线可以简单地由时钟变量实现, "
      "其存储着整数或者浮点形式的绝对时间值.")
   (H4. "真实时间")
   (P "我们可以将由CPU的高精度计时器寄存器直接度量的时间"
      "想成是坐落于我们称为真实时间线的东西之上. "
      )
   (H4. "游戏事件")
   (H4. "局部和全局时间线")
   (H3. "度量和处理时间")
   (P "本节我们将会检视不同种类的时间线和时钟之间的微妙以及不那么微妙的区别, "
      "并且看看它们是如何在真实的游戏引擎之中实现的.")
   (H4. "帧率和时间差 (time delta)")
   (P "一个实时游戏的帧率描述了静态的3D帧的序列呈现给观察者有多快. "
      "单位Hertz (Hz) 被定义为每秒的循环数目, "
      "其可以用来描述任何周期性过程的速率. "
      "对于游戏和电影行业, 帧率通常由frames per second (FPS) 度量, "
      "但实际上这和Hertz是一模一样的东西. "
      "传统电影的帧率是24 FPS. 北美和日本的游戏一般以30或60 FPS进行渲染, "
      
      )
   (H4. "从帧率到速度")
   (P "想象一下, 我们想要制作一个宇宙飞船, 其以每秒40米的恒定速度穿越我们的游戏世界 "
      "(在2D游戏之中, 我们或许会将其描述为每秒40像素). "
      "一个简单的完成这件事情的方法是将飞船的速度" $v
      " (单位是米每秒) 乘以一帧的时长" (Δ $t)
      " (单位是秒), 产生一个位移" (&= (Δ $x) (&i* $v (Δ $t)))
      " (单位是米每帧). {译注: 这个说法不是很严谨, 但是想必能看懂.} "
      "这个位移 (position delta) 可以加到飞船的当前位置" $x_1
      "上, 以找到其下一帧的位置"
      (&= $x_2 (&+ $x_1 (Δ $x)) (&+ $x_1 (&i* $v (Δ $t)))) ".")
   
   (H5. "老派的依赖于CPU的游戏")
   (P "在许多早期电子游戏之中, 开发者并不会度量游戏循环真实流逝的时间. "
      "程序员一般直接忽略了" (Δ $t)
      ", 转而基于米 (或者像素等其他度量距离的方式) 每帧来描述游戏对象的速度. "
      
      )
   (H5. "基于流逝时间的更新")
   (H5. "使用运行平均 (running average)")
   (H5. "控制 (govern) 帧率")
   (H5. "屏幕撕裂和v-sync")
   (H4. "使用高精度计时器来度量真实时间")
   (H5. "时钟漂移 (clock drift)")
   (H4. "时间单位和时钟变量")
   (H5. "64位整数时钟")
   (H5. "32位整数时钟")
   (H5. "32位浮点时钟")
   (H5. "浮点时钟的限制")
   (H5. "其他时间单位")
   (H4. "处理断点")
   (H3. "多处理器游戏循环")
   (H4. "任务分解")
   (P "为了利用并行计算硬件, "
      "我们需要将我们游戏循环的每次迭代所执行的各种任务分解为多重子任务, "
      "其中每一个子任务都可以并行执行. "
      
      )
   (H2. "人类接口设备")
   (H2. "debug和开发工具")
   (H2. "渲染引擎")
   (H2. "动画系统")
   (H2. "碰撞和刚体动力学")
   (H2. "音频")
   (H2. "gameplay系统引论")
   (P "到目前为止, 我们在本书中所讨论的一切都专注于技术. "
      "我们认识到游戏引擎是构建于目标机器的硬件, 驱动, 操作系统"
      "之上的复杂的分层的软件系统. "
      
      )
   (P "一个游戏并不由其技术定义, 而是由其gameplay. "
      "gameplay可以被定义为游玩游戏的总体体验. "
      "术语游戏机制稍微将这个想法更具体地固定住了, "
      "其通常被定义为掌控游戏中的诸实体之间的交互的规则集. "
      "游戏机制也定义了玩家的目标, 成功和失败的标准, 玩家角色的能力, "
      "存在于游戏的虚拟世界之中的非玩家实体的数目和类型, "
      "以及作为整体的游戏体验的总体流向 (overall flow). "
      "在许多游戏之中, 这些元素和令人信服的故事以及丰富的角色阵容交织在一起. "
      "然而, 故事和角色绝对并非每个电子游戏的必要部分, "
      "一个经典的例子是相当成功的游戏俄罗斯方块 (Tetris). "
      
      )
   (H3. "游戏世界解剖")
   (P "gameplay设计因题材而异, 更因具体的游戏而异. "
      "然而, 绝大多数3D游戏和相当多的2D游戏也在一些"
      "基本的结构模式上达成了或多或少的一致性. "
      "我们将会在接下来的内容中探讨了这些模式, "
      "但是请记住所有的这些模式都有其限度, "
      "总有超出这些模式的游戏存在.")
   (H4. "世界元素")
   (P "绝大多数电子游戏都发生在一个二维或者三维的虚拟游戏世界之中. "
      "这个世界一般由许多离散的元素构成. "
      "大致说来, 这些元素可以分为两类: 静态元素和动态元素. "
      "静态元素包括地形, 建筑, 道路, 桥梁, "
      "以及一切不会移动或者以积极方式与gameplay进行交互的东西. "
      "动态元素包括角色, 机动装置, 武器, "
      "漂浮的增强包 (power-up) 和健康包 (health pack), "
      "可收集对象, 粒子发射器, 动态光照, "
      "用于检测游戏中的重要事件的不可见区域, "
      "定义对象路径的样条曲线 (spline).")
   (P "gameplay一般关心的是游戏的动态元素. "
      
      )
   (H5. "静态几何")
   (P "静态世界元素的几何一般在像Maya这样的工具之中被定义. "
      "它可能是一个巨大的三角形网格, 也可能被分解为离散的片段. "
      "场景的静态部分有时基于实例化几何 (instanced geometry) 建造. "
      "实例化 (instancing) 是一种内存节约 (memory conservation) 技术, "
      "其中相当少数目的独特三角形网格被反复在游戏世界之中进行渲染, "
      "只不过有着不同的位置和朝向, 这是为了维护一种丰富的假象. "
      "例如, 一个3D建模者可能会创建五种短的墙块 (wall section), "
      "然后以随机组合的形式将其放在一起以创建数英里的具体独特外观的墙.")
   (P "静态可视元素以及碰撞数据也可以由刷子几何 (brush geometry) 创建. "
      "这种几何起源于Quake引擎族. 一个刷子将一个形状描述为一个凸体积的合集, "
      "每个凸体积都由一集平面划定边界. "
      "刷子几何是快速的, 并且易于创建, 也易于集成进基于BSP树的渲染引擎. "
      "刷子对于游戏世界内容的快速blocking out是相当有用的. "
      "这允许gameplay在初期阶段就进行测试, 而此时进行测试是比较容易的. "
      
      )
   (H4. "世界chunk")
   (P "如果一个游戏发生于一个非常巨大的虚拟世界, "
      "那么通常其会被划分为离散的可游玩区域, "
      "我们将其称为世界chunk. "
      "chunk也被称为关卡 (level), 地图 (map), "
      "舞台 (stage), 或者区域 (area). "
      
      )
   (P "最初, 关卡的概念的发明是作为一种机制, "
      "以在早期游戏硬件的内存限制下提供更丰富的gameplay. "
      "同一时间只有一个关卡可以在内存之中存在, "
      "但是玩家可以推进关卡, 从一个到另一个, "
      "提供远为丰富的总体体验. "
      
      )
   (H4. "高层次游戏流")
   (P "一个游戏的高层次流是玩家目标 (objective) 的序列, 树, 或者是图. "
      "目标有时也被称为任务 (task), 阶段 (stage), 关卡 (level) "
      "(这个术语也可应用于世界chunk), 或者波 (wave) "
      "(如果游戏主要是关于击败一堆堆的攻击性敌人的). "
      "高层次流也提供了每个游戏目标的成功定义 (例如清空所有敌人并取得钥匙) "
      "和失败惩罚 (例如回到当前区域的开头, 可能会失去一条生命). "
      "在故事驱动的游戏之中, 有时流也会包含诸多游戏内电影, "
      "其在故事展开时服务于推进玩家对于故事的理解. "
      
      )
   (P "早期游戏将玩家目标一对一地映射到特定的世界chunk之上 "
      "(因此关卡有着双重含义). 例如, 在" (Em "大金刚(Donkey Kong)")
      "里, 每个新的关卡都给"
      )
   (H3. "实现动态元素: 游戏对象")
   (P "游戏的动态元素通常以面向对象的方式进行设计. "
      "这种方法是直觉性且自然的, "
      "并且能够很好地映射至游戏设计师关于世界如何构建的概念. "
      
      )
   (H4. "游戏对象模型")
   (P "在计算机科学之中, 术语对象模型有着两个相互关联但是并不相同的含义. "
      "它可以指由特定编程语言或者形式化设计语言所提供的特性集. "
      "例如, 我们可以讨论C++对象模型或者OMT对象模型. "
      "它也可以指一种特定的面向对象编程接口 "
      "(即由类, 方法, 以及交错关系 (interrelationship) "
      "构成的, 设计用来解决特定问题的东西). "
      "后一种用法的一个例子是Microsoft Excel对象模型, "
      "其允许外部程序以多种方式控制Excel.")
   
   (H3. "数据驱动游戏引擎")
   (P "在游戏开发的早期时代, 游戏往往是由程序员进行硬编码的. "
      "即便存在什么样的工具, 往往也相当原始. "
      "这能够行之有效的原因在于那时典型游戏的内容体量是相当之小的, "
      "而游戏开发的门槛也不是很高, "
      "这或许还要多亏了当时羸弱的游戏硬件, "
      "只能提供相当原始的图形和音频.")
   
   (H3. "游戏世界编辑器")
   (P "我们已经讨论过了数据驱动的资产创建工具, 例如Maya, Photoshop, "
      "Havok内容工具, 等等. 这些工具能够产生用于渲染引擎, "
      "动画系统, 音频系统, 物理系统之类的东西的独立资产. "
      "这些工具之于gameplay空间的类似物是游戏世界编辑器, "
      "这是一种工具 (有时是工具箱), "
      "允许游戏世界chunk以静态和动态元素定义和填充.")
   (P "所有的商业游戏引擎都包含某种世界编辑器工具."
      (Ul (Li "Radiant用于为Quake和Doom引擎族创建地图.")
          (Li ""
              )
          )
      )
   (P "游戏世界编辑器通常允许游戏对象的初状态 (即其属性的值) 被描述. "
      
      )
   (H4. "游戏世界编辑器的典型特征")
   (P "不同的游戏世界编辑器之间可能有很大的差异, "
      "但是绝大多数编辑器都提供了相当标准的一集特性. "
      "以下是其中一些, 但是肯定不局限于此.")
   (H5. "世界chunk的创建和管理")
   (P "世界创建的单位一般是chunk. "
      "一般来说, 游戏世界编译器允许创建新的chunk, "
      "以及重命名, 拆散, 组合或者销毁既有的chunk. "
      "每个chunk被可以链接至一或多个静态网格, "
      "还可能有其他静态数据元素, "
      "例如AI导航地图, 对于可供玩家攀爬的架子的描述, "
      "cover point定义, 诸如此类. "
      "在某些引擎之中, 一个chunk由一个单独的背景网格定义, "
      "而且必须要有一个. "
      "在其他引擎之中, 一个chunk可能有着独立的存在, "
      "可能是由一个边界体积定义 "
      "(例如AABB, OBB, 或者任意的多边形区域), "
      
      )
   (H5. "游戏世界可视化")
   (P "游戏世界编辑器的用户能够可视化游戏世界的内容是重要的. "
      "因此, 几乎所有的游戏世界编辑器都提供对于世界的三维透视视角, "
      "还可能提供一个二维正交投影. "
      
      )
   (H5. "导航")
   (P "显然, 如果用户不能在游戏世界里面移动, "
      "那么世界编辑器就不会有多大用处. "
      "以正交视角, 能够滚动和放大缩小 (zoom in and out) 是重要的. "
      "以3D视角, 各种相机控制方式都可以使用. "
      
      )
   (H5. "选择")
   (P ""
      )
   (H5. "层次")
   (H5. "属性网格")
   (P "填充游戏世界chunk的静态和动态元素一般具有"
      "各种各样的用户可以编辑的性质 (或者说属性). "
      
      )
   (H5. "编辑多对象选择" #:auto? #f)
   (H5. "自由形式的性质" #:auto? #f)
   (H5. "对象放置和对齐辅助")
   (H5. "特殊的对象类型")
   (H5. "保存和加载世界chunk")
   (H5. "快速迭代")
   (H4. "集成的资产管理工具")
   (H5. "数据处理代价")
   (H2. "运行时gameplay基础系统")
   (H3. "gameplay基础系统的组件")
   (P "大多数游戏引擎提供一套运行时软件组件, 它们共同构成一个框架, "
      "在此框架上可以构建游戏的独特规则, 目标和动态世界元素. "
      "在游戏行业内, 这些组件没有标准的名称, "
      "但我们将它们统称为引擎的gameplay基础系统. "
      "如果可以在游戏引擎和游戏本身之间合理地画一条界线, "
      "那么这些系统就位于这条线的正下方. "
      "理论上, 人们可以构建在很大程度上与具体游戏无关的gameplay基础系统. "
      "然而, 在实践中, 这些系统几乎总是包含特定类型或特定游戏的细节. "
      "事实上, 引擎和游戏之间的界线最好被看作是一大片模糊地带"
      "&mdash;&mdash;一条跨越这些组件, 连接引擎与游戏的渐变弧线. "
      "在某些游戏引擎中, 人们甚至可能认为gameplay"
      "基础系统完全位于引擎与游戏的界线之上. "
      "游戏引擎之间的差异在gameplay组件的设计和实现上最为突出. "
      "尽管如此, 各个引擎之间仍然存在着数量惊人的共同模式, "
      "而这些共通之处将是我们在此讨论的主题.")
   (P "每个游戏引擎解决游戏gameplay软件设计问题的方式都大相径庭. "
      "然而, 大多数引擎都提供以下几个主要子系统:"
      (Ul (Li (B "运行时游戏对象模型 (runtime game object model). ")
              "这是游戏设计师通过世界编辑器所接触到的抽象游戏对象模型的实现.")
          (Li (B "关卡管理和流式加载 (level management and streaming). ")
              "这个系统负责加载和卸载游戏gameplay中虚拟世界的内容. "
              "在许多引擎中, 关卡数据会在游戏gameplay期间被流式加载到内存中, "
              "从而制造出无缝世界的错觉 (而实际上它是被分解为离散chunk的).")
          (Li (B "实时对象更新 (real-time object updating). ")
              "为了让游戏世界中的对象能够自主行为, "
              "每个对象都需要被周期性地更新. "
              "正是这个系统将一个游戏引擎中所有不同的系统整合成为一个有凝聚力的整体.")
          (Li (B "消息和事件处理 (messaging and event handling). ")
              "大多数游戏对象需要彼此通信.这通常通过一个抽象的消息传递系统来完成. "
              "对象间的通信信号通常被称为事件, 它们代表了游戏世界状态的变化. "
              "因此, 在许多工作室中, 消息系统也被称为事件系统.")
          (Li (B "脚本 (scripting). ")
              "用C++等高级语言编写游戏的高级逻辑可能很繁琐. "
              "为了提高生产力, 并让非程序员团队成员能够更高效地工作, "
              "脚本语言通常会被集成到游戏引擎中. "
              "这种语言可以是基于文本的, 比如Python或Lua, "
              "也可以是图形化的, 比如虚幻引擎的蓝图 (Blueprints).")
          (Li (B "目标和游戏流程管理 (objectives and game flow management). ")
              "这个子系统负责管理玩家的目标和整个游戏流程. "
              "它通常被描述为一个序列, 一棵树, 或者一个广义的玩家目标图. "
              "目标通常被分组为章节, 尤其是在许多现代游戏中, 游戏是故事驱动的. "
              "游戏流程管理系统管理游戏的整体流程, 跟踪玩家目标的完成情况, "
              "并在目标完成后将玩家从游戏世界的某个区域带到下一个区域. "
              "一些设计师将其称为游戏的" (Q "主干 (spine)") ".")))
   (P "这些主要系统之中, 运行时对象模型可能是最为复杂的. "
      "它一般会提供绝大多数以下列出的特性:"
      (Ul (Li ""
              )
          )
      )
   (H3. "运行时对象模型架构")
   (H3. "世界chunk的数据格式")
   (H3. "")
   (H3. "对象引用和世界查询")
   (H3. "实时更新游戏对象")
   (H3. "应用并发于游戏对象更新")
   (H3. "事件和消息传递")
   (H3. "脚本")
   (P "脚本语言可以被定义为一种编程语言, "
      "其主要目的是让用户能够控制和自定义软件应用的行为. "
      "例如, VBA语言可用于自定义微软Excel的行为; "
      "MEL语言和Python语言都可以用于自定义Maya的行为. "
      "在游戏引擎的上下文之中, "
      "脚本语言是一种高级的, 相对易于使用的编程语言, "
      "它能为用户提供方便的通道来使用引擎中大多数常用的功能. "
      "因此, 程序员和非程序员都可以使用脚本语言来开发新游戏或者"
      "对于现有游戏进行定制 (也称" (Q "mod") ").")
   (H4. "运行时和数据定义的对比")
   (P "这里我们需要注意一个重要的区别. "
      "游戏脚本语言通常有两种形式:"
      (Ul (Li (B "数据定义语言 (data-definition languages). ")
              "数据定义语言的主要目的是允许用户创建和填充数据结构, "
              "随后这些结构会被引擎使用. 这类语言通常是声明性的, "
              "并且要么离线地被执行或者parse, "
              "要么在数据加载进内存时进行运行时执行或者parse.")
          (Li (B "运行时脚本语言 (runtime scripting language). ")
              "运行时脚本语言旨在于引擎运行时在引擎的上下文中执行. "
              "这些语言通常用于扩展或自定义引擎游戏对象模型"
              "和/或其他引擎系统的硬编码功能."))
      "本节中, 我们将主要关注使用运行时脚本语言, "
      "以通过扩展和自定义游戏的物体模型来实现游戏功能.")
   (H4. "编程语言的特征 (characteristics)")
   
   (H5. "游戏脚本语言的典型特征")
   
   (H4. "一些常见的游戏脚本语言")
   (H5. "QuakeC")
   (H5. "UnrealScript")
   (H5. "Lua")
   (H5. "Python")
   (H5. "Pawn/Small/Small-C")
   (H4. "为了脚本的架构(设计)")
   (P "脚本代码可以在游戏引擎之中扮演着各种各样的角色. "
      "存在各种可能的架构, "
      "从为对象或引擎系统执行简单功能的微小脚本代码片段, "
      "到管理游戏操作的高级脚本. 以下只是其中一些可能性:"
      (Ul (Li (B "脚本化回调. ")
              
              )
          (Li (B "脚本化事件处理器. ")
              
              )
          (Li (B "以脚本扩展游戏对象类型, 或者定义新的类型. ")
              
              )
          (Li (B "脚本化组件或者性质. ")
              
              )
          (Li (B "脚本驱动引擎. ")
              
              )
          (Li (B "脚本驱动游戏. ")
              
              )
          )
      )
   (H4. "运行时游戏脚本语言的特性")
   (P "许多游戏脚本语言的主要目的是实现gameplay特性, "
      "而这往往是通过增强或者定制游戏的对象模型完成的. "
      "本小节之中, 我们将探索这样的脚本系统的"
      "一些最常见的要求和特性.")
   (H5. "与原生编程语言相连的接口")
   (P "为了使得脚本语言有用, 其必不可能在真空之中进行操作. "
      
      )
   (H5. "案例研究: Naughty Dog的DC语言" #:auto? #f)
   (P "作为一个例子, 让我们简要看看Naughty Dog的运行时脚本语言 "
      "(其被称为DC) 是如何集成进引擎之中的.")
   (P "DC是Scheme语言的一个变种, 而Scheme本身是Lisp语言的一个变种. "
      "DC之中的可执行代码块被称为" (Em "脚本lambda(script lambda)")
      ", 其基本上等价于Lisp语言族里的函数或者代码块. "
      "DC程序员编写脚本lambda, 然后通过赋予它们全局唯一的名字来识别它们. "
      "DC编译器将这些脚本lambda转换为字节码块, "
      "在游戏运行时其被加载进内存里, "
      "并且可以通过C++里的一个简单函数接口根据名字进行查找.")
   (P "一旦引擎获得了脚本lambda字节码块的指针, "
      "那么其就可以通过调用引擎之中的" (Q "虚拟机器执行")
      "函数并将字节码指针传给该函数来执行代码. "
      
      )
   (P "这个虚拟机器包含一集寄存器, "
      "其可以存放任何种类的脚本想要处理的数据. "
      "这是通过" (Em "variant")
      "数据类型实现的, a union of all the data types. "
      "{译注: untyped is unityped.} "
      "一些指令会导致数据被加载进一个寄存器之中, "
      "其他一些指令会导致寄存器之中的数据被查找和使用. "
      
      )
   (P "这个虚拟机器也支持一个" (Em "函数调用栈")
      ". DC之中的脚本lambda可以调用其他的脚本lambda "
      "(即函数), 其由脚本程序员通过DC的"
      (Code "(defun ...)") "句法定义. "
      "和其他的过程性编程语言一样, "
      "栈是必要的, 用以追踪寄存器的状态和当一个函数调用另一个函数时的返回地址. "
      "在DC虚拟机器之中, "
      )
   
   (H5. "游戏对象引用")
   (P "脚本函数经常需要和游戏对象进行交互, "
      "而游戏对象本身可能部分或者完全是由引擎的原生语言实现的. "
      "原生语言用于引用对象的机制 (例如C++中的指针或者引用) "
      "在脚本语言之中不一定是合法的. "
      "(例如, 其可能压根不支持指针.) "
      "因此, 我们需要想出一些让脚本代码引用游戏对象的可靠方式.")
   (P "存在许多可行的方式. 一种方法是通过opaque的数值"
      (Em "handle") "来在脚本中引用对象. "
      "脚本可以通过各种各样的方式来获取对象的handle. "
      "例如, handle可能是由引擎传递给脚本的, "
      
      )
   (H5. "在脚本之中接收和处理事件")
   
   (H3. "高层次游戏流")
   ))