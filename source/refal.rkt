#lang racket
(provide refal.html)
(require SMathML)
(define refal.html
  (TnTmPrelude
   #:title "REFAL-5编程指南和参考手册"
   #:css "styles.css"
   (H1. "REFAL-5编程指南和参考手册")
   (H2. "基本的REFAL")
   (H3. "一个简单的函数定义")
   (P "考虑这个非常简单的问题. "
      "你想要定义一个函数来判定一个给定字符串是否是一个回文. "
      "一个回文是一个自左向右读和自右向左读相同的字符串. "
      "存在两种显然的方式可以使得这个定义更加精确. "
      "第一种方式是定义一个反转字符串的过程, "
      "然后将反转的字符串和初始的字符串进行比较. "
      "显然, 以这种定义为基础的算法不会是最高效的. "
      "如果一个字符串以一个不同于开头字符的字符作结, "
      "那么它肯定不是回文, 而这种定义无需反转即可建立. "
      "因此, 我们将采取这另外的定义, "
      "其可以写成通常的数学形式:"
      (Ol (Li "一个空字符串是一个回文.")
          (Li "单个符号构成的字符串是一个回文.")
          (Li "如果一个字符串以相同的符号开头和作结, "
              "那么其是回文当且仅当去除首尾符号"
              "之后剩下来的字符串是一个回文.")
          (Li "如果以上规则均无法应用, "
              "那么该字符串不是回文.")))
   (P "让我们称想要定义的函数为" (Code "Pal")
      ", 并且当参数是回文时取" (Code "True")
      "值, 否则的话则取" (Code "False")
      ". Refal中的定义紧贴数学定义:"
      (CodeB "Pal { = True;
      s.1 = True;
      s.1 e.2 s.1 = &lt;Pal e.2>;
      e.1 = False;  }"))
   (P "这个程序以函数名开始, 后面跟着由括号括起的"
      (Em "块") ". 一个块是一列由分号隔开的句子. "
      "在我们的这种情况下块有着四个句子, "
      "分别对应于以上由文字描述的数学定义的每个分句. "
      "每个句子都是一个替换规则. 其左边代表函数的参数的模式; "
      "而由相等符号" (Code "=") "隔开的右边, "
      "则是对于函数调用的替换.")
   (P "第一个句子里, 函数" (Code "Pal")
      "的参数为空(字符串), 因而值必然为" (Code "True") ".")
   (P "第二个句子里, 参数以一个符号的自由变量" (Code "s.1")
      "的形式给出. 其匹配任意的符号, 例如一个字符, 但只是一个符号. "
      "因此, 这个句子应该读作: 如果参数是一个单独的符号, "
      "那么将调用替换为" (Code "True") ".")
   (P "第三个句子代表的情形是参数以某个符号" (Code "s.1")
      "开头和作结, 并且表达式" (Code "e.2")
      "夹在中间. 表达式是Refal中最一般的数据结构; "
      "具体地说, 它可以是一个符号的串. "
      "这个句子的右边是以" (Code "e.2")
      "为参数的对于函数" (Code "Pal")
      "的调用. 我们使用圆括号来创建数据结构, "
      "但是尖括号用来表示函数调用. "
      (Code "&lt;Pal e.2>") "在数学上的类似记号为"
      (app 'pal $e_2) ".")
   (P "最后一个句子的参数是一个任意的表达式 (字符串). "
      "Refal中的函数定义里的每个句子"
      "只会在前述句子均不可应用时才会使用, "
      "因此最后一个句子应该读作: "
      "如果以上均不可行, 那么不论什么参数, "
      "这个函数调用的值应该是"
      (Code "False") ".")
   (P "Refal程序的算法意义的精确定义是通过定义执行"
      "Refal程序 (即对于定义在Refal里的函数求值) "
      "的抽象Refal机器完成的 (见"
      (Ref "abstract-refal-machine")
      "). Refal机器按步骤运行, 每一步都是应用一个句子. "
      "例如, 如果利用Refal机器以参数" (Code "'revolver'")
      "调用" (Code "Pal") ", 即对于"
      (Code "&lt;Pal 'revolver'>")
      "求值, 那么Refal的工作空间 (我们称之为view field) "
      "将会经历以下阶段:"
      (CodeB "&lt;Pal 'revolver'>
 &lt;Pal 'evolve'>
  &lt;Pal 'volv'>
   &lt;Pal 'ol'>
     False")
      "这给出了计算过程的详细图景. "
      "程序员可以使用跟踪器来控制这个过程. "
      "最简单的使用方法是, 正如我们以上所做的, "
      "程序员可以检视并输出过程的所有相继阶段.")
   (H3. "符号和表达式")
   (P "现在我们开始系统地定义Refal. "
      "对于语言句法的总结也作为参考手册的B部分附于末尾.")
   (P "Refal中的" (Em "符号") "是数据结构的最小句法元素. "
      "我们使用以下种类的符号:"
      (Ul (Li "字符;")
          (Li (Em "复合符号") ", 一个具体的例子是"
              (Em "标识符") " (也被称为符号名字);")
          (Li "非负整数 (macrodigits).")))
   (P "字符以单引号围住, 例如" (Code "'a'") "和"
      (Code "'+'") ". 一串字符被引号围成一个整体. "
      "因此, " (Code "'a+b'") "是由三个符号构成的一个序列: "
      (Code "'a'") ", " (Code "'+'") "和"
      (Code "'b'") ". 一个串可能仅包含零个字符, 即"
      (Code "''") ". 这是一个空表达式, 代表什么都没有, "
      "但它当然不是一个符号.")
   
   (H3. "模式匹配")
   (H3. "句子和程序")
   (H3. "抽象Refal机器" #:id "abstract-refal-machine")
   (H3. "更多函数的例子")
   (H2. "计算机中的REFAL")
   (H3. "如何运行程序")
   (H3. "程序模块")
   (H3. "输入输出")
   (H3. "Refal表达式的表示")
   (H3. "模式匹配的算法")
   (H2. "基本的编程技巧")
   (H3. "括号作为指针")
   (H3. "函数的格式")
   (H3. "隐式和显式递归")
   (H3. "变量的重复")
   (H3. "将算法分解为函数")
   (H3. "递归和迭代")
   (H3. "处理嵌套括号")
   (H2. "扩展的REFAL")
   (H3. "条件")
   (H3. "块")
   (H3. "埋藏-挖掘函数")
   (H2. "程序建立")
   (H3. "传教士和食人者")
   (H3. "排序算法")
   (H3. "图中的路径")
   (H3. "算术表达式的转换")
   (H2. "元系统转换")
   (H3. "元函数" (Code "Mu"))
   (H3. "元代码")
   (H3. "求值器")
   (H3. "冻结器")
   (H2 "练习解答")
   (H2 "参考手册")
   (H3 "A. 安装和使用")
   (H3 "B. 句法总结")
   (H3 "C. 内置函数")
   (H3 "D. Refal跟踪器")
   ))