#lang racket
(provide cml.html)
(require SMathML)
(define cml.html
  (TnTmPrelude
   #:title "ML中的并发编程"
   #:css "styles.css"
   (H1. "ML中的并发编程")
   (H2. "引论")
   (P "并行编程是编写包含多个独立thread of control (称为进程) 的程序的任务. "
      "{译注: 原文的thread和process (进程), "
      "在意义上并不等价于今日技术上的线程和进程, 而是抽象概念.} "
      "从概念上来说, 我们将这些进程视为并行 (in parallel) 执行的, "
      "但是在实践中其执行或许会在某个单一的处理器上交织. "
      "{译注: 其实这里的in parallel的意思和今日也不尽相同, "
      "那时这个术语还没有那么强的技术性意味, 大概的意思是同时.} "
      "出于这种原因, 我们将编程语言中的并发性和硬件中的并行性区分开来. "
      "{译注: 也就是说, 并发并不意味着在物理上计算机器中的操作一定会"
      "在某个时间点同时进行.} "
      "我们称某个程序中的操作是" (Em "并发的")
      ", 如果它们可以并行执行; 而我们称硬件中的操作是"
      (Em "并行的") ", 如果它们在时间上存在重叠.")
   (P "操作系统需要有用的计算和相对缓慢的输入输出 (I/O) 操作并行进行, "
      "其提供了最早的并发的例子之一. 例如, 在某个程序" $P
      "的执行期间, 它或许要调用操作系统给某个打印机写入一行文本. "
      "鉴于这个操作花费了相对较长的时间, 操作系统会先启动这个操作, "
      "然后挂起 (suspend) " $P ", 接着开始运行另外一个程序"
      $Q ". 最终, 输出操作完成而操作系统接收到了一个"
      (Em "中断(interrupt)") ", 在这个点操作系统可以恢复执行"
      $P ". 除了引入并行性和隐藏延迟 (如在慢速I/O设备的情形那样), "
      "操作系统中还存在着其他重要的对于并发的运用. "
      "使用来自于硬件定时器的中断, "
      "操作系统可以在一集用户程序之间复用处理器, 这被称为"
      (Em "分时(time-sharing)")
      ". 大多数分时操作系统"
      )
   (H3. "作为结构化工具的并发")
   (H3. "高层次语言")
   (H3. "并发ML")
   (H2. "并发编程中的概念")
   (H3. "进程")
   (H3. "干涉")
   (H3. "并发编程中的正确性问题")
   (H3. "内存共享语言")
   (H3. "消息传递语言")
   (H2. "并发ML介绍")
   (H3. "顺序编程")
   (H3. "基本的并发原语")
   (H3. "第一级同步操作")
   (H3. "总结")
   (H2. "CML编程技巧")
   (H3. "进程网络")
   (H3. "客户端-服务器编程")
   (H2. "同步和通信机制")
   
   ))