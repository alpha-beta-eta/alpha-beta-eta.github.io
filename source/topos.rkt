#lang racket
(provide topos.html)
(require SMathML)
(define Σ $Sigma:normal)
(define $op (Mi "op"))
(define (&op C)
  (^ C $op))
(define Σ^op (&op Σ))
(define-syntax-rule (define-simple* (&id $id str) ...)
  (begin
    (define $id (Mi str))
    ...
    (define (&id x) (app $id x))
    ...))
(define-simple*
  (&dom $dom "dom")
  (&cod $cod "cod"))
(define (map* proc . x*)
  (map proc x*))
(define (!0 f) (curry app f))
(define (!1 f) (curry apply f))
#;
(define (!commute f g x)
  (&= (f (g x)) (g (f x))))
(define (!commute f g . x*)
  (&= (f (apply g x*))
      ((!1 g) (map f x*))))
(define $0^ (&prime $0))
(define ((answer #:n [n ""]) . x*)
  (keyword-apply
   Div '(#:attr*) '(((class "answer")))
   (B (format "解答~a." n)) " " x*))
(define ((tcomment #:n [n ""]) . x*)
  (keyword-apply
   Div '(#:attr*) '(((class "tcomment")))
   (B (format "译者注记~a." n)) " " x*))
(define (Arrow f a b)
  (&: f (&-> a b)))
(define (Parallel f g a b)
  (&: (&cm f g) (&rrarr a b)))
(define (map-toggle flag proc lst)
  (cond ((null? lst) '())
        (flag (cons (proc (car lst))
                    (map-toggle (not flag) proc (cdr lst))))
        (else (cons (car lst)
                    (map-toggle (not flag) proc (cdr lst))))))
(define (ARROW . arg*)
  (apply : (map-toggle
            #f (curry ^^ $->) arg*)))
(define $Id
  (Mi "1" #:attr* '((mathvariant "sans-serif"))))
(define (Id a)
  (_ $Id a))
(define (Mono f A B)
  (&: f (&>-> A B)))
(define (Epi f A B)
  (&: f (&->> A B)))
(define (Iso f A B)
  (&: f (&cong A B)))
(define (Functor F C D)
  (&: F (&-> C D)))
(define (Comma C a)
  (&darr C a))
(define (Coproduct f g)
  (li0 f g))
(define (Inclusion i A B)
  (&: i (&->hk A B)))
(define CatC $C:script)
(define CatC^op (&op CatC))
(define CatD $D:script)
(define (Cat str)
  (Mi str #:attr* '((mathvariant "bold"))))
(define-syntax-rule (define-Cat* (id str) ...)
  (begin
    (define id (Cat str))
    ...))
(define-Cat*
  (CatSet "Set")
  (CatMon "Mon")
  (CatGrp "Grp")
  (CatN "N")
  (CatMet "Met")
  (CatTop "Top")
  (CatVect "Vect")
  (CatFinset "Finset")
  (CatNonset "Nonset")
  (CatMan "Man")
  (CatTopGrp "TopGrp")
  (CatPos "Pos")
  (Cat1 "1")
  (Cat2 "2")
  (Cat3 "3")
  (CatFinord "Finord"))
(define CatSet^op (&op CatSet))
(define todo.svg
  (Svg
   #:attr* '((width "320")
             (height "160")
             (stroke "black")
             (style "display: block; margin: auto;"))
   (Path #:attr* '((x "0")
                   (y "0")
                   (d "M 0 0 h 320 v 160 h -320 z")
                   (fill "none")))
   (Text #:attr* '((x "130") (y "80")) "欠一张图")))
(define -- "&mdash;&mdash;")
(define $rrarr (Mo "&rrarr;"))
(define $varepsilon (Mi "&varepsilon;"))
(define (setI x . P*)
  (cur0 (&: x (apply : P*))))
(define $darr (Mo "&darr;"))
(define $cong (Mo "&cong;"))
(define $~ (Mo "&Tilde;"))
(define (&~ a) (: $~ a))
(define $sqsube (Mo "&sqsube;"))
(define $sqcup (Mo "&sqcup;"))
(define $->hk (Mo "&rarrhk;"))
(define-infix*
  (&->hk $->hk)
  (&sqcup $sqcup)
  (&sqsube $sqsube)
  (&disj $disj)
  (&cong $cong)
  (&darr $darr)
  (&rrarr $rrarr))
(define-@lized-op*
  (@op &op)
  (@compose &compose))
(define topos.html
  (TnTmPrelude
   #:title "Topos: 逻辑的范畴分析"
   #:css "styles.css"
   (H1. "Topos: 逻辑的范畴分析")
   (H2. "数学 = 集合论?")
   (Blockquote
    "无人能够将我们从Cantor创造的天堂中驱离."
    (Br) -- "David Hilbert")
   (H3. "集合论")
   (P "以" (Em "集合论") "为人所知的领域所坐落于的基本概念是"
      (Em "集合成员资格(set membership)")
      ". 一个集合最初可以想成是一个对象的合集, "
      "这些对象被称为该合集的" (Em "元素") ". " (Em "成员资格")
      "为一个对象由于是某个集合的元素而与该集合之间存在的一种关系. "
      "这个关系的符号化是希腊字母" $varepsilon
      " (epsilon). {译注: 虽然集合论最初会使用" $varepsilon
      "这个符号, 但是如今已标准化为了" $in
      ", 我们之后也将使用" $in ".} " (Q (∈ $x $A))
      "的含义是" $A "为一个对象合集, 而其中之一的对象为"
      $x ", 即" $x "是" $A "的一个" (Em "成员")
      " (元素). 当" $x "不是" $A "的一个元素时, 这记作"
      (&!in $x $A) ". 如果" (∈ $x $A) ", 我们也称"
      $x (Em "属于") $A ".")
   (P "根据这些基础想法, 我们可以构建一个定义和构造的名录, "
      "其允许我们刻画特定集合以及由给定的集合构造新的集合. "
      "以下是两种会用到的技术.")
   (P "(a) " (Em "表格形式: ")
      "这种方法在于通过显式陈述其所有的元素来描述一个集合. "
      "给出的是这些元素的列表, 以括号封闭. 因而"
      (MB (setE $0 $1 $2 $3))
      "代表这样的合集, 其元素是到" $3 "为止的所有完全数.")
   (P "(b) " (Em "集合构建器形式: ")
      "这是一种远为强大的设备, "
      "其通过陈述一个由集合的所有元素拥有"
      "而其他的对象并不具备的性质来刻画某个集合. "
      "因此, 性质" (Q "是一个小于四的完全数")
      "确定了其上以表格形式所给出的集合. "
      "使用性质来定义集合升华为了以下的")
   (P (Em "概括原理. ")
      "如果" (app $phi $x) "是一个与对象 (复数) " $x
      "有关的性质或者条件, 那么存在一个集合, "
      "其元素恰是具有性质 (或者满足条件) " (app $phi $x)
      "的对象.")
   (P "对应于性质" (app $phi $x) "的集合记作"
      (MB (setI $x (app $phi $x)))
      "这个表达式读作"
      (Q "由所有" $phi "之于" $x "为真的那些对象" $x "构成的集合")
      ".")
   ((example #:n "1")
    "如果" (app $phi $x) "是条件"
    (Q (∈ $x $A) "且" (∈ $x $B))
    ", 那么我们就得到了集合"
    (MB (setI $x (∈ $x $A) "且" (∈ $x $B)))
    "其由所有既属于" $A "又属于" $B
    "的对象构成, 即" $A "和" $B
    "所共有的对象之集合. 这被称为集合" $A "和" $B
    "的" (Em "交") ", 简记作" (&cap $A $B) ".")
   ((example #:n "2")
    "根据概括原理, 条件" (Q (∈ $x $A) "或" (∈ $x $B))
    "所产生的集合"
    (MB (setI $x (∈ $x $A) "或" (∈ $x $B)))
    "由所有" $A "的元素连带着所有" $B "的元素构成, "
    "而别无其他. 其被称为" $A "和" $B "之"
    (Em "并") ", 记作" (&union $A $B) ".")
   ((example #:n "3")
    "条件" (Q (&!in $x $A)) "确定了" (&- $A)
    ", 即" $A "的" (Em "补") ", 因而"
    (MB (&= (&- $A) (setI $x (&!in $x $A))))
    "这个集合的成员恰是那些不属于" $A "的对象.")
   (P "这些例子都是从已有的集合产生新的集合. "
      "我们也可以使用条件直接定义集合而不诉诸于任何特定的集合. "
      "因而通过" (Q (&!= $x $x)) "我们得到了集合"
      (MB (&= $empty (setI $x (&!= $x $x))))
      "其由所有那些" $x "不等于" $x "的对象" $x
      "构成. 既然没有对象与自身相异, "
      "所以没有可以满足性质" (&!= $x $x)
      "的对象, 即" $empty "没有成员. "
      "出于这个原因" $empty "被称为"
      (Em "空") "集. 注意到我们已经"
      (Q "拓宽了我们的本体论")
      ", 从集合作为有着一些成员的原始概念过渡到了"
      "承认压根没有任何成员的集合. "
      "空合集的概念往往最初是难以接受的. "
      "人们最初总是倾向于将集合想成是由组成部分 "
      "(或者元素) 以相当具体的方式建造而成的对象. "
      $empty "的引入迫使我们将集合考虑为抽象的"
      (Q "自成存在") ". 我们可以将对于" $empty
      "的引用想成是自然语言的替代形式, 例如"
      (Q (&= (&cap $A $B) $empty)) "是"
      (Q $A "和" $B "没有共同元素")
      "的缩略方式. 经验和熟悉最终将会表明接纳"
      $empty "作为实际的对象可以增强并简化理论. 称"
      $empty "为" (Em "the")
      "空集是由只可能存在一个没有成员的集合"
      "这一事实所澄清的. "
      "这是由集合相等的定义所推出的, "
      "而集合相等的定义则体现在以下的")
   (P (Em "外延原理. ")
      "两个集合相等当且仅当它们拥有相同的元素.")
   (P "从这条原理可以推出如果两个集合要是相异的, "
      "那么必然存在一个对象, "
      "其是其中一个的成员而不是另一个的成员. "
      "既然空集没有元素, 那么它们就不能由此区分, "
      "因而外延原理推出了只存在一种空集.")
   (H4 "子集")
   (P "集合相等性的定义可以另外通过" (Em "子集")
      "的概念传达. 集合" $A "是集合" $B "的一个"
      (Em "子集") ", 记作" (&sube $A $B)
      ", 如果每个" $A "的成员也是" $B
      "的一个成员.")
   ((example #:n "1")
    "集合" (setE $0 $1 $2) "是"
    (setE $0 $1 $2 $3) "的一个子集, "
    (&sube (setE $0 $1 $2)
           (setE $0 $1 $2 $3)) ".")
   ((example #:n "2")
    "对于任意的集合" $A ", 我们有"
    (&sube $A $A) ", 因为" $A
    "的每个成员都是" $A "的一个成员.")
   ((example #:n "3")
    "对于任意的集合" $A ", " (&sube $empty $A)
    ", 因为如果" $empty "不是" $A "的一个子集, "
    "那么将会存在" $empty "的一个元素而其不属于"
    $A ". 然而, " $empty "压根就没有元素.")
   (P "使用这一最新概念我们可以看到, "
      "对于任意的集合" $A "和" $B
      ", 我们有"
      (MB (&= $A $B) "当且仅当"
          (&sube $A $B) "且"
          (&sube $B $A) ".")
      "如果" (&sube $A $B) "但是"
      (&!= $A $B) ", 我们可以记作"
      (&sub $A $B) " (" $A "是"
      $B "的一个" (Em "真") "子集).")
   (H4 "Russell悖论")
   (P "在陈述和使用概况原理的过程中我们并没有给出对于什么是"
      (Q "与对象 (复数) " $x "的条件")
      "的精确解释, 当然也没有给出对于字母" $x
      "所引用的是何种实体 (entity) 的精确解释. "
      "我们集合所意图的元素是诸如桌子, 人, 埃菲尔铁塔之类的物理对象, "
      "抑或是抽象的东西, 还是说其他集合本身呢? "
      "下面这个合集是什么东西?"
      (MB (&= $V (setI $x (&= $x $x))))
      "所有等于自身的东西都满足这个集合的定义条件. 那么, "
      $V "应该囊括世界万物 (包括自身) 吗? "
      "抑或是, 其应该被限制于特定的一类对象或者"
      "一个特定的论域 (universe of discourse) 吗?")
   (P "为了刻画这些问题的重要性, 我们考虑条件"
      (Q (&!in $x $x)) ". "
      )
   (H3. "数学基础")
   (H3. "作为集合论的数学")
   (H2. "什么是范畴")
   (Blockquote
    "...理解在于将一种类型的现实归约为另一种."
    (Br) -- "Claude Lévi-Strauss")
   (H3. "函数是集合?")
   (H3. "函数的复合")
   (H3. "范畴: 最初的一些例子")
   (MB (set-attr*
        (&Table
         ("范畴" "对象" "箭头")
         (CatSet "所有的集合" "所有的集合之间的函数")
         (CatFinset "所有的有限集合" "所有的有限集合之间的函数")
         (CatNonset "所有的非空集合" "所有的非空集合之间的函数")
         (CatTop "所有的拓扑空间" "所有的拓扑空间之间的连续函数")
         (CatVect "向量空间" "线性变换")
         (CatGrp "群" "群同态")
         (CatMon "幺半群" "幺半群同态")
         (CatMet "度量空间" "压缩映射")
         (CatMan "流形" "光滑映射")
         (CatTopGrp "拓扑群" "连续同态")
         (CatPos "偏序集" "单调函数"))
        'columnalign "left"))
   (H3. "抽象的病理学")
   (P "我们刚刚在识别范畴概念过程中所经历的, 正是纯数学的基本运作方式之一. "
      "这种方式被称为抽象. 它始于通过经验和对若干具体情形的考察而产生的认识: "
      "某些现象反复出现, 存在若干共同特征, 不同实体的行为之间存在形式上的类比. "
      "随后才是抽象的实际过程, 即将这些共同特征单独提取出来加以呈现, 形成对某个"
      (Q "抽象") "概念的公理化描述. 这正是我们如何通过考察一系列特定范畴, "
      "从而得到范畴的一般定义的方式. 数学所研究的一切抽象结构 "
      "(群, 向量空间, 拓扑空间等) 也都是通过同样的过程得到的.")
   (P "获得抽象概念之后, 我们便发展其一般理论, 并寻求它的更多实例. "
      "这些实例被称为该概念的例子, 或定义该概念的公理的模型. "
      "任何属于该概念一般理论的命题 (即可从公理推导出的命题) 在所有模型中都成立. "
      "寻找新模型的过程是一种特殊化, 是抽象的逆过程. "
      "理解上的进步, 既来自于认识到某个新的特定结构是某种更一般现象的一个实例, "
      "也来自于认识到若干不同结构具有共同的核心. 我们对数学现实的认识, "
      "正是通过这两个过程的交互作用而不断深化的, 即在特殊与一般之间来回移动. "
      "我们将会看到, 这一程序将会在topos理论的发展中得到很好的刻画.")
   (P "特殊化的一个重要方面涉及所谓的" (Em "表示")
      "定理. 这类定理断言, 某一抽象结构的公理的任何模型都必定是 "
      "(或者说等价于) 某一特定具体模型列表中的一个. 它们" (Q "度量")
      "了原初的启发性例子在多大程度上涵盖了该一般概念的所有可能模型. "
      "例如, 我们知道(根据Cayley定理)任何群都可以被视为某个集合的置换群, "
      "而任何布尔代数本质上都是某个集合的子集代数. 粗略地说, 抽象程度越强, "
      "即我们在抽象概念中加入的内容越多, 其可能的例子就越少. "
      "极端情形是只有唯一的模型, 其经典例子是公理化呈现的完备有序域的概念. "
      "事实上, 只存在唯一一个这样的域, 即实数域. "
      "{译注: 当然了, 这个唯一也是在同构意义下唯一.}")
   (P "范畴论的公理代表了一种非常弱的抽象. "
      "基于我们最初的列表而言, 并不存在与之相关的表示定理. "
      "我们一开始讨论的是" (Q "数学论述的一般宇宙 (复数)")
      ". 然而, 我们仅仅选取了我们最初例子的骨头, "
      "血肉存留是如此之少以至于这些公理容许各种各样与"
      CatSet ", " CatTop ", " CatVect
      "等大相径庭的" (Q "病态")
      "例子. 人们很容易发现许多压根就不能算是论述宇宙的例子, "
      "其对象并非集合, 其箭头和函数全然不同, 而运算" $compose
      "也和函数复合毫无关系. 以下的列表包含了诸多这种范畴的例子. "
      "读者压根仔细检视它们, 填充定义的细节, "
      "并且检查每种情况下结合性公理和恒元公理的确得到了满足.")
   (H3. "基本例子")
   ((example #:n "1")
    Cat1 ": 这个范畴只有一个对象和一个箭头. "
    "既已说过这句话, 我们发现其实其结构就已经完全确定下来了. "
    "设我们称这个对象为" $a "而这个箭头为" $f
    ", 那么我们必然只能置" (&= (&dom $f) (&cod $f) $a)
    ", 因为" $a "是唯一可用的对象. 既然" $f
    "是唯一的箭头, 那么我们必然只能取其为" $a
    "上的恒等箭头了, 即置" (&= (Id $a) $f)
    ". 唯一可以进行复合的箭头序对是" (tupa0 $f $f)
    ", 而我们只能置" (&= (&compose $f $f) $f)
    ". 这就满足了恒元律, 因为"
    (&= (&compose (Id $a) $f)
        (&compose $f (Id $a))
        (&compose $f $f)
        $f)
    ". 而结合律自然也是满足的, 因为"
    (&= (&compose $f (@compose $f $f))
        (&compose (@compose $f $f) $f)
        $f)
    ". 因此, 我们的确有了一个范畴, 图示为"
    todo.svg
    "我们并没有解释" $a "和" $f
    "是什么. 要义在于其可以是任何你喜欢的东西, 例如"
    $a "或许是一个集合而" $f "是其恒等函数. 但是, "
    $f "也可以是一个数字, 一对数字, 一个香蕉, "
    "埃菲尔铁塔, 或者Richard Nixon. "
    )
   (H2. "箭头而非epsilon")
   (Blockquote
    "思想的世界并不会一下子就向我们敞开. 我们必须持续不断地在我们的意识之中重新创造它."
    (Br) -- "René Thom")
   (P "本章我们将会检视诸多标准的集合论构造, 然后将其重新以箭头的语言表述. "
      "正如引论中所言, 一般的主题在于诉诸于成员资格的" (Q "内部")
      "结构的概念定义要通过诉诸于集合之间的联系从" (Q "外部")
      "进行刻画, 而这些联系是通过函数建立的. "
      "分析将会逐步引导我们抵达" (Em "泛性质") "和" (Em "极限")
      "的概念, 其涵盖了几乎所有范畴论中的构造.")
   (H3. "单态箭头")
   (P "一个集合函数" (func $f $A $B) "被称为是" (Em "单射的")
      ", 或者" (Em "一对一的")
      ", 如果不存在两个不同的输入能够给出相同的输出, "
      "即对于输入" (∈ $x $y $A) ", 有"
      (MB "如果" (&= (app $f $x) (app $f $y))
          ", 那么" (&= $x $y) ".")
      "现在让我们取一个单射" (func $f $A $B) "和两个" (Q "平行")
      "函数" (Parallel $g $h $C $A) "满足"
      todo.svg
      "交换, 即" (&= (&compose $f $g) (&compose $f $h)) ".")
   (P "然后对于" (∈ $x $C) ", 我们有"
      (&= (app (&compose $f $g) $x)
          (app (&compose $f $h) $x))
      ", 即"
      (&= (app $f (app $g $x))
          (app $f (app $h $x)))
      ". 但是, 既然" $f "是单射的, 这意味着"
      (&= (app $g $x) (app $h $x))
      ". 因此, " $g "和" $h
      "对于每个输入都会给出相同的输出, "
      "也就是说它们是相同的函数. "
      "我们表明了一个单射" $f "是"
      (Em "左可消去的") ", 即"
      (MB "每当" (&= (&compose $f $g) (&compose $f $h))
          ", 都有" (&= $g $h) ".")
      "从另一方向来说, 如果" $f "具有此左可消去性质, "
      "其必然是一个单射. 为了看出这点, 取" $A
      "中的" $x "和" $y "使得" (&= (app $f $x) (app $f $y)) "."
      todo.svg
      "指令" (Q (&= (app $g $0) $x)) "和"
      (Q (&= (app $h $0) $y)) "建立了一对从"
      (setE $0) " (即序数" $1 ") 到" $A
      "的函数" $g "和" $h ", 并且我们有"
      (&= (&compose $f $g) (&compose $f $h))
      ". 根据左消去性质, " (&= $g $h)
      ", 于是" (&= (app $g $0) (app $h $0))
      ", 即" (&= $x $y) ".")
   (P "因此, 我们看到" CatSet
      "中的单射箭头恰是左可消去的箭头. "
      "所有这些的要义在于后一种性质全然仅需诉诸于箭头而表述, "
      "这产生了以下的抽象定义:")
   (P "一个范畴" CatC "中的一个箭头" (Arrow $f $a $b)
      "在" CatC "中是" (Em "单态的(monic)") ", 如果对于任意的平行"
      CatC "-箭头" (Parallel $g $h $c $a)
      ", 等式" (&= (&compose $f $g) (&compose $f $h))
      "可以推出" (&= $g $h) ". 符号" (Mono $f $a $b)
      "用来指明" $f "是单态的. 这个名字来源于单射的代数同态 "
      "(代数同态即诸如" CatMon "和" CatGrp
      "这样的范畴中的箭头) 被称为"
      (Q "单态射 (monomorphism)") ".")
   ((tcomment)
    "如今术语monomorphsim专指本书的monic arrow了. "
    "当我使用" (Q "单态射") "的时候, 读者必须注意, "
    "我指的只是monic arrow而不是injective homomorphism. "
    "这两个概念并不等价, "
    "并不仅仅是因为某些范畴里的箭头并非函数. "
    "即便在箭头的确是函数的范畴里 "
    "(一般来说, 这种范畴的自然例子是具有结构的集合和保持结构的映射), "
    "monic arrow和injective homomorphism也未必相同.")
   ((example #:n "1")
    "在范畴" CatN " (第2章, 例子6) 中" (Em "每个")
    "箭头都是" (Em "单态的") ". 这里左可消去的含义是"
    (MB "如果" (&= (&+ $m $n) (&+ $m $p))
        ", 那么" (&= $n $p) ".")
    "这当然是一条关于数字加法的正确陈述.")
   ((example #:n "2")
    "在一个预序里, 每个箭头都是单态的: 对于一对"
    (Parallel $g $h $c $a)
    ", 我们必然有" (&= $g $h)
    ", 因为至多只有一个箭头" (&-> $c $a) ".")
   ((example #:n "3")
    "在" (&cm CatMon CatGrp CatMet CatTop)
    "里单态射即是那些作为集合函数是单射的箭头 "
    "(见例如Arbib和Manes [75]).")
   ((example #:n "4")
    "在一个逗号范畴" (Comma CatC $a)
    "中, 从" (tu0 $b $f) "到" (tu0 $c $g)
    "的一个箭头" $k
    todo.svg
    "在" (Comma CatC $a) "中是单态的当且仅当"
    $k "作为一个从" $b "到" $c
    "的箭头在" CatC "中是单态的.")
   ((exercise)
    "在任意的范畴里"
    (Ol (Li "如果" $f "和" $g "都是单态射, 那么"
            (&compose $g $f) "是单态射.")
        (Li "如果" (&compose $g $f)
            "是单态射, 那么" $f "是单态射.")))
   ((answer)
    (Ol (Li "对于箭头" $h_1 "和" $h_2 "满足"
            (MB (&= (&compose (@compose $g $f) $h_1)
                    (&compose (@compose $g $f) $h_2)))
            "根据范畴复合的结合律有"
            (MB (&= (&compose $g (@compose $f $h_1))
                    (&compose $g (@compose $f $h_2))))
            "根据" $g "是单态射, 我们将" $g
            "从左边消去就得到了"
            (MB (&= (&compose $f $h_1)
                    (&compose $f $h_2)))
            "根据" $f "是单态射, 我们将" $f
            "从左边消去就得到了"
            (MB (&= $h_1 $h_2))
            "故" (&compose $g $f)
            "可从左边消去, 即其为单态射.")
        (Li "对于箭头" $h_1 "和" $h_2 "满足"
            (MB (&= (&compose $f $h_1)
                    (&compose $f $h_2)))
            "我们有"
            (MB (&= (&compose $g (@compose $f $h_1))
                    (&compose $g (@compose $f $h_2))))
            "根据范畴复合的结合律有"
            (MB (&= (&compose (@compose $g $f) $h_1)
                    (&compose (@compose $g $f) $h_2)))
            "鉴于" (&compose $g $f)
            "是单态射, 可从左边消去以得到"
            (MB (&= $h_1 $h_2))
            "那么, " $f "的确也是可以从左边消去的, 即"
            $f "是单态射.")))
   (H3. "满态箭头")
   (P "一个集合函数" (func $f $A $B) "是" (Em "映上的")
      ", 或者说" (Em "满射的") ", 如果陪域" $B "是" $f
      "的值域, 即对于每个" (∈ $y $B) ", 存在某个"
      (∈ $x $A) "满足" (&= $y (app $f $x))
      ", 也就是" $B "的每个成员都是" $f
      "的一个输出. 这个概念的" (Q "仅箭头")
      "定义来源于将" (Q "单态")
      "的定义调转箭头方向, 形式化地说:")
   (P "一个范畴" CatC "中的一个箭头" (Arrow $f $a $b)
      "是" (Em "满态的(epic)") " (右可消去的), "
      "如果对于任意的一对" CatC "-箭头"
      (Parallel $g $h $b $c)
      ", 等式" (&= (&compose $g $f) (&compose $h $f))
      "可以推出" (&= $g $h) ", 即每当图表"
      todo.svg
      "交换, 就有" (&= $g $h) ". 记号" (Epi $f $a $b)
      "用于满态箭头.")
   (P "在" CatSet "之中, 满态箭头恰是满射函数 "
      "(留给读者作为联系, 或者参见Arbib和Manes, p. 2). "
      "满射的同态被称为" (Em "满态射(epimorphsim)") ".")
   ((tcomment)
    "和之前的译者注记一样, 我们的译文中所有的"
    (Q "满态射") "将会指的是epic arrow而非"
    "surjective homomorphism. "
    "如今的epimorphsim在文献中仅指epic arrow, "
    "并且epic arrow和surjective homomorphism并不等价.")
   (P "在范畴" CatN "中, 每个箭头都是满态射, 因为"
      (&= (&+ $n $m) (&+ $p $m)) "可以推出"
      (&= $n $p) ". 在任何预序里, 所有的箭头都是满态的.")
   (P "在我们原本所列的范畴列表里, 这些箭头都是函数, "
      "并且作为函数是满射的箭头总是满态射. "
      "相反的方向在" CatGrp "中为真, 但在" CatMon
      "中不是. 自然数到整数的嵌入是一个幺半群同态 (相对于"
      $+ "), 这显然并非满射, 然而其在" CatMon
      "中是右可消去的 (Arbib和Manes p. 57).")
   (H3. "同构箭头")
   (P "既是单射又是满射的函数被称为" (Em "双射的")
      ". 如果" (func $f $A $B) "是一个双射, 那么"
      $f "之下从" $A "到" $B "的路径可以被逆转或者说"
      (Q "反转") ". 我们可以将" $f "想成是对于" $A
      "的" (Q "重新贴标签") ". "
      )
   (H3. "同构对象")
   (P CatC "中的对象" $a "和" $b "是"
      (Em "同构的") ", 记作" (&cong $a $b)
      ", 如果存在一个" CatC "-箭头"
      (Arrow $f $a $b) ", 其在" CatC
      "中是一个同构, 即" (Iso $f $a $b) ".")
   (P "在" CatSet "中, " (&cong $A $B)
      "当且仅当" $A "和" $B "之间存在一个双射, "
      "在这种情况下其中每个集合都可以想成是另一个集合的"
      (Q "重新贴标签") "版本. 作为一个具体的例子, "
      "取一个集合" $A ", 然后置"
      (MB (&= $B (&c* $A (setE $0))
              (setI (tupa0 $x $0)
                    (∈ $x $A))) ".")
      
      )
   (H3. "始对象")
   (P "什么箭头性质可以突显" CatSet "中的空集" $empty
      "呢? 对于一个集合" $A ", 我们可以找到什么函数"
      (&-> $empty $A) "呢? 回忆一下, 我们将函数刻画为了三元组"
      (tupa0 $A $B $X) ", 其中" (&sube $X (&c* $A $B))
      " (第2.1节). 仔细检查这个定义的细节之后我们发现"
      (&= $f (tupa0 $empty $A $empty)) "是一个从"
      $empty "到" $A "的函数. " $f "的图为空, 而这"
      $f "被人称为" $A "的" (Em "空函数")
      ". 既然" (&c* $empty $A) "为空, 那么"
      $empty "是" (&c* $empty $A) "唯一的子集, 因而"
      $f "是从" $empty "到" $A "的唯一函数. "
      "这种观察带我们抵达了以下定义:")
   ((definition)
    "范畴" CatC "中的一个对象" $0 "是" (Em "始的(initial)")
    ", 如果对于每个" CatC "-对象" $a ", " CatC
    "中恰存在唯一的从" $0 "到" $a "的箭头.")
   (P "任意两个始" CatC "-对象在" CatC
      "中必然是同构的. 这是因为如果" $0 "和" $0^
      "是始对象, 那么存在唯一的箭头" (Arrow $f $0^ $0)
      "和" (Arrow $g $0 $0^) ". 但是, 如此就有"
      (Arrow (&compose $f $g) $0 $0)
      "必然为" (Id $0) ", 因为" (Id $0) "是" (Em "唯一")
      "的箭头" (&-> $0 $0) ", 鉴于" $0
      "是始对象. 类似地, 因为" $0^ "是始对象, "
      (Arrow (&compose $g $f) $0^ $0^)
      "是" (Id $0^) ". 因此, " $f
      "有一个逆" $g ", 而" (Iso $f $0^ $0) ".")
   
   (H3. "终对象")
   (H3. "对偶性")
   (P "我们已经观察到满态的概念是通过单态的概念" (Q "反转箭头")
      "得到的. 同样的手法也适用于终对象和始对象. 这是范畴论中的"
      (Em "对偶性") "概念的两个例子, 现在我们会将其描述得更为精确.")
   (P "如果" Σ "是以基本的范畴语言写成的一句陈述, 那么" Σ
      "的" (Em "对偶(dual)") Σ^op "是由将" Σ "中的"
      (Q $dom) "替换为" (Q $cod) ", " (Q $cod) "替换为"
      (Q $dom) ", " (Q (&= $h (&compose $g $f))) "替换为"
      (Q (&= $h (&compose $f $g))) "所得到的陈述. 因此, 由"
      Σ "所提及的所有箭头和复合都在" Σ^op "中得到了反转. 由"
      Σ^op "所描述的概念或者构造被称为是" (Em "对偶")
      "于由" Σ "所描述的概念或者构造. 因此, "
      "满态箭头的概念对偶于单态箭头, " (Q "始对象")
      "的对偶是" (Q "终对象") ", 诸如此类.")
   (P "根据一个给定的范畴" CatC "我们可以按照以下方式构造其"
      (Em "对偶") "或者说" (Em "相反") "范畴" CatC^op ":")
   (P CatC "和" CatC^op "拥有相同的对象. 对于每个"
      CatC "-箭头" (Arrow $f $a $b) ", 我们引入一个"
      CatC^op "中的箭头" (Arrow (&op $f) $b $a)
      ", 这些就是" CatC^op "中全部的箭头了. 恰当"
      (&compose $g $f) "在" CatC "中有定义时, "
      (&compose (&op $f) (&op $g)) "在" CatC^op
      "中有定义, 并且"
      todo.svg
      (&= (&compose (&op $f) (&op $g))
          (&op (@compose $g $f)))
      ". 注意到" (&= (&dom (&op $f)) (&cod $f))
      ", 而" (&= (&cod (&op $f)) (&dom $f)) ".")
   ((example #:n "1")
    "如果" CatC "是一个离散范畴, 那么" (&= (&op CatC) CatC) ".")
   ((example #:n "2")
    "如果" CatC "是一个预序" (tu0 $P $R) ", 其中"
    (&sube $R (&c* $P $P)) ", 那么" CatC^op
    "是预序" (tu0 $P (inv $R)) ", 其中"
    (: $p (inv $R) $q) "当且仅当" (: $q $R $p)
    ", 即" (inv $R) "是" $R "的逆关系.")
   ((example #:n "3")
    "对于任意的" CatC ", " (&= (&op (@op CatC)) CatC) ".")
   (P "由" Σ "所表达的构造的对偶可以解释为应用于相反范畴的原本构造. 如果"
      Σ "对于" CatC "而言为真, 那么" Σ^op "对于" CatC^op
      "为真. 因此, " CatSet "中的始对象" $empty "在"
      CatSet^op "中是终对象. 现在如果" Σ "是一个范畴论的定理, "
      "即可从范畴论的公理中推导出来, 那么" Σ
      "将会在所有的范畴中为真. 因此, " Σ^op
      "将会在所有具有形式" CatC^op "的范畴之中成立. "
      "但是, 任意的范畴" CatD "都具有这种形式 (置"
      (&= CatC (&op CatD)) "), 于是" Σ^op
      "在所有范畴之中都成立. 因此, 根据任何对于范畴论的真陈述"
      Σ "我们立即就可以得到另一个真陈述" Σ^op
      ", 此即所谓的" (Em "对偶原理") ".")
   (P "对偶原理将要证明的东西的数目削减了一半. "
      "例如, 首先我们注意到同构箭头的概念是自对偶的. "
      
      )
   (H3. "积")
   (P "现在我们开始考虑赋予两个集合" $A "和" $B "的积集合"
      (MB (&= (&c* $A $B)
              (setI (tupa0 $x $y)
                    (∈ $x $A) "且" (∈ $y $B))))
      "一个基于箭头的刻画. "
      "不了解范畴论的人或许很难相信"
      "这的确可以在不诉诸于有序对的情况下做到. "
      "但是实际上的确可以, 在同构的意义下, "
      "并且其完成的方式会将我们引向对于什么是范畴中的"
      (Q "构造") "的一般刻画.")
   (P "与" (&c* $A $B) "相关联的是两个特殊的映射, 即"
      (Em "投影(projection)")
      (MB (func $p_A (&c* $A $B) $A))
      "和"
      (MB (func $p_B (&c* $A $B) $B))
      "其由下列规则给出"
      (MB (&= (app $p_A (tupa0 $x $y)) $x))
      (MB (&= (app $p_B (tupa0 $x $y)) $y))
      "现在设"
      )
   (H3. "余积")
   (P (Q "积") "的对偶概念是对象的" (Em "余积") ", 或者说" (Em "和")
      ", 根据对偶原理我们可以将其直接定义如下.")
   ((definition)
    CatC "-对象" $a "和" $b "的一个" (Em "余积")
    "是一个" CatC "-对象" (&+ $a $b) "连带着一对"
    CatC "-箭头" (Arrow $i_a $a (&+ $a $b)) "和"
    (Arrow $i_b $b (&+ $a $b)) ", 其满足对于任意具有形式"
    (tu0 (Arrow $f $a $c) (Arrow $g $b $c))
    "的" CatC "-箭头序对, 恰存在一个箭头"
    (Arrow (Coproduct $f $g) (&+ $a $b) $c)
    "使得"
    todo.svg
    "交换, 即"
    (&= (&compose (Coproduct $f $g) $i_a) $f)
    "而"
    (&= (&compose (Coproduct $f $g) $i_b) $g)
    ".")
   (P (Coproduct $f $g) "被称为" $f "和" $g
      "相对于" (Em "嵌入(injection)") $i_a "和" $i_b
      "的" (Em "余积") "箭头.")
   (P "在" CatSet "之中, " $A "和" $B "的余积是其"
      (Em "无交并") (&+ $A $B)
      ". 这是两个看起来和" $A "和" $B
      "一样的集合的并, 即它们分别同构于" $A "和" $B
      ", 但是两个新的集合之间又是" (Em "无交的")
      ", 即没有共同元素. 我们置"
      (MB (&= $A^ (setI (tupa0 $a $0) (∈ $a $A))
              (&c* $A (setE $0))))
      "而"
      (MB (&= $B^ (setI (tupa0 $b $1) (∈ $b $B))
              (&c* $B (setE $1))))
      "(为什么" (&= (&cap $A^ $B^) $empty)
      "?) 然后定义"
      (MB (&= (&+ $A $B) (&union $A^ $B^)))
      "嵌入" (func $i_A $A (&+ $A $B)) "是由规则"
      (MB (&= (app $i_A $a) (tupa0 $a $0)))
      "给出的, 而" (func $i_B $B (&+ $A $B)) "则是"
      (MB (&= (app $i_B $b) (tupa0 $b $1)) "."))
   ((exercise #:n "1")
    "表明刚才定义的" (&cm (&+ $A $B) $i_A $i_B)
    "满足余积的定义. (首先你应该确定这种情况下函数"
    (Coproduct $f $g) "的规则.)")
   ((exercise #:n "2")
    "如果" (&= (&cap $A $B) $empty) ", 表明"
    (&cong (&union $A $B) (&+ $A $B)) ".")
   (P "在一个预序" (tu0 $P $sqsube)
      "里, " (&+ $p $q) "是由以下性质定义的:"
      (Ol #:attr* '((type "i"))
          (Li (&sqsube $p (&+ $p $q)) ", "
              (&sqsube $q (&+ $p $q))
              ", 即" (&+ $p $q) "是"
              $p "和" $q "的一个" (Q "上界") ";")
          (Li "如果" (&sqsube $p $c) "且"
              (&sqsube $q $c) ", 那么"
              (&sqsube (&+ $p $q) $c)
              ", 即" (&+ $p $q) (Q "小于")
              "任何其他的" $p "和" $q "的上界.")))
   (P "换言之, " (&+ $p $q) "是" $p "和" $q
      "的" (Em "最小上界") ". 在一个偏序集里, "
      "最小上界若是存在则唯一, 并且会记作"
      (&sqcup $p $q) ". 对于一个偏序集而言, "
      "若其任意两个元素都具有最小上界和最大下界 (第3.8节), "
      "那么其会被称为一个" (Em "格(lattice)") ".")
   (P "用范畴的语言来说, 一个格是一个骨架预序, "
      "其任意两个元素都有一个积和一个余积.")
   (P "两个分别具有" $m "和" $n "个元素的有限集合的无交并是一个具有("
      $m "加" $n ")个元素的集合. 的确在" CatFinord
      "里, " $m "和" $n "的余积是序数" (&+ $m $n)
      " (这里的" $+ "是相当字面意思的" (Q "加法")
      "). 相对于序数" (&= $1 (setE $0)) "和"
      (&= $2 (setE $0 $1)) ", 在骨架范畴" CatFinord
      "里下列陈述为真:"
      (MB (&= (&+ $1 $1) $2))
      "而在" CatFinset "或者" CatSet
      "之中, 更准确来说是"
      (MB (&cong (&+ $1 $1) $2))
      "(余积是在同构意义下定义的.)")
   (P "我们之后在第5.4节里将会看到存在范畴在某种合理的解释下, "
      "这上面最后一条陈述为假.")
   ((exercise #:n "3")
    
    )
   (H3. "等化子")
   (P "对于" CatSet "中的一对平行函数" (Parallel $f $g $A $B)
      ", 令" $E "是使得" $f "和" $g "相合的" $A "的子集, 即"
      (MB (&= $E (setI $x (∈ $x $A) "且"
                       (&= (app $f $x) (app $g $x)))))
      "那么嵌入函数" (Inclusion $i $E $A) "被称为"
      $f "和" $g "的" (Em "等化子(equaliser)")
      ". 之所以取这个名字, 是因为在其与" $i "的复合下我们发现"
      (&= (&compose $f $i) (&compose $g $i))
      ", 即两个函数被" $i (Q "等化 (equalised)")
      "了. 而且, " $i "是" $f "和" $g "的"
      (Q "标准 (canonical)") "等化子" --
      "如果" (func $h $C $A) "任意其他这样的"
      $f "和" $g "的等化子, 即"
      (&= (&compose $f $h) (&compose $g $h))
      todo.svg
      "那么" $h "可以通过" (Inclusion $i $E $A)
      "进行唯一" (Q "分解") ", 即存在唯一的函数"
      (func $k $C $E) "使得" (&= (&compose $i $k) $h)
      ". 换言之, 给定了" $h "之后, 只存在唯一的方式"
      "填充虚线箭头以使得上述图表交换. "
      )
   (H3. "极限和余极限")
   (P "对于两个对象之积和两个箭头的等化子而言, "
      "其定义有着相同的基本形式. 在每种情形下, "
      "待定的实体都以" (Q "标准")
      "的方式具有一个特定的性质, "
      "也就是说任何其他具有该性质的实体都能按照之前指出的方式"
      (Q "通过它进行分解") ". 在等化子的情形中, "
      "这个性质是能够" (Q "等化") "原本的两个箭头. "
      "在" $a "和" $b "的情形之中, 这个性质是作为以"
      $a "和" $b "为陪域的一对箭头的定义域. "
      "这种情况叫做" (Em "泛构造(universal construction)")
      ". 待定的实体在所有具有某个特定性质的东西里是"
      (Em "泛的(universal)") ".")
   (P "我们可以通过考虑图表以使得这个想法更加精确, "
      "但希望不会太过学究琐碎. "
      "当我们言称某个范畴" CatC "中的一个图表"
      $D "时, 我们指的不过是一个" CatC
      "-对象" (&cm $d_i $d_j $..h)
      "的合集连带着一些图表的特定对象之间的"
      CatC "-箭头" (Arrow $g $d_i $d_j)
      ". (一对对象之间可能存在多于一个箭头, "
      "也可能没有箭头.)")
   (P "图表" $D "中的一个" (Em "锥(cone)")
      "由一个" CatC "-对象" $c "和连带着对于每个"
      $D "中的对象" $d_i "的一个" CatC
      "-箭头" (Arrow $f_i $c $d_i)
      "构成, 其满足每当" $g
      "是图表里的一个箭头, 则有图表"
      todo.svg
      "交换. 我们使用符号"
      (setE (Arrow $f_i $c $d_i))
      "来表示" $D "的一个锥.")
   
   (H3. "余等化子")
   (H3. "拉回")
   (H3. "推出")
   (H3. "完备性")
   (H3. "指数")
   (H2. "介绍topos")
   (H3. "子对象")
   (H3. "对于子对象进行分类")
   (H3. "topos的定义")
   (H3. "最初的一些例子")
   (H2. "topos结构: 最初的几步")
   (H2. "古典逻辑 (logic classically conceived)")
   (Blockquote
    "简要解释什么是逻辑并不简单, 甚至可能并不有用."
    (Br) -- "E. J. Lemmon")
   (H3. "topos逻辑的动机")
   (P "在任何对于集合论的系统性建立过程之中, "
      "最初要被检视的主题之一即是所谓的"
      (Em "类的代数(algebra of classes)")
      ". "
      )
   (H2. "子对象代数")
   (Blockquote
    "既然新的范式是从旧的范式中诞生的, "
    "它们通常会融入诸多旧范式之前所采用的术语和机制, "
    "不论是概念性的还是操作性的. 不过, "
    "它们很少以传统的方式来运用这些借来的元素."
    (Br) -- "Thomas Kuhn")
   (H3. "补, 交, 并")
   (H2. "直觉主义及其逻辑")
   (Blockquote
    "让那些我之后的人思考为什么我建立这些心智构造"
    "以及它们如何可以在某种哲学中得到解释; "
    "我满足于建立它们, "
    "以着其在某种意义上将会有助于澄清人类思想的信念."
    (Br) -- "L. E. J. Brouwer")
   (H3. "构造主义哲学")
   (P "在Newton和Leibnitz于17世纪末发现微积分之后相当长的一段时间里, "
      "人们对其基本概念存在争议和分歧. "
      "无穷小量的概念以及无穷序列的极限仍笼罩在神秘之中, "
      "其中一些表述在今天看来也颇为奇异 (例如J. Bernoulli所说的"
      (Q "无穷小地增加或者减少的量既未增加也未减少")
      "). 这一学科在19世纪才获得了严格的基础, "
      "最初是通过Cauchy对极限与收敛概念给出精确定义来实现的. "
      "此后, Weierstrass等人推进了" (Q "分析的算术化")
      ", 给出了实数系统的纯代数处理. 其重要后果之一是, "
      "分析学开始与其物理直觉的根基相分离 "
      "(参见Weierstrass关于(反直觉的?)连续但处处不可微函数存在性的证明). "
      "这一点, 连同非欧几何的发展等其他因素, 共同促成了人们认识到: "
      "数学结构具有一种抽象的概念实在性, 完全独立于物理世界之外.")
   (P "同样重要的是这一时期Dedekind和Peano在数系方面的工作. "
      "实数由有理数构造而来, 有理数由整数构造而来, 整数则由自然数构造而来. "
      "而后, Peano公理对自然数本身的性质给出了抽象的刻画. "
      "这种归约方式推动了一种思想的发展, "
      "即整个数学可以被纳入一个宏大的公理体系之中, "
      "而该体系本身建立在少数几个基本概念和原理之上. "
      "这一构想此后始终是数学基础研究的核心. 它在Frege和Russell的"
      (Q "逻辑主义") "论题中达到了极端的形式" --
      "数学是逻辑的一部分, 数学真理可以从纯粹的逻辑原理中推导出来. "
      "这一构想也体现在Hilbert的工作中, 他试图将数学公理化, "
      "并用有穷方法证明这些公理的一致性.")
   (P "当Cantor登上历史舞台时, 人们已经认识到涉及无穷的表述, 例如"
      (Q "当" $n "趋于无穷时, 序列" $n^2 "也趋于无穷")
      ", 可以视为关于实数性质的精确但复杂的命题的形象化表述 ("
      (Q "对于所有的" $epsilon ", 存在一个" $delta "...")
      ", 诸如此类). Cantor的集合论超越了这一点, "
      "将实无穷作为数学研究的对象加以处理. "
      "无穷集合成为一种" (Q "自成存在") ", 可以作为某个其他集合的"
      (Em "元素") ". 数的概念通过建立" (Q "超限")
      "基数和序数的理论而从有穷延伸到了无穷, 其算术涉及对无穷集合的运算. "
      "Cantor的态度是: 只要命题在语法上正确, 演绎在逻辑上可靠 (sound), "
      "这样的命题就具有概念上的意义, "
      "即便它们超越了我们关于有穷数与有穷集合的基本直觉.")
   (P "集合论取得了巨大的成功, 但也并非没有批评者. Leopold Kronecker以"
      (Q "上帝创造了整数, 其余一切皆是人的工作")
      "这句名言而广为人知, 他拒绝承认无穷集合与无理数的概念, "
      "认为它们是神秘主义的, 而非数学的. 他坚持认为, "
      "一个理论在逻辑上的正确性并不意味着它所声称描述的那些实体的存在性. "
      "除非这些实体能够被实际地" (Em "构造") "出来, 否则它们就毫无意义. "
      "Kronecker说, 数及其运算必须具有" (Q "直觉的基础")
      ". 定义和证明必须在相当字面的意义上是" (Q "构造性的")
      ". 定义必须明确地展示如何利用已知存在的对象来构造所定义的对象. "
      "在古典数学中, " (Q "存在性证明")
      "往往通过证明某类实体不存在的假设会导致矛盾来进行. "
      "而从构造主义的立场来看, 这根本不是存在性证明, "
      "因为合法的存在性证明必须明确地展示出所讨论的那个具体对象. "
      "Kronecker相信自然数可以被给予这样一种基础, 但实数则不然. "
      "他实际上曾试图从这一立场出发重写数学的某些部分.")
   (P "将事物视为由已知实体" (Q "建造而成") "的这一观念, "
      "也体现在Henri Poincaré对集合论悖论的回应之中. "
      "他认为矛盾的根源在于使用了" (Em "非直谓(impredicative)")
      "定义. 这类定义是循环和自指的, 对于其描述一个对象" $X
      "所需要引用的集合, 这些集合自身的存在性都依赖于" $X
      "的存在性. Poincaré坚持认为此类定义是不可接受的, "
      "一个集合在其每个元素被刻画之前是无法被刻画的. "
      "因此, Russell悖论 (第1.1节) 一半的问题在于需要表明(是否)"
      (∈ $R $R) ". 以这种观点, 那么" $R "的定义是循环性的, "
      "因为其只能在" $R "已经被定义的情况下才能给出. "
      "这样一来Russell类" $R "甚至无法作为合法的研究对象出现. "
      "实际上将会消失的东西远不止于此, "
      "因为实数系统的古典分析的很大一部分都依赖于非直谓定义.")
   (P "构造主义态度在Kronecker和Poincaré的观点中均有所体现, "
      "而其最为激进的表达则见于直觉主义哲学" --
      "这一哲学由荷兰数学家L. E. J. Brouwer于本世纪初所开创. "
      "Brouwer拒绝非构造性论证, 也拒绝将无穷集合视为自成存在的观念. "
      "但他更进一步, 否认传统逻辑是数学推理的有效表示. "
      "我们已经指出, 所谓的" (Q "反证法")
      " (" $alpha "为真是因为否则会推出矛盾) "
      "在存在性证明中从构造主义角度来看是不可接受的. "
      "但是对于Brouwer而言, 其压根就不是一条可以接受的论证原理. "
      "他对于排中律" (&disj $alpha (&~ $alpha))
      "的态度也是一样的.")
   
   (H3. "Heyting的演算")
   (H3. "Heyting代数")
   (H3. "Kripke语义")
   (H2. "函子")
   (Blockquote
    "首先应该观察到整个范畴的概念本质上是辅助性的; "
    "我们的基本概念本质上是关于函子和自然变换的."
    (Br) -- "S. Eilenberg和S. MacLane")
   (H3. "函子的概念")
   (P "一个函子是一个从某个范畴到另一个范畴的变换, 其"
      (Q "保持") "它的源头的范畴结构. "
      "正如范畴论的创立者的引言所指出的, "
      "函子的概念恰恰是范畴论的本质. "
      "原初的视角已经发生了某种意义上的改变, "
      "因而至少在本书中函子并不比范畴本身更加重要. "
      "诚然如此, topos作为数学基础的可行性很大程度上"
      "建立在其可以不用诉诸于函子而" (Em "定义")
      ". 然而, 我们现在也已经到了无法忽略函子的阶段了. "
      "函子提供了描述topos和Kripke模型之间"
      "以及topos和集合论模型之间的关系的必要语言.")
   (P "从范畴" CatC "到范畴" CatD "的一个"
      (Em "函子") $F "是一个函数, 其赋"
      (Ol #:attr* '((type "i"))
          (Li "每个" CatC "-对象" $a "以一个" CatD
              "-对象" (app $F $a) ";")
          (Li "每个" CatC "-箭头" (Arrow $f $a $b)
              "以一个" CatD "-箭头"
              ((!1 Arrow) (map* (!0 $F) $f $a $b)) "."))
      "其满足"
      (Ol #:attr* '((type "a"))
          (Li "对于所有的" CatC "-对象" $a ", "
              (!commute (!0 $F) Id $a)
              ", 即函子赋" $a "上的恒等箭头以"
              (app $F $a) "上的恒等箭头;")
          (Li (!commute (!0 $F) &compose $g $f)
              ", 只要" (&compose $g $f) "有定义.")))
   (P "这最后一个条件所陈述的是两个箭头的复合的"
      $F "-像是其" $F "-像的复合, 即每当"
      todo.svg
      "在" CatC "中交换 (" (&= $h (&compose $g $f))
      "), 就有"
      todo.svg
      "在" CatD "中交换. 我们记" (Functor $F CatC CatD)
      "或者" (ARROW CatC $F CatD) "以指示" $F
      "是一个从" CatC "到" CatD "的函子. "
      "既已有了函子的定义, 简而言之, 函子就是" (Q "保持")
      $dom ", " $cod ", 恒等箭头, 以及复合的变换. "
      "{译注: 换言之, 就是函子与这些操作在某种意义上都是交换的, 例如"
      (!commute (!0 $F) &dom $f) "和"
      (!commute (!0 $F) &cod $f) ".}")
   ((example #:n "1")
    
    )
   ((example #:n "2")
    
    )
   ((example #:n "3")
    
    )
   ((example #:n "4")
    
    )
   
   (H3. "自然变换")
   (H3. "函子范畴")
   
   ))