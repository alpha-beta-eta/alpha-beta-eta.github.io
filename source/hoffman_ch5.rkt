#lang racket
(provide div:hoffman_ch5)
(require SMathML "linear_algebra_utils.rkt")
(define div:hoffman_ch5
  (TmDiv
   (H2 "第5章 行列式")
   (H3 "第5.1节 交换环")
   (P "本章我们将证明与方阵的行列式有关的基本事实. 我们不仅对于域上的矩阵这么做, "
      "矩阵的元素还可能是更一般类型的&quot;标量&quot;. 这种一般化有两个理由. "
      "首先, 在下一章, 我们将会发现不得不处理元素是多项式的矩阵的行列式. "
      "其次, 在我们呈现的对于行列式的处理中, 有一条公理是不发挥作用的, 也就是"
      "保证每个非零元素都拥有乘法逆元的那条公理. 出于这些原因, 建立含幺交换环上"
      "的矩阵的行列式理论是合适的.")
   ((definition)
    "一个环是一个集合" $K ", 带有两种运算" (&\|-> (tu0 $x $y) (&+ $x $y)) "和"
    (&\|-> (tu0 $x $y) (&i* $x $y)) "满足"
    (Ol #:attr* '((type "a"))
        (Li $K "在运算" (&\|-> (tu0 $x $y) (&+ $x $y)) "下是一个交换群;")
        (Li (&= (&i* (@ (&i* $x $y)) $z) (&i* $x (@ (&i* $y $z)))) ";")
        (Li (&= (&i* $x (@ (&+ $y $z))) (&+ (&i* $x $y) (&i* $x $z))) "; "
            (&= (&i* (@ (&+ $y $z)) $x) (&+ (&i* $y $x) (&i* $z $x))) "."))
    "如果" (commute* $x $y) "对于所有" $K "中的" $x "和" $y "成立, 那么我们称环" $K "是交换的. "
    "如果" $K "中存在一个元素" $1 "满足对于每个" $x "有" (&= (&i* $1 $x) (&i* $x $1) $x)
    ", 那么" $K "就被称为含幺环, 而" $1 "就被称为" $K "的幺元.")
   (P "这里我们感兴趣的是含幺交换环. 这样的环, 可以被简要地描述为一个集合" $K
      "带有两种运算, 满足第1章给出的域公理, 除了公理8和条件" (&!= $1 $0) ". "
      "因此, 域是含有非零幺元的交换环, 并且每个非零元都可逆. 整数集, 带有通常的运算, "
      "就是一个含幺交换环, 但不是域. 另一个含幺交换环的例子是域上的多项式.")
   (P "如果" $K "是一个含幺交换环, 我们定义" $K "上的" m*n
      "矩阵是一个从整数序对" (&cm (tu0 $i $j) (&<= $1 $i $m) (&<= $1 $j $n))
      "的集合到" $K "的函数. 像往常一样, 我们将这样的矩阵表示为" $m
      "行" $n "列的矩形阵列. " $K "上的矩阵的和与积定义恰如域上的矩阵"
      (MB (&= (mref (@+ $A $B) $i $j) (&+ Aij (mref $B $i $j))))
      (MB (&= (_ @AB (&cm $i $j))
              (sum $k $ (&i* (mref $A $i $k) (mref $B $k $j)))))
      "当" $A "和" $B "具有相同的行数和列数时, 和有定义. "
      "当" $A "的列数等于" $B "的行数时, 积有定义. "
      "这些运算的基本代数性质当然仍然成立, 例如"
      (MB (&cm (disR $A $B $C) (assoc* $A $B $C) "等等.")))
   (P "和域的情况一样, 我们将称" $K "的元素为标量. 接着, 我们可以像之前一样"
      "定义矩阵的行或列的线性组合. 粗略说来, 我们对于域上的矩阵所做的事情, 对于"
      $K "上的矩阵一样合法, 除了那些需要&quot;除法&quot;的结果.")
   (H3 "第5.2节 行列式函数")
   (P "令" $K "是一个含幺交换环. 我们希望为每个" $K "上的"
      n*n "矩阵赋一个被称为行列式的标量. 将行列式定义为基于"
      "矩阵元素的公式是可能的, 接着人们可以从这个公式里推导出行列式的性质. "
      "然而, 这样的公式是相当复杂的, 为了获得一些技术性优势, 我们将按以下方式处理. "
      "我们将" (^ $K n*n) "上的&quot;行列式函数&quot;定义为一种"
      "具有如下特别性质的函数. 它对于矩阵的每一行都是线性的; 若矩阵具有两个相等的行, "
      "那么其值为" $0 "; 对于恒等矩阵, 其值为" $1 ". "
      "我们将证明这样的函数存在, 并且唯一, 也就是恰有一个这样的函数. 随着我们证明唯一性, "
      "就得到了一个行列式的显式公式, 以及许多有用的性质.")
   (P "本节我们将致力于&quot;行列式函数&quot;的定义, 以及证明至少有一个这样的函数存在.")
   ((definition)
    "令" $K "是一个含幺交换环, 令" $n "是一个正整数, 令" $D
    "是一个函数, 其赋每个" $K "上的" n*n "矩阵" $A
    "以一个" $K "中标量" (app $D $A) ". 我们称" $D "是"
    $n "线性的, 如果对于每个" (&cm $i (&<= $1 $i $n)) ", "
    "在其他" (@- $n $1) "行固定的情况下, " $D "对于第" $i
    "行是一个线性函数.")
   (P "这个定义需要一些澄清. 如果" $D "是一个从" (^ $K n*n) "到"
      $K "的函数, 并且如果" alpha_1..n "是矩阵" $A "的行, 那么我们也记"
      (MB (&= (app $D $A) (appl $D $alpha_1 $..h $alpha_n)))
      "即是说, 我们也将" $D "想成是" $A "的行的函数. " $D "是" $n "线性的陈述意味着"
      (MB (&= (appl $D $alpha_1 $..h (&+ (&i* $c $alpha_i)
                                         (_^ $alpha $i $prime))
                    $..h $alpha_n)
              (&+ (&i* $c (appl $D $alpha_1 $..h $alpha_i $..h $alpha_n))
                  (appl $D $alpha_1 $..h (_^ $alpha $i $prime) $..h $alpha_n))))
      "如果我们固定除了第" $i "行之外的所有行并将" $D "视为第" $i "行的函数, 那么将"
      (app $D $A) "写成" (app $D $alpha_i) "是更方便的. 因此, 我们可以将上式"
      "简写成"
      (MB (&= (app $D (&+ (&i* $c $alpha_i)
                          (_^ $alpha $i $prime)))
              (&+ (&i* $c (app $D $alpha_i))
                  (app $D (_^ $alpha $i $prime)))))
      "只要意思足够清楚即可.")
   ((example #:n "1")
    "令" (&cm $k_1 $..h $k_n) "是正整数, 其中" (&<= $1 $k_i $n) ", 并令"
    $a "是" $K "的一个元素. 对于每个" $K "上的" n*n "矩阵" $A ", 定义"
    (MB (&= (app $D $A)
            (&i* $a (appl $A $1 $k_1) $..c (appl $A $n $k_n))))
    "那么函数" $D "就是" $n "线性的. 这是因为如果我们将" $D "视为第" $i "行的函数, "
    "而其他行固定, 我们可以将其写作"
    (MB (&= (app $D $alpha_i)
            (&i* (appl $A $i $k_i) $b)))
    "其中" $b "是一个" $K "的固定元素. 令"
    (&= (_^ $alpha $i $prime)
        (tu0 (_^ $A (&cm $i $1) $prime) $..h (_^ $A (&cm $i $n) $prime)))
    ", 那么我们有"
    (MB (deriv (app $D (&+ (&i* $c $alpha_i) (_^ $alpha $i $prime)))
               (&i* (bra0 (&+ (&i* $c (appl $A $i $k_i))
                              (appl $A^ $i $k_i)))
                    $b)
               (&+ (&i* $c (app $D $alpha_i))
                   (app $D (_^ $alpha $i $prime)))))
    "因此" $D "对于" $A "的每一行都是一个线性函数." (Br)
    "这种类型的" $n "线性函数的一个特别例子是"
    (MB (&= (app $D $A) (&i* (mref $A $1 $1)
                             (mref $A $2 $2)
                             $..c
                             (_ $A (&cm $n $n)))))
    "换言之, &quot;对角线元素之积&quot;是一个" (^ $K n*n)
    "上的" $n "线性函数.")
   ((example #:n "2")
    "让我们找出所有" $K "上的" 2*2 "矩阵上的" $2 "线性函数. "
    "令" $D "是这样一个函数. 如果我们用" (&cm $epsilon_1 $epsilon_2)
    "代表" 2*2 "的恒等矩阵的行, 那么我们有"
    (MB (&= (app $D $A)
            (appl $D
                  (&+ (&i* (mref $A $1 $1) $epsilon_1)
                      (&i* (mref $A $1 $2) $epsilon_2))
                  (&+ (&i* (mref $A $2 $1) $epsilon_1)
                      (&i* (mref $A $2 $2) $epsilon_2)))))
    "因为" $D "是" $2 "线性的, 我们有"
    (MB (deriv (app $D $A)
               (&+ (&i* (mref $A $1 $1)
                        (appl $D $epsilon_1
                              (&+ (&i* (mref $A $2 $1) $epsilon_1)
                                  (&i* (mref $A $2 $2) $epsilon_2))))
                   (&i* (mref $A $1 $2)
                        (appl $D $epsilon_2
                              (&+ (&i* (mref $A $2 $1) $epsilon_1)
                                  (&i* (mref $A $2 $2) $epsilon_2)))))
               (&+ (&i* (mref $A $1 $1)
                        (mref $A $2 $1)
                        (appl $D $epsilon_1 $epsilon_1))
                   (&i* (mref $A $1 $1)
                        (mref $A $2 $2)
                        (appl $D $epsilon_1 $epsilon_2))
                   (&i* (mref $A $1 $2)
                        (mref $A $2 $1)
                        (appl $D $epsilon_2 $epsilon_1))
                   (&i* (mref $A $1 $2)
                        (mref $A $2 $2)
                        (appl $D $epsilon_2 $epsilon_2)))))
    "因此, " $D "完全由四个标量"
    (MB (&cm (appl $D $epsilon_1 $epsilon_1)
             (appl $D $epsilon_1 $epsilon_2)
             (appl $D $epsilon_2 $epsilon_1)
             (appl $D $epsilon_2 $epsilon_2)))
    "决定. 读者应该很容易验证, 如果" (&cm $a $b $c $d) "是" $K "中四个标量, 定义"
    (MB (&= (app $D $A)
            (&+ (&i* (mref $A $1 $1)
                     (mref $A $2 $1)
                     $a)
                (&i* (mref $A $1 $1)
                     (mref $A $2 $2)
                     $b)
                (&i* (mref $A $1 $2)
                     (mref $A $2 $1)
                     $c)
                (&i* (mref $A $1 $2)
                     (mref $A $2 $2)
                     $d))))
    "那么" $D "是一个" $K "上的" 2*2 "矩阵上的" $2 "线性函数, 并且"
    (MB (&cm (&= (appl $D $epsilon_1 $epsilon_1) $a)
             (&= (appl $D $epsilon_1 $epsilon_2) $b)
             (&= (appl $D $epsilon_2 $epsilon_1) $c)
             (&= (appl $D $epsilon_2 $epsilon_2) $d))))
   ((lemma)
    $n "线性函数之线性组合亦是" $n "线性函数.")
   ((proof)
    "证明两个" $n "线性函数的线性组合是" $n "线性函数足矣. 令" $D "和" $E "是" $n
    "线性函数. 如果" $a "和" $b "属于" $K ", 那么" (&+ (&i* $a $D) (&i* $b $E))
    "当然由"
    (MB (&= (app (@ (&+ (&i* $a $D) (&i* $b $E))) $A)
            (&+ (&i* $a (app $D $A))
                (&i* $b (app $E $A)))))
    "定义. 因此, 如果我们固定除了第" $i "行之外的所有行"
    (MB (deriv (app (@ (&+ (&i* $a $D) (&i* $b $E)))
                    (&+ (&i* $c $alpha_i) (_^ $alpha $i $prime)))
               (&+ (&i* $a (app $D (&+ (&i* $c $alpha_i) (_^ $alpha $i $prime))))
                   (&i* $b (app $E (&+ (&i* $c $alpha_i) (_^ $alpha $i $prime)))))
               (&+ (&i* $a $c (app $D $alpha_i))
                   (&i* $a (app $D (_^ $alpha $i $prime)))
                   (&i* $b $c (app $E $alpha_i))
                   (&i* $b (app $E (_^ $alpha $i $prime))))
               (&+ (&i* $c (app (@ (&+ (&i* $a $D) (&i* $b $E))) $alpha_i))
                   (app (@ (&+ (&i* $a $D) (&i* $b $E))) (_^ $alpha $i $prime))))))
   (P "如果" $K "是一个域而" $V "是" $K "上的" n*n "矩阵的集合, 那么以上引理是说, "
      $V "上的" $n "线性函数的集合是从" $V "到" $K "的所有函数的空间的子空间.")
   ((example #:n "3")
    "令" $D "是" $K "上的" 2*2 "矩阵上的函数, 由"
    (MB (&= (app $D $A) (&- (&i* (mref $A $1 $1) (mref $A $2 $2))
                            (&i* (mref $A $1 $2) (mref $A $2 $1)))))
    "定义. 现在" $D "是两个函数之和, 它们具有例子1所刻画的类型:"
    (MB (&Table ($D $= (&+ $D_1 $D_2))
                ((app $D_1 $A) $= (&i* (mref $A $1 $1) (mref $A $2 $2)))
                ((app $D_2 $A) $= (&- (&i* (mref $A $1 $2) (mref $A $2 $1))))))
    "根据以上引理, " $D "是一个" $2 "线性函数. 对于行列式有任何一点经验的读者"
    "都不会对此感到惊讶, 因为他会识别出来这就是" 2*2 "矩阵的行列式的通常定义. "
    "当然了, 我们刚才定义的函数" $D "不是一个普通的" $2 "线性函数. 它拥有许多特别的性质. "
    "让我们注意到其中一些. "
    "首先, 如果" $I "是" 2*2 "的恒等矩阵, 那么" (&= (app $D $I) $1) ", 即"
    (&= (appl $D $epsilon_1 $epsilon_2) $1) ". 其次, 如果" $A "的两行是相等的, 那么"
    (MB (&= (app $D $A)
            (&- (&i* (mref $A $1 $1) (mref $A $2 $2))
                (&i* (mref $A $1 $2) (mref $A $2 $1)))
            $0))
    "最后, 如果" $A^ "是由一个" 2*2 "的矩阵" $A "交换其行得到的, 那么"
    (&= (app $D $A^) (&- (app $D $A))) ", 因为"
    (MB (deriv (app $D $A^)
               (&- (&i* (_^ $A (&cm $1 $1) $prime) (_^ $A (&cm $2 $2) $prime))
                   (&i* (_^ $A (&cm $1 $2) $prime) (_^ $A (&cm $2 $1) $prime)))
               (&- (&i* (mref $A $2 $1) (mref $A $1 $2))
                   (&i* (mref $A $2 $2) (mref $A $1 $1)))
               (&- (app $D $A)))))
   ((definition)
    "令" $D "是一个" $n "线性函数, 称" $D "是交错的, 如果其下两个条件满足:"
    (Ol #:attr* '((type "a"))
        (Li "凡" $A "有两行相等, 则" (&= (app $D $A) $0) ".")
        (Li "如果" $A^ "由" $A "交换两行获得, 那么"
            (&= (app $D $A^) (&- (app $D $A))) ".")))
   (P "我们将在之后证明任何满足条件a的" $n "线性函数自动地满足条件b. "
      "我们将两种条件放在交错" $n "线性函数的定义里主要是为了方便. "
      "读者可能也会注意到如果" $D "满足b, 而" $A "是一个有着相等两行的矩阵, 那么"
      (&= (app $D $A) (&- (app $D $A))) ". "
      "这让人忍不住断言" $D "也满足条件a. 这在某些时候是对的, 例如" $K
      "是一个满足" (&!= (&+ $1 $1) $0) "的域, 但在一般情况下a不是b的推论.")
   ((definition)
    "令" $K "是一个含幺交换环, 令" $n "是一个正整数. 设" $D "是一个从" $K "上的"
    n*n "矩阵到" $K "的函数. 我们称" $D "是一个行列式函数, 如果" $D "是" $n
    "线性的, 交错的, 并且" (&= (app $D $I) $1) ".")
   (P "正如我们之前所说的, 我们最终要证明" $K "上的" n*n "矩阵上恰存在一个行列式函数. "
      "这对于" $K "上的" (&c* $1 $1) "矩阵" (&= $A (bra0 $a)) "而言是显然的. "
      "由" (&= (app $D $A) $a) "给定的函数" $D "是一个行列式函数, 并且很明显这就是"
      (&c* $1 $1) "的矩阵上唯一的行列式函数. "
      "现在我们来处理" (&= $n $2) "的情况. 我们已经在例子3中表明了"
      (MB (&= (app $D $A) (&- (&i* (mref $A $1 $1) (mref $A $2 $2))
                              (&i* (mref $A $1 $2) (mref $A $2 $1)))))
      "是一个行列式函数. 而且, 例子2中呈现的公式表明" $D "是" 2*2
      "矩阵上唯一的行列式函数. 这是因为, 我们已经证明了对于任何" $2 "线性函数" $D "有"
      (MB (&= (app $D $A)
              (&+ (&i* (mref $A $1 $1)
                       (mref $A $2 $1)
                       (appl $D $epsilon_1 $epsilon_1))
                  (&i* (mref $A $1 $1)
                       (mref $A $2 $2)
                       (appl $D $epsilon_1 $epsilon_2))
                  (&i* (mref $A $1 $2)
                       (mref $A $2 $1)
                       (appl $D $epsilon_2 $epsilon_1))
                  (&i* (mref $A $1 $2)
                       (mref $A $2 $2)
                       (appl $D $epsilon_2 $epsilon_2)))))
      "如果" $D "是交错的, 那么"
      (MB (&= (appl $D $epsilon_1 $epsilon_1)
              (appl $D $epsilon_2 $epsilon_2)
              $0))
      "且"
      (MB (&= (appl $D $epsilon_2 $epsilon_1)
              (&- (appl $D $epsilon_1 $epsilon_2))
              (&- (app $D $I))))
      "如果" $D "还满足" (&= (app $D $I) $1) ", 那么"
      (MB (&= (app $D $A) (&- (&i* (mref $A $1 $1) (mref $A $2 $2))
                              (&i* (mref $A $1 $2) (mref $A $2 $1))))))
   ((example #:n "4")
    "令" $F "是一个域, 令" $D "是多项式环" polyF "上的" (&c* $3 $3)
    "矩阵上的任意一个交错的" $3 "线性函数. 令"
    (MB (&= $A (Mat ($x $0 (&- $x^2))
                    ($0 $1 $0)
                    ($1 $0 $x^3))))
    "如果我们将" (&c* $3 $3) "的恒等矩阵的行表示为"
    (&cm $epsilon_1 $epsilon_2 $epsilon_3) ", 那么"
    (MB (&= (app $D $A)
            (appl $D
                  (&- (&i* $x $epsilon_1) (&i* $x^2 $epsilon_3))
                  $epsilon_2
                  (&+ $epsilon_1 (&i* $x^3 $epsilon_3)))))
    "既然" $D "对于每一行都是线性的,"
    (MB (deriv
         (app $D $A)
         (&- (&i* $x (appl $D $epsilon_1 $epsilon_2
                           (&+ $epsilon_1 (&i* $x^3 $epsilon_3))))
             (&i* $x^2
                  (appl $D  $epsilon_3 $epsilon_2
                        (&+ $epsilon_1 (&i* $x^3 $epsilon_3)))))
         (&-
          (&+ (&i* $x (appl $D $epsilon_1 $epsilon_2 $epsilon_1))
              (&i* (^ $x $4) (appl $D $epsilon_1 $epsilon_2 $epsilon_3)))
          (&i* $x^2 (appl $D  $epsilon_3 $epsilon_2 $epsilon_1))
          (&i* (^ $x $5) (appl $D  $epsilon_3 $epsilon_2 $epsilon_3))
          )
         ))
    "因为" $D "是交错的, 于是"
    (MB (&= (app $D $A)
            (&i* (@ (&+ (^ $x $4) $x^2))
                 (appl $D $epsilon_1 $epsilon_2 $epsilon_3))))
    )
   ((lemma)
    "令" $D "是一个" $2 "线性函数, 并且对于" $K "上具有相同的行的" 2*2
    "矩阵" $A "有" (&= (app $D $A) $0) ", 那么" $D "是交错的."
    )
   ((proof)
    "我们必须证明的是, 如果" $A "是一个" 2*2 "的矩阵而" $A^
    "是由" $A "交换两行得到的, 那么"
    (&= (app $D $A^) (&- (app $D $A))) ". 如果" $A "的行是" $alpha "和" $beta
    ", 这意味着我们必须证明的是"
    (&= (appl $D $beta $alpha) (&- (appl $D $alpha $beta)))
    ". 既然" $D "是" $2 "线性的,"
    (MB (&= (appl $D (&+ $alpha $beta) (&+ $alpha $beta))
            (&+ (appl $D $alpha $alpha)
                (appl $D $alpha $beta)
                (appl $D $beta $alpha)
                (appl $D $beta $beta))))
    "根据我们的假设, "
    (&= (appl $D (&+ $alpha $beta) (&+ $alpha $beta))
        (appl $D $alpha $alpha)
        (appl $D $beta $beta)
        $0)
    ", 于是"
    (MB (&= $0 (&+ (appl $D $alpha $beta) (appl $D $beta $alpha))))
    )
   ((lemma)
    "令" $D "是一个" $K "上的" n*n "矩阵上的" $n "线性函数. 设" $D "满足凡" $A "两相邻行相等时"
    "即有" (&= (app $D $A) $0) ", 那么" $D "是交错的."
    )
   ((proof)
    "我们必须证明, 每当" $A "的两行相等时, " (&= (app $D $A) $0) ", 以及若" $A^
    "是由" $A "交换某两行得到的, 那么" (&= (app $D $A^) (&- (app $D $A))) ". "
    "首先, 让我们设" $A^ "是由" $A "交换两个相邻的行得到的. 读者应该能够看出来, "
    "前一个引理的证明中使用的论证可以扩展到目前的情形, 并告诉我们"
    (&= (app $D $A^) (&- (app $D $A))) "." (Br)
    "现在令" $B "由" $A "交换第" $i "行和第" $j "行得到, 其中" (&< $i $j) ". "
    "我们可以由" $A "通过一系列交换相邻行的操作得到" $B ". 我们首先交换第" $i "行和第"
    (@ (&+ $i $1)) "行, 如此反复直至行的排列呈现"
    (MB (&cm $alpha_1 $..h (_ $alpha (&- $i $1)) (_ $alpha (&+ $i $1))
             $..h $alpha_j $alpha_i (_ $alpha (&+ $j $1))
             $..h $alpha_n))
    "的顺序. 这需要交换" (&= $k (&- $j $i)) "次交换相邻的行. 现在我们用" (@ (&- $k $1))
    "次交换相邻的行将" $alpha_j "移到第" $i "行的位置. 因此, 我们通过"
    (&= (&+ $k (@ (&- $k $1))) (&- (&i* $2 $k) $1)) "次交换相邻行的操作由" $A
    "获得了" $B ", 于是"
    (MB (&= (app $D $B)
            (&i* (^ (@ $-1) (&- (&i* $2 $k) $1)) (app $D $A))
            (&- (app $D $A))))
    "设" $A "是任意拥有相等两行的" n*n "矩阵, 即有" (&= $alpha_i $alpha_j)
    ", 其中" (&< $i $j) ". 如果" (&= $j (&+ $i $1)) ", 那么" $A "有相等的邻行, 于是"
    (&= (app $D $A) $0) ". 如果" (&> $j (&+ $i $1)) ", 我们交换"
    (_ $alpha (&+ $i $1)) "和" $alpha_j ", 其结果" $B "拥有相等的邻行, 于是"
    (&= (app $D $B) $0) ". 从另一方面说, " (&= (app $D $B) (&- (app $D $A)))
    ", 因此" (&= (app $D $A) $0) ".")
   ((definition)
    "如果" (&> $n $1) "并且" $A "是一个" $K "上的" n*n "矩阵, 我们令"
    (subm $A $i $j) "代表删去" $A "的第" $i "行和第" $j "列得到的"
    (&c* (@- $n $1) (@- $n $1)) "矩阵. 如果" $D "是一个"
    (@- $n $1) "线性函数, 而" $A "是一个" n*n "矩阵, 我们记"
    (&= (app (_ $D (&cm $i $j)) $A) (ap $D (bra0 (subm $A $i $j)))) ".")
   ((theorem #:n "1")
    "令" (&> $n $1) ", 令" $D "是" $K "上的" (&c* (@- $n $1) (@- $n $1))
    "矩阵上的一个交错的" (@- $n $1) "线性函数. 对于每个" (&cm $j (&<= $1 $j $n))
    ", 由"
    (MB (&= (app $E_j $A)
            (sum (&= $i $1) $n
                 (&i* (^ (@ $-1) (&+ $i $j))
                      Aij
                      (app (_ $D (&cm $i $j)) $A)))))
    "定义的函数" $E_j "是" n*n "矩阵" $A "上的一个交错的" $n "线性函数. "
    "如果" $D "是一个行列式函数, 那么每个" $E_j "也是行列式函数.")
   ((proof)
    "如果" $A "是一个" n*n "矩阵, 那么" (app (_ $D (&cm $i $j)) $A)
    "独立于" $A "的第" $i "行. 既然" $D "是" (@- $n $1) "线性的, 那么显然"
    (_ $D (&cm $i $j)) "对于除了第" $i "行之外的行都是线性的. 因此, "
    (&i* Aij (app (_ $D (&cm $i $j)) $A)) "是" $A "的一个" $n
    "线性函数. " $n "线性函数的线性组合仍是" $n "线性的, 于是" $E_j
    "是" $n "线性的. 为了证明" $E_j "是交错的, 只需证明凡" $A "有相等的邻行则"
    (&= (app $E_j $A) $0) "就够了. 设" (&= $alpha_k (_ $alpha (&+ $k $1)))
    ", 如果" (&!= $i $k) "且" (&!= $i (&+ $k $1)) ", 那么矩阵" (subm $A $i $j)
    "拥有相等的两行, 于是" (&= (app (_ $D (&cm $i $j)) $A) $0) ", 因此"
    (MB (&= (app $E_j $A)
            (&+ (&i* (^ (@ $-1) (&+ $k $j))
                     (mref $A $k $j)
                     (app (_ $D (&cm $k $j)) $A))
                (&i* (^ (@ $-1) (&+ (&+ $k $1) $j))
                     (mref $A (&+ $k $1) $j)
                     (app (_ $D (&cm (&+ $k $1) $j)) $A)))))
    "既然" (&= $alpha_k (_ $alpha (&+ $k $1))) ", 那么"
    (MB (&= (mref $A $k $j) (mref $A (&+ $k $1) $j))
        "且"
        (&= (subm $A $k $j) (subm $A (&+ $k $1) $j)))
    "显然有" (&= (app $E_j $A) $0) "." (Br)
    "现在设" $D "是一个行列式函数. 如果" (^ $I (@ $n)) "是" n*n "的恒等矩阵, 那么"
    (subm (^ $I (@ $n)) $j $j) "是" (&c* (@- $n $1) (@- $n $1)) "的恒等矩阵"
    (^ $I (@- $n $1)) ". 既然" (&= (mref (^ $I (@ $n)) $i $j) δij)
    ", 那么根据" $E_j "的定义有"
    (MB (&= (app $E_j (^ $I (@ $n))) (app $D (^ $I (@- $n $1)))))
    "因为" (&= (app $D (^ $I (@- $n $1))) $1) ", 所以"
    (&= (app $E_j (^ $I (@ $n))) $1) ", 即" $E_j "是一个行列式函数.")
   ((corollary)
    "令" $K "是一个含幺交换环而" $n "是一个正整数, 那么至少存在一个" (^ $K n*n)
    "上的行列式函数."
    )
   ((proof)
    "我们已经证明了" $K "上的" (&c* $1 $1) "矩阵上行列式函数的存在性, 甚至"
    2*2 "的矩阵上也证明了. 定理1告诉我们如何从"
    (&c* (@- $n $1) (@- $n $1)) "矩阵上的行列式函数构造出" n*n
    "矩阵上的行列式函数, 根据归纳可得推论.")
   ((example #:n "5")
    "如果" $B "是" $K "上的一个" 2*2 "矩阵, 我们令"
    (MB (&= (&abs $B)
            (&- (&i* (mref $B $1 $1)
                     (mref $B $2 $2))
                (&i* (mref $B $1 $2)
                     (mref $B $2 $1)))))
    "那么" (&= (&abs $B) (app $D $B)) ", 其中" $D "是" 2*2 "矩阵上的行列式函数. "
    "我们已经证明过" (^ $K 2*2) "上这样的函数是唯一的了. 令"
    (MB (&= $A (Mat ((mref $A $1 $1) (mref $A $1 $2) (mref $A $1 $3))
                    ((mref $A $2 $1) (mref $A $2 $2) (mref $A $2 $3))
                    ((mref $A $3 $1) (mref $A $3 $2) (mref $A $3 $3)))))
    "是" $K "上的一个" (&c* $3 $3) "矩阵. 如果我们如定理1中对于" $E_j
    "的定义一样定义了" (&cm $E_1 $E_2 $E_3) ", 那么"
    (let ((Tt (Ttable (lambda (d i j)
                        (if (= j 2)
                            (set-attr* d 'columnalign "right")
                            d)))))
      (MB
       (Tt
        (&Table
         ((app $E_1 $A)
          $= (&i* (mref $A $1 $1)
                  (Det ((mref $A $2 $2) (mref $A $2 $3))
                       ((mref $A $3 $2) (mref $A $3 $3))))
          $- (&i* (mref $A $2 $1)
                  (Det ((mref $A $1 $2) (mref $A $1 $3))
                       ((mref $A $3 $2) (mref $A $3 $3))))
          $+ (&i* (mref $A $3 $1)
                  (Det ((mref $A $1 $2) (mref $A $1 $3))
                       ((mref $A $2 $2) (mref $A $2 $3)))))
         ((app $E_2 $A)
          $= (&i* (&- (mref $A $1 $2))
                  (Det ((mref $A $2 $1) (mref $A $2 $3))
                       ((mref $A $3 $1) (mref $A $3 $3))))
          $+ (&i* (mref $A $2 $2)
                  (Det ((mref $A $1 $1) (mref $A $1 $3))
                       ((mref $A $3 $1) (mref $A $3 $3))))
          $- (&i* (mref $A $3 $2)
                  (Det ((mref $A $1 $1) (mref $A $1 $3))
                       ((mref $A $2 $1) (mref $A $2 $3)))))
         ((app $E_3 $A)
          $= (&i* (mref $A $1 $3)
                  (Det ((mref $A $2 $1) (mref $A $2 $2))
                       ((mref $A $3 $1) (mref $A $3 $2))))
          $- (&i* (mref $A $2 $3)
                  (Det ((mref $A $1 $1) (mref $A $1 $2))
                       ((mref $A $3 $1) (mref $A $3 $2))))
          $+ (&i* (mref $A $3 $3)
                  (Det ((mref $A $1 $1) (mref $A $1 $2))
                       ((mref $A $2 $1) (mref $A $2 $2)))))
         ))))
    "从定理1可知" (&cm $E_1 $E_2 $E_3) "都是行列式函数. 实际上, 我们之后将证明"
    (&= $E_1 $E_2 $E_3) ", 但即便在此简单情形之下这也并非显然. "
    "然而, 这可以直接地通过展开以上每个表达式进行验证. "
    "我们不做这种事情, 转而给出一些特定的例子."
    (Ol #:attr* '((type "a"))
        (Li "令" (&= $K (&poly $RR)) "并且"
            (MB (&= $A
                    (Mat ((&- $x $1) $x^2 $x^3)
                         ($0 (&- $x $2) $1)
                         ($0 $0 (&- $x $3)))))
            "那么"
            (let ((Tt (Ttable (lambda (d i j)
                                (if (= j 2)
                                    (set-attr* d 'columnalign "left")
                                    d)))))
              (MB
               (Tt
                (&Table
                 ((app $E_1 $A) $= (&i* (@ (&- $x $1))
                                        (Det ((&- $x $2) $1)
                                             ($0 (&- $x $3)))))
                 ($ $= (&i* (@ (&- $x $1))
                            (@ (&- $x $2))
                            (@ (&- $x $3))))
                 ((app $E_2 $A) $= (&+ (&i* (&- $x^2)
                                            (Det ($0 $1)
                                                 ($0 (&- $x $3))))
                                       (&i* (@ (&- $x $2))
                                            (Det ((&- $x $1) $x^3)
                                                 ($0 (&- $x $3))))))
                 ($ $= (&i* (@ (&- $x $1))
                            (@ (&- $x $2))
                            (@ (&- $x $3))))
                 ((app $E_3 $A)
                  $=
                  (&+
                   (&- (&i* $x^3
                            (Det ($0 (&- $x $2))
                                 ($0 $0)))
                       (Det ((&- $x $1) $x^2)
                            ($0 $0)))
                   (&i* (@ (&- $x $3))
                        (Det ((&- $x $1) $x^2)
                             ($0 (&- $x $2))))))
                 ($ $= (&i* (@ (&- $x $1))
                            (@ (&- $x $2))
                            (@ (&- $x $3)))))))))
        (Li "令" (&= $K $RR) "并且"
            (MB (&= $A (Mat ($0 $1 $0)
                            ($0 $0 $1)
                            ($1 $0 $0))))
            "那么"
            (let ((Tt (Ttable (lambda (d i j)
                                (if (= j 2)
                                    (set-attr* d 'columnalign "right")
                                    d)))))
              (MB
               (Tt
                (&Table
                 ((app $E_1 $A)
                  $= (Det ($1 $0)
                          ($0 $1))
                  $= $1)
                 ((app $E_2 $A)
                  $= (&- (Det ($0 $1)
                              ($1 $0)))
                  $= $1)
                 ((app $E_3 $A)
                  $= (&- (Det ($0 $1)
                              ($1 $0)))
                  $= $1)
                 )))))))
   ((exercise #:n "1")
    "下列每个表达式都定义了一个实数域上的" (&c* $3 $3) "矩阵上的函数" $D ", 其中哪些" $D
    "是" $3 "线性函数?"
    (Ol #:attr* '((type "a"))
        (Li (&= (app $D $A) (&+ (mref $A $1 $1) (mref $A $2 $2) (mref $A $3 $3))) ";")
        (Li (&= (app $D $A) (&+ (^ (@ (mref $A $1 $1)) $2)
                                (&i* $3 (mref $A $1 $1) (mref $A $2 $2)))) ";")
        (Li (&= (app $D $A) (&i* (mref $A $1 $1) (mref $A $1 $2) (mref $A $3 $3))) ";")
        (Li (&= (app $D $A)
                (&+ (&i* (mref $A $1 $3) (mref $A $2 $2) (mref $A $3 $2))
                    (&i* $5 (mref $A $1 $2) (mref $A $2 $2) (mref $A $3 $2)))) ";")
        (Li (&= (app $D $A) $0) ";")
        (Li (&= (app $D $A) $1) ".")))
   ((exercise #:n "2")
    "直接验证前文中的" (&cm $E_1 $E_2 $E_3) "是等同的.")
   ((exercise #:n "3")
    "令" $K "是一个含幺交换环. 如果" $A "是" $K "上的一个" 2*2
    "矩阵, 那么" $A "的古典伴随" (ap $adj $A) "由"
    (MB (&= (ap $adj $A)
            (Mat ((mref $A $2 $2) (&- (mref $A $1 $2)))
                 ((&- (mref $A $2 $1)) (mref $A $1 $1)))))
    "定义. 如果" $det "代表" $K "上的" 2*2 "矩阵上唯一的行列式函数, 证明"
    (Ol #:attr* '((type "a"))
        (Li (&= (&i* (&adj $A) $A) (&i* $A (&adj $A)) (&i* (&det0 $A) $I)) ";")
        (Li (&= (ap $det (&adj $A)) detA) ";")
        (Li (&= (app $adj $A^t) (^ (&adj $A) $t)) "."))
    "(" $A^t "代表" $A "的转置.)")
   ((exercise #:n "4")
    "令" $A "是一个域" $F "上的" 2*2 "矩阵. 证明" $A "可逆当且仅当"
    (&!= detA $0) ". 当" $A "可逆时, 给出一个" (inv $A) "的公式.")
   ((exercise #:n "5")
    "令" $A "是一个域" $F "上的" 2*2 "矩阵, 设" (&= $A^2 $0) ". 证明对于每个标量"
    $c "有" (&= (&det (&- (&i* $c $I) $A)) $c^2) ".")
   ((exercise #:n "6")
    "令" $K "是一个复数域的子域, 并且" $n "是一个正整数. 令" (&cm $j_1 $..h $j_n) "和"
    (&cm $k_1 $..h $k_n) "是不超过" $n "的正整数. 对于一个" $K "上的" n*n "的矩阵" $A
    "而言定义"
    (MB (&= (app $D $A)
            (&i* (appl $A $j_1 $k_1) (appl $A $j_2 $k_2) $..c
                 (appl $A $j_n $k_n))))
    "证明" $D "是" $n "线性的当且仅当整数" (&cm $j_1 $..h $j_n) "是互异的.")
   ((exercise #:n "7")
    "令" $K "是一个含幺交换环. 证明" $K "上的" 2*2 "矩阵上的行列式函数对于列是" $2 
    "线性的和交错的.")
   ((exercise #:n "8")
    "令" $K "是一个含幺交换环. 通过规则"
    (MB (&= (app $D $A)
            (&+ (&- (&i* (mref $A $1 $1)
                         (Det ((mref $A $2 $2) (mref $A $2 $3))
                              ((mref $A $3 $2) (mref $A $3 $3))))
                    (&i* (mref $A $1 $2)
                         (Det ((mref $A $2 $1) (mref $A $2 $3))
                              ((mref $A $3 $1) (mref $A $3 $3)))))
                (&i* (mref $A $1 $3)
                     (Det ((mref $A $2 $1) (mref $A $2 $2))
                          ((mref $A $3 $1) (mref $A $3 $2)))))))
    "定义了一个" $K "上的" (&c* $3 $3) "矩阵上的函数" $D ". "
    "证明" $D "对于列而言是交错的和" $3 "线性的.")
   ((exercise #:n "9")
    "令" $K "是一个含幺交换环而" $D "是" $K "上的" n*n "矩阵上的交错的" $n
    "线性函数, 证明"
    (Ol #:attr* '((type "a"))
        (Li "如果" $A "有一行为" $0 ", 那么" (&= (app $D $A) $0) ";")
        (Li "如果" $B "是由" $A "通过将一行的倍数加到另一行上去得到的, 那么"
            (&= (app $D $B) (app $D $A)) ".")))
   ((exercise #:n "10")
    "令" $F "是一个域, " $A "是一个域" $F "上的" (&c* $2 $3) "矩阵. "
    (tu0 $c_1 $c_2 $c_3) "是一个" $F^3 "中的向量, 由"
    (MB (&cm (&= $c_1 (Det ((mref $A $1 $2) (mref $A $1 $3))
                           ((mref $A $2 $2) (mref $A $2 $3))))
             (&= $c_2 (Det ((mref $A $1 $3) (mref $A $1 $1))
                           ((mref $A $2 $3) (mref $A $2 $1))))
             (&= $c_3 (Det ((mref $A $1 $1) (mref $A $1 $2))
                           ((mref $A $2 $1) (mref $A $2 $2))))))
    "定义. 证明"
    (Ol #:attr* '((type "a"))
        (Li (&= (&rank $A) $2) "当且仅当" (&!= (tu0 $c_1 $c_2 $c_3) $0) ";")
        (Li "如果" $A "的秩为" $2 ", 那么" (tu0 $c_1 $c_2 $c_3)
            "是线性方程组" AX=0 "的解空间的一个基.")))
   ((exercise #:n "11")
    "令" $K "是一个含幺交换环而" $D "是" $K "上的" 2*2 "矩阵上的一个交错的" $2
    "线性函数. 证明对于每个" $A "而言有" (&= (app $D $A) (&i* (&det0 $A) (app $D $I)))
    ". 现在使用这个结果, 在不对于矩阵的元素进行计算的情况下, 证明"
    (&= (&det AB) (&i* (&det0 $A) (&det0 $B))) "对于" $K "上任意的"
    2*2 "矩阵" $A "和" $B "成立.")
   ((exercise #:n "12")
    "令" $F "是一个域, " $D "是一个" $F "上的" n*n "矩阵上的函数. 设"
    (&= (app $D AB) (&i* (app $D $A) (app $D $B)))
    "对于所有" $A "和" $B "成立. 证明要么对于所有的" $A "有" (&= (app $D $A) $0)
    ", 要么" (&= (app $D $I) $1) ". 在后一种情况, 证明凡" $A "可逆即有"
    (&!= (app $D $A) $0) ".")
   ((exercise #:n "13")
    "令" $RR "是实数域, 令" $D "是一个" $RR "上的" 2*2 "矩阵上的函数, 满足"
    (&= (app $D AB) (&i* (app $D $A) (app $D $B)))
    "对于所有" $A "和" $B "成立, 并设"
    (MB (&!= (ap $D (pare (Mat ($0 $1) ($1 $0))))
             (ap $D (pare (Mat ($1 $0) ($0 $1))))))
    "证明以下命题."
    (Ol #:attr* '((type "a"))
        (Li (&= (app $D $0) $0) ";")
        (Li "如果" (&= $A^2 $0) ", 那么" (&= (app $D $A) $0) ";")
        (Li "如果" $B "由" $A "交换两行 (或交换两列) 获得, 那么"
            (&= (app $D $B) (&- (app $D $A))) ";")
        (Li "如果" $A "有一行 (或一列) 为零, 那么" (&= (app $D $A) $0) ";")
        (Li "若" $A "是奇异的, 那么" (&= (app $D $A) $0) ".")))
   ((exercise #:n "14")
    "令" $A "是域" $F "上的一个" 2*2 "矩阵, 那么所有具有形式" (app $f $A)
    "的矩阵, 其中" $f "是" $F "上的一个多项式, 构成了一个含幺交换环" $K ". "
    "如果" $B "是" $K "上的一个" 2*2 "矩阵, 那么" $B
    "的行列式是" $F "上的一个" 2*2 "矩阵. 设" $I "是" $F "上的"
    2*2 "的恒等矩阵, " $K "上的" 2*2 "矩阵" $B "为"
    (MB (&= $B (Mat ((&- $A (&i* (mref $A $1 $1) $I)) (&- (&i* (mref $A $1 $2) $I)))
                    ((&- (&i* (mref $A $2 $1) $I)) (&- $A (&i* (mref $A $2 $2) $I))))))
    "证明" (&= (&det $B) (app $f $A)) ", 其中"
    (&= $f (&+ (&- $x^2 (&i* (@ (&+ (mref $A $1 $1) (mref $A $2 $2))) $x)) detA))
    ", 并证明" (&= (app $f $A) $0) ".")
   (H3 "第5.3节 置换和行列式的唯一性")
   (P "本节我们将证明" $K "上的" n*n "矩阵上的行列式函数的唯一性. 这个证明相当自然地将我们"
      "引向考虑置换及其一些基本性质.")
   (P "设" $D "是" $K "上的" n*n "矩阵上的一个交错的" $n "线性函数. 令" $A "是一个"
      $K "上的" n*n "矩阵, 其行分别为" alpha_1..n ". 如果我们用"
      (&cm $epsilon_1 $epsilon_2 $..h $epsilon_n) "表示" $K "上的" n*n
      "恒等矩阵的行, 那么"
      (MB (&cm
           (&= $alpha_i
               (sum (&= $j $1) $n (&i* (appl $A $i $j) $epsilon_j)))
           (&<= $1 $i $n)))
      "因此"
      (MB (deriv (app $D $A)
                 (ap $D (tup (sum $j $ (&i* (appl $A $1 $j) $epsilon_j))
                             $alpha_2 $..h $alpha_n))
                 (sum $j $
                      (&i* (appl $A $1 $j)
                           (appl $D $epsilon_j $alpha_2 $..h $alpha_n)))))
      "如果我们现在替换" $alpha_2 "以"
      (sum $k $ (&i* (appl $A $2 $k) $epsilon_k)) ", 那么我们看到"
      (MB (&= (appl $D $epsilon_j $alpha_2 $..h $alpha_n)
              (sum $k $
                   (&i* (appl $A $2 $k)
                        (appl $D $epsilon_j
                              $epsilon_k $..h $alpha_n)))))
      "因此"
      (MB (&= (app $D $A)
              (sum (&cm $j $k) $
                   (&i* (appl $A $1 $j) (appl $A $2 $k)
                        (appl $D $epsilon_j
                              $epsilon_k $..h $alpha_n)))))
      "对于" (appl $D $epsilon_j $epsilon_k $..h $alpha_n)
      "我们接着替换" $alpha_3 "以" (sum $l $ (&i* (appl $A $3 $l) (_ $epsilon $l)))
      ", 如此反复. 最终我们得到了一个" (app $D $A) "的表达式, 其复杂但在理论上十分重要, 即"
      (MB (&= (app $D $A)
              (sum (&cm $k_1 $k_2 $..h $k_n) $
                   (&i* (appl $A $1 $k_1) (appl $A $2 $k_2) $..c (appl $A $n $k_n)
                        (appl $D (_ $epsilon $k_1) (_ $epsilon $k_2) $..h
                              (_ $epsilon $k_n))))))
      "此和布于所有不超过" $n "的正整数的有限序列" (tu0 $k_1 $k_2 $..h $k_n) "之上. "
      "这表明" $D "是一系列函数的有限之和, 它们具有例子1所刻画的类型. "
      "应该注意到此式仅是" $D "为" $n "线性之推论, 而例子2是其一个特殊情形. "
      "既然" $D "是交错的, 那么每当下标" $k_i "之中有两个相等时, 有"
      (MB (&= (appl $D (_ $epsilon $k_1) (_ $epsilon $k_2) $..h (_ $epsilon $k_n)) $0))
      "不超过" $n "的正整数的一个有限序列" (tu0 $k_1 $k_2 $..h $k_n) ", 若其没有两个相等的分量, "
      "则被称为一个" $n "阶置换. 因此, 在这" $D "的复杂表达式之中, 我们只需要将"
      (tu0 $k_1 $k_2 $..h $k_n) "算是" $n "阶置换的部分加起来即可.")
   (P "既然一个有限的序列, 或者说" $n "元组, 是一个定义于前" $n "个正整数上的函数, 一个"
      $n "阶置换可以被定义为从集合" (setE $1 $2 $..h $n) "到自身的双射. "
      "这样一个函数" $sigma "对应于" $n "元组" (tu0 σ1 σ2 $..h σn)
      ", 因此实际上它不过就是一个以某种良定的方式排列" (&cm $1 $2 $..h $n) "的规则.")
   (P "如果" $D "是一个交错的" $n "线性函数, 而" $A "是" $K "上的一个" n*n "矩阵, 那么"
      (MB (&= (app $D $A)
              (sum $sigma $
                   (&i* (appl $A $1 σ1) $..c (appl $A $n σn)
                        (appl $D (_ $epsilon σ1) $..h
                              (_ $epsilon σn))))))
      "此和布于所有" $n "阶置换" $sigma "之上.")
   (P "接着我们将证明"
      (MB (&= (appl $D (_ $epsilon σ1) $..h (_ $epsilon σn))
              (&+- (appl $D $epsilon_1 $..h $epsilon_n))))
      "其中符号" $+- "仅依赖于排列" $sigma ". 理由如下. 序列"
      (tu0 σ1 σ2 $..h σn) "可由"
      (tu0 $1 $2 $..h $n) "通过有限次交换元素得到. 例如, 如果" (&!= σ1 $1)
      ", 那么我们可以交换" $1 "和" σ1 "的位置, 获得"
      (tu0 σ1 $..h $1 $..h) ". 继行此法, 我们将在" $n "次或更少这样的交换之后"
      "抵达序列" (tu0 σ1 σ2 $..h σn) ". "
      "[译注: 实际上最多仅需" (@- $n $1) "次这样的交换. 另外, 交换也可以被视为"
      "一种特殊的置换, 那么这是说任何置换都可以被表示为交换的复合.] "
      "既然" $D "是交错的, 那么每当我们交换行" $epsilon_i "和" $epsilon_j
      "其值的符号就会改变. 因此, 如果我们通过" $m "次交换从" (tu0 $1 $2 $..h $n) "得到了"
      (tu0 σ1 σ2 $..h σn) ", 我们有"
      (MB (&= (appl $D (_ $epsilon σ1) $..h (_ $epsilon σn))
              (&i* (^ (@ $-1) $m) (appl $D $epsilon_1 $..h $epsilon_n))))
      "特别地, 如果" $D "是一个行列式函数,"
      (MB (&= (appl $D (_ $epsilon σ1) $..h (_ $epsilon σn))
              (^ (@ $-1) $m)))
      "其中" $m "仅依赖于" $sigma "而不依赖于" $D ". 因此, 所有的行列式函数为以"
      (&cm (_ $epsilon σ1) $..h (_ $epsilon σn))
      "为行的矩阵赋相同的值, 该值要么是" $1 "要么是" $-1 ".")
   (P "现在我们给出一个关于置换的基本事实. 如果" $sigma "是一个" $n "阶置换, 读者可以通过"
      "一系列交换由" (tu0 $1 $2 $..h $n) "得到" (tu0 σ1 σ2 $..h σn)
      ", 而且这可以按照各种不同的方式进行. 尽管如此, 不论以何种方式进行, 交换的次数要么"
      "总是偶数, 要么总是奇数. 于是, 置换也就相应地被称为偶的或奇的. 我们以"
      (MB (&= sgnσ
              (Choice
               ($1 (: $cm "如果" $sigma "是偶置换"))
               ($-1 (: $cm "如果" $sigma "是奇置换")))))
      "定义置换的符号 (sign), 其中符号 (symbol) &quot;" $1 "&quot;代表整数" $1 ". "
      "[译注: 实际上, 我们需要定义整数和环/域的元素的乘法, 当然它只依赖于加法群的结构.]")
   (P "我们将在之后表明置换的这个基本性质可从我们已经知道的关于行列式函数的东西推导出来. "
      "让我们暂时假设这个性质成立, 那么整数" $m "在" $sigma "是偶置换的情况下总是偶数, 在"
      $sigma "是奇置换的情况下总是奇数. 那么, 对于任何一个交错的" $n "线性函数" $D "我们有"
      (MB (&= (appl $D (_ $epsilon σ1) $..h (_ $epsilon σn))
              (&i* @sgnσ (appl $D $epsilon_1 $..h $epsilon_n))))
      "那么根据我们已经得到的公式,"
      (MB (&= (app $D $A)
              (&i* (brac
                    (sum $sigma $
                         (&i* @sgnσ
                              (appl $A $1 σ1)
                              $..c
                              (appl $A $n σn))))
                   (app $D $I))))
      "当然" $I "代表" n*n "的恒等矩阵.")
   (P "从此结果之中我们可以看出来" $K "上的" n*n "矩阵上恰存在唯一的行列式函数. "
      "如果我们用" $det "代表这个函数, 那么它由"
      (MB (&= detA
              (sum $sigma $
                   (&i* @sgnσ
                        (appl $A $1 σ1)
                        $..c
                        (appl $A $n σn)))))
      "给出, 其中和布于所有" $n "阶置换之上. 我们可以将其形式化地总结如下.")
   ((theorem #:n "2")
    "令" $K "是一个含幺交换环, 令" $n "是一个正整数. " $K "上的" n*n
    "矩阵上恰存在唯一的行列式函数, 即由"
    (MB (&= detA
            (sum $sigma $
                 (&i* @sgnσ
                      (appl $A $1 σ1)
                      $..c
                      (appl $A $n σn)))))
    "给定的函数" $det ". 如果" $D "是一个" (^ $K n*n) "上的交错的" $n
    "线性函数, 那么对于每个" n*n "的矩阵" $A ","
    (MB (&= (app $D $A) (&i* (@ (ap $det $A)) (app $D $I)))))
   (P "这就是我们一直在寻求的定理, 不过证明中我们留下了一个gap. 这个gap就是证明对于一个给定的"
      $sigma ", 当我们从" (tu0 $1 $2 $..h $n) "经过交换得到"
      (tu0 σ1 σ2 $..h σn) "时, 交换的次数要么总是偶数, "
      "要么总是奇数. 这个基本的组合学事实当然可以不借助于行列式来证明. 然而, 我们乐意指出如何从"
      n*n "矩阵上的行列式函数的存在性中得到这个事实.")
   (P "令" $K "是整数环, 令" $D "是" $K "上的" n*n "矩阵上的一个行列式函数. 令" $sigma
      "是一个" $n "阶置换, 设我们通过" $m "次交换从" (tu0 $1 $2 $..h $n) "得到"
      (tu0 σ1 σ2 $..h σn) ". 之前我们已经知道的"
      (MB (&= (^ (@ $-1) $m)
              (appl $D (_ $epsilon σ1) $..h (_ $epsilon σn))))
      "也就是说, " (^ (@ $-1) $m) "必须是" $D "在以"
      (&cm (_ $epsilon σ1) $..h (_ $epsilon σn))
      "为行的矩阵上的值. 如果"
      (MB (&=
           (appl $D (_ $epsilon σ1) $..h (_ $epsilon σn))
           $1))
      "那么" $m "必须是偶数. 如果"
      (MB (&=
           (appl $D (_ $epsilon σ1) $..h (_ $epsilon σn))
           $-1))
      "那么" $m "必须是奇数. [译注: 若"$m "可能为奇可能为偶, 那么" $D "就不是良定的了.]")
   (P "既然我们有了" n*n "矩阵的行列式的显式公式, 并且这个公式牵扯到" $n "阶置换, "
      "让我们对于置换的一些观察为本节作结. 首先, 我们注意到恰存在"
      (&= (&fact $n) (&d* $1 $2 $..c $n)) "个" $n "阶置换. 这是因为, 如果" $sigma
      "是一个置换, " σ1 "存在" $n "种可能的选择. 当作出这个选择之后, "
      σ2 "有" (@- $n $1) "种选择, 然后" (ap $sigma $3) "有"
      (@ (&- $n $2)) "种选择, 诸如此类. 因此, 存在"
      (MB (&= (&d* $n (@- $n $1) (@ (&- $n $2)) $..c $2 $1) (&fact $n)))
      "种置换" $sigma ". 于是, " detA "的公式是" (&fact $n) "个项的和, 每一项对应于一个"
      $n "阶置换. 每个项都是" $A "的" $n "个元素之积"
      (MB (&i* (appl $A $1 σ1) $..c (appl $A $n σn)))
      "其中每个元素都来自于不同的每一行和不同的每一列, 并且根据" $sigma "是偶置换还是奇置换, "
      "前面带着符号&quot;" $+ "&quot;或者&quot;" $- "&quot;.")
   (P "当置换被认为是从集合" (setE $1 $2 $..h $n) "到自身的双射时, 我们可以定义置换的积. "
      $sigma "和" $tau "之积被简单地定义为复合函数" (&i* $sigma $tau) ", 其由"
      (MB (&= (app (@ (&i* $sigma $tau)) $i) (app $sigma (app $tau $i))))
      "定义. 如果" $epsilon "代表恒等置换, 即由" (&= (app $epsilon $i) $i)
      "定义的置换, 那么对于每个置换" $sigma "存在一个逆" (inv $sigma) "满足"
      (MB (&= (&i* $sigma (inv $sigma)) (&i* (inv $sigma) $sigma) $epsilon))
      "我们可以这样总结我们的观察, 即是说所有" $n "阶置换构成的集合, 在函数复合之下, 是一个群. "
      "这个群一般被称为" $n "阶对称群.")
   (P "从置换的积的角度来看, 置换的符号的基本性质是"
      (MB (&= (&sgn (@ (&i* $sigma $tau)))
              (&i* @sgnσ
                   (@ (&sgn $tau)))))
      "换句话说, " (&i* $sigma $tau) "是偶置换, 如果" $sigma "和" $tau "都是偶置换或都是"
      "奇置换; " (&i* $sigma $tau) "是奇置换, 如果其中有一个是奇置换, 另一个是偶置换. "
      "读者可以基于交换操作的相继从符号的定义中看出来这个结果. "
      "[译注: 如果" $sigma "可以被表示为" $m "个交换的复合, 而" $tau "可以被表示为" $l
      "个交换的复合, 那么显然" (&i* $sigma $tau) "可以被表示为" (@ (&+ $m $l))
      "个交换的复合, 由此看出这基本性质.] "
      "如果我们指出如何从行列式的一个基本性质中得到"
      (&= (&sgn (@ (&i* $sigma $tau)))
          (&i* @sgnσ
               (@ (&sgn $tau))))
      ", 那也是很有好处的.")
   (P "令" $K "是整数环, 令" $sigma "和" $tau "是" $n "阶置换. 令"
      (&cm $epsilon_1 $..h $epsilon_n) "是" $K "上的" n*n "恒等矩阵的行, 令" $A "是以"
      (&cm (_ $epsilon (ap $tau $1)) $..h (_ $epsilon (ap $tau $n)))
      "为行的矩阵, 令" $B "是以"
      (&cm (_ $epsilon σ1) $..h (_ $epsilon σn))
      "为行的矩阵. " $A "的第" $i "行仅包含一个非零元素, 那就是在第" (ap $tau $i)
      "列的" $1 ". 从这点很容易看出" (_ $epsilon (ap (&i* $sigma $tau) $i))
      "是积矩阵" AB "的第" $i "行, 那么现在有"
      (MB (&cm (&= detA (&sgn $tau))
               (&= (&det $B) sgnσ)
               (&= (&det AB) (&sgn (@ (&i* $sigma $tau))))))
      "只要我们证明了以下定理, 就能立刻得出"
      (&= (&sgn (@ (&i* $sigma $tau))) (&i* @sgnσ (@ (&sgn $tau)))) ".")
   ((theorem #:n "3")
    "令" $K "是一个含幺交换环, 令" $A "和" $B "是" $K "上的" n*n "矩阵, 那么"
    (MB (&= (&det AB) (&i* (@ (ap $det $A)) (@ (ap $det $B))))))
   ((proof)
    "令" $B "是" $K "上一个固定的" n*n "矩阵, 并且对于每个" n*n "矩阵" $A ", 定义"
    (&= (app $D $A) (&det AB)) ". 如果我们用"
    alpha_1..n "代表矩阵" $A "的行, 那么"
    (MB (&= (appl $D $alpha_1 $..h $alpha_n)
            (appl $det (&i* $alpha_1 $B) $..h (&i* $alpha_n $B))))
    "这里" (&i* $alpha_j $B) "代表一个" (&c* $1 $n) "矩阵, 其是" (&c* $1 $n) "矩阵"
    $alpha_j "和" n*n "矩阵" $B "之积. 既然"
    (MB (&= (&i* (@ (&+ (&i* $c $alpha_i) (_^ $alpha $i $prime))) $B)
            (&+ (&i* $c $alpha_i $B) (&i* (_^ $alpha $i $prime) $B))))
    "并且" $det "是" $n "线性的, 那么很容易看出" $D "是" $n "线性的. "
    "如果" (&= $alpha_i $alpha_j) ", 那么"
    (&= (&i* $alpha_i $B) (&i* $alpha_j $B)) ", 鉴于" $det "是交错的,"
    (MB (&= (appl $D $alpha_1 $..h $alpha_n) $0))
    "因此, " $D "是交错的, 现在" $D "是一个交错的" $n "线性函数. 根据定理2,"
    (MB (&= (app $D $A) (&i* (&det0 $A) (app $D $I))))
    "但是" (&= (app $D $I) (&det (&i* $I $B)) (&det $B)) ", 那么"
    (MB (&= (&det AB) (app $D $A) (&i* (&det0 $A) (&det0 $B)))))
   (P (&= (&sgn (@ (&i* $sigma $tau)))
          (&i* @sgnσ
               (@ (&sgn $tau))))
      "仅是定理3的众多推论之一. 我们将在下一节考虑其中一些推论.")
   ((exercise #:n "1")
    "如果" $K "是一个含幺交换环, 而" $K "上的矩阵"
    (MB (&= $A (Mat ($0 $a $b)
                    ((&- $a) $0 $c)
                    ((&- $b) (&- $c) $0))))
    "证明" (&= detA $0) ".")
   ((exercise #:n "2")
    "证明Vandermonde矩阵"
    (MB (Mat ($1 $a $a^2)
             ($1 $b $b^2)
             ($1 $c $c^2)))
    "的行列式为" (&i* (@ (&- $b $a)) (@ (&- $c $a)) (@ (&- $c $b))) ".")
   ((exercise #:n "3")
    "显式列出所有的六个" $3 "阶置换, 判断它们是奇是偶, 然后给出" (&c* $3 $3)
    "行列式的完整公式.")
   ((exercise #:n "4")
    "令" $sigma "和" $tau "是" $4 "阶置换, 其由"
    (&cm (&= σ1 $2) (&= σ2 $3)
         (&= (ap $sigma $3) $4) (&= (ap $sigma $4) $1))
    "和"
    (&cm (&= (ap $tau $1) $3) (&= (ap $tau $2) $1)
         (&= (ap $tau $3) $2) (&= (ap $tau $4) $4))
    "定义."
    (Ol #:attr* '((type "a"))
        (Li "判断" $sigma "和" $tau "奇偶性.")
        (Li "找出" (&i* $sigma $tau) "和" (&i* $tau $sigma) ".")))
   ((exercise #:n "5")
    "如果" $A "是一个" n*n "的可逆矩阵, 证明" (&!= detA $0) ".")
   ((exercise #:n "6")
    "如果" $A "是某个域上的" 2*2 "矩阵, 证明"
    (&= (&det (&+ $I $A)) (&+ $1 detA)) "当且仅当"
    (&= (&trace $A) $0) "."
    )
   ((exercise #:n "7")
    "一个" n*n "的矩阵" $A "被称为三角的, 若每当" (&> $i $j)
    "即有" (&= Aij $0) ", 或是每当" (&< $i $j)
    "即有" (&= Aij $0) ". 证明三角矩阵的行列式是其对角线元素之积"
    (&i* (mref $A $1 $1) (mref $A $2 $2) $..c (mref $A $n $n)) ".")
   ((exercise #:n "8")
    "令" $A "是复数域上的一个" (&c* $3 $3) "矩阵. 我们构造一个矩阵"
    (&- (&i* $x $I) $A) ", 其元素是多项式, 该矩阵第" $i "行" $j "列的元素是"
    (&- (&i* δij $x) Aij) ". 如果"
    (&= $f (&det (&- (&i* $x $I) $A))) ", 证明" $f "是一个次数为" $3
    "的首项次数为一的多项式. 如果我们将多项式写成"
    (MB (&= $f (&i* (@- $x $c_1) (@- $x $c_2) (@- $x $c_3))))
    "其中" (&cm $c_1 $c_2 $c_3) "是复数, 证明"
    (MB (&= (&+ $c_1 $c_2 $c_3) (&trace $A))
        "和"
        (&= (&i* $c_1 $c_2 $c_3) detA)))
   ((exercise #:n "9")
    "令" $n "是一个正整数而" $F "是一个域, 如果" $sigma "是一个" $n "阶置换, 证明函数"
    (MB (&= (appl $T $x_1 $..h $x_n)
            (tu0 (_ $x σ1) $..h (_ $x σn))))
    "是一个" $F^n "上的可逆线性算子.")
   ((exercise #:n "10")
    "令" $F "是一个域, " $n "是一个正整数, " $S "是域" $F "上的" n*n "所有矩阵的集合. "
    "令" $V "是一个从" $S "到" $F "的所有函数构成的向量空间, 令" $W
    "是" $S "上交错" $n "线性形式的集合. 证明" $W "是" $V "的一个子空间. "
    $W "的维数又是多少?")
   ((exercise #:n "11")
    "令" $T "是" $F^n "上的一个线性算子. 定义"
    (MB (&= (appl $D_T $alpha_1 $..h $alpha_n)
            (appl $det (ap $T $alpha_1) $..h (ap $T $alpha_n))))
    (Ol #:attr* '((type "a"))
        (Li "证明" $D_T "是一个交错的" $n "线性函数.")
        (Li "如果"
            (MB (&= $c (appl $det (ap $T $epsilon_1) $..h (ap $T $epsilon_n))))
            "证明对于任意的" $n "个向量" alpha_1..n "我们有"
            (MB (&= (appl $det (ap $T $alpha_1) $..h (ap $T $alpha_n))
                    (&i* $c (appl $det $alpha_1 $..h $alpha_n))))
            )
        (Li "如果" $BBB "是" $F^n "任意的有序基, " $A "是" $T "在有序基" $BBB
            "下的矩阵, 证明" (&= detA $c) ".")
        (Li "你觉得标量" $c "的合理名字是什么?")))
   ((exercise #:n "12")
    "如果" $sigma "是一个" $n "阶置换, " $A "是一个以" alpha_1..n
    "为行向量的域" $F "上的" n*n "矩阵, 令" (app $sigma $A)
    "代表以" (&cm (_ $alpha σ1) $..h (_ $alpha σn))
    "为行向量的" n*n "矩阵."
    (Ol #:attr* '((type "a"))
        (Li "证明" (&= (app $sigma AB) (&i* (app $sigma $A) $B)) "并且特别地, "
            (&= (app $sigma $A) (&i* (app $sigma $I) $A)) ".")
        (Li "如果" $T "是练习9中的线性算子, 证明" $T "在标准有序基下的矩阵是"
            (app $sigma $I) ".")
        (Li (app (inv $sigma) $I) "是" (app $sigma $I) "的逆矩阵吗?")
        (Li (app $sigma $A) "相似于" $A "吗?")))
   ((exercise #:n "13")
    "证明置换的符号函数在以下意义上是唯一的. 如果" $f "是一个函数, 其赋每个" $n
    "阶置换以一个整数, 并且" (preserve* $f $sigma $tau)
    ", 那么要么" $f "恒为" $0 ", 要么" $f "是符号函数.")
   (H3 "第5.4节 行列式的额外性质")
   (P "本节我们将讲述" n*n "矩阵上的行列式函数的一些有用性质. "
      "或许首先应该注意到以下事实. 在我们对于" detA "的讨论中, " $A
      "的行扮演着具有特权的角色. 既然行和列本质上没有区别, 那么读者也会期望" detA
      "是" $A "的列的交错的" $n "线性函数. 诚然如此, 而为了证明它, 仅需要证明"
      (MB (&= (&det $A^t) detA))
      "就够了, 其中" $A^t "代表" $A "的转置. ")
   (P "如果" $sigma "是一个" $n "阶置换,"
      (MB (&= (appl $A^t $i (ap $sigma $i))
              (appl $A (ap $sigma $i) $i)))
      "根据行列式的公式, 我们可以得到"
      (MB (&= (&det $A^t)
              (sum $sigma $
                   (&i* @sgnσ
                        (appl $A σ1 $1)
                        $..c
                        (appl $A σn $n)))))
      "当" (&= $i (ap (inv $sigma) $j)) "时, "
      (&= (appl $A (ap $sigma $i) $i)
          (appl $A $j (ap (inv $sigma) $j)))
      ", 因此"
      (MB (&= (&i* (appl $A σ1 $1)
                   $..c
                   (appl $A σn $n))
              (&i* (appl $A $1 (ap (inv $sigma) $1))
                   $..c
                   (appl $A $n (ap (inv $sigma) $n)))))
      "既然" (&i* $sigma (inv $sigma)) "是恒等置换, 那么"
      (MB (&= (&i* @sgnσ (@ (&sgn (inv $sigma)))) $1)
          "或"
          (&= (&sgn (@ (inv $sigma))) (&sgn (@ $sigma))))
      "而且, 当" $sigma "遍历所有" $n "阶置换时, " (inv $sigma)
      "也遍历了所有的" $n "阶置换. 因此,"
      (MB (deriv (&det $A^t)
                 (sum $sigma $
                      (&i* (@ (&sgn (inv $sigma)))
                           (appl $A $1 (ap (inv $sigma) $1))
                           $..c
                           (appl $A $n (ap (inv $sigma) $n))))
                 detA))
      "证明完毕.")
   (P "在特定场合, 读者需要计算特定的行列式. 当不得不进行计算时, 以下事实往往是很有用的. "
      "如果" $B "是由" $A "通过将某一行的倍数加到另一行上去 (或者将某一列的倍数加到"
      "另一列上去) 得到的, 那么"
      (MB (&= (&det $B) detA))
      "我们将证明关于行的陈述. 令" $B "是" $A "由加" (&i* $c $alpha_j) "到"
      $alpha_i "上得到的, 其中" (&!= $i $j) ". "
      "[译注: 原文是" (&< $i $j) ", 疑有误.] "
      "既然" $det "对于第" $i "行是线性的, 那么"
      (MB (deriv (&det $B)
                 (&+ detA
                     (&i* $c (appl $det $alpha_1 $..h $alpha_j
                                   $..h $alpha_j $..h $alpha_n)))
                 detA))
      "[译注: 当然这也用到交错性.]")
   (P "另一个有用的事实如下. 设我们拥有一个分块形式的" n*n "矩阵"
      (MB (Mat ($A $B) ($0 $C)))
      "其中" $A "是一个" (&c* $r $r) "的矩阵, 而" $C "是一个" (&c* $s $s)
      "的矩阵, " $B "是一个" (&c* $r $s) "矩阵, " $0 "是一个" (&c* $s $r)
      "的零矩阵, 那么"
      (MB (&= (ap $det (Mat ($A $B) ($0 $C)))
              (&i* (&det0 $A) (&det0 $C))))
      "为了证明这个, 我们定义"
      (MB (&= (appl $D $A $B $C) (ap $det (Mat ($A $B) ($0 $C)))))
      "如果我们固定" $A "和" $B ", 那么" $D "对于" $C "的行而言是一个交错的" $s
      "线性函数. 因此, 根据定理2,"
      (MB (&= (appl $D $A $B $C) (&i* (&det0 $C) (appl $D $A $B $I))))
      "其中" $I "是" (&c* $s $s) "的恒等矩阵. 通过给" $B "的行减去" $I
      "的行的倍数, 我们得到了"
      (MB (&= (appl $D $A $B $I) (appl $D $A $0 $I)))
      "现在" (appl $D $A $0 $I) "显然对于" $A "的行是一个交错的" $r "线性函数, 因此"
      (MB (&= (appl $D $A $0 $I) (&i* (&det0 $A) (appl $D $I $0 $I))))
      "但是" (&= (appl $D $I $0 $I) $1) ", 于是"
      (MB (deriv (appl $D $A $B $C)
                 (&i* (&det0 $C) (appl $D $A $B $I))
                 (&i* (&det0 $C) (appl $D $A $0 $I))
                 (&i* (&det0 $C) (&det0 $A))))
      "通过类似的论证, 或者通过转置, 可以得到"
      (MB (&= (ap $det (Mat ($A $0) ($B $C)))
              (&i* (&det0 $A) (&det0 $C)))))
   ((example #:n "6")
    "设" $K "是有理数域, 我们希望计算" (&c* $4 $4) "矩阵"
    (MB (&= $A (Mat ($1 $-1 $2 $3)
                    ($2 $2 $0 $2)
                    ($4 $1 $-1 $-1)
                    ($1 $2 $3 $0))))
    "的行列式." (Br)
    "通过给第" (&cm $2 $3 $4) "行减去第" $1 "行的适当倍数, 我们就得到了"
    (MB (Mat ($1 $-1 $2 $3)
             ($0 $4 $-4 $-4)
             ($0 $5 $-9 (&- 13))
             ($0 $3 $1 $-3)))
    "我们知道其与" $A "有着相同的行列式. 如果我们给第" $3 "行减去" 5/4
    "倍的第" $2 "行, 给第" $4 "行减去" 3/4 "倍的第" $2 "行, 就得到了"
    (MB (&= $B (Mat ($1 $-1 $2 $3)
                    ($0 $4 $-4 $-4)
                    ($0 $0 $-4 $-8)
                    ($0 $0 $4 $0))))
    "又一次, 我们知道" (&= (&det $B) detA) ". " $B "的分块形式告诉我们"
    (MB (&= detA (&det $B)
            (&i* (Det ($1 $-1) ($0 $4))
                 (Det ($-4 $-8) ($4 $0)))
            (&c* $4 32)
            128)))
   (P "现在我们令" (&> $n $1) ", 令" $A "是" $K "上的" n*n "矩阵. "
      "在定理1中, 我们呈现了如何从" (&c* (@- $n $1) (@- $n $1))
      "矩阵上的行列式函数构造" n*n "矩阵上的行列式函数. "
      "既然现在我们已经证明了行列式的唯一性, 这告诉我们, 如果固定列数" $j ", 那么"
      (MB (&= detA
              (sum (&= $i $1) $n
                   (&i* (^ (@ $-1) (&+ $i $j))
                        Aij
                        (ap $det (bra0 (subm $A $i $j)))))))
      "标量" (&i* (^ (@ $-1) (&+ $i $j)) (ap $det (bra0 (subm $A $i $j))))
      "通常被称为" $A "的" (&cm $i $j) "代数余子式, 或者" $A "的第" $i "行" $j "列"
      "的代数余子式. [译注: &quot;代数余子式&quot;的英文是&quot;cofactor&quot;.] "
      "那么, 以上关于" detA "的公式被称为" detA "按第" $j "列的代数余子式展开 "
      "(有的时候也被称为按第" $j "列的余子式 (minor) 展开). 如果我们令"
      (MB (&= (mref $C $i $j)
              (&i* (^ (@ $-1) (&+ $i $j)) (ap $det (bra0 (subm $A $i $j))))))
      "那么以上公式即对于每个" $j ","
      (MB (&= detA
              (sum (&= $i $1) $n (&i* Aij (mref $C $i $j)))))
      "其中代数余子式" (mref $C $i $j) "为" (^ (@ $-1) (&+ $i $j)) "乘上一个"
      (&c* (@- $n $1) (@- $n $1)) "矩阵的行列式, 这个矩阵是由" $A
      "删去第" $i "行和第" $j "列得到的.")
   (P "如果" (&!= $j $k) ", 那么"
      (MB (&= (sum (&= $i $1) $n (&i* (mref $A $i $k) (mref $C $i $j))) $0))
      "这是因为, 如果将" $A "的第" $j "列替换以第" $k "列, 并称结果为" $B ", 那么"
      $B "有相等的两列, 于是" (&= (&det $B) $0) ". 既然"
      (&= (subm $B $i $j) (subm $A $i $j)) ", 我们有"
      (MB (deriv $0 (&det $B)
                 (sum (&= $i $1) $n
                      (&i* (^ (@ $-1) (&+ $i $j))
                           (mref $B $i $j)
                           (ap $det (bra0 (subm $B $i $j)))))
                 (sum (&= $i $1) $n
                      (&i* (^ (@ $-1) (&+ $i $j))
                           (mref $A $i $k)
                           (ap $det (bra0 (subm $A $i $j)))))
                 (sum (&= $i $1) $n
                      (&i* (mref $A $i $k) (mref $C $i $j)))))
      "代数余子式的这些性质可以被总结为"
      (MB (&= (sum (&= $i $1) $n
                   (&i* (mref $A $i $k) (mref $C $i $j)))
              (&i* (_ $delta (&cm $j $k)) detA))))
   (P n*n "矩阵" (ap (Mi "adj") $A) ", 其是" $A "的代数余子式的矩阵的转置, "
      "被称为" $A "的古典伴随, 因此"
      (MB (&= (mref (&adj $A) $i $j)
              (mref $C $j $i)
              (&i* (^ (@ $-1) (&+ $i $j))
                   (ap $det (bra0 (subm $A $j $i))))))
      "那么以上关于代数余子式的性质, 可以被转写成以下形式."
      (MB (&= (&i* (&adj $A) $A) (&i* (&det0 $A) $I)))
      "我们也希望看到"
      (&= (&i* $A (&adj $A)) (&i* (&det0 $A) $I))
      ". 既然" (&= (subm $A^t $i $j) (^ (bra0 (subm $A $j $i)) $t)) ", 我们有"
      (MB (&= (&i* (^ (@ $-1) (&+ $i $j))
                   (ap $det (bra0 (subm $A^t $i $j))))
              (&i* (^ (@ $-1) (&+ $j $i))
                   (ap $det (bra0 (subm $A $j $i))))))
      "这简单说来就是" $A^t "的" (&cm $i $j) "代数余子式等于" $A "的"
      (&cm $j $i) "代数余子式. 因此,"
      (MB (&= (app $adj $A^t) (^ (&adj $A) $t)))
      "应用" (&= (&i* (&adj $A) $A) (&i* (&det0 $A) $I)) "于" $A^t ", 我们就得到"
      (MB (&= (&i* (&adj $A^t) $A^t)
              (&i* (&det0 $A^t) $I)
              (&i* (&det0 $A) $I)))
      "再进行转置"
      (MB (&= (&i* $A (^ (bra0 (app $adj $A^t)) $t)) (&i* (&det0 $A) $I)))
      "使用" (&= (app $adj $A^t) (^ (&adj $A) $t)) ", 我们得到了我们想要的"
      (MB (&= (&i* $A (&adj $A)) (&i* (&det0 $A) $I))))
   (P "就像域上的矩阵, 一个" $K "上的" n*n "矩阵被称为在" $K "上可逆, 如果存在" $K
      "上的" n*n "矩阵" (inv $A) "满足" (&= (&i* $A (inv $A)) (&i* (inv $A) $A) $I)
      ". 若逆矩阵存在, 则它是唯一的, 因为第1章使用的相同论证表明当"
      (&= (&i* $B $A) (&i* $A $C) $I) "时我们有" (&= $B $C) ". "
      "上面关于古典伴随的公式告诉我们以下关于" $K "上矩阵的可逆性的事实. "
      "如果" detA "在" $K "中具有乘法逆元, 那么" $A "是可逆的, 并且"
      (&= (inv $A) (&i* (inv (&det0 $A)) (&adj $A))) "是" $A "唯一的逆元. "
      "反过来说, 很容易看出来如果" $A "在" $K "上可逆, 那么" detA
      "在" $K "中可逆, 因为如果" (&= AB $I) ", 那么"
      (MB (&= $1 (&det $I) (&det AB) (&i* (&det0 $A) (&det0 $B))))
      "我们已经证明的是以下定理.")
   ((theorem #:n "4")
    "令" $A "是" $K "上的一个" n*n "矩阵, 那么" $A "是" $K "上的可逆矩阵当且仅当"
    detA "在" $K "中可逆. 当" $A "可逆的时候, " $A "唯一的逆元是"
    (MB (&= (inv $A) (&i* (inv (&det0 $A)) (&adj $A))))
    "特别地, 域上的" n*n "矩阵可逆当且仅当其行列式异于零.")
   (P "我们应该指出这个可逆性的行列式判则也证明了有左逆或右逆的" n*n "矩阵可逆. "
      "这个证明独立于我们在第1章中为域上的矩阵给出的. 我们还应该指出可逆性对于"
      "多项式环上的矩阵意味着什么. 如果" $K "是多项式环" polyF ", 那么"
      $K "中仅有的可逆元素是非零的标量多项式, 因为若" $f "和" $g "是多项式且有"
      (&= (&i* $f $g) $1) ", 那么" (&= (&+ (&deg $f) (&deg $g)) $0) ", 于是"
      (&= (&deg $f) (&deg $g) $0) ", 即" $f "和" $g "都是非零的标量多项式. 因此, "
      "一个多项式环" polyF "上的" n*n "矩阵在" polyF
      "上可逆当且仅当其行列式是一个非零的标量多项式.")
   ((example #:n "7")
    "令" (&= $K (&poly $RR)) ", 即实数域上的多项式环, 令"
    (MB (&cm (&= $A (Mat ((&+ $x^2 $x) (&+ $x $1))
                         ((&- $x $1) $1)))
             (&= $B (Mat ((&- $x^2 $1) (&+ $x $2))
                         ((&+ (&- $x^2 (&i* $2 $x)) $3) $x)))))
    "接着, 根据简单的计算, " (&= detA (&+ $x $1)) ", "
    (&= (&det $B) $-6) ". 因此, " $A "在" $K "上不可逆, 而" $B "在" $K "上可逆. "
    "注意到"
    (MB (&cm (&= (app $adj $A)
                 (Mat ($1 (&- (&- $x) $1))
                      ((&+ (&- $x) $1) (&+ $x^2 $x))))
             (&= (app $adj $B)
                 (Mat ($x (&- (&- $x) $2))
                      ((&- (&+ (&- $x^2) (&i* $2 $x)) $3) (&- $x^2 $1))))))
    "并且" (&= (&i* (&adj $A) $A) (&i* (@ (&+ $x $1)) $I)) ", "
    (&= (&i* (&adj $B) $B) (&i* $-6 $I)) ". 当然,"
    (MB (&= (inv $B)
            (&i* -1/6
                 (Mat ($x (&- (&- $x) $2))
                      ((&- (&+ (&- $x^2) (&i* $2 $x)) $3) (&- $x^2 $1))))))
    "[译注: 原文将" (&- $x^2 $1) "写成了" (&- $1 $x^2) ", 应该是笔误.]")
   ((example #:n "8")
    "令" $K "是整数环, 并且"
    (MB (&= $A (Mat ($1 $2) ($3 $4))))
    "那么" (&= detA $-2) ","
    (MB (&= (app $adj $A)
            (Mat ($4 $-2)
                 ($-3 $1))))
    "因此, " $A "作为一个整数环上的矩阵是不可逆的. 然而, 我们也可以将" $A
    "当成有理数域上的矩阵, 那么" $A "就可逆了, 并且"
    (MB (&= $A (&i* -1/2 (Mat ($4 $-2) ($-3 $1)))
            (Mat ($-2 $1) (3/2 -1/2))))
    "[译注: 原文将" -1/2 "写成了" $1/2 ", 应该是笔误.]")
   (P "与可逆矩阵有关, 我们想要提及一个更加初等的事实. 相似矩阵具有相同的行列式, 即若"
      $P "在" $K "上可逆, 并有" (&= $B (&i* (inv $P) $A $P)) ", 那么"
      (&= (&det $B) detA) ". 这很显然, 因为"
      (MB (&= (&det (&i* (inv $P) $A $P))
              (&i* (&det0 (inv $P)) (&det0 $A) (&det0 $P))
              detA))
      "这个简单的观察使得定义有限维向量空间上的线性算子的行列式是可能的. 如果" $T
      "是" $V "上的一个线性算子, 那么我们定义" $T "的行列式为任何在" $V "的某个有序基下"
      "表示" $T "的" n*n "矩阵的行列式. 因为这样的矩阵都是相似的, 所以我们的定义是"
      "有意义的. 在此联系之下, 看看第5.3节的练习11.")
   (P "现在我们想要讨论以下求解线性方程组的Cramer法则. 设" $A "是一个域" $F
      "上的" n*n "矩阵, 我们想要求解线性方程组" AX=Y ", 对于某个给定的" $n "元组"
      (tu0 $y_1 $..h $y_n) ". 若" AX=Y ", 那么"
      (MB (&= (&i* (&adj $A) $A $X) (&i* (&adj $A) $Y)))
      "于是"
      (MB (&= (&i* (&det0 $A) $X) (&i* (&adj $A) $Y)))
      "因此"
      (MB (deriv (&i* (&det0 $A) $x_j)
                 (sum (&= $i $1) $n
                      (&i* (mref (&adj $A) $j $i) $y_i))
                 (sum (&= $i $1) $n
                      (&i* (^ (@ $-1) (&+ $i $j))
                           $y_i
                           (ap $det (bra0 (subm $A $i $j)))))
                 ))
      "最后一个表达式的值是由将" $A "的第" $j "列替换为" $Y "得到的" n*n "矩阵的行列式. "
      "如果" (&= detA $0) ", 那么它什么也没有告诉我们. 然而, 若" (&!= detA $0)
      ", 那么我们就得到了所谓的Cramer法则. 令" $A "是一个域" $F "上的" n*n "矩阵满足"
      (&!= detA $0) ", 如果" (&cm $y_1 $..h $y_n) "是" $F "中任意的标量, 那么"
      "线性方程组" AX=Y "的唯一解" (&= $X (&i* (inv $A) $Y)) "由"
      (MB (&cm (&= $x_j (~ (&det $B_j) detA))
               (&= $j (&cm $1 $..h $n))))
      "给出, 其中" $B_j "是由将" $A "的第" $j "列替换为" $Y "得到的" n*n "矩阵.")
   (P "在本章的末尾, 我们想要作出一些评注, 以将行列式置于我们所认为的适当位置. "
      "我们时常不得不计算一些特定的行列式, 而本节的很大一部分是在处理相关的技巧. "
      "然而, 在本书之中, 行列式的主要地位是理论性的. "
      "这不是要否认某些结果的漂亮, 例如Cramer法则. 但是对于求解线性方程组而言Cramer法则"
      "是一个并不有效的工具, 主要是因为它牵扯太多的计算. "
      "因此, 读者应该关注Cramer法则说了什么, 而不是如何利用它进行计算. "
      "的确, 在回顾整个章节的时候, 我们希望读者将更多的精力放在理解行列式函数是什么以及"
      "它具有怎样的行为上, 而不是计算特定矩阵的行列式. "
      "[译注: 的确这不是本章的末尾, 但是原文的确使用的是&quot;chapter&quot;, "
      "这大概是因为后文是之后补充的高级部分.]")
   ((exercise #:n "1")
    "使用古典伴随公式计算下列" (&c* $3 $3) "实矩阵的逆."
    (MB (&cm (Mat ($-2 $3 $2)
                  ($6 $0 $3)
                  ($4 $1 $-1))
             (Mat ((&cos $theta) $0 (&- (&sin $theta)))
                  ($0 $1 $0)
                  ((&sin $theta) $0 (&cos $theta)))
             ))
    )
   ((exercise #:n "2")
    "使用Cramer法则计算下列每个有理数域上的线性方程组的解."
    (Ol #:attr* '((type "a"))
        (Li (MB
             (Ttle
              (Choice
               ($x $+ $y $+ $z $= 11)
               ((&i* $2 $x) $- (&i* $6 $y) $- $z $= $0)
               ((&i* $3 $x) $+ (&i* $4 $y) $+ (&i* $2 $z) $= $0)))))
        (Li (MB
             (Ttle
              (Choice
               ((&i* $3 $x) $- (&i* $2 $y) $= $7)
               ((&i* $3 $y) $- (&i* $2 $z) $= $6)
               ((&i* $3 $z) $- (&i* $2 $x) $= $-1)))))))
   ((exercise #:n "3")
    "一个域" $F "上的" n*n "矩阵" $A "被称为斜对称的, 如果" (&= $A^t (&- $A))
    ". 如果" $A "是一个复数域上的" n*n "的斜对称矩阵, 并且" $n "是奇数, 证明"
    (&= detA $0) ".")
   ((exercise #:n "4")
    "一个域" $F "上的" n*n "矩阵" $A "被称为正交的, 如果" (&= (&i* $A $A^t) $I)
    ". 如果" $A "是正交的, 证明" (&= detA (&+- $1)) ". 给出一个正交矩阵" $A
    "的例子, 其行列式" (&= detA $-1) ".")
   ((exercise #:n "5")
    "一个复数域上的" n*n "矩阵被称为是酉的 (unitary), 如果" (&= (&i* $A (ctrans $A)) $I)
    " (" (ctrans $A) "代表" $A "的共轭转置). 如果" $A "是酉矩阵, 证明"
    (&= (&abs detA) $1) ".")
   ((exercise #:n "6")
    "令" $T "和" $U "是有限维向量空间" $V "上的线性算子, 证明"
    (Ol #:attr* '((type "a"))
        (Li (&= (&det (&i* $T $U)) (&i* (&det0 $T) (&det0 $U))) ";")
        (Li $T "可逆当且仅当" (&!= (&det $T) $0) ".")))
   ((exercise #:n "7")
    "令" $A "是一个含幺交换环" $K "上的" n*n "矩阵, 设" $A "具有分块形式"
    (MB (&= $A (Mat ($A_1 $0 $..c $0)
                    ($0 $A_2 $..c $0)
                    ($..v $..v $ $..v)
                    ($0 $0 $..c $A_k))))
    "其中" $A_j "是一个" (&c* $r_j $r_j) "矩阵. 证明"
    (MB (&= detA (&i* (&det0 $A_1) (&det0 $A_2) $..c (&det0 $A_k))))
    )
   ((exercise #:n "8")
    "令" $V "是域" $F "上的" n*n "矩阵构成的向量空间, 令" $B "是" $V
    "的一个固定元素. 令" $T_B "是一个" $V "上的线性算子, 由"
    (&= (app $T_B $A) (&- AB (&i* $B $A))) "定义. 证明"
    (&= (&det $T_B) $0) ".")
   ((exercise #:n "9")
    "令" $A "是域" $F "上的一个" n*n "矩阵, 并且" (&!= $A $0) ". "
    "如果" $r "是一个" $1 "和" $n "之间的正整数, 那么" $A "的" (&c* $r $r)
    "子矩阵是由" $A "删去" (@- $n $r) "行和" (@- $n $r) "列得到的. "
    $A "的行列式秩是最大的正整数" $r ", 满足存在" $A "的某个" (&c* $r $r)
    "子矩阵其行列式不为零. 证明" $A "的行列式秩等于" $A "的行秩, 当然也等于" $A "的列秩.")
   ((exercise #:n "10")
    "令" $A "是一个域" $F "上的" n*n "矩阵. 证明至多存在" $n "个不同的标量" $c
    "满足" (&= (&det (&- (&i* $c $I) $A)) $0) ".")
   ((exercise #:n "11")
    "令" $A "和" $B "是域" $F "上的" n*n "矩阵. 证明如果" $A "可逆, 那么至多存在" $n
    "个不同的标量" $c "使得矩阵" (&+ (&i* $c $A) $B) "不可逆.")
   ((exercise #:n "12")
    "如果" $V "是域" $F "上的" n*n "矩阵的向量空间, " $B "是" $F "上一个固定的" n*n
    "矩阵, 令" $L_B "和" $R_B "是" $V "上的线性算子, 由"
    (&= (app $L_B $A) (&i* $B $A)) "和" (&= (app $R_B $A) AB) "定义. 证明"
    (Ol #:attr* '((type "a"))
        (Li (&= (&det $L_B) (^ (&det0 $B) $n)) ";")
        (Li (&= (&det $R_B) (^ (&det0 $B) $n)) ".")))
   ((exercise #:n "13")
    "令" $V "是复数域上所有的" n*n "矩阵构成的向量空间, 令" $B "是" $CC "上一个固定的"
    n*n "矩阵. 由" (&= (app $M_B $A) (&i* $B $A (ctrans $B)))
    "定义一个" $V "上的线性算子" $M_B ", 其中"
    (&= (ctrans $B) (OverBar $B^t)) ". 证明"
    (MB (&= (&det $M_B) (^ (&abs (&det $B)) (&i* $2 $n))))
    "现在令" $H "是" $V "中所有的Hermite矩阵构成的集合, 称" $A "是Hermite的, 如果"
    (&= $A (ctrans $A)) ", 那么" $H "是实数域上的一个向量空间. "
    "证明由" (&= (app $T_B $A) (&i* $B $A (ctrans $B))) "定义的函数" $T_B
    "实向量空间" $H "上的一个线性算子, 并证明"
    (&= (&det $T_B) (^ (&abs (&det $B)) (&i* $2 $n))) ". "
    "(提示: 计算" $T_B "的时候表明" $V "具有一个由Hermite矩阵构成的基, 然后证明"
    (&= (&det $T_B) (&det $M_B)) ".)")
   ((exercise #:n "14")
    "令" (&cm $A $B $C $D) "是域" $F "上" n*n "的可交换矩阵, 证明"
    (&c* (&i* $2 $n) (&i* $2 $n)) "矩阵"
    (MB (Mat ($A $B)
             ($C $D)))
    "的行列式为" (&det (&- (&i* $A $D) (&i* $B $C))) ".")
   (H3 "第5.5节 模")
   (P "如果" $K "是一个含幺交换环 [译注: 本章的剩余部分, 凡提到含幺交换环, 均默认是非平凡的], 一个"
      $K "上的模是一种表现得类似于向量空间的代数系统, "
      "其中" $K "扮演着类似于标量域的角色. 为了精确起见, 我们称" $V "是一个" $K "上的模 "
      "(或者一个" $K "模) 如果"
      (Ol (Li $V "上存在一个加法" (&\|-> (tu0 $alpha $beta) (&+ $alpha $beta)) ", "
              $V "在其下是一个交换群;")
          (Li "存在一个乘法" (&\|-> (tu0 $c $alpha) (&i* $c $alpha)) ", 其中"
              $alpha "在" $V "之中, " $c "在" $K "之中, 满足"
              (MB ((Ttable (lambda (d i j)
                             (cond ((= j 0) (set-attr* d 'columnalign "right"))
                                   ((= j 2) (set-attr* d 'columnalign "left"))
                                   (else d))))
                   (&Table
                    ((&i* (@ (&+ $c_1 $c_2)) $alpha)
                     $=
                     (&+ (&i* $c_1 $alpha) (&i* $c_2 $alpha)))
                    ((&i* $c (@ (&+ $alpha_1 $alpha_2)))
                     $=
                     (&+ (&i* $c $alpha_1)
                         (&i* $c $alpha_2)))
                    ((&i* (@ (&i* $c_1 $c_2)) $alpha)
                     $=
                     (&i* $c_1 (@ (&i* $c_2 $alpha))))
                    ((&i* $1 $alpha) $= $alpha)))))))
   (P "对于我们而言, 最重要的" $K "模是" $n "元组的模" $K^n ". 矩阵模" (^ $K m*n)
      "也很重要. 如果" $V "是一个模, 我们可以讨论线性组合, 线性相关和线性无关, 就像在向量空间里一样. "
      "我们必须小心不将依赖于非零标量的可逆性的向量空间的结果应用于" $V
      ", 因为在域中可以施行的除法不一定在环" $K "中可以进行. 例如, 如果"
      (&cm $alpha_1 $..h $alpha_k) "是线性相关的, 我们不能断言某个" $alpha_i
      "可以被表示为其他元素的线性组合. 这使得在模中寻找基变得更加困难.")
   (P "模" $V "的一个基是一个线性无关的子集, 其可以张成 (或者说生成) 这个模. "
      "这与我们对于向量空间给出的定义是一样的. 一个基" $BBB "的重要性质在于每个" $V
      "的元素都可以被唯一地表示为" $BBB "的 (有限数目的) 元素的线性组合. 如果承认选择公理 (见附录) 的话, "
      "那么可以证明每个向量空间都拥有一个基. 读者已经很清楚若是一个向量空间可由有限数目的向量张成, 那么"
      "它肯定拥有一个基, 但是对于模来说这并非如此. 因此, 对于拥有基的模和可由有限数目的元素张成的模, "
      "我们需要特别的不同名字.")
   ((definition)
    $K "模" $V "被称为一个自由模, 如果它拥有一个基. 如果" $V "拥有一个有限的基, 其包含" $n "个元素, 那么"
    $V "被称为具有" $n "个生成元的自由" $K "模.")
   ((definition)
    "模" $V "是有限生成的, 如果它包含一个能够张成" $V "的有限子集. 一个有限生成模的秩是使得某" $k
    "个元素能够张成" $V "的最小整数" $k ".")
   (P "我们需要强调一个模在没有有限的基的情况下仍然可能是有限生成的. 如果" $V "是一个具有"
      $n "个生成元的自由" $K "模, 那么" $V "同构于模" $K^n ". 如果" (setE $beta_1 $..h $beta_n) "是" $V
      "的一个基, 那么存在一个同构, 将向量" (&+ (&i* $c_1 $beta_1) $..c (&i* $c_n $beta_n)) "送至" $K^n
      "中的" $n "元组" (tu0 $c_1 $..h $c_n) ". 我们并不能立即看出来这相同的模" $V "不能也是一个具有"
      $k "个生成元的自由模, 其中" (&!= $k $n) ". 换句话说, " $V "的任意两个基都必然包含相同数目的元素"
      "并非显然的事实, 而其证明是行列式的一个有趣应用.")
   ((theorem #:n "5")
    "令" $K "是一个含幺交换环, 如果" $V "是一个具有" $n "个生成元的自由" $K "模, 那么" $V "的秩是" $n ".")
   ((proof)
    "我们要证明的是" $V "不能由少于" $n "个它的元素张成. 既然" $V "同构于" $K^n ", 我们必须证明, 如果"
    (&< $m $n) ", 那么模" $K^n "不能由" $n "元组" (&cm $alpha_1 $..h $alpha_m) "张成. 令" $A "是以"
    (&cm $alpha_1 $..h $alpha_m) "为行的矩阵. 假设标准基向量" (&cm $epsilon_1 $..h $epsilon_n) "都是"
    (&cm $alpha_1 $..h $alpha_m) "的线性组合, 那么存在矩阵" (&in $P (^ $K (&c* $n $m))) "使得"
    (MB (&= (&i* $P $A) $I))
    "其中" $I "是" n*n "的恒等矩阵. 令" (&~~ $A) "是一个" n*n "的矩阵, 其由" $A "往底部再填充"
    (&- $n $m) "个零行得到. 令" (&~~ $P) "是任意的以" $P "的列为前" $m "列的" n*n "矩阵. 那么,"
    (MB (&= (&i* (&~~ $P) (&~~ $A)) $I) ".")
    "因此, " (&!= (&det (&~~ $A)) $0) ". 但是, 既然" (&< $m $n) ", " (&~~ $A) "至少有一行全为零. "
    "这个矛盾表明" (&cm $alpha_1 $..h $alpha_m) "不能张成" $K^n
    ". [译注: 这里的证明用到了" (&!= $0 $1) ", 也就是说, 排除了平凡环的情况. 另请读者参考维基百科条目"
    (A "invariant basis number" #:attr* '((href "https://en.wikipedia.org/wiki/Invariant_basis_number"))) ".]")
   (P "有趣的是, 读者应该注意到定理5建立了(有限维)向量空间的维数的唯一性. 而且, "
      "这个基于行列式函数的存在性的证明, 与我们第2章所给出的证明截然不同. 从定理5我们知道"
      "&quot;秩为" $n "的自由模&quot;和&quot;具有" $n "个生成元的自由模&quot;是一样的.")
   (P "如果" $V "是" $K "上的一个模, 那么对偶模" V* "由所有从" $V "到" $K "的线性函数"
      $f "构成. 如果" $V "是秩为" $n "的自由模, 那么" V* "也是秩为" $n "的自由模. 这个事实的"
      "证明就和向量空间一样. 如果" (setE $beta_1 $..h $beta_n) "是" $V "的一个有序基, 那么存在与之对应的"
      V* "的对偶基" (setE $f_1 $..h $f_n) ". 函数" $f_i "赋予每个" (&in $alpha $V) "以其相对于"
      (setE $beta_1 $..h $beta_n) "的第" $i "个坐标分量:"
      (MB (&= $alpha (LC0 (app $f_1 $alpha) $beta_1 (app $f_n $alpha) $beta_n)) ".")
      "如果" $f "是" $V "上的一个线性函数, 那么"
      (MB (&= $f (LC0 (app $f $beta_1) $f_1 (app $f $beta_n) $f_n)) "."))
   (H3 "第5.6节 多线性函数")
   (P "本节的目的在于将关于行列式的讨论置于我们所相信的正确视角之下. 我们将处理模上的"
      "交错多线性形式. 这些形式是我们之前呈现的行列式的自然泛化. 还没有阅读 (或者不希望"
      "阅读) 第5.5节对于模的简要总结的读者仍可从学习本节中获益良多, 只要一致地将&quot;"
      $K "上秩为" $n "的自由模&quot;读作&quot;" $F "上维数为" $n "的向量空间&quot;即可.")
   (P "令" $K "是一个含幺交换环, " $V "是" $K "上的一个模. 如果" $r "是一个正整数, 那么从"
      (&= $V^r (&c* $V $V $..c $V)) "到" $K "的函数" $L "被称为多线性的, 如果"
      (appl $L $alpha_1 $..h $alpha_r) "对于每个" $alpha_i "在其他" $alpha_j
      "的值固定的情况下是线性的函数. 也就是说, 对于每个" $i "有"
      (MB (&= (appl $L $alpha_1 $..h (LC $c $alpha_i $beta_i) $..h $alpha_r)
              (LC $c (appl $L $alpha_1 $..h $alpha_i $..h $alpha_r)
                  (appl $L $alpha_1 $..h $beta_i $..h $alpha_r))) ".")
      $V^r "上的多线性函数也被称为" $V "上的" $r "线性形式或者" $V "上的阶数为" $r
      "的多线性形式. 这样的函数有时也被称为" $V "上的" $r "张量. " $V^r
      "上所有多线性形式的集合将被记成" (app $M^r $V) ". 如果" (∈ $L $M (app $M^r $V))
      ", 那么其和" (&+ $L $M) ":"
      (MB (&= (appl (@+ $L $M) $alpha_1 $..h $alpha_r)
              (&+ (appl $L $alpha_1 $..h $alpha_r)
                  (appl $M $alpha_1 $..h $alpha_r))))
      "也是多线性的; 并且, 如果" (∈ $c $K) ", 那么积" (&i* $c $L) ":"
      (MB (&= (appl (@i* $c $L) $alpha_1 $..h $alpha_r)
              (&i* $c (appl $L $alpha_1 $..h $alpha_r))))
      "是多线性的. 因此, " (app $M^r $V) "是一个" $K "模&mdash;&mdash;所有从" $V^r
      "到" $K "的函数构成的模的一个子模.")
   (P "如果" (&= $r $1) ", 那么我们有" (&= (app $M^1 $V) V*) ", 即由线性函数构成的"
      $V "的对偶模. 线性函数也可被用来构造更高阶的多线性形式. 如果" (&cm $f_1 $..h $f_r)
      "是" $V "上的线性函数, 那么"
      (MB (&= (appl $L $alpha_1 $..h $alpha_r)
              (&i* (app $f_1 $alpha_1) (app $f_2 $alpha_2) $..c (app $f_r $alpha_r))))
      "显然是" $V "上的一个" $r "线性形式.")
   ((example #:n "9")
    "如果" $V "是一个模, 那么" $V "上的" $2 "线性形式也常被称为" $V "上的双线性形式 (bilinear form). 令"
    $A "是一个元素来源于" $K "的" n*n "矩阵, 那么"
    (MB (&= (appl $L $X $Y) (&i* $Y^t $A $X)))
    "定义了模" (^ $K n*1) "上的一个双线性形式" $L ". 类似地,"
    (MB (&= (appl $M $alpha $beta) (&i* $alpha $A $beta^t)))
    "定义了一个" $K^n "上的双线性形式" $M ". [译注: 你需要将" (^ $K (&c* $1 $1))
    "和" $K "通过自然的同构视为等同的.]")
   ((example #:n "10")
    "行列式函数将" $K "上的每个" n*n "矩阵与元素" (&in (&det $A) $K) "联系起来. 若"
    (&det $A) "被视为" $A "的行的函数:"
    (MB (&= (&det $A) (appl $D $alpha_1 $..h $alpha_n)))
    "那么" $D "是" $K^n "上的一个" $n "线性形式.")
   ((example #:n "11")
    "很容易得到模" $K^n "上的一般的" $r "线性形式的代数表达式. 如果向量" (∈ $alpha_1 $..h $alpha_r $V)
    "而" $A "是以" (&cm $alpha_1 $..h $alpha_r) "为行的" (&c* $r $n) "矩阵, 那么对于任意的函数"
    (∈ $L (app $M^r $K^n)) "有"
    (MB (deriv (appl $L $alpha_1 $..h $alpha_r)
               (ap $L (tup (sum (&= $j $1) $n (&i* (mref $A $1 $j) $epsilon_j))
                           $alpha_2 $..h $alpha_r))
               (sum (&= $j $1) $n
                    (&i* (mref $A $1 $j)
                         (appl $L $epsilon_j $alpha_2 $..h $alpha_r)))
               (sum (&= $j $1) $n
                    (&i* (mref $A $1 $j)
                         (ap $L (tup $epsilon_j
                                     (sum (&= $k $1) $n (&i* (mref $A $2 $k) $epsilon_k))
                                     $alpha_3 $..h $alpha_r))))
               (sum (&= $j $1) $n
                    (sum (&= $k $1) $n
                         (&i* (mref $A $1 $j)
                              (mref $A $2 $k)
                              (appl $L $epsilon_j $epsilon_k $alpha_3 $..h $alpha_r))))
               (sum (&= (&cm $j $k) $1) $n
                    (&i* (mref $A $1 $j)
                         (mref $A $2 $k)
                         (appl $L $epsilon_j $epsilon_k $alpha_3 $..h $alpha_r)))))
    "如果我们将" (&cm $alpha_3 $..h $alpha_r) "依次替换以其标准基向量下的线性组合, 并且记"
    (mref $A $i $j) "为" (appl $A $i $j) ", 那么我们得到了以下表达式:"
    (MB (&= (appl $L $alpha_1 $..h $alpha_r)
            (sum (&= (&cm $j_1 $..h $j_r) $1) $n
                 (&i* (appl $A $1 $j_1) $..c (appl $A $r $j_r)
                      (appl $L (_ $epsilon $j_1) $..h (_ $epsilon $j_r))))) ".")
    "此表达式中, 每个分量为从" $1 "至" $n "的正整数的" $r "元组" (&= $J (tu0 $j_1 $..h $j_r))
    "与一个项相对应. 这样的" $r "元组有" $n^r "个. 因此, " $L "完全由该表达式以及赋给"
    $n^r "个元素" (tu0 (_ $epsilon $j_1) $..h (_ $epsilon $j_r)) "的特定值:"
    (MB (&= $c_J (appl $L (_ $epsilon $j_1) $..h (_ $epsilon $j_r))))
    "决定. 也很容易看出以下事实, 如果我们为每个" $r "元组" $J "挑选一个元素" (∈ $c_J $K) ", 那么"
    (MB (&= (appl $L $alpha_1 $..h $alpha_r)
            (sum $J $ (&i* (appl $A $1 $j_1) $..c (appl $A $r $j_r) $c_J))))
    "定义了一个" $K^n "上的" $r "线性形式.")
   (P "设" $L "是" $V^r "上的一个多线性形式而" $M "是" $V^s "上的一个多线性形式. 我们定义"
      (^ $V (&+ $r $s)) "上的函数" (&t* $L $M) "为"
      (MB (&= (appl (@t* $L $M) $alpha_1 $..h (_ $alpha (&+ $r $s)))
              (&i* (appl $L $alpha_1 $..h $alpha_r)
                   (appl $M (_ $alpha (&+ $r $1)) $..h (_ $alpha (&+ $r $s))))) ".")
      "如果我们将" (^ $V (&+ $r $s)) "想成是" (&c* $V^r $V^s) ", 那么对于"
      (∈ $alpha $V^r) "和" (∈ $beta $V^s) "有"
      (MB (&= (appl (@t* $L $M) $alpha $beta) (&i* (app $L $alpha) (app $M $beta))) ".")
      "显然" (&t* $L $M) "在" (^ $V (&+ $r $s)) "是多线性的, 其被称为" $L "和" $M
      "的张量积 (tensor product). 张量积不是可交换的. 实际上, 除非" (&= $L $0) "或"
      (&= $M $0) ", " (&!= (&t* $M $L) (&t* $L $M)) ". 然而, 张量积的确与" $M^r "和"
      $M^s "中的模运算漂亮地联系在一起.")
   ((lemma)
    "令" (&cm $L $L_1) "是" $V "上的" $r "线性形式, " (&cm $M $M_1) "是" $V "上的" $s
    "线性形式, " $c "是" $K "的一个元素."
    (Ol #:attr* '((type "a"))
        (Li (&= (&t* (@LC $c $L $L_1) $M) (LC $c (@t* $L $M) (&t* $L_1 $M))) ";")
        (Li (&= (&t* $L (@LC $c $M $M_1)) (LC $c (@t* $L $M) (&t* $L $M_1))) ".")))
   ((proof) "留作练习.")
   (P "张量积的确是可结合的, 例如, 令" (&cm $L $M $N) "分别是" $V "上的" (&cm $r $s $t)
      "线性形式, 那么"
      (MB (&assoc &t* $L $M $N) ".")
      "这从" $K "的乘法的结合律中可立即推出. 因此, 如果" (&cm $L_1 $..h $L_k)
      "是" (&cm (^ $V $r_1) $..h (^ $V $r_k)) "上的多线性函数, 那么张量积"
      (MB (&= $L (&t* $L_1 $..c $L_k)))
      "无歧义地被定义为" $V^r "上的一个多线性函数, 其中" (&= $r (&+ $r_1 $..c $r_k))
      ". 之前我们已经提及了它的一种特殊情形, 即如果" (&cm $f_1 $..h $f_r) "是" $V
      "上的线性函数, 那么张量积"
      (MB (&= $L (&t* $f_1 $..c $f_r)))
      "由"
      (MB (&= (appl $L $alpha_1 $..h $alpha_r)
              (&i* (app $f_1 $alpha_1) $..c (app $f_r $alpha_r))))
      "给出.")
   ((theorem #:n "6")
    "令" $K "是一个含幺交换环. 如果" $V "是一个秩为" $n "的自由" $K "模, 那么"
    (app $M^r $V) "是一个秩为" $n^r "的自由" $K "模. 实际上, 如果"
    (setE $f_1 $..h $f_n) "是对偶模" V* "的一个基, 那么" $n^r "个张量积"
    (MB (&cm (&t* (_ $f $j_1) $..c (_ $f $j_r))
             (&<= $1 $j_1 $n) $..h (&<= $1 $j_r $n)))
    "构成了" (app $M^r $V) "的一个基.")
   ((proof)
    "令" (setE $f_1 $..h $f_n) "是" V* "的一个有序基, 其对偶于" $V "的基"
    (setE $beta_1 $..h $beta_n) ". 对于每个向量" (&in $alpha $V) ", 我们有"
    (MB (&= $alpha (LC0 (app $f_1 $alpha) $beta_1 (app $f_n $alpha) $beta_n)) ".")
    "现在我们进行例子11所施行的计算. 如果" $L "是" $V "上的一个" $r "线性形式而"
    (&cm $alpha_1 $..h $alpha_r) "是" $V "的元素, 那么"
    (MB (&= (appl $L $alpha_1 $..h $alpha_r)
            (sum (&cm $j_1 $..h $j_r) $
                 (&i* (app (_ $f $j_1) $alpha_1) $..c (app (_ $f $j_r) $alpha_r)
                      (appl $L (_ $beta $j_1) $..h (_ $beta $j_r))))) ".")
    "换言之, 即"
    (MB (&= $L (sum (&cm $j_1 $..h $j_r) $
                    (&i* (appl $L (_ $beta $j_1) $..h (_ $beta $j_r))
                         (&t* (_ $f $j_1) $..c (_ $f $j_r))))) ".")
    "这表明由" $r "元组" (&= $J (tu0 $j_1 $..h $j_r)) "给出的" $n^r "个张量积"
    (MB (&= $E_J (&t* (_ $f $j_1) $..c (_ $f $j_r))))
    "可以张成模" (app $M^r $V) ". 我们也可看出这些" $r "形式" $E_J "是线性无关的. 设对于每个"
    $J "我们有一个元素" (∈ $c_J $K) ", 然后我们构造多线性函数"
    (MB (&= $L (sum $J $ (&i* $c_J $E_J))) ".")
    "注意到如果" (&= $I (tu0 $i_1 $..h $i_r)) ", 那么"
    (MB (&= (appl $E_J (_ $beta $i_1) $..h (_ $beta $i_r))
            (Choice0
             ($0 ",&nbsp;" (&!= $I $J))
             ($1 ",&nbsp;" (&= $I $J)))))
    "因而我们看到"
    (MB (&= $c_I (appl $L (_ $beta $i_1) $..h (_ $beta $i_r))) ".")
    "特别地, 如果" (&= $L $0) ", 那么对于每个" $r "元组" $I "都有" (&= $c_I $0) ".")
   ((definition)
    "令" $L "是" $K "模" $V "上的一个" $r "线性形式. 我们称" $L "是交错的, 如果每当"
    (&cm (&= $alpha_i $alpha_j) (&!= $i $j)) "时有" (&= (appl $L $alpha_1 $..h $alpha_r) $0) ".")
   (P "如果" $L "是" $V^r "上的一个交错多线性函数, 那么"
      (MB (&= (appl $L $alpha_1 $..h $alpha_i $..h $alpha_j $..h $alpha_r)
              (&- (appl $L $alpha_1 $..h $alpha_j $..h $alpha_i $..h $alpha_r))) ".")
      "换言之, 交换" $r "元组" (tu0 $alpha_1 $..h $alpha_r) "中两个(不同下标的)向量, 那么与之关联的"
      $L "的值会改变符号 (sign). 既然每个置换" $sigma "都是交换之积, 我们看出"
      (&= (appl $L (_ $alpha σ1) $..h (_ $alpha σr))
          (&i* @sgnσ (appl $L $alpha_1 $..h $alpha_r))) ".")
   (P "我们用" (Alt $r) "表示" $V "上所有交错" $r "线性形式构成的集合. 显然" (Alt $r) "是"
      (app $M^r $V) "的一个子模.")
   ((example #:n "12")
    "本章的早些时候, 我们证明了模" $K^n "上恰存在一个交错" $n "线性形式" $D "满足性质"
    (&= (appl $D $epsilon_1 $..h $epsilon_n) $1) ". 我们也在定理2中证明了如果形式" (∈ $L (Alt $n $K^n))
    ", 那么"
    (MB (&= $L (&i* (appl $L $epsilon_1 $..h $epsilon_n) $D)) ".")
    "换言之, " (Alt $n $K^n) "是一个秩为" $1 "的自由" $K "模. 我们也建立了" $D "的显式公式. "
    "基于我们现在所使用的记号, 其可以记成"
    (MB (&= $D (sum $sigma $ (&i* @sgnσ (&t* (_ $f σ1) $..c (_ $f σn))))))
    "其中" (&cm $f_1 $..h $f_n) "是" $K^n "上的标准坐标函数而其和布于集合" (setE $1 $..h $n)
    "的所有" (&fact $n) "个不同置换" $sigma "之上. 如果我们将一个矩阵" $A "的行列式写成"
    (MB (&= (&det $A) (sum $sigma $ (&i* @sgnσ (appl $A σ1 $1) $..c (appl $A σn $n)))))
    "那么我们就得到了" $D "的一个不同的表达式:"
    (MB (deriv (appl $D $alpha_1 $..h $alpha_n)
               (sum $sigma $ (&i* @sgnσ (app $f_1 (_ $alpha σ1)) $..c (app $f_n (_ $alpha σn))))
               (sum $sigma $ (&i* @sgnσ (appl $L (_ $alpha σ1) $..h (_ $alpha σn))))))
    "其中" (&= $L (&t* $f_1 $..c $f_n)) ".")
   (P "存在一种一般性的方法将一个交错形式与一个多线性形式联系起来. 如果" $L "是模" $V "上的一个"
      $r "线性形式, " $sigma "是" (setE $1 $..h $r) "的一个置换, 那么通过定义"
      (MB (&= (appl $L_sigma $alpha_1 $..h $alpha_r)
              (appl $L (_ $alpha σ1) $..h (_ $alpha σr))))
      "我们就得到了另一个" $r "线性函数" $L_sigma ". 若" $L "碰巧是交错的, 那么"
      (&= $L_sigma (&i* @sgnσ $L)) ". 现在, 对于每个" (∈ $L (app $M^r $V))
      ", 我们通过"
      (MB (&= (ap $pi_r $L) (sum $sigma $ (&i* @sgnσ $L_sigma))))
      "定义一个函数" (∈ (ap $pi_r $L) (app $M^r $V)) ", 即"
      (MB (&= (appl (@ap $pi_r $L) $alpha_1 $..h $alpha_r)
              (sum $sigma $
                   (&i* @sgnσ
                        (appl $L (_ $alpha σ1) $..h (_ $alpha σr))))) "."))
   ((lemma)
    $pi_r "是一个从" (app $M^r $V) "到" (Alt $r) "的线性变换. 如果"
    (∈ $L (Alt $r)) ", 那么" (&= (ap $pi_r $L) (&i* (&fact $r) $L)) ".")
   ((proof)
    "令" $tau "是" (setE $1 $..h $r) "任意的置换, 那么"
    (MB (deriv (appl (@ap $pi_r $L) (_ $alpha (ap $tau $1)) $..h (_ $alpha (ap $tau $r)))
               (sum $sigma $
                    (&i* @sgnσ
                         (appl $L (_ $alpha (ap $tau (ap $sigma $1)))
                               $..h (_ $alpha (ap $tau σr)))))
               (&i* (@sgn $tau)
                    (sum $sigma $
                         (&i* (@sgn (&i* $tau $sigma))
                              (appl $L (_ $alpha (ap $tau (ap $sigma $1)))
                                    $..h (_ $alpha (ap $tau σr))))))))
    "当" $sigma "遍历所有" (setE $1 $..h $r) "的置换时, " (&i* $tau $sigma)
    "也是如此. 因此, 我们有"
    (MB (&= (appl (@ap $pi_r $L) (_ $alpha (ap $tau $1)) $..h (_ $alpha (ap $tau $r)))
            (&i* (@sgn $tau) (appl (@ap $pi_r $L) $alpha_1 $..h $alpha_r))) ".")
    "于是, " (ap $pi_r $L) "是一个交错形式. [译注: 这个论证是有问题的, 因为对于任意的"
    (∈ $x $K) ", 我们并不总是能够保证" (&= (&i* $2 $x) $0) "可以推出" (&= $x $0)
    ", 这点本书之前也有提及.]" (Br)
    "如果" (∈ $L (Alt $r)) ", 那么对于每个" $sigma "有"
    (&= (appl $L (_ $alpha σ1) $..h (_ $alpha σr))
        (&i* @sgnσ (appl $L $alpha_1 $..h $alpha_r)))
    ", 因而" (&= (ap $pi_r $L) (&i* (&fact $r) $L)) ".")
   ((proof)
    "既然以上的论证存在问题, 我们补充一个没有问题的证明. 设对于某" $i "和" $j "满足" (&!= $i $j)
    ", 我们有" (&= $alpha_i $alpha_j) ". 考虑" (setE $1 $..h $r) "的所有置换构成的集合的一个子集"
    (&= $A (setI $sigma (&< (ap $sigma $i) (ap $sigma $j))))
    ". 根据简单的组合推理, 我们知道" $A "的元素个数为" (&/ (&fact $n) $2) ". 再考虑子集"
    (&= $B (setI $tau (&> (ap $tau $i) (ap $tau $j))))
    ", 我们知道" $B "的元素个数也是" (&/ (&fact $n) $2) ", 并且" $A "和" $B
    "构成了一个划分. 现在我们给出一个对换" $upsilon ", 其由"
    (&cm (&= (ap $upsilon $i) $j) (&= (ap $upsilon $j) $i)) "定义, 那么函数"
    (&= (app $f $sigma) (&compose $sigma $upsilon)) "是一个从" $A "到" $B
    "的映射. 并且, 实际上它也可以被视为从" $B "到" $A "的一个映射, 而"
    (&= (&compose $f $f) 'id) ". 那么, 我们知道" (func $f $A $B) "是一个双射, 以及"
    (MB (deriv (appl (@ap $pi_r $L) $alpha_1 $..h $alpha_r)
               (sum $sigma $
                    (&i* @sgnσ
                         (appl $L (_ $alpha σ1) $..h (_ $alpha σr))))
               (&+ (sum (∈ $sigma $A) $
                        (&i* @sgnσ
                             (appl $L (_ $alpha σ1) $..h (_ $alpha σr))))
                   (sum (∈ $tau $B) $
                        (&i* (@sgn $tau)
                             (appl $L (_ $alpha (ap $tau $1)) $..h (_ $alpha (ap $tau $r))))))
               (&+ (sum (∈ $sigma $A) $
                        (&i* @sgnσ
                             (appl $L (_ $alpha σ1) $..h (_ $alpha σr))))
                   (sum (∈ $sigma $A) $
                        (&i* (bra0 (&sgn (app $f $sigma)))
                             (appl $L (_ $alpha (app (app $f $sigma) $1))
                                   $..h (_ $alpha (app (app $f $sigma) $r))))))
               (&+ (sum (∈ $sigma $A) $
                        (&i* @sgnσ
                             (appl $L (_ $alpha σ1) $..h (_ $alpha σr))))
                   (sum (∈ $sigma $A) $
                        (&i* (&- @sgnσ)
                             (appl $L (_ $alpha σ1) $..h (_ $alpha σr)))))
               $0))
    "换句话说, 也就是" (ap $pi_r $L) "是一个交错形式. 剩下的命题论证和原文一致.")
   (P "根据(按列的)公式, 我们知道行列式函数" (∈ $D (Alt $n $K^n)) "是"
      (MB (&= $D (app $pi_n (&t* $f_1 $..c $f_n))))
      "其中" (&cm $f_1 $..h $f_n) "是" $K^n "上的标准坐标函数. 我们还有一个与上面的引理有关的"
      "重要评注要说. 如果" $K "是一个特征为零的域, 以至于" (&fact $r) "在" $K
      "中是可逆的, 那么" $pi "是一个从" (app $M^r $V) "到" (Alt $r) "的满射. 实际上, 在这种情况下"
      "从某种角度来说使用映射" (&= $pi_1 (&i* (@ (&/ $1 (&fact $r))) $pi)) "而不是" $pi
      "是更自然的, 因为" $pi_1 "是一个从" (app $M^r $V) "到" (Alt $r) "的投影, 即一个从"
      (app $M^r $V) "到" (Alt $r) "的线性映射满足" (&= (app $pi_1 $L) $L) "当且仅当"
      (∈ $L (Alt $r)) ".")
   ((theorem #:n "7")
    "令" $K "是一个含幺交换环, " $V "是一个秩为" $n "的自由" $K "模. 如果" (&> $r $n) ", 那么"
    (&= (Alt $r) (setE $0)) ". 如果" (&<= $1 $r $n) ", 那么" (Alt $r) "是一个秩为"
    (M #:attr* '((displaystyle "true")) (comb $n $r)) "的自由" $K "模.")
   ((proof)
    "令" (setE $beta_1 $..h $beta_n) "是" $V "的一个有序基, 其以" (setE $f_1 $..h $f_n)
    "为对偶基. 如果" (∈ $L (app $M^r $V)) ", 我们有"
    (MB (&= $L (sum $J $
                    (&i* (appl $L (_ $beta $j_1) $..h (_ $beta $j_r))
                         (&t* (_ $f $j_1) $..c (_ $f $j_r))))))
    "其中和布于" $1 "到" $n "之间的整数 [译注: 当然包括" $1 "和" $n "] 的所有" $r "元组"
    (&= $J (tu0 $j_1 $..h $j_r)) "之上. 如果" $L "是交错的, 那么每当下标" $j_i
    "中存在两个数字相同时, 就有"
    (MB (&= (appl $L (_ $beta $j_1) $..h (_ $beta $j_r)) $0) ".")
    "如果" (&> $r $n) ", 那么每个" $r "元组" $J "中必有整数重复出现, 因此" (&> $r $n)
    "时有" (&= (Alt $r) (setE $0)) "." (Br)
    "现在设" (&<= $1 $r $n) ". 如果" (∈ $L (Alt $r)) ", 那么上面的和只需要布于满足"
    (&cm $j_1 $..h $j_r) "两两不同的" $r "元组" $J "之上, 因为其余的项均为" $0
    ". 每个这样的" $r "元组都是某个满足" (&< $j_1 $..c $j_r) "的" $r "元组"
    (&= $J (tu0 $j_1 $..h $j_r)) "的置换, 后者这种特别类型的" $r "元组被称为"
    (setE $1 $..h $n) "的一个" $r "-shuffle. 这样的shuffle的数目为"
    (MB (&= (comb $n $r) (~ (&fact $n) (&i* (&fact $r) (&fact (@- $n $r))))) ".")
    "设我们固定一个" $r "-shuffle " $J ". 令" $L_J "是与shuffle " $J "的所有置换"
    "相对应的项之和. 如果" $sigma "是" (setE $1 $..h $r) "的一个置换, 那么"
    (MB (&= (appl $L (_ $beta (_ $j σ1)) $..h (_ $beta (_ $j σr)))
            (&i* @sgnσ (appl $L (_ $beta $j_1) $..h (_ $beta $j_r)))))
    "因此"
    (MB (deriv $L_J
               (sum $sigma $
                    (&i* (appl $L (_ $beta (_ $j σ1)) $..h (_ $beta (_ $j σr)))
                         (&t* (_ $f (_ $j σ1)) $..c (_ $f (_ $j σr)))))
               (&i* (appl $L (_ $beta $j_1) $..h (_ $beta $j_r)) $D_J)))
    "其中"
    (MB (deriv $D_J
               (sum $sigma $
                    (&i* @sgnσ
                         (&t* (_ $f (_ $j σ1)) $..c (_ $f (_ $j σr)))))
               (app $pi_r (&t* (_ $f $j_1) $..c (_ $f $j_r)))))
    "我们从中看出每个" $D_J "都是交错的, 而对于每个" (∈ $L (Alt $r)) "有"
    (MB (&= $L (sum (: "shuffles&nbsp;" $J) $
                    (&i* (appl $L (_ $beta $j_1) $..h (_ $beta $j_r))
                         $D_J))) ".")
    "我们断言" (M #:attr* '((displaystyle "true")) (comb $n $r)) "个形式"
    $D_J "构成了" (Alt $r) "的一个基, 而我们已经看到它们能够张成" (Alt $r)
    ". 很容易看出来它们也是线性无关的. 如果" (&= $I (tu0 $i_1 $..h $i_r))
    "和" (&= $J (tu0 $j_1 $..h $j_r)) "是shuffle, 那么"
    (MB (&= (appl $D_J (_ $beta $i_1) $..h (_ $beta $i_r))
            (Choice0
             ($1 ",&nbsp;" (&= $I $J))
             ($0 ",&nbsp;" (&!= $I $J)))) ".")
    "设对于每个shuffle " $J "我们有一个标量" $c_J "与之对应, 并且定义"
    (MB (&= $L (sum $J $ (&i* $c_J $D_J))) ".")
    "根据之前的式子, 我们得到"
    (MB (&= $c_I (appl $L (_ $beta $i_1) $..h (_ $beta $i_r))) ".")
    "特别地, 如果" (&= $L $0) ", 那么对于每个shuffle " $I
    ", 我们有" (&= $c_I $0) ".")
   (P (B "译者注记.") " 以上的证明中有一个不大不小的gap, 但至少不算平凡, 即"
      (MB (deriv $D_J
                 (sum $sigma $
                      (&i* @sgnσ
                           (&t* (_ $f (_ $j σ1)) $..c (_ $f (_ $j σr)))))
                 (app $pi_r (&t* (_ $f $j_1) $..c (_ $f $j_r)))))
      "从第一行到第二行并不是直接的, 因为"
      (MB (&= (sum $sigma $
                   (&i* @sgnσ
                        (appl (@ (&t* (_ $f (_ $j σ1)) $..c (_ $f (_ $j σr))))
                              $alpha_1 $..h $alpha_r)))
              (sum $sigma $
                   (&i* @sgnσ
                        (app (_ $f (_ $j σ1)) $alpha_1) $..c
                        (app (_ $f (_ $j σr)) $alpha_r)))))
      "而"
      (MB (&= (appl (app $pi_r (&t* (_ $f $j_1) $..c (_ $f $j_r)))
                    $alpha_1 $..h $alpha_r)
              (sum $sigma $
                   (&i* @sgnσ
                        (app (_ $f $j_1) (_ $alpha σ1)) $..c
                        (app (_ $f $j_r) (_ $alpha σr))))))
      "不过, 如何证明这右边两个式子相等的思路, 其实在第5.4节的开头就有, 那里证明了"
      "行列式不论按行展开还是按列展开都是一样的.")
   ((corollary)
    "如果" $V "是一个秩为" $n "的自由" $K "模, 那么" (Alt $n)
    "是一个秩为" $1 "的自由" $K "模. 如果" $T "是" $V
    "上的一个线性算子, 那么存在唯一的元素" (∈ $c $K) "使得"
    (MB (&= (appl $L (ap $T $alpha_1) $..h (ap $T $alpha_n))
            (&i* $c (appl $L $alpha_1 $..h $alpha_n))))
    "对于每个" $V "上的交错" $n "线性形式" $L "成立.")
   ((proof)
    "如果" (∈ $L (Alt $n)) ", 那么显然"
    (MB (&= (appl $L_T $alpha_1 $..h $alpha_n)
            (appl $L (ap $T $alpha_1) $..h (ap $T $alpha_n))))
    "定义了一个交错" $n "线性形式" $L_T ". 令" $M "是秩" $1 "模" (Alt $n)
    "的一个生成元. 每个" (∈ $L (Alt $n)) "都可以被唯一的表达为"
    (&= $L (&i* $a $M)) ", 其中" (&in $a $K) ". 特别地, 对于某个特定的"
    $c "有" (&= $M_T (&i* $c $M)) ". 对于" (&= $L (&i* $a $M)) ", 我们有"
    (MB (deriv $L_T (_ (@i* $a $M) $T) (&i* $a $M_T)
               (&i* $a (@i* $c $M)) (&i* $c (@i* $a $M))
               (&i* $c $L))))
   (P "当然, 这个推论中的元素" $c "被称为" $T "的行列式. 从式子"
      (MB (deriv $D_J
                 (sum $sigma $
                      (&i* @sgnσ
                           (&t* (_ $f (_ $j σ1)) $..c (_ $f (_ $j σr)))))
                 (app $pi_r (&t* (_ $f $j_1) $..c (_ $f $j_r)))))
      "我们可以看出在" (&= $r $n) "的情形下 (此时仅存在一种shuffle "
      (&= $J (tu0 $1 $..h $n)) ") " $T "的行列式就是在有序基" (setE $beta_1 $..h $beta_n)
      "下表示" $T "的矩阵的行列式. 让我们现在弄明白为什么. 这个表示矩阵的第" $i "行" $j
      "列的元素是 [译注: 原文下面这个式子恰好把" $i "和" $j "搞反了]"
      (MB (&= (mref $A $i $j) (app $f_i (ap $T $beta_j))))
      "于是"
      (MB (deriv (appl $D_J (ap $T $beta_1) $..h (ap $T $beta_n))
                 (sum $sigma $
                      (&i* @sgnσ (app $f_1 (ap $T (_ $beta σ1))) $..c
                           (app $f_n (ap $T (_ $beta (ap $sigma $n))))))
                 (sum $sigma $
                      (&i* @sgnσ (appl $A $1 σ1)
                           $..c (appl $A $n σn)))
                 (&det $A)))
      "另一方面,"
      (MB (deriv (appl $D_J (ap $T $beta_1) $..h (ap $T $beta_n))
                 (&i* (&det0 $T) (appl $D_J $beta_1 $..h $beta_n))
                 (&det $T)))
      "这些评注的要义在于通过定理7及其推论, 我们获得了一个线性算子的行列式的定义而不需要"
      "预先的关于矩阵的行列式的知识. 矩阵的行列式可以基于算子的行列式定义而不是反过来.")
   (P "关于这特别的交错" $r "线性形式" $D_J ", 其与" V* "的一个基" (setE $f_1 $..h $f_n)
      "相关, 我们还有一点想说的东西. 理解" (appl $D_J $alpha_1 $..h $alpha_r)
      "是一个特定的" (&c* $r $r) "矩阵的行列式是很重要的. 如果"
      (MB (&cm (&= (mref $A $i $j) (app $f_j $alpha_i))
               (&<= $1 $i $r) (&<= $1 $j $n)))
      "即如果"
      (MB (&cm (&= $alpha_i (LC0 (mref $A $i $1) $beta_1 (mref $A $i $n) $beta_n))
               (&<= $1 $i $r)))
      "而" $J "是" $r "-shuffle " (tu0 $j_1 $..h $j_r) ", 那么"
      (MB (deriv (appl $D_J $alpha_1 $..h $alpha_r)
                 (sum $sigma $
                      (&i* @sgnσ
                           (appl $A $1 (_ $j σ1)) $..c
                           (appl $A $n (_ $j σr))))
                 (ap $det
                     (Mat
                      ((appl $A $1 $j_1) $..c (appl $A $1 $j_r))
                      ($..v $ $..v)
                      ((appl $A $r $j_1) $..c (appl $A $r $j_r))))))
      "[译注: 这里第一行的" $D_J "是按照"
      (sum $sigma $
           (&i* @sgnσ
                (&t* (_ $f (_ $j σ1)) $..c (_ $f (_ $j σr)))))
      "展开的.] 因此, " (appl $D_J $alpha_1 $..h $alpha_r) "是以"
      (&cm $alpha_1 $..h $alpha_r) "的坐标" $n "元组为行的" (&c* $r $n)
      "矩阵取第" (&cm $j_1 $..h $j_r) "列得到的" (&c* $r $r) "矩阵的行列式. "
      "有时我们也用另一个记号"
      (MB (&= (appl $D_J $alpha_1 $..h $alpha_r)
              (~ (&part $alpha_1 $..h $alpha_r)
                 (&part (_ $beta $j_1) $..h (_ $beta $j_r)))))
      "来表示这个行列式. 在这个记号下, 定理7的证明表明每个交错的" $r
      "线性形式" $L "都可以相对于某个基" (setE $beta_1 $..h $beta_n) "由式子"
      (MB (&= (appl $L $alpha_1 $..h $alpha_r)
              (sum (&< $j_1 $..c $j_r) $
                   (&i* (~ (&part $alpha_1 $..h $alpha_r)
                           (&part (_ $beta $j_1) $..h (_ $beta $j_r)))
                        (appl $L (_ $beta $j_1) $..h (_ $beta $j_r))))))
      "表达.")
   (H3 "第5.7节 Grassman环")
   (P "许多行列式和交错多线性形式的性质最好基于一种形式 (form) 上的乘法运算进行描述, "
      "这种乘法被称为外积 (exterior product). 如果" $L "和" $M "分别是模" $V
      "上的交错" $r "和" $s "线性形式, 我们有一个" $L "和" $M "的满足结合律的积, 即张量积"
      (&t* $L $M) ". 除非" (&= $L $0) "或者" (&= $M $0) ", 这不是一个交错形式. 然而, "
      "我们有一种自然的方式将其投影于" (Alt (&+ $r $s)) ". 似乎"
      (MB (&= (&d* $L $M) (app (_ $pi (&+ $r $s)) (&t* $L $M))))
      "应该是交错形式的&quot;自然&quot;乘法, 但果真如此吗?")
   (P "让我们举一个特定的例子. 设" $V "是模" $K^n "而" (&cm $f_1 $..h $f_n) "是" $K^n
      "上的标准坐标函数. 如果" (&!= $i $j) ", 那么"
      (MB (&= (&d* $f_i $f_j) (app $pi_2 (&t* $f_i $f_j))))
      "是之前给出的(行列式)函数 [译注: 注意一下那里要求" $J "是一个shuffle, 也就是"
      (&< $i $j) ", 但是这里并不需要]"
      (MB (&= (mref $D $i $j) (&- (&t* $f_i $f_j) (&t* $f_j $f_i))) ".")
      "现在设" $k "是一个不同于" $i "和" $j "的下标, 那么"
      (MB (deriv (&d* (mref $D $i $j) $f_k)
                 (ap $pi_3 (bra0 (&t* (@- (&t* $f_i $f_j) (&t* $f_j $f_i)) $f_k)))
                 (&- (app $pi_3 (&t* $f_i $f_j $f_k))
                     (app $pi_3 (&t* $f_j $f_i $f_k)))))
      "前一章的引理的证明表明对于任意的" $r "线性形式"
      $L "和" (setE $1 $..h $r) "任意的置换" $sigma ", 我们有"
      (MB (&= (app $pi_r $L_sigma) (&i* @sgnσ (app $pi_r $L)))) "因此, "
      (&= (&d* (mref $D $i $j) $f_k)
          (&i* $2 (app $pi_3 (&t* $f_i $f_j $f_k))))
      ". 根据类似的计算, "
      (&= (&d* $f_i (mref $D $j $k))
          (&i* $2 (app $pi_3 (&t* $f_i $f_j $f_k))))
      ". 因此, 我们有"
      (MB (&assoc &d* $f_i $f_j $f_k))
      "而所有这一切看起来前途都那么光明. 但是, 这里存在隐藏的陷阱. "
      "尽管刚才我们所完成的计算看起来像是那么回事, 之前提出的这个乘法"
      "并不满足结合律. 实际上, 如果" $l "是一个不同于" (&cm $i $j $k)
      "的下标, 那么我们可以算出"
      (MB (&= (&d* (mref $D $i $j) (mref $D $k $l))
              (&i* $4 (app $pi_4 (&t* $f_i $f_j $f_k $f_l)))))
      "以及 [译注: 原文为" 6 ", 应作" 12 "]"
      (MB (&= (&d* (@d* (mref $D $i $j) $f_k) $f_l)
              (&i* 12 (app $pi_4 (&t* $f_i $f_j $f_k $f_l)))))
      "因此, 在一般情况下"
      (MB (&!= (&d* (@d* $f_i $f_j) (@d* $f_k $f_l))
               (&d* (bra0 (&d* (@d* $f_i $f_j) $f_k)) $f_l)))
      "我们看到我们的第一次寻找乘法运算的尝试产生了一个非结合运算.")
   (P (B "译者注记.") " 以上的论证里有一些gap. 首先, 前一章的引理证明的是"
      (MB (&= (_ (@ap $pi_r $L) $sigma)
              (&i* @sgnσ (app $pi_r $L))))
      "而不是"
      (MB (&= (app $pi_r $L_sigma) (&i* @sgnσ (app $pi_r $L))))
      "不过这也是正确的, 而且论证方式也和前一章的引理类似, 只是的确需要证明一下:"
      (MB (deriv (appl (app $pi_r $L_sigma) $alpha_1 $..h $alpha_r)
                 (sum $tau $
                      (&i* (@sgn $tau)
                           (appl $L_sigma
                                 (_ $alpha (ap $tau $1)) $..h
                                 (_ $alpha (ap $tau $r)))))
                 (sum $tau $
                      (&i* (@sgn $tau)
                           (appl $L (_ $alpha (ap $tau (ap $sigma $1)))
                                 $..h (_ $alpha (ap $tau σr)))))
                 (&i* @sgnσ
                      (sum $tau $
                           (&i* (@sgn (&i* $tau $sigma))
                                (appl $L (_ $alpha (ap $tau (ap $sigma $1)))
                                      $..h (_ $alpha (ap $tau σr))))))
                 (appl (&i* @sgnσ (app $pi_r $L))
                       $alpha_1 $..h $alpha_r)))
      "其实" (appl (_ (@ap $pi_r $L) $sigma) $alpha_1 $..h $alpha_r)
      "展开之后和" (appl (app $pi_r $L_sigma) $alpha_1 $..h $alpha_r)
      "是类似的, 即"
      (MB (&= (appl (_ (@ap $pi_r $L) $sigma) $alpha_1 $..h $alpha_r)
              (sum $tau $
                   (&i* (@sgn $tau)
                        (appl $L (_ $alpha (ap $sigma (ap $tau $1)))
                              $..h (_ $alpha (ap $sigma (ap $tau $r))))))))
      "其次, 作者由此结果直接得出"
      (&= (&d* (mref $D $i $j) $f_k)
          (&i* $2 (app $pi_3 (&t* $f_i $f_j $f_k))))
      "的过程并不是那么显然. 实际上, 我们想要证明一下以下结果:"
      (MB (&= (&i* @sgnσ
                   (app $pi_r (&t* (_ $f σ1) $..c (_ $f σr))))
              (app $pi_r (&t* $f_1 $..c $f_r))))
      "为了证明它, 我们先证明一个引理:"
      (MB (&= (&t* (_ $f σ1) $..c (_ $f σr))
              (_ (@t* $f_1 $..c $f_r) (inv $sigma))))
      "计算一下"
      (MB (&= (appl (@t* (_ $f σ1) $..c (_ $f σr))
                    $alpha_1 $..h $alpha_r)
              (&i* (app (_ $f σ1) $alpha_1) $..c
                   (app (_ $f σr) $alpha_r))))
      "然后我们发现" $f_i "就应用于" (_ $alpha (ap (inv $sigma) $i))
      ", 鉴于" (&cm $f_1 $..h $f_r) "在这个积中恰好都出现一次, 经过重新"
      "排序我们就得到了引理. 现在我们证明刚才陈述的结果:"
      (MB (deriv (&i* @sgnσ
                      (app $pi_r (&t* (_ $f σ1) $..c (_ $f σr))))
                 (&i* @sgnσ
                      (ap $pi_r
                          (brac (_ (@t* $f_1 $..c $f_r) (inv $sigma)))))
                 (&i* @sgnσ (@sgn (inv $sigma))
                      (app $pi_r (&t* $f_1 $..c $f_r)))
                 (app $pi_r (&t* $f_1 $..c $f_r)))))
   (P "如果读者发现直接验证表明非结合性的两个式子相当乏味, 那也不必感到"
      "惊讶. 这是该主题的典型特征, 并且同样典型的是, 存在一个一般性的事实"
      "可以极大地简化工作.")
   (P "设" $L "是模" $V "上的一个" $r "线性形式而" $M "是模" $V
      "上的一个" $s "线性形式, 那么"
      (MB (deriv (app (_ $pi (&+ $r $s))
                      (&t* (@ap $pi_r $L) (@ap $pi_s $M)))
                 (ap (_ $pi (&+ $r $s))
                     (@sum (&cm $sigma $tau) $
                           (&i* @sgnσ (@sgn $tau)
                                (@t* $L_sigma $M_tau))))
                 (sum (&cm $sigma $tau) $
                      (&i* @sgnσ (@sgn $tau)
                           (app (_ $pi (&+ $r $s))
                                (&t* $L_sigma $M_tau))))))
      "其中" $sigma "布于" (setE $1 $..h $r) "的所有置换构成的对称群"
      $S_r "之上而" $tau "布于" $S_s "之上. 每对" (&cm $sigma $tau)
      "都定义了" (_ $S (&+ $r $s)) "的一个元素" (tu0 $sigma $tau)
      ", 其中" (setE $1 $..h (&+ $r $s)) "的前" $r "个元素根据" $sigma
      "进行置换, 而后" $s "个元素根据" $tau "进行置换. 显然我们有"
      (MB (&= (&sgn (tu0 $sigma $tau))
              (&i* @sgnσ (@sgn $tau))))
      "以及"
      (MB (&= (_ (@t* $L $M) (tu0 $sigma $tau))
              (&t* $L_sigma $M_tau)))
      "因此"
      (MB (&= (app (_ $pi (&+ $r $s))
                   (&t* (@ap $pi_r $L) (@ap $pi_s $M)))
              (sum (&cm $sigma $tau) $
                   (&i* (&sgn (tu0 $sigma $tau))
                        (ap (_ $pi (&+ $r $s))
                            (brac (_ (@t* $L $M)
                                     (tu0 $sigma $tau))))))) ".")
      "既然我们已经观察到"
      (MB (&= (&i* (&sgn (tu0 $sigma $tau))
                   (ap (_ $pi (&+ $r $s))
                       (brac (_ (@t* $L $M)
                                (tu0 $sigma $tau)))))
              (app (_ $pi (&+ $r $s)) (&t* $L $M))))
      "于是, 我们就有"
      (MB (&= (ap (_ $pi (&+ $r $s))
                  (bra0 (&t* (@ap $pi_r $L) (@ap $pi_s $M))))
              (&i* (&fact $r) (&fact $s)
                   (app (_ $pi (&+ $r $s)) (&t* $L $M)))) ".")
      "这个公式简化了大量的计算. 例如, 设我们有一个" $r "-shuffle "
      (&= $I (tu0 $i_1 $..h $i_r)) "和一个" $s "-shuffle "
      (&= $J (tu0 $j_1 $..h $j_s)) ". 为了使事情比较简单, 我们额外假设"
      (MB (&< $i_1 $..c $i_r $j_1 $..c $j_s) ".")
      "那么, 我们有与之关联的行列式函数"
      (MB (&cm (&= $D_I (app $pi_r $E_I))
               (&= $D_J (app $pi_s $E_J))))
      "其中" (&= $E_I (&t* (_ $f $i_1) $..c (_ $f $i_r))) "而"
      (&= $E_J (&t* (_ $f $j_1) $..c (_ $f $j_s)))
      ". 使用我们已经得到的结果, 我们立即可以看出"
      (MB (deriv (&d* $D_I $D_J)
                 (ap (_ $pi (&+ $r $s))
                     (bra0 (&t* (app $pi_r $E_I)
                                (app $pi_s $E_J))))
                 (&i* (&fact $r) (&fact $s)
                      (app (_ $pi (&+ $r $s)) (&t* $E_I $E_J)))))
      "既然" (&= (&t* $E_I $E_J) (_ $E (&union $I $J)))
      " [译注: 鉴于" $I "和" $J "是元素不重复的递增序列, "
      "所以可以用集合来表示它们, 于是这个记号有其合理性], 我们得到"
      (MB (&= (&d* $D_I $D_J)
              (&i* (&fact $r) (&fact $s) (_ $D (&union $I $J)))) ".")
      "这暗示了乘法的结合性的缺失是由 [译注: 在一般情况下]"
      (&!= (&d* $D_I $D_J) (_ $D (&union $I $J)))
      "导致的. 毕竟, " $D_I "和" $D_J "的积应该是" (_ $D (&union $I $J))
      ". 为了修复这种情况, 我们应该定义一个新的积. 一个交错" $r
      "线性形式" $L "和一个交错" $s "线性形式" $M "的外积 (或者楔积) 是"
      (MB (&= (&wedge $L $M)
              (&i* (~ $1 (&i* (&fact $r) (&fact $s)))
                   (app (_ $pi (&+ $r $s)) (&t* $L $M)))))
      "那么, 对于" $K^n "上的行列式函数, 我们有"
      (MB (&= (&wedge $D_I $D_J) (_ $D (&union $I $J))))
      "或许若有公平可言, 那么我们必然已经找到了正确的交错多线性形式的乘法. "
      "不幸的是, 这个定义在我们所考虑的最一般情况下是没有意义的, 因为在环"
      $K "中我们不一定能够除以" (&i* (&fact $r) (&fact $s))
      ". 不过, 如果" $K "是一个特征为零的域, 那么就没有问题了, "
      "并且我们能够迅速证明楔积是结合的.")
   ((theorem #:n "8")
    "令" $K "是一个特征为零的域, " $V "是" $K "上的一个向量空间, 那么外积是"
    $V "上的交错多线性形式上的一个结合运算. 换言之, 如果" (&cm $L $M $N)
    "分别是" $V "上阶数为" (&cm $r $s $t) "的交错多线性形式, 那么"
    (MB (&assoc &wedge $L $M $N) "."))
   ((proof)
    "根据楔积的定义, 我们知道对于任意的标量" $c "和" $d "有"
    (&= (&i* $c $d (@wedge $L $M)) (&wedge (@i* $c $L) (@i* $d $M))) ", 因此"
    (MB (&= (&i* (&fact $r) (&fact $s) (&fact $t)
                 (bra0 (&wedge (@wedge $L $M) $N)))
            (&wedge (bra0 (&i* (&fact $r) (&fact $s) (@wedge $L $M)))
                    (@i* (&fact $t) $N))))
    "既然" (&= (app $pi_t $N) (&i* (&fact $t) $N)) ", 这就导致"
    (MB (deriv (&i* (&fact $r) (&fact $s) (&fact $t)
                    (bra0 (&wedge (@wedge $L $M) $N)))
               (&wedge (app (_ $pi (&+ $r $s)) (&t* $L $M)) (app $pi_t $N))
               (&i* (~ $1 (&fact (@+ $r $s))) (~ $1 (&fact $t))
                    (ap (_ $pi (&+ $r $s $t))
                        (bra0 (&t* (app (_ $pi (&+ $r $s)) (&t* $L $M))
                                   (app $pi_t $N)))))))
    "根据之前的结果, 我们看出"
    (MB (&= (&i* (&fact $r) (&fact $s) (&fact $t)
                 (bra0 (&wedge (@wedge $L $M) $N)))
            (app (_ $pi (&+ $r $s $t)) (&t* $L $M $N))))
    "通过类似的计算我们得到"
    (MB (&= (&i* (&fact $r) (&fact $s) (&fact $t)
                 (bra0 (&wedge $L (@wedge $M $N))))
            (app (_ $pi (&+ $r $s $t)) (&t* $L $M $N))))
    "因此就有" (&assoc &wedge $L $M $N) ".")
   (P "现在我们回到一般情况上来, 其仅假定" $K "是一个含幺交换环. "
      "第一个问题在于将楔积的定义换成能在一般情况下生效的等价版本. 如果"
      $L "和" $M "分别是阶数为" $r "和" $s "的交错多线性形式, "
      "那么我们将构造一个阶数为" (&+ $r $s) "的典范的 "
      "[译注: 可以理解成存在且唯一的] 交错多线性形式" (&wedge $L $M) "满足"
      (MB (&= (&i* (&fact $r) (&fact $s) (@wedge $L $M))
              (app (_ $pi (&+ $r $s)) (&t* $L $M))) "."))
   (P "让我们回忆一下我们是如何定义" (app (_ $pi (&+ $r $s)) (&t* $L $M))
      "的. 对于" (setE $1 $..h (&+ $r $s)) "的每个置换" $sigma
      ", 我们联系以多线性函数"
      (MB (&i* @sgnσ (_ (@t* $L $M) $sigma)))
      "其中"
      (MB (&= (appl (_ (@t* $L $M) $sigma) $alpha_1 $..h (_ $alpha (&+ $r $s)))
              (appl (@t* $L $M) (_ $alpha σ1) $..h
                    (_ $alpha (ap $sigma (@+ $r $s))))))
      "然后我们将布于所有置换" $sigma "之上的这些函数加起来. 存在"
      (&fact (@+ $r $s)) "个置换. 然而, 既然" $L "和" $M "都是交错的, 许多这样的"
      "函数都是相同的. 实际上, 至多存在"
      (MB (~ (&fact (@+ $r $s)) (&i* (&fact $r) (&fact $s))))
      "个不同的这种函数. 让我们看看为什么. 令" (_ $S (&+ $r $s)) "是"
      (setE $1 $..h (&+ $r $s)) "的所有置换构成的集合, 即" (&+ $r $s)
      "阶对称群. 如我们之前所做的, 我们区分出一个子集" $G "来, 其由所有这样的置换"
      $sigma "构成, 满足"
      (&sube (ap $sigma (setE $1 $..h $r)) (setE $1 $..h $r)) "且"
      (&sube (ap $sigma (setE (&+ $r $1) $..h (&+ $r $s)))
             (setE (&+ $r $1) $..h (&+ $r $s)))
      ". 换言之, " (&in $sigma $G) ", 如果对于每个" $i "满足" (&<= $1 $i $r)
      "有" (&<= $1 (ap $sigma $i) $r) ". (然后就必然也满足对于每个" $j
      "满足" (&<= (&+ $r $1) $j (&+ $r $s)) "有"
      (&<= (&+ $r $1) (ap $sigma $j) (&+ $r $s)) ".) 现在" $G "是"
      (_ $S (&+ $r $s)) "的一个子群, 即若" $sigma "和" $tau "是" $G
      "的元素, 那么" (&in (&i* $sigma (inv $tau)) $G)
      ". [译注: 当然" $G "还要是非空的, 不过这是明显的.] 显然" $G
      "有" (&i* (&fact $r) (&fact $s)) "个元素.")
   (P "我们定义一个映射"
      (MB (func:def $psi (_ $S (&+ $r $s)) (Multi (&+ $r $s))
                    $sigma (&i* @sgnσ (_ (@t* $L $M) $sigma))))
      "既然" $L "和" $M "是交错的, 那么对于每个" (&in $gamma $G) "有"
      (MB (&= (app $psi $gamma) (&t* $L $M)) ".")
      "因此, 既然对于" $V "上任意的" (@+ $r $s) "线性形式" $N "有"
      (&= (_ (@ $N_sigma) $tau) (_ $N (&i* $tau $sigma))) ", 那么"
      (MB (&cm (&= (app $psi (&i* $tau $gamma)) (app $psi $tau))
               (∈ $tau (_ $S (&+ $r $s))) (∈ $gamma $G)) ".")
      "这是在说映射" $psi "在子群" $G "的每个(左)陪集" (&i* $tau $G)
      "上都是常函数. 如果" (∈ $tau_1 $tau_2 (_ $S (&+ $r $s)))
      ", 那么陪集" (&i* $tau_1 $G) "和" (&i* $tau_2 $G)
      "根据" (&i* (_^ $tau $2 $-1) $tau_1) "在" $G "中还是不在" $G
      "中, 要么相等要么互不相交. 每个陪集都具有" (&i* (&fact $r) (&fact $s))
      "个元素, 因此存在"
      (MB (~ (&fact (@+ $r $s)) (&i* (&fact $r) (&fact $s))))
      "个不同的陪集. 若用" (&/ (_ $S (&+ $r $s)) $G) "代表由所有这些"
      "陪集构成的集合, 那么" $psi "导出了" (&/ (_ $S (&+ $r $s)) $G)
      "上的一个函数, 即根据我们已知的东西, 存在 [译注: 当然也是唯一的] 函数"
      (&~~ $psi) "满足对于每个" (&in $tau (_ $S (&+ $r $s))) "有"
      (MB (&= (app $psi $tau) (app (&~~ $psi) (&i* $tau $G))) ".")
      "如果" $H "是" $G "的一个左陪集, 那么对于每个" (&in $tau $H)
      "有" (&= (app (&~~ $psi) $H) (app $psi $tau)) ".")
   (P (B "译者注记.") " 以上有点小小的gap, 在声称"
      (&= (app $psi (&i* $tau $gamma)) (app $psi $tau))
      "那里, 我们补充一下证明:"
      (MB (deriv (app $psi (&i* $tau $gamma))
                 (&i* (&sgn (@i* $tau $gamma))
                      (_ (@t* $L $M) (&i* $tau $gamma)))
                 (&i* (@sgn $tau) (@sgn $gamma)
                      (_ (bra0 (_ (@t* $L $M) $gamma)) $tau))
                 (&i* (@sgn $tau) (@sgn $gamma)
                      (_ (bra0 (&i* (@sgn $gamma) (@t* $L $M))) $tau))
                 (&i* (@sgn $tau) (@sgn $gamma) (@sgn $gamma)
                      (_ (@t* $L $M) $tau))
                 (&i* (@sgn $tau) (_ (@t* $L $M) $tau))
                 (app $psi $tau)))
      "以上推导中我们用到了"
      (&= (_ (@t* $L $M) $gamma) (&i* (@sgn $gamma) (@t* $L $M)))
      ", 这可由" (&= (app $psi $gamma) (&t* $L $M)) "两边左乘"
      (@sgn $gamma) "得到. 另外, 如果你看不懂上面这一段在说什么, "
      "那么你应该找一本代数入门书籍看一看.")
   (P "现在我们定义阶数分别为" $r "和" $s "的交错多线性形式" $L "和" $M
      "的外积为"
      (MB (&= (&wedge $L $M) (sum $H $ (app (&~~ $psi) $H))))
      "其中" $H "遍历" (&/ (_ $S (&+ $r $s)) $G) "的每个元素. 另一种陈述"
      (&wedge $L $M) "的定义的方式如下. 令" $S "是" (_ $S (&+ $r $s))
      "的一个子集, 其从每个" $G "的左陪集中恰选一个代表出来, 那么"
      (MB (&= (&wedge $L $M)
              (sum (&in $sigma $S) $
                   (&i* @sgnσ
                        (_ (@t* $L $M) $sigma)))) ".")
      "显然我们有"
      (MB (&= (&i* (&fact $r) (&fact $s) (@wedge $L $M))
              (app (_ $pi (&+ $r $s)) (&t* $L $M))))
      "于是这个新定义等价于之前我们所给出的在" $K
      "是特征为零的域的情况下的定义.")
   ((theorem #:n "9")
    "令" $K "是一个含幺交换环, " $V "是" $K "上的一个模, 那么外积是"
    $V "上的交错多线性形式上的一个结合运算. 换言之, 如果" (&cm $L $M $N)
    "分别是" $V "上阶数为" (&cm $r $s $t) "的交错多线性形式, 那么"
    (MB (&assoc &wedge $L $M $N) "."))
   ((proof)
    "尽管定理8的证明不能直接应用到这里来, 它的确暗示了该如何处理一般的情况. 令"
    (appl $G $r $s $t) "是" (_ $S (&+ $r $s $t)) "的一个子群, 其由所有这样的置换"
    $sigma "构成, 它们满足" (stable $sigma (setEnum $1 $r)) "且"
    (stable $sigma (setEnum (&+ $r $1) (&+ $r $s))) "且"
    (stable $sigma (setEnum (&+ $r $s $1) (&+ $r $s $t)))
    ". 那么, 对于一个给定的" (appl $G $r $s $t) "的左陪集而言, 其每个元素" $mu
    "给出的" (&i* (@sgn $mu) (_ (@t* $L $M $N) $mu)) "均是相同的多线性函数. 从"
    (appl $G $r $s $t) "的每个左陪集中选出一个代表" $mu "来, 令" $E "是这些代表所对应的项"
    (&i* (@sgn $mu) (_ (@t* $L $M $N) $mu)) "之和, 那么" $E "独立于代表元" $mu
    "的选取方式, 并且"
    (MB (&= (&i* (&fact $r) (&fact $s) (&fact $t) $E)
            (&pi (&+ $r $s $t) $L $M $N)) ".")
    "我们将证明" (&wedge (@wedge $L $M) $N) "和" (&wedge $L (@wedge $M $N))
    "均等于" $E "." (Br)
    "令" (appl $G (&+ $r $s) $t) "是" (_ $S (&+ $r $s $t)) "的一个子群, 其定义方式"
    "与上面相同. 令" $T "是任意的恰从" (appl $G (&+ $r $s) $t) "的每个左陪集"
    "中选取一个元素得到的集合, 那么根据楔积的定义, 我们有"
    (MB (&= (&wedge (@wedge $L $M) $N)
            (sum (&in $tau $T) $
                 (&i* (@sgn $tau)
                      (_ (bra0 (&t* (@wedge $L $M) $N)) $tau)))) ".")
    "现在令" (appl $G $r $s) "是如上定义的" (_ $S (&+ $r $s)) "的一个子群. 令"
    $S "是任意的恰从" (appl $G $r $s) "的每个左陪集中选取一个元素得到的集合. "
    "那么, 根据楔积的定义和我们已经知道的结果, 立即可以得出"
    (MB (&= (&wedge (@wedge $L $M) $N)
            (sum (&in (tu0 $sigma $tau) (&c* $S $T)) $
                 (&i* @sgnσ (@sgn $tau)
                      (_ (bra0 (&t* (_ (@t* $L $M) $sigma) $N)) $tau)))) ".")
    "如果我们将" (_ $S (&+ $r $s)) "的每个元素" $sigma "视为" (_ $S (&+ $r $s $t))
    "的元素, 即" $sigma "在" (setEnum $1 (&+ $r $s)) "上与原来一致, 而在"
    (setEnum (&+ $r $s $1) (&+ $r $s $t)) "上是恒等函数, 那么我们或许可以将以上式子写成"
    (MB (&= (&wedge (@wedge $L $M) $N)
            (sum (&in (tu0 $sigma $tau) (&c* $S $T)) $
                 (&i* (&sgn (@i* $sigma $tau))
                      (_ (bra0 (_ (@t* $L $M $N) $sigma)) $tau)))))
    "但是"
    (MB (&= (_ (bra0 (_ (@t* $L $M $N) $sigma)) $tau)
            (_ (@t* $L $M $N) (&i* $tau $sigma))))
    "因此"
    (MB (&= (&wedge (@wedge $L $M) $N)
            (sum (&in (tu0 $sigma $tau) (&c* $S $T)) $
                 (&i* (&sgn (@i* $tau $sigma))
                      (_ (@t* $L $M $N) (&i* $tau $sigma))))))
    "现在设我们有"
    (MB (&= (&i* $tau_1 $sigma_1) (&i* $tau_2 $sigma_2 $gamma)))
    "其中" (&cm (∈ $sigma_i $S) (∈ $tau_i $T) (∈ $gamma (appl $G $r $s $t)))
    ", 那么" (&= (&i* (_^ $tau $2 $-1) $tau_1) (&i* $sigma_2 $gamma (_^ $sigma $1 $-1)))
    ". 并且, 既然" (&in (&i* $sigma_2 $gamma (_^ $sigma $1 $-1)) (appl $G (&+ $r $s) $t))
    ", 那么" $tau_1 "和" $tau_2 "落入了" (appl $G (&+ $r $s) $t) "的相同的左陪集中. 因此, "
    (&= $tau_1 $tau_2) " [译注: 虽然" $T "是任意的, 却也是固定的], 然后"
    (&= $sigma_1 (&i* $sigma_2 $gamma)) ". 但是, 这将推出" $sigma_1 "和" $sigma_2
    " (被视为" (_ $S (&+ $r $s)) "的元素) 落入了" (appl $G $r $s) "的相同的左陪集中, 于是"
    (&= $sigma_1 $sigma_2) ". [译注: 这句话里, " $gamma "被视为 (或者说限制为) " (appl $G $r $s) "的元素.] "
    "因此, 与"
    (MB (&i* (~ (&fact (@+ $r $s $t)) (&i* (&fact (@+ $r $s)) (&fact $t)))
             (cosetN $r $s)))
    "个序对" (&in (tu0 $tau $sigma) (&c* $T $S)) "相对应的积" (&i* $tau $sigma)
    "都是不同的, 并且落入了" (appl $G $r $s $t) "的不同的左陪集中. 既然" (_ $S (&+ $r $s $t)) "中恰有"
    (MB (cosetN $r $s $t))
    "个" (appl $G $r $s $t) "的左陪集, 那么" (&= (&wedge (@wedge $L $M) $N) $E)
    ". 根据类似的论证, 也可说明" (&= (&wedge $L (@wedge $M $N)) $E) ".")
   ((example #:n "13")
    "外积与所谓的Laplace展开关系密切, 其可以用来计算行列式的值. 令" $K "是一个含幺交换环, " $n
    "是一个正整数. 设" (&< (&<= $1 $r) $n) ", 并且令" $L "是" $K^n "上的交错" $r "线性形式, 其由"
    " [译注: 作者默认" (&= $alpha_i (tu0 (mref $A $i $1) $..h (mref $A $i $n))) "]"
    (MB (&= (appl $L $alpha_1 $..h $alpha_r)
            (ap $det (Mat ((mref $A $1 $1) $..c (mref $A $1 $r))
                          ($..v $ $..v)
                          ((mref $A $r $1) $..c (mref $A $r $r))))))
    "定义. 如果" (&= $s (&- $n $r)) "并且" $M "是交错" $s "线性形式"
    (MB (&= (appl $M $alpha_1 $..h $alpha_s)
            (ap $det (Mat ((mref $A $1 (&+ $r $1)) $..c (mref $A $1 $n))
                          ($..v $ $..v)
                          ((mref $A $s (&+ $r $1)) $..c (mref $A $s $n))))))
    "那么" (&= (&wedge $L $M) $D) ", 即" $K^n "上的行列式函数. 这可以从"
    (&wedge $L $M) "是交错" $n "线性形式以及 (可以看出来)"
    (MB (&= (appl (@wedge $L $M) $epsilon_1 $..h $epsilon_n) $1))
    "立即得出. 如果我们现在以适当的方式描述" (&wedge $L $M) ", 那么我们就得到了" $K
    "上的" n*n "矩阵的行列式的一种Laplace展开." (Br)
    "在置换群" $S_n "中, 令" (&= $G (appl $G $r $s)) "是之前所定义的子群. 每个" $G
    "的左陪集中都恰包含一个这样的置换" $sigma ", 其满足"
    (&< σ1 (ap $sigma $2) $..c σr) "且" (&< (ap $sigma (@+ $r $1)) $..c σn)
    ". 这个置换的符号由 [译注: 原文是" (bra0 (&/ (&i* $r (@- $r $1)) $2))
    ", 应作" (bra0 (&/ (&i* $r (@+ $r $1)) $2)) ", 下同]"
    (MB (&= sgnσ (^ (@ $-1) (&+ σ1 $..c σr (bra0 (&/ (&i* $r (@+ $r $1)) $2))))))
    "给出, 而楔积" (&wedge $L $M) "由"
    (MB (&= (appl (@wedge $L $M) $alpha_1 $..h $alpha_n)
            (sum $sigma $
                 (&i* @sgnσ
                      (appl $L (_ $alpha σ1) $..h (_ $alpha σr))
                      (appl $M (_ $alpha (ap $sigma (@+ $r $1))) $..h
                            (_ $alpha σn))))))
    "给出, 其和中的" $sigma "是从" $G "的每个左陪集中挑选出的那个满足上述要求的置换, 因此"
    (MB (&= (appl (@wedge $L $M) $alpha_1 $..h $alpha_n)
            (sum (&< $j_1 $..c $j_r) $
                 (&i* $e_J (appl $L (_ $alpha $j_1) $..h (_ $alpha $j_r))
                      (appl $M (_ $alpha $k_1) $..h (_ $alpha $k_s))))))
    "其中 [译注: 实际上, " $k_i "就是集合" (&- (setEnum $1 $n) (setEnum $j_1 $j_r))
    "中的元素从小到大排列的第" $i "个]"
    (MB (&cm (&= $e_J (^ (@ $-1) (&+ $j_1 $..c $j_r (bra0 (&/ (&i* $r (@+ $r $1)) $2)))))
             (&= $k_i (ap $sigma (@+ $r $i)))) ".")
    "换句话说,"
    (MB (&= (&det $A)
            (sum (&< $j_1 $..c $j_r) $
                 (&i* $e_J
                      (Det ((mref $A $j_1 $1) $..c (mref $A $j_1 $r))
                           ($..v $ $..v)
                           ((mref $A $j_r $1) $..c (mref $A $j_r $r)))
                      (Det ((mref $A $k_1 (&+ $r $1)) $..c (mref $A $k_1 $n))
                           ($..v $ $..v)
                           ((mref $A $k_s $1) $..c (mref $A $k_s $n)))))))
    "这只是一种Laplace展开. 其他的展开可由将集合" (setEnum $1 $r) "和" (setEnum (&+ $r $1) $n)
    "替换成两个互补的下标集合得到.")
   (P (B "译者注记.") " 我们继续补充一些gap. 虽然看出"
      (&= (appl (@wedge $L $M) $epsilon_1 $..h $epsilon_n) $1)
      "还算容易, 但也不是那么平凡. 对于" (∈ $sigma (appl $G $r $s)) ", 我们有"
      (MB (deriv (&i* @sgnσ (appl (_ (@t* $L $M) $sigma) $epsilon_1 $..h $epsilon_n))
                 (appl (@t* $L $M) $epsilon_1 $..h $epsilon_n)
                 (&i* (appl $L $epsilon_1 $..h $epsilon_r)
                      (appl $M (_ $epsilon (&+ $r $1)) $..h $epsilon_n))
                 (&i* (&det $I) (&det $I))
                 $1))
      "对于" (&!in $sigma (appl $G $r $s)) ", 存在" $i "满足" (&<= $1 $i $r)
      "但是" (&> (ap $sigma $i) $r) ", 那么矩阵"
      (MB (&= $A (Mat ((&delta σ1 $1) $..c (&delta σ1 $r))
                      ($..v $ $..v)
                      ((&delta σr $1) $..c (&delta σr $r)))))
      "的第" $i "行是零行, 于是" (&= (&det $A) $0) ", 而"
      (MB (deriv (&i* @sgnσ (appl (_ (@t* $L $M) $sigma) $epsilon_1 $..h $epsilon_n))
                 (&i* @sgnσ
                      (appl $L (_ $epsilon σ1) $..h (_ $epsilon σr))
                      (appl $M (_ $epsilon (ap $sigma (@+ $r $1))) $..h (_ $epsilon σn)))
                 (&i* @sgnσ (&det $A)
                      (appl $M (_ $epsilon (ap $sigma (@+ $r $1))) $..h (_ $epsilon σn)))
                 $0))
      "因此, 根据楔积的定义, " (appl (@wedge $L $M) $epsilon_1 $..h $epsilon_n)
      "的和中只有一项为" $1 "而其余项均为" $0 ", 所以其值为" $1 ". 另外, 作者没有说明"
      "置换的符号是怎样计算的. 实际上, 如果考虑更一般的Laplace展开, 也就是说考虑互补的集合"
      (setEnum $j_1 $j_r) "和" (setEnum $k_1 $k_s) ", 其中"
      (&< $j_1 $..c $j_r) "且" (&< $k_1 $..c $k_s) ", 那么我们就需要思考如何计算这样的置换"
      $sigma "的符号, 其满足" (&< (ap $sigma $j_1) $..c (ap $sigma $j_r)) "且"
      (&< (ap $sigma $k_1) $..c (ap $sigma $k_s)) ". 我们先将" (ap $sigma $j_1)
      "通过反复交换插入到第" $1 "个位置, 这需要" (&- $j_1 $1) "次交换. 接着, 从小到大依次将"
      (ap $sigma $j_i) "插入到第" $i "个位置, 这分别需要" (&- $j_i $i) "次交换. 然后, 我们将位于第"
      $r "个位置的" (ap $sigma $j_r) "插入到它本应该位于的第" (ap $sigma $j_r) "个位置, 这需要"
      (&- (ap $sigma $j_r) $r) "次交换. 从大到小, 我们依次将" (ap $sigma $j_i) "从第" $i "个位置插入到第"
      (ap $sigma $j_i) "个位置, 这分别需要" (&- (ap $sigma $j_i) $i) "次交换. 最终我们得到了恒等置换, "
      "而所用的交换次数为"
      (MB (&= (&+ (sum (&= $i $1) $r (@- $j_i $i))
                  (sum (&= $i $1) $r (@- (ap $sigma $j_i) $i)))
              (&- (&+ (@+ $j_1 $..c $j_r) (@+ (ap $sigma $j_1) $..c (ap $sigma $j_r)))
                  (&i* $r (@+ $r $1)))))
      "鉴于" (&i* $r (@+ $r $1)) "是偶数, 那么置换" $sigma "的符号为"
      (MB (&= sgnσ
              (^ (@ $-1)
                 (&+ (@+ $j_1 $..c $j_r)
                     (@+ (ap $sigma $j_1) $..c (ap $sigma $j_r))))) "."))
   (P "如果" $V "是一个" $K "模, 我们可以将各种形式模 (form module) " (Alt $r) "放在一起并使用外积定义一个"
      "环. 为了简单性, 我们只考虑秩为" $n "的自由" $K "模的情形. 那么, 在" (&> $r $n)
      "时模" (Alt $r) "是平凡的. 我们定义"
      (MB (&= AltV (&d+ (Alt $0) (Alt $1) $..c (Alt $n))) ".")
      "这是外直和, 某个之前我们还没讨论过的东西. " AltV "的元素是" (@+ $n $1) "元组" (tu0 $L_0 $..h $L_n)
      ", 其中" (∈ $L_r (Alt $r)) ". 加法和乘上" $K "的元素按读者的预想定义. 顺带一提, " (&= (Alt $0) $K)
      ". 如果我们将" (&in $L (Alt $r)) "与" (@+ $n $1) "元组" (tu0 $0 $..h $0 $L $0 $..h $0)
      "等同起来, 其中自零计的第" $r "个分量是" $L ", 那么" (Alt $r) "是" AltV "的一个子模, 而直和分解"
      (MB (&= AltV (&d+ (Alt $0) $..c (Alt $n))))
      "在通常的意义下成立. [译注: 前一句话作者将多处" (Alt $r) "写成了" (Alt $r $K) ".] 既然"
      (Alt $r) "是一个秩为" (M #:attr* '((displaystyle "true")) (comb $n $r)) "的自由" $K
      "模, 那么我们看到" AltV "是一个自由" $K "模并且"
      (MB (&= (ap $rank (bra0 AltV)) (sum (&= $r $0) $n (comb $n $r)) $2^n) ".")
      "外积定义了一个" AltV "上的乘法: 使用形式 (form) 上的外积并将其线性地扩展至" AltV
      "的情形. 它对于" AltV "上的加法分配并给予了" AltV "一个环的结构. 这个环是" V*
      "上的Grassman环. 它不是一个交换环, 例如若" $L "和" $M "分别在" (Alt $r) "和" (Alt $s) "中, 那么"
      " [译注: 这" (^ (@ $-1) (&i* $r $s)) "是将前面和后面的参数互换得到的]"
      (MB (&= (&wedge $L $M) (&i* (^ (@ $-1) (&i* $r $s)) (@wedge $M $L))) ".")
      "但是, Grassman环在许多数学领域里是重要的."
      " [译注: 以上所提Grassman环, 现多称Grassman代数, 毕竟它还有个数乘运算.]")
   ))