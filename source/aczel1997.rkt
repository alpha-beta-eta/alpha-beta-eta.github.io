#lang racket
(provide aczel1997.html)
(require SMathML)
(define $PS (Mi "PS" #:attr* '((mathvariant "double-struck"))))
(define ||M|| (&abs $M))
(define $dot (Mi "dot"))
(define $atom (Mi "atom"))
(define (&atom k)
  (app $atom k))
(define $K^inf (^ $K $inf))
(define $K* (&* $K))
(define $cons (Mi "cons"))
(define $cons^inf (^ $cons $inf))
(define (&cons a d)
  (appl $cons a d))
(define (&cons^inf a d)
  (appl $cons^inf a d))
(define $varepsilon (Mi "&varepsilon;"))
(define $NN^inf (^ $NN $inf))
(define $s^inf (^ $s $inf))
(define (ap f . x*)
  (Mrow f $af (apply : x*)))
(define $OverBrace (Mo "&OverBrace;"))
(define (OverBrace x y)
  (Mover x (Mover $OverBrace y)))
(define (^+ x) (^ x $+))
(define |$[]| (Mi "[]"))
(define $square (Mi "&EmptySmallSquare;"))
(define $::= (Mo "&Colone;"))
(define $\| (Mo "|"))
(define |$[[0| (Mo "&LeftDoubleBracket;"
                   #:attr* '((stretchy "false"))))
(define |$]]0| (Mo "&RightDoubleBracket;"
                   #:attr* '((stretchy "false"))))
(define (|[[]]0| x)
  (: |$[[0| x |$]]0|))
(define denote
  (case-lambda
    ((x A) (^ (|[[]]0| x) A))
    ((x) (|[[]]0| x))))
(define $dummy
  (Mphantom $d*))
(define Σ $Sigma:normal)
(define-infix*
  (&::= $::=)
  (&\| $\|))
(define-@lized-op*
  (@cm &cm)
  (@∈ ∈))
(define aczel1997.html
  (TnTmPrelude
   #:title "语义学讲义: 始代数和终余代数方面"
   #:css "styles.css"
   (H1. "语义学讲义: 始代数和终余代数方面")
   (H2 "摘要")
   (P "这些讲义为计算机科学专业的学生提供了一个形式语言的数学语义的非标准介绍. "
      "我们并不试图给出平衡的处理, 而是专注于一些关键的一般性思想, "
      "并用简单的例子加以刻画. "
      "这些思想使用一些基本的范畴论概念来表述. "
      "所有需要的范畴论知识都会在讲义中介绍. "
      "除了为人熟知的句法和语义的始代数方法之外, "
      "我们还会检视不那么为人熟知的操作语义的终余代数方法. "
      "我们对形式语义的处理旨在对于更为标准的介绍进行补充.")
   (H2 "引论")
   (P "这些讲义主要旨在为计算机科学专业的学生介绍形式语言的数学语义的某些方面. "
      "这些讲义并不试图在任何意义上对该领域进行综述, "
      "而是聚焦于一簇与这样的观念相关的想法, "
      "即句法和语义在某种意义上是相互对偶的. "
      "为了表达这一观念, 我们需要使用范畴论中的一些基本概念. "
      "因此, 这些讲义的次要目标是给出对于主要目的而言"
      "必要的那些范畴论概念的介绍.")
   (P "这些讲义只是给出了对于语义学和基本的范畴论的部分介绍. "
      "但是, 我相信将这两个主题结合起来进行介绍能够有效地"
      "对于更为标准的介绍进行实用的补充. "
      "至于那些对于这两个主题均有所熟悉的人而言, "
      "我希望这里仍然有些新颖的内容能够吸引你.")
   
   (H2. "数学语义")
   (H3. "对于语义学的一般介绍")
   (P "句法和语义这两个学科之间的区别起源于对于自然语言的研究. "
      "句法关心的是语言的表达式的形式的结构性质, "
      "通常对于其意义毫不在意. 在语义学中, "
      "注意力集中于表达式的意义上. "
      "自然语言" (Q "在自然中")
      "出现, 一般经过了漫长的时间演化. "
      "它们的句法和语义通常只是隐式给出的, "
      "因而有必要通过观察语言的实际使用来建立"
      "对于其句法和语义的理解. "
      "这是语言学研究的一部分内容.")
   (P "与之形成的对比的是, 形式语言, 也就是这些讲义所关心的对象, "
      "是显式的构造, 并且通常拥有显式刻画的句法, "
      "而且理想情况下拥有显式的语义. "
      "形式语言的范例最初出现于逻辑学领域. "
      "它们是经典的命题演算和谓词演算, "
      "以及无数变体和扩展. "
      "形式语言也用于语言学, "
      "其可能扮演着理论性的角色, "
      "作为自然语言的片段的模型出现, "
      "这类似于物理科学中所使用的数学模型.")
   (P "在计算机科学中形式语言的最直接例子是编程语言. "
      "计算机科学里形式语言的想法有着更为广阔的应用, "
      "不单单是应用于编程语言. "
      "但是对于我们的目的而言, "
      "我们暂时只考虑编程语言就够了.")
   (P "从历史上来说, 编程语言的设计者没有必要通过"
      "给出全然精确的显式句法和语义来描述他们的语言. "
      "他们可以对于一个特定的机器构造一个编译器 (或者一个解释器), "
      "然后编写一个手册给出可以在这个机器上运行的以该语言写成的示例程序. "
      
      )
   
   (H4 "形式语言")
   (P "一个" (B "形式语言") "具有一个" (B "句法")
      ", 其刻画了语言的表达式的句法范畴, 它还有一个"
      (B "语义") ", 其刻画了对于句法的一些可能"
      (B "解释") ", 这赋予了语言的表达式以意义. "
      "有时存在一个突出的解释, 其或许可以称为"
      (B "意图") "或者说" (B "标准")
      "解释, 其他的则被称为" (B "非意图的")
      "或者" (B "非标准的")
      ". 一个形式语言可能只有单独一个意图解释, "
      "之后才会考虑其他可能的解释. "
      "也可能提供形式语言的时候就没有给出语义, "
      "或者甚至是语义为空, 没有提供解释. "
      "由逻辑学家所研究的未经解释的"
      (B "形式系统") ", 是这样的例子.")
   (P "与其专注于单独一个形式语言, 其有着单独一个句法和可能多个解释, "
      "不如把注意力放在" (B "一族形式语言")
      "的意图解释的统一方法上. "
      "这些讲义的一个主题是在精确的范畴论意义下, "
      "第二种想法可以视为对偶于第一种想法.")
   (P "运用范畴论, 我们想要检视两个对偶的主题, "
      "其中每个主题都需要选择一个自函子:"
      (Ol (Li "对于形式语言的抽象刻画, "
              "通过聚焦于句法的抽象表示作为自函子代数的范畴的始对象, "
              "其解释也被表示为范畴的对象而意义函数则是箭头.")
          (Li "对于表示一族形式语言的每个的意图解释的特定统一方法的刻画, "
              "作为自函子余代数的范畴的终对象, "
              "其每个语言的句法也被表示为范畴的对象而意义函数则是箭头.")))
   (P "当然了, 上述主题对于尚不熟悉范畴论术语的读者而言可能并不清晰. "
      "但是所有的术语都会在这些讲座里介绍.")
   (P "这些讲义的主题是" (B "数学语义")
      ". "
      )
   (H3. "句法和语义的例子")
   (P "这些讲义里我们将会专注于四个非常简单的带有句法和语义的形式语言的例子. "
      "它们是不切实际的简单, 以至于我们可以看到清晰的一般想法"
      "而不被更为现实的例子的细节所迷惑. "
      "在每种情形下我们都给出了一个抽象句法, 其确定了一个表达式的集合"
      $E ", 我们还会给出一个与之相关的数学结构概念, 并且对于每个这样的结构"
      (&= $A:script (tu0 $A $..h)) ", 还要给出一个" (B "意义函数")
      (func (denote $dummy $A:script) $E $A)
      ". 结构的第一个分量是" $A "是一个集合, 其被称为结构的"
      (B "潜在集合 (underlying set)")
      ". 于是, 意义函数将每个表达式与潜在集合中的一个值关联起来. "
      "数学结构是形式语言的解释. {译注: 解释的结果而非解释的过程.} "
      "意义函数是由结构递归定义的, 其遵照表达式生成的方式; "
      "即这个函数被刻画为满足定义性等式 (复数) 的唯一函数, "
      "每种表达式的形式都有一个等式.")
   (P "在第二个和第三个例子里我们会假设给定了一个固定的集合"
      $K ". 在第四个例子里, 我们假设给定了一个签名, "
      "其由一个" (B "函数符号") "的集合" Σ "构成, 每个"
      (∈ $sigma Σ) "都有一个与之关联的自然数"
      $n_sigma "作为其" (B "元数 (arity)") ".")
   (H4 "Peano结构")
   (P "一个" (B "Peano结构") (&= $A:script (tu0 $A $a $f))
      "由一个集合连带着" (∈ $a $A) "和" (func $f $A $A)
      "构成. 这个例子的表达式集合" $E "由以下抽象句法给出:"
      (MB (&::= $e (&\| $square (^+ $e))))
      "于是" (&= $E (setE $square (^+ $square) (^+ (^+ $square)) $..h))
      ". 给定一个Peano结构" (&= $A:script (tu0 $A $a $f))
      ", 意义函数" (denote $dummy $A:script)
      "是唯一的函数" (func (denote $dummy) $E $A) "满足"
      (MB (Choice
           ((denote $square) $= $a)
           ((denote (^+ $e)) $= (app $f (denote $e))
                             (@∈ $e $E)))))
   (H4 "列表结构")
   (P "给定一个集合" $K ", 一个" (B $K "上的列表结构")
      (&= $A:script (tu0 $A $a $f)) "由一个集合" $A
      "连带着" (∈ $a $A) "和" (func $f (&c* $K $A) $A)
      "构成. 这次表达式的集合" $E "是由以下抽象句法给出的:"
      (MB (&cm (&::= $e (&\| |$[]| (&: $k $e)))
               (@∈ $k $K)))
      $E "的一个典型元素具有形式"
      (&: $k_1 $..c $k_n |$[]|)
      ", 其中" (&cm $k_1 $..h $k_n)
      "都是" $K "的元素. 给定一个列表结构"
      (&= $A:script (tu0 $A $a $f))
      ", 意义函数" (denote $dummy $A:script)
      "是唯一的函数" (func (denote $dummy) $E $A) "满足"
      (MB (Choice
           ((denote |$[]|) $= $a)
           ((denote (&: $k $e))
            $=
            (appl $f $k (denote $e))
            (@cm (∈ $k $K) (∈ $e $E))))))
   (H4 "Lisp结构")
   (P "给定一个集合" $K ", 一个" (B $K "上的Lisp结构")
      (&= $A:script (tu0 $A $a $f)) "由一个集合" $A
      "连带着" (func $a $K $A) "和" (func $f (&c* $A $A) $A)
      "构成. 表达式集合" $E "由以下抽象句法给出:"
      (MB (&cm (&::= $e (&\| $k (&d* $e $e)))
               (@∈ $k $K)))
      "给定一个Lisp结构" (&= $A:script (tu0 $A $a $f))
      ", 意义函数" (denote $dummy $A:script)
      "是唯一的函数" (func (denote $dummy) $E $A) "满足"
      (MB (Choice
           ((denote $k) $= (app $a $k) (@∈ $k $K))
           ((denote (&d* $e_1 $e_2))
            $=
            (appl $f (denote $e_1) (denote $e_2))
            (@∈ $e_1 $e_2 $E)))))
   (H4 Σ "-结构")
   (P "给定一个签名" Σ ", 一个" Σ "-结构"
      (&= $A:script (_ (tu0 $A (^ $sigma $A:script))
                       (∈ $sigma Σ)))
      "由一个集合" $A "连带着对于每个" (∈ $sigma Σ) "的"
      (func (^ $sigma $A:script)
            (^ $A $n_sigma) $A)
      "构成. 当" (&= $n_sigma $0) "时, " (^ $A $n_sigma)
      "是一个单元素集合, 其由一个空元组构成, 于是"
      (^ $sigma $A:script) "不过就是挑选" $A
      "的某个元素" (app (^ $sigma $A:script))
      ". 根据惯例此时我们将" (^ $sigma $A:script)
      "与这个元素视为等同的. 表达式集合" $E
      "由以下抽象句法给出:"
      (MB (&cm (&::= $e (ap $sigma
                            (OverBrace
                             (: $e $..c $e)
                             $n_sigma)))
               (@∈ $sigma Σ)))
      "给定一个" Σ "-结构"
      (&= $A:script (_ (tu0 $A (^ $sigma $A:script))
                       (∈ $sigma Σ)))
      ", 意义函数" (denote $dummy $A:script)
      "是唯一的函数" (func (denote $dummy) $E $A) "满足"
      (MB (&cm (&= (denote (ap $sigma $e_1 $..c (_ $e $n_sigma)))
                   (appl (^ $sigma $A:script)
                         (denote $e_1) $..h
                         (denote (_ $e $n_sigma))))
               (@cm (∈ $sigma Σ)
                    (∈ $e_1 $..h (_ $e $n_sigma) $E))) "."))
   ((exercise #:n "1.1")
    "请你表明前三个例子可以视为第四个例子的特殊情况, 通过选择"
    (Ol (Li (&= Σ (setE $square $+)) ", 并且"
            (&= (_ $n $square) $0) ", "
            (&= (_ $n $+) $1) ".")
        (Li (&= Σ (&union (setE |$[]|) $K))
            ", 假定" (&!in |$[]| $K) ", 并且"
            (&= (_ $n |$[]|) $0) "而对于"
            (∈ $k $K) "有" (&= $n_k $1) ".")
        (Li (&= Σ (&union $K (setE $d*)))
            ", 假定" (&!in $d* $K) ", 并且对于"
            (∈ $k $K) "有" (&= $n_k $0) "而"
            (&= (_ $n $d*) $2) "."))
    "{译注: 不过, 一般认为之前的定义里已经隐含了这里的假定了.}")
   (H3. "关于结构归纳和结构递归的讨论")
   
   (H3. "结构的例子")
   (H4 "Peano结构")
   (P "标准的例子是" (tu0 $NN $0 $s) ", 其中"
      (&= $NN (setE $0 $1 $2 $..h))
      "是自然数集, 而对于" (∈ $n $NN)
      "有" (&= (app $s $n) (&+ $n $1))
      ". 另一个我们之后会感兴趣的例子是"
      (tu0 $NN^inf $0 $s^inf)
      ", 其中" (&= $NN^inf (&union $NN (setE $inf))) "而"
      (MB (&= (app $s^inf $n)
              (Choice0
               ((app $s $n) ", 如果" (∈ $n $NN))
               ($inf        ", 如果" (&= $n $inf)))) ".")
      "这里的" $inf "是一个不在" $NN
      "之中的对象.")
   (H4 "列表结构")
   (P "我们将取" (tu0 $K* $varepsilon $cons)
      "作为我们的标准例子, 其中" $K* "是由" $K
      "的元素的所有(有限的)字符串"
      (&= $rho (: $k_1 $..c $k_n))
      "构成的集合, " $varepsilon "是空字符串, 而"
      (MB (&= (&cons $k $rho)
              (: $k $k_1 $..c $k_n)))
      "其中" (∈ $k $K) "而"
      (∈ (&= $rho (: $k_1 $..c $k_n)) $K*)
      ".")
   (P "我们也会对于可能无穷的字符串的列表结构"
      (tu0 $K^inf $varepsilon $cons^inf)
      "感兴趣. 这里" (&= $K^inf (&union $K* $K^omega))
      ", 其中" $K^omega "是由" $K "的元素的无穷字符串"
      (&= $rho (: $k_1 $k_2 $..c)) "构成的集合, 而"
      (MB (&= (&cons^inf $k $rho)
              (: $k $k_1 $..c)))
      "其中" (∈ $k $K) "而"
      (∈ (&= $rho (: $k_1 $..c)) $K^inf)
      ".")
   (H4 "Lisp结构")
   (P "给定集合" $K ", 标准的例子是Lisp结构"
      (tu0 $SS $atom $dot) ", 其中" $SS
      "是Lisp的" $S "-表达式的集合, 而"
      $S "-表达式由对于每个"
      (∈ $k $K) "的原子" (&atom $k)
      "通过点对 (dotted pairing) 操作" $dot
      "构建而成, " $dot "将两个" $S
      "-表达式" (&cm $M_1 $M_2) "和一个"
      $S "-表达式" (&d* $M_1 $M_2)
      "联系起来.")
   (P "我们也对于带有可能循环或者无限的" $S
      "-表达式的Lisp结构感兴趣. "
      "这些表达式可以被视为叶子以" $K
      "的元素所标记的特定种类的二叉树. "
      "给出一个对于这些树的精确集合论定义是有用的. "
      "我们从更一般的" (B $S "-预树")
      "的概念开始. 这些对象被定义为序对"
      (&= $M (tu0 ||M|| $l_M))
      ", 其中" (&sube ||M|| (&* (setE $1 $2)))
      "而" (func $l_M ||M|| (&union $K (setE $d*)))
      ". 这里的" $d* "是某个不在" $K
      "之中的对象. 令" $PS "是由这些预树构成的集合. 如果"
      (∈ $k $K) ", 令" (&atom $k) "是由"
      (MB (Choice
           (||M|| $= (setE $varepsilon))
           ((app $l_M $varepsilon) $= $k)))
      "所给出的预树" $M ". 如果" (&cm $M_1 $M_2)
      "是预树, 令" (&d* $M_1 $M_2) "是由"
      
      )
   (H3. "句法作为结构")
   
   (H2. "结构的范畴")
   (H3. "范畴")
   (P "这一节我们将引入范畴的概念. "
      "我们初始的启发性例子是集合与集合之间的函数的范畴.")
   (H4 "集合之间的函数")
   (P "如果" (&cm $A $B) "是集合, 那么我们记"
      (func $f $A $B) ", 如果" $f "是一个从" $A
      "到" $B "的函数. 集合" $A "被称为" $f "的"
      (B "定义域 (domain)") "而集合" $B "被称为"
      $f "的" (B "陪域 (codomain)")
      ". "
      )
   (H4 "定义")
   (H4 "集合的范畴")
   (H3. "结构的范畴")
   (H4 "Peano结构的范畴")
   
   ))