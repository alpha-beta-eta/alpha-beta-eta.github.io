#lang racket
(provide some_programs.html)
(require SMathML)
(define some_programs.html
  (Prelude
   #:title "一些程序"
   #:css "styles.css"
   (H1 "一些程序")
   (P "Programs must be written for people to read, and only incidentally for machines to execute.")
   (H2 "(按值调用的)Y组合子")
   (CodeB "(define Y
  (lambda (h)
    ((lambda (f) (f f))
     (lambda (g)
       (h (lambda (x) ((g g) x)))))))")
   (H2 "Fibonacci数列")
   (CodeB "(define (fib n)
  (if (&lt; n 2)
      n
      (+ (fib (- n 1))
         (fib (- n 2)))))")
   (CodeB "(define (fib n)
  (let iter ((a 0) (b 1) (c 0))
    (if (= c n)
        a
        (iter b (+ a b) (+ c 1)))))")
   (H2 "阶乘")
   (CodeB "(define (fact n)
  (if (= n 0)
      1
      (* n (fact (- n 1)))))")
   (H2 "Knuth箭头记号")
   (CodeB "(define ((up n) a b)
  (cond ((zero? n) (* a b))
        ((zero? b) 1)
        (else
         ((up (sub1 n)) a ((up n) a (sub1 b))))))")
   (H2 "葛立恒数")
   (CodeB "(define ((repeated n) f)
  (if (zero? n)
      identity
      (compose f ((repeated (sub1 n)) f))))
(define (f n) ((up n) 3 3))
(define f64 ((repeated 64) f))
(define G (f64 4))")
   (H2 "Knuth洗牌算法")
   (CodeB "(define (shuffle! v)
  (define l (vector-length v))
  (let iter ((i l))
    (unless (&lt; i 2)
      (vector-swap! v (random i) (- i 1))
      (iter (- i 1)))))")
   (H2 "排列数和组合数")
   (CodeB "(define (P n k)
  (let iter ((n n) (k k) (r 1))
    (if (= k 0)
        r
        (iter (- n 1) (- k 1) (* n r)))))
(define (C n k)
  (let ((k (min k (- n k))))
    (/ (P n k) (fact k))))")
   (H2 "计算置换符号")
   (CodeB "(define (sign-of-permutation permutation)
  (define p (vector-copy permutation))
  (define l (vector-length p))
  (define q (make-vector l))
  (let iter ((i 0))
    (unless (= i l)
      (define x (vector-ref p i))
      (vector-set! q x i)
      (iter (+ i 1))))
  (let iter ((i 0) (s 1))
    (if (= i l)
        s
        (let ((x (vector-ref p i)))
          (if (= i x)
              (iter (+ i 1) s)
              (let ((j (vector-ref q i)))
                (vector-swap! p i j)
                (vector-swap! q x i)
                (iter (+ i 1) (- s))))))))")
   (H2 "笛卡尔积")
   (CodeB "(define (product . lst*)
  (if (null? lst*)
      '(())
      (append-map
       (lambda (d)
         (map (lambda (a) (cons a d))
              (car lst*)))
       (apply product (cdr lst*)))))")
   (H2 "Euclid算法")
   (CodeB "(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))")
   (H2 "扩展Euclid算法")
   (CodeB "(define (ext-gcd a b)
  (if (= b 0)
      (values a 1 0)
      (let*-values
          (((q r) (quotient/remainder a b))
           ((d m n) (ext-gcd b r)))
        (values d n (- m (* q n))))))")
   (H2 "Eratosthenes筛法 (Turner筛法)")
   (CodeB "(define (divides? a b)
  (= (remainder b a) 0))
(define (make-ints n)
  ($cons n (make-ints (+ n 1))))
(define (sieve $)
  ($cons ($car $)
         (sieve
          ($filter (lambda (x)
                     (not (divides? ($car $) x)))
                   ($cdr $)))))
(define primes
  (sieve (make-ints 2)))")
   (H2 "进制转换")
   (CodeB "(define (base-convert n b)
  (let iter ((n n) (r '()))
    (if (= n 0)
        r
        (iter (quotient n b)
              (cons (remainder n b) r)))))")
   (CodeB "(define (positive-base-convert n b)
  (let iter ((n n) (r '()))
    (if (= n 0)
        r
        (iter (quotient (- n 1) b)
              (cons (+ (remainder (- n 1) b) 1)
                    r)))))")
   (CodeB "(define (index->label index)
  (define (integer->upper i)
    (integer->char (+ i 64)))
  (let iter ((rest index) (result '()))
    (if (= rest 0)
        (list->string result)
        (iter (quotient (- rest 1) 26)
              (cons (integer->upper
                     (add1 (remainder (- rest 1) 26)))
                    result)))))")
   (H2 "计数器")
   (CodeB "(define (make-counter)
  (let ((x -1))
    (lambda ()
      (set! x (+ x 1))
      x)))")
   (H2 "de Casteljau算法")
   (CodeB "(define (make-pt x y) (vector 'pt x y))
(define (pt-x pt) (vector-ref pt 1))
(define (pt-y pt) (vector-ref pt 2))
(define (make-vec x y) (vector 'vec x y))
(define (vec-x vec) (vector-ref vec 1))
(define (vec-y vec) (vector-ref vec 2))
;pt- : pt * pt -> vec
(define (pt- p1 p2)
  (make-vec
   (- (pt-x p1) (pt-x p2))
   (- (pt-y p1) (pt-y p2))))
;pt+ : pt * vec -> pt
(define (pt+ p v)
  (make-pt
   (+ (pt-x p) (vec-x v))
   (+ (pt-y p) (vec-y v))))
;vec* : real * vec -> vec
(define (vec* k v)
  (make-vec
   (* k (vec-x v))
   (* k (vec-y v))))
;lerp : real -> pt * pt -> pt
(define ((lerp t) p1 p2)
  (pt+ p1 (vec* t (pt- p2 p1))))
;deCasteljau : pt* -> real -> pt
(define ((deCasteljau p*) t)
  (let iter ((p* p*))
    (if (null? (cdr p*))
        (car p*)
        (iter (map (lerp t)
                   (drop-right p* 1)
                   (cdr p*))))))")
   (H2 "列表上的插入排序")
   (CodeB "(define (isort l)
  (if (null? l)
      '()
      (insert (car l) (isort (cdr l)))))
(define (insert x l)
  (cond ((null? l) (list x))
        ((&lt;= x (car l)) (cons x l))
        (else
         (cons (car l)
               (insert x (cdr l))))))")
   (H2 "列表上的快速排序")
   (CodeB "(define (qsort l)
  (if (or (null? l) (null? (cdr l)))
      l
      (let-values (((left middle right) (partition l)))
        (append (qsort left) middle (qsort right)))))
(define (partition l)
  (define pivot (car l))
  (let iter ((left '()) (middle '()) (right '()) (rest l))
    (cond ((null? rest) (values left middle right))
          ((&lt; (car rest) pivot)
           (iter (cons (car rest) left) middle right (cdr rest)))
          ((= (car rest) pivot)
           (iter left (cons pivot middle) right (cdr rest)))
          (else
           (iter left middle (cons (car rest) right) (cdr rest))))))")
   (H2 "一个模式匹配宏")
   (CodeB "(define-syntax match
  (syntax-rules (guard)
    ((_ v) (error 'match &quot;~s&quot; v))
    ((_ v (pat (guard g ...) e ...) cs ...)
     (let ((fk (lambda () (match v cs ...))))
       (ppat v pat (if (and g ...) (let () e ...) (fk)) (fk))))
    ((_ v (pat e ...) cs ...)
     (let ((fk (lambda () (match v cs ...))))
       (ppat v pat (let () e ...) (fk))))))
(define-syntax ppat
  (syntax-rules (unquote)
    ((_ v () kt kf) (if (null? v) kt kf))
    ((_ v (unquote var) kt kf) (let ((var v)) kt))
    ((_ v (x . y) kt kf)
     (if (pair? v)
         (let ((vx (car v)) (vy (cdr v)))
           (ppat vx x (ppat vy y kt kf) kf))
         kf))
    ((_ v lit kt kf) (if (eqv? v (quote lit)) kt kf))))")
   (H2 "Church编码")
   (CodeB "(define zero
  (lambda (f)
    (lambda (x)
      x)))
(define one
  (lambda (f)
    (lambda (x)
      (f x))))
(define true
  (lambda (x)
    (lambda (y)
      x)))
(define false
  (lambda (x)
    (lambda (y)
      y)))
(define cons
  (lambda (x)
    (lambda (y)
      (lambda (m)
        ((m x) y)))))
(define car
  (lambda (p)
    (p true)))
(define cdr
  (lambda (p)
    (p false)))
(define succ
  (lambda (n)
    (lambda (f)
      (lambda (x)
        (f ((n f) x))))))
(define pred
  (lambda (n)
    (car
     ((n (lambda (p)
           ((cons (cdr p)) (succ (cdr p)))))
      ((cons zero) zero)))))")
   (H2 "A Tricky Interpreter")
   (CodeB "(define (Z env)
  (car env))
(define ((S vp) env)
  (vp (cdr env)))
(define ((Lam e) env)
  (lambda (x)
    (e (cons x env))))
(define ((App e1 e2) env)
  ((e1 env) (e2 env)))")
   (P "and a small compiler")
   (CodeB "(define (deBruijn exp)
  (let recur ((exp exp) (env '()))
    (match exp
      ((? symbol? var) (walk var env))
      (`(lambda (,x) ,body)
       `(Lam ,(recur body (cons x env))))
      (`(,rator ,rand)
       `(App ,(recur rator env)
             ,(recur rand env))))))
(define (walk var env)
  (let iter ((rest env) (result 'Z))
    (cond ((null? rest)
           (error 'walk &quot;unbound var ~s&quot; var))
          ((eq? var (car rest)) result)
          (else
           (iter (cdr rest) `(S ,result))))))")
   (H2 "简单可扩展的模式匹配器")
   (CodeB "(define (empty-dict) '())
(define (ext-dict key val dict)
  (cons (list key val) dict))
(define (lookup key dict)
  (assq key dict))
(define (bd-val bd) (cadr bd))
;&lt;var> ::= (? &lt;symbol>)
;&lt;seg-var> ::= (?? &lt;symbol>)
(define (var-id v) (cadr v))
;&lt;const> ::= &lt;number>
;         |  &lt;boolean>
;         |  &lt;symbol>
(define (const? x)
  (or (number? x)
      (boolean? x)
      (symbol? x)))
(define (Const c)
  (lambda (x* dict succ fail)
    (cond ((null? x*) (fail))
          ((eqv? (car x*) c)
           (succ (cdr x*) dict fail))
          (else (fail)))))
(define (Var id)
  (lambda (x* dict succ fail)
    (if (null? x*)
        (fail)
        (let ((bd (lookup id dict)))
          (if bd
              (let ((val (bd-val bd)))
                (if (equal? val (car x*))
                    (succ (cdr x*) dict fail)
                    (fail)))
              (succ (cdr x*)
                    (ext-dict id (car x*) dict)
                    fail))))))
(define (Seq2 m1 m2)
  (lambda (x* dict succ fail)
    (m1 x* dict
        (lambda (x* dict fail)
          (m2 x* dict succ fail))
        fail)))
(define (Succ)
  (lambda (x* dict succ fail)
    (succ x* dict fail)))
(define (Fail)
  (lambda (x* dict succ fail)
    (fail)))
(define (Seq . m*)
  (if (null? m*)
      (Succ)
      (let iter ((m (car m*))
                 (m* (cdr m*)))
        (if (null? m*)
            m
            (iter (Seq2 m (car m*))
                  (cdr m*))))))
(define (List . m*)
  (let ((m (apply Seq m*)))
    (lambda (x* dict succ fail)
      (if (null? x*)
          (fail)
          (let ((x (car x*))
                (x* (cdr x*)))
            (if (or (null? x) (pair? x))
                (m x dict
                   (lambda (rest dict fail)
                     (if (null? rest)
                         (succ x* dict fail)
                         (fail)))
                   fail)
                (fail)))))))
(define (Seg-var id)
  (lambda (x* dict succ fail)
    (let ((bd (lookup id dict)))
      (if bd
          (let ((y* (bd-val bd)))
            (let iter ((y* y*) (x* x*))
              (cond ((null? y*) (succ x* dict fail))
                    ((null? x*) (fail))
                    ((equal? (car y*) (car x*))
                     (iter (cdr y*) (cdr x*)))
                    (else (fail)))))
          (let iter ((y* '()) (x* x*))
            (succ x* (ext-dict id y* dict)
                  (lambda ()
                    (if (null? x*)
                        (fail)
                        (iter (attach y* (car x*))
                              (cdr x*))))))))))
(define (attach l x)
  (append l (list x)))
;&lt;pattern> ::= &lt;const>
;           |  &lt;var>
;           |  (list &lt;pat>*)
;&lt;pat> ::= &lt;const>
;       |  &lt;var>
;       |  &lt;seg-var>
;       |  (list &lt;pat>*)
(define (compile-pattern p)
  (define (Pattern p)
    (if (const? p)
        (Const p)
        (case (car p)
          ((?) (Var (var-id p)))
          ((list)
           (apply List (map Pat (cdr p)))))))
  (define (Pat p)
    (if (const? p)
        (Const p)
        (case (car p)
          ((?) (Var (var-id p)))
          ((??) (Seg-var (var-id p)))
          ((list)
           (apply List (map Pat (cdr p)))))))
  (Pattern p))")
   (H2 "向量处理")
   (CodeB "(define (vector-copy v)
  (define l (vector-length v))
  (define u (make-vector l))
  (let iter ((i 0))
    (if (= i l)
        u
        (begin
          (vector-set! u i (vector-ref v i))
          (iter (+ i 1))))))
(define (vector-swap! v i j)
  (define t (vector-ref v i))
  (vector-set! v i (vector-ref v j))
  (vector-set! v j t))
(define (build-vector l p)
  (define v (make-vector l))
  (let iter ((i 0))
    (if (= i l)
        v
        (begin
          (vector-set! v i (p i))
          (iter (+ i 1))))))
(define (vector-map p v)
  (define l (vector-length v))
  (define u (make-vector l))
  (let iter ((i 0))
    (if (= i l)
        u
        (begin
          (vector-set! u i (p (vector-ref v i)))
          (iter (+ i 1))))))
(define (vector-map! p v)
  (define l (vector-length v))
  (let iter ((i 0))
    (unless (= i l)
      (vector-set! v i (p (vector-ref v i)))
      (iter (+ i 1)))))
(define (vector-for-each p v)
  (define l (vector-length v))
  (let iter ((i 0))
    (unless (= i l)
      (p (vector-ref v i))
      (iter (+ i 1)))))")
   (H2 "自然数")
   (CodeB "datatype nat = Zero
             | Succ of nat

fun plus m Zero = m
  | plus m (Succ n) = Succ(plus m n)

fun mult m Zero = Zero
  | mult m (Succ n) = plus (mult m n) m

fun expt m Zero = Succ Zero
  | expt m (Succ n) = mult (expt m n) m")
   (H2 "面向对象 (伪)")
   (CodeB "(define make-obj
  (let ((id* '()))
    (define (add-id! id)
      (unless (symbol? id)
        (error 'make-obj &quot;id [~s] should be a symbol.&quot; id))
      (if (memq id id*)
          (error 'make-obj &quot;id [~s] has been used.&quot; id)
          (set! id* (cons id id*))))
    (lambda (id)
      (add-id! id)
      (lambda (msg)
        (case msg
          ((get-id) (lambda (self) id))
          (else #f))))))
(define (method? x) (procedure? x))
(define (tell obj msg . arg*)
  (define method (obj msg))
  (unless (method? method)
    (error (get-id obj) &quot;unknown message [~s]&quot; msg))
  (apply method obj arg*))
(define (get-id obj) (tell obj 'get-id))")
   (H2 "合一 (unification)")
   (P "抄录自The Reasoned Schemer (2ed), 略有修改.")
   (CodeB "(define (var x) (vector x))
(define (var? x) (vector? x))
(define (walk x s)
  (let ((a (and (var? x) (assv x s))))
    (if a (walk (cdr a) s) x)))
(define (occurs? x v s)
  (let ((v (walk v s)))
    (cond ((var? v) (eqv? x v))
          ((pair? v)
           (or (occurs? x (car v) s)
               (occurs? x (cdr v) s)))
          (else #f))))
(define (ext-s x v s)
  (if (occurs? x v s)
      #f
      (cons (cons x v) s)))
(define (unify u v s)
  (let ((u (walk u s))
        (v (walk v s)))
    (cond ((eqv? u v) s)
          ((var? u) (ext-s u v s))
          ((var? v) (ext-s v u s))
          ((and (pair? u) (pair? v))
           (let ((s (unify (car u) (car v) s)))
             (and s (unify (cdr u) (cdr v) s))))
          (else #f))))
(define (walk* v s)
  (let ((v (walk v s)))
    (if (pair? v)
        (cons (walk* (car v) s)
              (walk* (cdr v) s))
        v)))
(define (reify-name n)
  (string->symbol (format &quot;_.~s&quot; n)))
(define (reify-s v r)
  (let ((v (walk v r)))
    (cond ((var? v)
           (let ((rn (reify-name (length r))))
             (cons (cons v rn) r)))
          ((pair? v)
           (let ((r (reify-s (car v) r)))
             (reify-s (cdr v) r)))
          (else r))))
(define (reify q s)
  (let ((q (walk* q s)))
    (walk* q (reify-s q '()))))")
   (H2 "FFT")
   (CodeB "(define (interleave x y)
  (if (null? x)
      '()
      (cons (car x)
            (cons (car y)
                  (interleave (cdr x) (cdr y))))))
(define (evens x)
  (if (null? x)
      '()
      (cons (car x)
            (evens (cddr x)))))
(define (split x)
  (let recur ((slow x) (fast x))
    (if (null? fast)
        (values '() slow)
        (let-values (((front back) (recur (cdr slow) (cddr fast))))
          (values (cons (car slow) front) back)))))
(define (w-powers n)
  (define Δ (/ (* -2i pi) n))
  (let recur ((x 0) (c 0))
    (if (= c n)
        '()
        (cons (exp x)
              (recur (+ x Δ) (+ c 2))))))
(define (butterfly x w)
  (let-values (((y z) (split x)))
    (values
     (map + y z)
     (map (lambda (a b c)
            (* (- a b) c))
          y z w))))
(define (fft x)
  (let recur ((x x) (w (w-powers (length x))))
    (if (null? (cddr x))
        (let ((x0 (car x)) (x1 (cadr x)))
          (list (+ x0 x1) (- x0 x1)))
        (let-values (((y z) (butterfly x w)))
          (let ((w (evens w)))
            (interleave (recur y w) (recur z w)))))))")
   (H2 "根据语法生成随机句子")
   (CodeB "(define *grammar*
  '((sentence -> (noun-phrase verb-phrase))
    (noun-phrase -> (Article Noun))
    (verb-phrase -> (Verb noun-phrase))
    (Article -> the a)
    (Noun -> man ball woman table)
    (Verb -> hit took saw liked)))
(define (random-select lst)
  (list-ref lst (random (length lst))))
(define (lookup symbol grammar)
  (cond ((assq symbol grammar)
         => (lambda (line)
              (random-select (cddr line))))
        (else
         (error 'lookup &quot;unknown symbol ~s with respect to grammar ~s&quot;
                symbol grammar))))
(define (generate symbol grammar)
  (define more (lookup symbol grammar))
  (if (symbol? more)
      (list more)
      (append-map (curryr generate grammar) more)))
(generate 'sentence *grammar*)")
   ))