#lang racket
(provide control.html)
(require SMathML)
(define (LP label #:attr* [attr* '()] . x*)
  `(p ,attr* ,(B label ". ") . ,x*))
(define (denotation e) (&db0 e))
(define $Store (Mi "Store"))
(define $Int (Mi "Int"))
(define $Variable (Mi "Variable"))
(define $op (Mi "op"))
(define $\| (Mo "|"))
(define-infix*
  (&\| $\|))
(define &\;
  (make-op $\;
    (lambda () $)
    (lambda (x) x)))
(define (pseq . x*)
  (cur0 (apply &\; x*)))
(define control.html
  (TnTmPrelude
   #:title "编程语言中的控制结构"
   #:css "styles.css"
   (H1. "编程语言中的控制结构")
   (H2 "引论")
   (H2. "早期编程语言")
   (H3. "处理器之中的控制流")
   (H3. "机器语言, 汇编语言")
   (H3. "FORTRAN")
   (H3. "ALGOL 60")
   (H3. "条件式和循环")
   (H3. "从循环和块之中及早退出")
   (H3. "深入阅读")
   (H2. "结构化编程")
   (H3. "一场运动和一场争议")
   (P "如今" (Q "结构化编程")
      "指的是使用高层次控制结构 (条件式, 循环, ...) 而非低层次的"
      (Code "goto") "跳转这一毫无争议的编程实践. 然而, "
      "在1965-1975期间, 结构化编程则是充满争论的主题, "
      "其既可以视为一场迈向看待软件的新角度的运动, "
      "也可以视为关于如何编写良好程序的一场争议.")
   (LP "结构化编程运动"
       
       )
   (H3. "没有goto的编程")
   
   (H2. "非局部控制")
   (H2. "控制反转")
   (H2. "函数式语言")
   (H3. "声明式编程: 抛弃控制?")
   (P "到目前为止, 我们理所当然地认为源代码必须显式描述程序之中的计算顺序 (sequencing), "
      "并且编程语言必须提供表达这种顺序的控制结构. "
      "然而, 这种假设受到了" (Em "声明式语言")
      "的质疑, 其在源代码之中大体将计算顺序留作隐式, "
      "而依赖于编译器确定计算的正确顺序. "
      "换言之, 声明式语言强调" (Em "什么") " (什么是要被计算的?) 而非"
      (Em "如何") " (如何将计算分解为基本步骤? 以什么顺序施行这些步骤?).")
   (P "声明性方法的一个例子是诸如SQL这样的数据库查询语言: "
      "查询描述了要从数据库里拉取什么记录; "
      "如何搜索数据库则留给数据库管理系统确定. "
      "其他的声明性编程范式包括逻辑编程 (Prolog, Datalog), "
      "纯函数式编程 (Haskell, Agda), 以及数据流编程 (Simulink, Lustre). "
      "诸如Verilog和VHDL这样的硬件描述语言本质上也是声明性的.")
   (P "声明式编程于1970年代引入, 其目的在于简化编程和"
      (Q "将编程从von Neumann风格之中解放出来")
      ", 如Backus (1978) 所言. 1980年代的焦点转移到了并行计算之上: "
      "人们希望声明式语言比起标准的命令式语言并行执行起来更加容易, "
      "这恰恰是因为前者给予了编译器在调度计算方面更大的灵活性. "
      "自1990年代起, 声明式编程因其安全性和与形式验证的亲缘关系而受到认可.")
   (P "声明式编程能否摆脱控制结构? 其能否将程序员从表达程序之中的控制的重担中"
      (Q "解放") "出来呢? 本章试图在纯函数式编程的上下文之中回答这些问题, "
      "通过检视三种表达力依次递增的小语言: "
      "XL, 一个电子表格语言; APP, 带有与值不同的函数的一个应用性语言; "
      "FUN, 将函数作为值的一个函数式语言.")
   (H3. "XL: 表达式和电子表格")
   (LP "带有共享的表达式"
       "考虑以下算术表达式和等式的语言, 昵称" (Q "XL") ":"
       (MB (set-attr*
            (&Table
             ("表达式:" $e $::= (&\| $0 (Mn "1.2") (Mn "3.1415") $..h)    "常量")
             ($         $  $\|  (&\| $x $y $z $..h)                       "变量")
             ($         $  $\|  (appl $op $e_1 $..h $e_n)                 "运算")
             ("程序:"   $p $::= (pseq (&= $x_1 $e_1) $..h (&= $x_n $e_n)) "等式的集合"))
            'columnalign "right right center left left"))
      "诸如" (&+ $x $1) "和" (&c* $y $z) "这样的算术表达式是由常量和变量通过使用诸如"
      (&cm $+ $- $c* $/) "等运算构筑而成的. 程序是变量和表达式之间的等式的集合.")
   (P "通过等式被绑定至表达式的变量使用捕获了计算共享的概念. "
      "例如, 以下两个程序"
      (eqn*
       ($p_1 $= (pseq (&= $x (&c* $2 $3)) (&= $y (&+ $x $x))))
       ($p_2 $= (pseq (&= $x (&c* $2 $3))
                      (&= $y (&+ (&c* $2 $3) (&c* $2 $3))))))
      "能够计算出相同的结果 (其含义之后将会精确化), 但是" $p_1
      "只会对于" (&c* $2 $3) "进行一次求值, 之后在对于" (&+ $x $x)
      "的求值过程中共享结果" $6 ", 而" $p_2 "会对于" (&c* $2 $3)
      "求值三次.")
   (LP "电子表格"
       
       )
   (LP "无环条件"
       "我们希望XL程序容易求值. 这意味着避免难以求解的等式, 例如"
       (&= $x (&+ (&- $x^3 (&i* $2 $x^2)) $2))
       ". 我们还要走的远得多, 排除所有这样的等式" (&= $x $e)
       ", 其中" $e "依赖于" $x ", 不论直接依赖还是通过其他等式间接依赖, "
       "如以下例子所示:"
       (MB (&Table
            ((pseq (&= $x (&+ $x $1))))
            ((pseq (&= $x (&+ $y $1))
                   (&= $y (&- $x $1))))))
       "换言之, 这些等式不能包含依赖循环. "
       "这种无环条件成立当且仅当程序不只是能写作等式的集合, "
       "而且可以写作等式的" (Em "有序列表")
       (MB (&\; (&= $x_1 $e_1) $..h (&= $x_n $e_n)))
       "其中可以出现在" $e_i "之中的变量只能是满足"
       (&< $j $i) "的变量" $x_j ".")
   (LP "电路和数据流"
       
       )
   (LP "程序求值"
       
       )
   (H3. "APP: 表达式和用户定义的函数")
   (H3. "FUN: 函数作为第一级值")
   (H3. "上下文下的归约")
   (H3. "深入阅读")
   (H2. "延续和CPS变换")
   (H3. "延续的概念")
   (LP "程序点的延续"
       "考虑程序执行过程中的一个点. 这个程序中该程序点的"
       (Em "延续") "是在执行抵达该点之后还要执行的计算序列, "
       "其是为了完成整个程序的执行过程.")
   (H3. "指称语义回顾")
   (P "指称语义由Christopher Strachey, Dana Scott, "
      "Christopher Wadsworth于1960年代后期引入, "
      "其是以数学的精确定义程序的含义之方法. "
      "指称语义以复合性的方式将数学对象与编程语言的每个句法元素 "
      "(表达式, 语句, 函数, ...) 联系起来.")
   (P "例如, 一个牵涉变量的整数算术表达式" $e
      "的含义可以被定义为从存储到整数的映射, "
      "其中存储将整数与变量联系起来:"
      
      )
   (H3. "基于延续的指称语义")
   (H3. "标签和跳转的指称语义")
   (H3. "CPS变换")
   (H3. "CPS变换的语义性质")
   (H3. "深入阅读")
   (H2. "延续编程" #:id "programming-with-continuations")
   (H2. "控制运算子")
   (P "控制运算子是由某些函数式语言所提供的语言构造, "
      "其允许表达式捕获延续, 将延续作为第一级值操纵, "
      "以及之后重启延续.")
   (P "控制运算子使得将高级控制结构 "
      "(异常, 回溯, 协作线程, 等等) "
      "编写为库函数成为可能, "
      "其可以在以直接风格写成的程序之中运用. "
      "藉由控制运算子, 我们无需像我们在"
      (Ref "programming-with-continuations")
      "所做的那样, 通过将程序改写为延续传递风格以使用用户所定义的高级控制结构.")
   (H3. "Landin的J运算子")
   
   (H3. "call-with-current-continuation (callcc)")
   (P "最为知名的控制运算子或许是来自于Scheme语言的"
      (Q "call-with-current-continuation")
      ", 其经常被缩略为" (Code "call/cc") "或者"
      (Code "callcc") ". 其允许一个表达式将其自身的延续以函数的形式捕获. "
      "这个运算子在文献里以各种不同的名字出现: "
      )
   (H3. "使用callcc实现控制结构")
   (H3. "callcc的语义")
   (H3. "定界延续")
   (H3. "定界延续运算子的语义")
   (H3. "使用定界延续实现控制结构")
   (H3. "定界延续的CPS变换")
   (H3. "深入阅读")
   (H2. "异常")
   (H2. "用户定义作用的作用处理器")
   (H2. "单子")
   (H2. "代数作用")
   (H2. "类型和作用系统")
   (H2. "控制结构的Hoare逻辑")
   (H2. "控制运算子的分离逻辑")
   ))