#lang racket
(provide spec.html)
(require SMathML)
(define -- "&mdash;&mdash;")
(define (&label x . t*)
  (Table #:attr* '((class "label") (align "center"))
         (Tr (Td ;#:attr* '((align "center"))
              x))
         (Tr (keyword-apply
              Td '(#:attr*) '(((align "center")))
              t*))))
(define-@lized-op*
  (@/ &/))
(define $highbound (Mi "highbound"))
(define (&highbound x)
  (app $highbound x))
(define $lowbound (Mi "lowbound"))
(define (&lowbound x)
  (app $lowbound x))
(define $found (Mi "found"))
(define spec.html
  (TnTmPrelude
   #:title "程序开发中的抽象和规格"
   #:css "styles.css"
   (H1. "程序开发中的抽象和规格")
   (P "这是MIT曾经软件工程课程所使用的教材.")
   (H2 "前言")
   (P "优秀的编程在于对复杂性的系统化掌控. "
      "这并不是一门容易教授的学科. 学生必须被说服, "
      "编程并非一门神秘莫测的技艺, 而是一门工程学科. "
      "其中存在着有用的原则, 而且这些原则可以并且应该被应用. "
      "在本书中, 我们试图通过提出, 论证并阐释一套连贯的理论体系, "
      "来塑造学生对编程的思考方式. 我们的核心信条是, "
      "抽象与规格说明必须成为任何有效编程方法的支柱. "
      "我们特别强调通过数据抽象来构造高度模块化的程序.")
   (P "我们遵循这些原则已有十余年, 并自1976年以来在MIT及其他地方教授它们. "
      "我们坚信, 这些原则的应用帮助我们和学生成为了更好的程序员. "
      "当然, 它们并非魔法. 构建优秀的程序仍然充满挑战. "
      "系统化的方法固然重要, 但它无法替代聪明才智, 勤奋努力以及良好的品味.")
   (P "本书的初版草稿已被用于两门不同的课程: 一门本科实验课程, "
      "以及一门面向职业程序员和分析人员的研究生课程. "
      "在本科实验课程中, 学生要完成规模各异的编程项目, "
      "最终以一个为期一个月的团队项目作为高潮. "
      "这门课程的学生此前已学习过一门编程课程, "
      "因而对算法的发现有所了解, 并且至少熟悉一种高级程序设计语言, "
      "如Pascal, C或LISP. 本课程的重点在于构造中等规模的程序, "
      "而不是发明或实现算法. "
      "研究生课程的学生则拥有相当丰富的编程经验, 即使不进行较大的编程练习, "
      "他们也能够理解并欣赏我们所提出的编程方法. "
      "这使我们能够将时间集中用于形式化规格和程序验证等高级内容.")
   (P "第1章讨论了在程序构造过程中出现的问题, "
      "并给出了我们进行程序开发的方法概述. "
      "本书其余部分采用自底向上的组织方式. "
      "我们首先讨论作为本方法基本构件的各种抽象类型, "
      "随后再探讨将这些构件组合在一起时所产生的一些问题. "
      "这样的编排顺序源自实验课程的教学安排, "
      "因为在学期初期让学生尽早投入项目实践是非常重要的.")
   (P "第2章概述了一种程序设计语言CLU, "
      "它是越来越多的支持数据抽象机制的语言之一. "
      "书中的大多数示例实现都是用CLU编写的. "
      "我们在MIT教授的实验课程中使用CLU, "
      "而附录A则包含了一份完整的CLU参考手册. "
      "基于本书的实验课程可以很容易地使用任何支持数据抽象的语言来教授, "
      "例如Modula 2或Ada. 在稍加注意的情况下, "
      "该课程几乎可以使用任何高级程序设计语言来讲授. "
      "我们曾使用PL/1教授过这门课程, 本书中也包含了一些材料, "
      "旨在促进使用Pascal进行课程教学.")
   (P "第3-6章重点讨论三类抽象: 过程, 类型和迭代子. "
      "我们讨论这些抽象是什么, 以及如何对它们进行规格说明, 使用和实现. "
      "关于实现的部分讨论中, 有一些内容是特定于CLU的, 但大多数并非如此.")
   (P "第7章讨论如何将我们的编程方法与Pascal结合使用. "
      "这一章在书中的位置多少有些任意. "
      "当我们使用CLU教授实验课程时, 通常在学期末讲授本章内容. "
      "而对于学生将使用Pascal进行编程的课程, "
      "教师可能希望将本章内容与第3-6章的材料结合起来讲授.")
   (P "第8章再次强调了规格在我们编程方法中的作用. "
      "它在第3-6章的基础上, 对规格说明的含义进行了更为细致的讨论, "
      "并给出了一些关于如何编写良好规格说明的提示.")
   (P "第9章讨论测试与调试. 本章中的许多内容对有经验的程序员来说将是熟悉的. "
      "教师可能希望用自己的一些轶事和格言来补充有关调试的内容.")
   (P "第10章对全书中使用的规格说明语言进行了形式化, "
      "第11章则介绍了程序验证中所使用的关键概念. "
      "这两章的重点都在于通过形式化方法, "
      "加深读者对书中其他地方以非形式方式讨论之主题的直觉理解. "
      "这两章相较于本书其余部分, 假定读者具备稍强一些的数学背景. "
      "特别是, 我们假设学生已经接触过简单的一阶谓词演算和数学归纳法. "
      "这两章在书中的位置是根据它们在研究生课程中的使用情况来安排的. "
      "在本科实验课程中, 我们会将它们推迟到学期末再讲授. "
      "正因为如此, 本书的其余部分并不依赖于这两章的内容.")
   (P "第12至第14章概述了程序生产过程的若干方面. "
      "第12章讨论需求分析, 第13章讨论程序设计, "
      "第14章讨论设计评审与程序开发策略. "
      "在这三章中, 第13章的内容最为详尽. "
      "它强调基于对有用抽象的识别而进行的模块化分解. "
      "本章的核心是一则扩展的程序设计示例, 该设计的一个实现给出了附录B中. "
      "第12章和第14章则相对较为概括. "
      "它们讨论了一些既涉及管理问题又涉及技术问题的主题, "
      "其中许多内容超出了本书的范围.")
   (P "第15章讨论了我们的编程方法与程序设计语言之间的关系. "
      "它涵盖的内容与第7章大致相同, 但置于一个更为一般的背景之下.")
   (P "本书的大多数章节都以进一步阅读的建议作为结尾, "
      "并且每一章都包含一组练习. 我们刻意保持了参考文献列表的简短. "
      "文献的选择并非基于其科学贡献的大小, 而是因为我们认为, "
      "选修基于本书的课程的学生会觉得它们易于理解且富有帮助. "
      "有些练习涉及编程, 但许多并不需要. "
      "附录C包含了一组由五个编程问题组成的题目序列, "
      "其中包括一个为期一个月的团队项目. "
      "这些题目代表了我们本科实验课程中一种典型的作业安排.")
   (H2. "引论")
   (P "这本书将发展一种用于程序构造的方法论. "
      "我们的目标是帮助程序员构造高质量的程序" --
      "这些程序是可靠的, 并且相对容易理解, 修改和维护.")
   (P "一个非常小的程序, 由不超过几百行代码组成, "
      "可以作为一个单一的整体单元来实现. "
      "然而, 随着程序规模的增大, 这种整体式结构就不再合理, "
      "因为代码会变得难以理解. "
      "因此, 程序必须被分解为若干个相互独立的小程序, 称为"
      (Em "模块") ", 这些模块共同提供所需的功能. "
      "我们将重点关注这种分解过程: "
      "如何将大型编程问题分解为小问题, "
      "在这一过程中哪些类型的模块最有用, "
      "以及哪些技术能够提高将模块组合起来以解决原始问题的可能性.")
   (P "随着程序规模的增长, 正确地进行分解变得越来越重要, 原因有很多. "
      "首先, 大型程序的构造需要许多人共同参与. "
      "如果只有少数人参与开发, 他们自然会经常进行交流. "
      "这种接触可以减少对职责分工的误解, "
      "并减轻即使发生误解时所带来的后果的严重性. "
      "如果有许多人参与同一个项目, 频繁的沟通就变得不可能, "
      "因为那会消耗过多的时间. 因此, 程序必须被分解为若干部分, "
      "使个人能够在尽量少的相互联系下独立地开展工作.")
   (P "程序的有效寿命 (即其" (Em "生产") "阶段) 从交付给客户时开始. "
      "然而, 此时对程序的工作并未结束. "
      "代码中很可能还残留着需要处理的错误, "
      "而且为了提升程序的可用性或提供更符合用户需求的服务, "
      "往往还需要对程序进行修改. 这种程序"
      (Em "修改") "与" (Em "维护") "的活动, "
      "很可能会消耗整个项目投入总工作量的一半以上.")
   (P "在进行修改和维护时, 从头开始重新实现整个程序几乎总是不切实际的. "
      "相反, 必须在现有结构中嵌入修改, 因此程序结构能够适应变化就显得尤为重要. "
      "特别是, 程序的各个部分必须彼此独立, "
      "这样对某一部分的修改才能在不需要改变所有部分的情况下完成.")
   (P "最后, 大多数程序都具有很长的生命周期. "
      "人们常常需要在最初参与开发之后很久仍然与这些程序打交道. "
      "此外, 在任何项目的整个生命周期中, 人员更替都很可能是相当频繁的, "
      "而程序的修改和维护通常由最初实现者以外的人来完成. "
      "所有这些因素都表明, 程序必须以一种易于理解的结构方式来组织.")
   (P "在本书将要介绍的方法论中, 程序将通过基于对有用抽象的识别而进行的问题分解来开发. "
      (Em "分解") "与" (Em "抽象")
      "这两个关键概念构成了本书接下来要讨论的主题.")
   (H3. "分解和抽象")
   (P "解决任何大型问题的基本范式都是清楚的" -- "我们必须" (Q "分而治之")
      ". 然而, 仅仅决定遵循马基雅维利的这一格言, "
      "仍然距离真正解决手头的问题相去甚远. "
      "如何具体地对问题进行划分, 具有压倒性的重要性.")
   (P "在对程序进行分解时, 我们的目标是创建这样的模块: "
      "它们本身就是小型程序, 并且以简单, 明确定义的方式相互交互. "
      "如果我们达成这一目标, 不同的人就能够在几乎不需要彼此沟通的情况下, "
      "独立地负责不同的模块, 同时这些模块又能够协同工作. "
      "此外, 在程序的修改与维护过程中, "
      "也可以只修改其中某些模块, 而不必影响所有其他模块.")
   (P "当我们对一个问题进行分解时, 我们将其划分为若干可分离的子问题, 并使其满足以下条件:"
      (Ol (Li "每个子问题都处在相同的细节层次上;")
          (Li "每个子问题都可以独立求解;")
          (Li "子问题的解能够组合起来以解决原始问题."))
      "使用归并排序进行排序, 是通过分解来解决问题的一个优雅示例. "
      "它将对任意规模列表进行排序的问题, 分解为两个更简单的问题: "
      "对长度为二的列表进行排序, 以及将两个任意长度的已排序列表进行合并.")
   (P "分解是一种在许多学科中由来已久且十分有用的技术. "
      "从巴贝奇的时代开始, 人们就已经认识到诸如宏和子程序之类的机制, "
      "作为程序员进行分解的工具所具有的价值. "
      "然而, 需要认识到的是, 分解并非灵丹妙药, "
      "如果使用不当, 反而会产生有害的效果. "
      "此外, 对于规模庞大或理解不充分的问题, 正确地进行分解也十分困难. "
      "最常见的问题是, 各个独立组件虽然能够解决所陈述的子问题, "
      "却无法组合起来解决原始问题. "
      "这也是系统集成往往十分困难的原因之一.")
   (P "例如, 可以想象这样一种情况: "
      "组建一群作家, 给每个人一份角色名单和一个大致的剧情大纲, "
      "并要求他们各自撰写某个角色的台词. "
      "这些作者可能会出色地完成各自的任务, "
      "但他们的合力很可能无法组成一部出色的戏剧. "
      "它或许具有艺术性, 但却缺乏任何连贯性或整体感. "
      "如果最初的任务划分方式适得其反, "
      "那么各自独立可接受的解决方案就不能指望能够正确地组合在一起.")
   (P "抽象是一种通过改变考虑细节的层次来高效进行分解的方法. "
      "当我们从问题中进行抽象时, "
      "就是在努力将原始问题转化为更简单的问题的过程中, 同意忽略某些细节. "
      "例如, 我们可以将写戏剧的问题抽象为决定它应有多少幕, 它的剧情安排如何, "
      "或甚至抽象为把握各段对话的意思 (而非具体措辞). "
      "在完成这一抽象之后, 原始问题 (即撰写全部台词) 仍然存在, "
      "但已经被大大简化" --
      "甚至可能简化到可以交给他人或几个人来完成的程度. "
      "(大仲马就是以这种方式大量创作小说的.)")
   (P "先抽象再分解的范式是程序设计过程中的典型方法: "
      "分解用于将软件拆分为可以组合以解决原始问题的组件; "
      "抽象则有助于选择合适的组件. "
      "我们在这两种过程之间交替进行, "
      "直到将原始问题缩减为一组我们已经知道如何解决的问题为止.")
   (H3. "抽象")
   (P "抽象的过程可以看作是多对一映射的应用. "
      "它允许我们遗忘某些信息, 因此可以把不同的事物当作相同的来对待. "
      "我们这样做的目的是希望通过将相关属性与不相关属性分离来简化我们的分析. "
      "然而, 必须记住, 相关性往往依赖于上下文. "
      "在小学课堂的环境中,我们学习将" (&c* (@/ $8 $3) $3)
      "和" (&+ $5 $3) "抽象为用数字" $8 "表示的概念. "
      "更晚一些, 我们常常在不愉快的情况下学到, "
      "在许多计算机上, 这种抽象可能会把我们带入麻烦的世界.")
   (P "例如, 考虑图1.1所示的结构. 这里的概念是" (Q "哺乳动物")
      ". 所有哺乳动物都有某些共同特征, 比如雌性会产奶. "
      "在这个抽象层次上, 我们关注这些共同特征, "
      "而忽略各种哺乳动物类型之间的差异.")
   (P "在较低的抽象层次上, 我们可能对哺乳动物的具体实例感兴趣. "
      "然而, 即使在这里, 我们仍然可以通过考虑不是个体, "
      "甚至不是物种, 而是相关物种的群体来进行抽象. "
      "在这个层次上, 我们会有诸如灵长类或啮齿类这样的分组. "
      "在这里, 我们依然关注共同特征, 比如所有灵长类都是胎生的, "
      "而不是关注例如人类和黑猩猩之间的差异. "
      "这些差异将在更低的抽象层次上变得相关.")
   (P "图1.1的抽象层次结构来自动物学领域, "
      "但它同样可能出现在实现某些动物学应用的程序中. "
      "一个更具体的面向计算机的例子是" (Q "文件")
      "的概念, 它在许多程序中都很有用. "
      "文件从原始存储中抽象出来, "
      "提供了命名实体的长期的, 在线的存储. "
      "不同的操作系统对文件有不同的实现方式; "
      "例如, 文件名的结构因系统而异, "
      "文件在辅助存储设备上的存储方式也各不相同.")
   (P "在本书中, 我们关注的是抽象在程序中的一般应用. "
      "迄今为止这一领域最重要的发展是高级语言的发展. "
      "通过直接与高级语言的构造打交道, "
      "而不是与可以将其转换成的"
      "具有多种可能的机器指令序列打交道, "
      "程序员实现了显著的简化.")
   (&label
    (CodeB "found := false
i := lowbound(a)
while i < highbound(a) + 1 do
  if a[i] = e
    then z := i
    found := true
    end
  i := i + 1
  end

found := false
i := highbound(a)
while i > lowbound(a) - 1 do
  if a[i] = e
    then z := i
    found := true
    end
  i := i + 1
  end")
    "图1.2 两个程序片段")
   (P "然而, 近年来即便对于高级语言程序一般所能达到的抽象层次, "
      "程序员也变得不再满意. 例如, 考虑图1.2中的程序片段. "
      "在由编程语言所定义的抽象层次上, "
      "这两个片段显然是不同的: "
      "如果" $a "中存在" $e "的某个出现, "
      "那么一个片段找到的是其首次出现的索引, "
      "而另一个片段找到的是其最后出现的索引. "
      "一个将" $i "置为" (&+ (&highbound $a) $1)
      ", 另一个将" $i "置为" (&- (&lowbound $a) $1)
      ". 然而, 不难看出这两段程序都是为了达到相同的目的: "
      "如果" $a "中不存在" $e "的出现, 置" $found
      "为假, 否则将" $found "置为真, 将" $z
      "置为" $a "中某个" $e "的出现的索引. "
      "如果这就是我们所想要的, "
      "那么这些程序片段本身显然没有达到我们所想要的抽象层次.")
   
   (H2. "CLU概览")
   (H3. "程序结构")
   (H3. "整数, 布尔和数组")
   (H3. "对象")
   (H3. "声明和赋值")
   (H3. "过程")
   (H3. "表达式")
   (H3. "数据类型")
   (H3. "输入/输出")
   (H3. "面向对象程序")
   (H2. "过程抽象")
   (H3. "抽象的好处")
   (H3. "规格")
   (H3. "过程抽象的规格")
   (H3. "实现过程")
   (H3. "更为一般的过程")
   (H3. "设计过程抽象")
   (H3. "总结")
   (H2. "数据抽象")
   (H3. "数据抽象的规格")
   (H3. "实现数据抽象")
   (H3. "使用数据抽象")
   (H3. "实现多项式")
   (H3. "理解实现的辅助")
   (H3. "参数化数据抽象")
   (H3. "列表")
   (H3. "有序列表")
   (H3. "讨论")
   (H3. "总结")
   (H2. "异常")
   (H3. "规格")
   (H3. "CLU的异常机制")
   (H3. "在程序中使用异常")
   (H3. "设计问题")
   (H3. "总结")
   (H2. "迭代抽象")
   (H3. "规格")
   (H3. "CLU的迭代子")
   (H3. "例子")
   (H3. "设计问题")
   (H3. "总结")
   (H2. "使用Pascal")
   (H3. "过程和函数抽象")
   (H3. "数据抽象")
   (H3. "多态抽象")
   (H2. "更多关于规格的讨论")
   (H2. "测试和debug")
   (H3. "测试")
   (H3. "单元测试和集成测试")
   (H3. "测试的工具")
   (H3. "debug")
   (H3. "防御性编程")
   (H3. "总结")
   (H2. "编写形式化规格")
   (H3. "辅助规格简介")
   (H3. "过程抽象的接口规格")
   (H3. "数据抽象的接口规格")
   (H3. "总结")
   (H2. "程序验证一瞥")
   (H3. "对于直线代码进行推理")
   (H3. "对于多路径代码进行推理")
   (H3. "对于过程进行推理")
   (H3. "对于数据抽象进行推理")
   (H3. "一些关于形式化推理的评注")
   (H3. "总结")
   (H2. "程序设计引论")
   (H3. "软件生命周期")
   (H3. "需求分析概览")
   (H3. "一个示例问题")
   (H3. "总结")
   (H2. "设计")
   (H2. "设计和实现之间")
   (H2. "使用其他语言")
   ))