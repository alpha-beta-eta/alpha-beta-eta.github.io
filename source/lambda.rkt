#lang racket
(provide lambda.html)
(require SMathML)
(define lambda.html
  (TmPrelude
   #:title "lambda演算: 其句法和语义"
   #:css "styles.css"
   (H1 $lambda "演算: 其句法和语义")
   (P "本书关于纯粹的无类型" $lambda "演算, 而不是" $lambda
      "演算和类型论, 也不是" $lambda "演算在其他各个领域的应用. "
      "可以说, 我还不具备阅读这本书所需要的maturity, "
      "甚至也没有读这本书的必要, 但我就是想读一读而已.")
   (H2 "第1章 引论")
   (H3 "第1.1节 lambda演算的各个方面")
   (P "lambda演算是一种将函数当作规则而不是图的无类型理论. "
      "&quot;将函数当作规则&quot;是一种曾经流行的函数概念, "
      "其指的是从参数到值的过程, 这个过程往往是由定义编码的. "
      "将函数视为图 (即参数和值的序对的集合) 的想法通常归功于Dirichlet, "
      "是一项重要的数学贡献. 然而, " $lambda "演算重新将函数视为规则"
      "以强调其计算性的方面.")
   (P "将函数视为规则以全然的一般性考虑问题. 例如, 我们可以考虑由通常的自然语言"
      "定义的函数应用于同样由自然语言表述的参数. 或者, 更确切地, 考虑由供机器运行的"
      "程序给定的函数应用于其他这样的程序. 在这两种情况下我们都拥有一个无类型的结构, "
      "其中研究的对象同时为函数和参数. 这是无类型" $lambda "演算的起点. 特别地, "
      "一个函数可以被应用于自身. 对于数学中 (或者说Zermelo-Fraenkel集合论中) 的"
      "通常函数概念而言, 这是不可能的 (因为基础公理). (也见练习18.5.30)")
   (P $lambda "演算存在三个方面:"
      (Ol #:attr* '((type "I"))
          (Li "数学基础.")
          (Li "计算.")
          (Li "纯lambda演算."))
      "这些方面将在之后的数页描述. 其他一些关于lambda演算的基础的观点, 也可见Scott "
      "[1975b], [1980]和[1980a].")
   (H4 "I. 基础和lambda演算")
   (P $lambda "演算和与其相关的组合子逻辑理论的建立者心中拥有两个目的:"
      (Ul (Li "建立一般的函数理论 (例如, 可以处理公式操作).")
          (Li "用逻辑概念扩展理论以提供逻辑和(部分)数学的基础."))
      "第一点为Sch&ouml;nfinkel和Curry (他们是组合子逻辑的建立者) 所显式强调, 而隐式"
      "见于Church建立" $lambda "演算的工作中.")
   (P "不幸的是, 所有这些为数学提供基础的尝试都失败了. "
      )
   ))