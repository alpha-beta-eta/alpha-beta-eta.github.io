#lang racket
(provide order.html)
(require SMathML)
(define (set-compact op)
  (set-attr* op 'lspace "0" 'rspace "0"))
(define $forall (Mo "&forall;"))
(define $& (Mo "&amp;"))
(define (∀ x S)
  (@ $forall (∈ x S)))
(define $exists (Mo "&exist;"))
(define $uarr (set-compact (Mo "&uarr;")))
(define $darr (set-compact (Mo "&darr;")))
(define (&uarr x) (: $uarr x))
(define (&darr x) (: $darr x))
(define $par (Mo "&par;"))
(define $!<= (Mo "&nle;"))
(define $<==> (Mo "&DoubleLongLeftRightArrow;"))
(define $or (Mo "&or;"))
(define $and (Mo "&and;"))
(define $Or (Mo "&bigvee;"))
(define $And (Mo "&bigwedge;"))
(define &Or
  (case-lambda
    ((S) (: $Or S))
    ((Q S) (: (_ $Or Q) S))))
(define &And
  (case-lambda
    ((S) (: $And S))
    ((Q S) (: (_ $And Q) S))))
(define-infix*
  (&par $par)
  (&!<= $!<=)
  (&<==> $<==>)
  (&or $or)
  (&and $and)
  (&& $&))
(define order.html
  (TmPrelude
   #:title "格与序导论"
   #:css "styles.css"
   (H1 "格与序导论")
   (H2 "第1章 有序集")
   (P "序, 序, 序&mdash;&mdash;其渗透着整个数学和日常生活, 以至于我们将序视为理所当然的存在. "
      "序以各种伪装出现: 第一, 第二, 第三, ...; 更大vs更小; 更好vs更坏. 进展, 先后, 倾向"
      "都可以被归结为序的概念. 我们的首要任务在于打磨这些不够精确的想法, 形式化&quot;"
      "小于等于&quot;这种关系. 除了呈现有序集的例子和基本性质, 本章也引入了图表, "
      "其使得序理论生动形象起来.")
   (H3 "有序集")
   (P "究竟何谓序? 或者更数学地说, 何谓有序集?")
   ((example #:n "1.1")
    
    )
   ((definition #:n "1.2")
    "令" $P "是一个集合. " $P "上的一个" (B "序") " (或者说" (B "偏序") ") 是" $P
    "上的一个二元关系" $<= "满足对于所有的" (∈ $x $y $z $P) "有"
    (Ol #:attr* '((type "i"))
        (Li (&<= $x $x) ";")
        (Li (&<= $x $y) "和" (&<= $y $x) "可以推出" (&= $x $y) ";")
        (Li (&<= $x $y) "和" (&<= $y $z) "可以推出" (&<= $x $z) "."))
    "以上的条件分别被称为" (B "自反性") ", " (B "反对称性") "和" (B "传递性")
    ". 一个装备有序关系" $<= "的集合" $P "就成为了一个" (B "有序集") " (或者说"
    (B "偏序集") "). 有些作者使用缩略词" (B "poset") ". 在任意集合上, " $=
    "是一个序, 即" (B "离散序") ". 集合" $P "上满足自反和传递但不必然满足反对称性的关系被称为一个"
    (B "半序") ", 或者有些作者称为" (B "预序") ". " $P "上的一个序关系" $<= "导出了" $P
    "上的一个" (B "严格不等") "的关系" $< ": " $P "中" (&< $x $y) "当且仅当" (&<= $x $y)
    "并且" (&!= $x $y) ". 基于" $< "而不是" $<= "重述以上三个条件也是有可能的. 其他与" $<=
    "相关的记号是可以预见到的, 例如我们交换地使用" (&<= $x $y) "和" (&>= $y $x) ". "
    (&!<= $x $y) "的意思是'" (&<= $x $y) "为假'. [译注: 换言之, " (&!in (tu0 $x $y) (set-compact $<=))
    ".] 我们使用不那么常见的符号" $par "表示不可比较性, 记" (&par $x $y) "如果" (&!<= $x $y)
    "且" (&!<= $y $x) ". 如果" $P "是一个有序集而" $Q "是其一个子集, 那么" $Q "从" $P
    "那里" (B "继承") "了自然的序关系, 我们将其称为" (B "导出序") " [译注: 也有人将其翻译成诱导序].")
   ((definition #:n "1.3. 链和反链")
    "令" $P "是一个有序集, 那么" $P "被称为一个" (B "链") ", 如果对于所有的" (∈ $x $y $P)
    "都有" (&<= $x $y) "或" (&<= $y $x) ", 即任意两个元素都是可以比较的. 链也被称为" (B "线序集")
    "或者" (B "全序集") ". 反链是另一个极端. 有序集" $P "被称为一个" (B "反链") ", 如果"
    (&<= $x $y) "仅当" (&= $x $y) ". 显然, 在导出序下, 链的子集是链, 反链的子集是反链. 令" $P
    "是" $n "元素集" (setE $0 $1 $..h (&- $n $1)) ", 我们用" $n:bold "表示赋予了集合" $P
    "序" (&< $0 $1 $..c (&- $n $1)) "的链, 而" (OverBar $n:bold) "表示作为反链的" $P
    ". 任何集合" $S "都可以被赋予离散序而成为反链" (OverBar $S) ".")
   ((definition #:n "1.4. 序同构")
    "我们称" $P "和" $Q "是" (B "序同构的") ", 如果存在一个保持序关系的双射"
    (func $phi $P $Q) ". 换言之, 对于任意的" (∈ $x $y $P) ", " (&<= $x $y) "当且仅当"
    (&<= (app $phi $x) (app $phi $y)) ". 实际上, 保持序关系的映射必然是单射, 因为"
    (MB (deriv0 (&= (app $phi $x) (app $phi $y)) $<==>
                (&& (&<= (app $phi $x) (app $phi $y))
                    (&<= (app $phi $y) (app $phi $x)))
                $<==>
                (&& (&<= $x $y) (&<= $y $x)) $<==>
                (&= $x $y)))
    "当然, 双射并非都是保持序关系的. 一旦我们有了一个序同构" (func $phi $P $Q)
    ", 那么逆映射" (func (inv $phi) $Q $P) "也是一个序同构.")
   ((example #:n "1.5")
    "实数集" $RR "在通常序下形成了一个链. " (&:= $NN (setE $1 $2 $3 $..h))
    ", " $ZZ ", " $QQ "也都在通常序下成为了链. 这些序关系都与其上的运算相协调. "
    "我们记" (&:= $NN_0 (&union $NN (setE $0))) ". "
    )
   
   (H2 "第2章 格与完全格")
   ((definition #:n "2.1")
    "令" $P "是一个有序集而" (&sube $S $P) ". 一个元素" (∈ $x $P) "被称为" $S
    "的一个" (B "上界") ", 如果对于每个" (∈ $s $S) "有" (&<= $s $x) ". " (B "下界")
    "可以被对偶地定义. " $S "的所有上界构成的集合记作" $S^u " (读作'" $S " " (B "upper")
    "'), 而其所有下界构成的集合记作" $S^l " (读作'" $S " " (B "lower") "'):"
    (MB (&cm (&:= $S^u (setI (∈ $x $P) (: (∀ $s $S) (&<= $s $x))))
             (&:= $S^l (setI (∈ $x $P) (: (∀ $s $S) (&>= $s $x))))) ".")
    "既然" $<= "是传递的, " $S^u "总是一个up-set而" $S^l "总是一个down-set. 如果" $S^u
    "拥有最小元" $x ", 那么" $x "被称为" $S "的" (B "最小上界") ". 等价地, " $x
    "是" $S "的最小上界, 如果"
    (Ol #:attr* '((type "i"))
        (Li $x "是" $S "的一个上界;")
        (Li "对于所有" $S "的上界" $y ", " (&<= $x $y) "."))
    $S "的最小上界存在当且仅当存在" (∈ $x $P) "满足"
    (MB (∀ $y $P) (bra0 (&<==> (@ (∀ $s $S) (&<= $s $y)) (&<= $x $y))))
    "并且这就刻画了" $S "的最小上界. 对偶地, 如果" $S^l "拥有最大元, 那么其被称为"
    $S "的" (B "最大下界") ". 既然最小元和最大元都是唯一的, 那么最小上界和最大下界"
    "也是唯一的. " $S "的最小上界也被称为" $S "的" (B "上确界") ", 记作" (ap 'sup $S)
    ". " $S "的最大下界也被称为" $S "的" (B "下确界") ", 记作" (ap 'inf $S) ".")
   ((remark #:n "2.2. 顶和底")
    "在上确界和下确界的定义中, 存在两种极端的情况, 即空集和有序集本身, 这值得单独一说. "
    "回忆一下, 当" $P "的顶和底元素存在时, 其被分别记为" $top "和" $bottom
    ". 很容易看出来, 如果" $P "具有顶元素, 那么" (&= $P^u (setE $top)) "而此时"
    (&= (ap 'sup $P) $top) ". 若" $P "没有顶元素, 那么" (&= $P^u $empty) ", 因而"
    (ap 'sup $P) "并不存在. 根据对偶性, 当" $P "具有底元素时, " (&= (ap 'inf $P) $bottom)
    ". 现在考虑空集的情况, 此时每个" (&in $x $P) "都是其上界, 因此" (&= (^ $empty $u) $P)
    "而" (ap 'sup $empty) "存在当且仅当" $P "具有底元素, 若存在则有"
    (&= (ap 'sup $empty) $bottom) ". 对偶地, 若" $P "有顶元素, 则"
    (&= (ap 'inf $empty) $top) ".")
   ((notation #:n "2.3")
    "我们记" (ap 'sup (setE $x $y)) "为" (&or $x $y) " (读作'" (B $x " join " $y)
    "'), " (ap 'inf (setE $x $y)) "为" (&and $x $y) " (读作'" (B $x " meet " $y)
    "'). 类似的, 我们记" (&Or $S) " (即'" (B "join of " $S) "') 和"
    (&And $S) " (即'" (B "meet of " $S) "') 而不是" (ap 'sup $S) "和"
    (ap 'inf $S) ". 若有必要指出join和meet在某一个特定的有序集" $P "中寻找, 那么记"
    (&Or $P $S) "和" (&And $P $S) ". 我们也经常遇到" (&= $S (_ (setE $A_i) (∈ $i $I)))
    "的情形, 其中" $I "是一个指标集, 那么" (&Or (∈ $i $I) $A_i) "是比"
    (&Or (setI $A_i (∈ $i $I))) "更紧凑的记号.")
   ((definition #:n "2.4")
    "令" $P "是一个非空的有序集."
    (Ol #:attr* '((type "i"))
        (Li "若" (&or $x $y) "和" (&and $x $y) "对于任意的" (∈ $x $y $P)
            "均存在, 那么" $P "被称为一个" (B "格") ".")
        (Li "若" (&Or $S) "和" (&And $S) "对于任意的" (&sube $S $P)
            "均存在, 那么" $P "被称为一个" (B "完全格") ".")))
   ((remark #:n "2.5")
    (Ol (Li "令" $P "是任意的有序集. 如果" (∈ $x $y $P) "而" (&<= $x $y)
            ", 那么" (&= (^ (setE $x $y) $u) (&uarr $y)) "且"
            (&= (^ (setE $x $y) $l) (&darr $x)) ". 因为" (&uarr $y)
            "的最小元是" $y "而" (&darr $x) "的最大元是" $x ", 我们有"
            (&= (&or $x $y) $y) "和" (&= (&and $x $y) $x) ". 特别地, 鉴于"
            $<= "是自反的, " (&= (&or $x $x) $x) "且" (&= (&and $x $x) $x) ".")
        (Li "在有序集" $P "中, " (setE $x $y) "的最小上界" (&or $x $y)
            "可能出于两种原因并不存在:"
            (Ol #:attr* '((type "a"))
                (Li "因为" $x "和" $y "没有共同的上界;")
                (Li "因为它们没有&quot;最小的&quot;上界.")))
        (Li ""
            )
        (Li "令" $P "是一个格, 对于" (∈ $a $b $c $d $P) ","
            (Ol #:attr* '((type "i"))
                (Li (&<= $a $b) "可以推出" (&<= (&or $a $c) (&or $b $c)) "和"
                    (&<= (&and $a $c) (&and $b $c)) ".")
                (Li (&<= $a $b) "且" (&<= $c $d) "可以推出"
                    (&<= (&or $a $c) (&or $b $d)) "和"
                    (&<= (&and $a $c) (&and $b $d)) ".")))
        (Li "令" $P "是一个格. 令" (∈ $a $b $c $P) "并假定"
            (&<= $b $a (&or $b $c)) ". 既然" (&<= $c (&or $b $c))
            ", 我们有" (&= (&or (@ (&or $b $c)) $c) (&or $b $c))
            ". 因此, "
            (MB (&<= (&or $b $c) (&or $a $c)
                     (&= (&or (@ (&or $b $c)) $c) (&or $b $c))))
            "即" (&= (&or $a $c) (&or $b $c)) ". 这个简单的观察及其对偶"
            "在计算图上的join和meet时是特别有用的.")))
   ((remark #:n "2.6")
    (Ol (Li "令" $P "是非空有序集. 如果" (&<= $x $y) ", 那么"
            (&= (&or $x $y) $y) "且" (&= (&and $x $y) $x)
            ", 因此为了证明" $P "是一个格, 只需要考虑不可比较的元素是否拥有"
            "join和meet即可. 特别地, 每个(非空)链是一个格. 显然, "
            (&cm $RR $QQ $ZZ $NN) "在其通常的序关系下是一个格. 它们都不是"
            "完全格, 每个都缺失顶元素, 而一个完全格必然拥有顶和底. 然而, 对于实数"
            (&< $x $y) ", 闭区间" (li0 $x $y) "是一个完全格. "
            )
        )
    )
   (H2 "第3章 形式概念分析")
   
   (H2 "第4章 模格, 分配格, 布尔格")
   
   (H2 "第5章 表示: 有限情形")
   
   (H2 "第6章 Congruences")
   
   (H2 "第7章 完全格与Galois连接")
   
   (H2 "第8章 完全偏序 (CPO) 和不动点定理")
   
   (H2 "第9章 域 (domain) 和信息系统")
   
   (H2 "第10章 极大原理")
   
   (H2 "第11章 表示: 一般情形")
   
   ))