#lang racket
(provide cmu15210.html)
(require SMathML)
(define (vref A i)
  (ap A (bra0 i)))
(define cmu15210.html
  (TnTmPrelude
   #:title "并行和顺序算法"
   #:css "styles.css"
   (H1. "并行和顺序算法")
   (H2. "引论")
   (H2. "并行")
   (H2. "规格, 问题, 实现")
   (H2. "基因测序 (一个例子)")
   (H2 "第I部分 背景")
   (H2. "集合和关系")
   (H2. "图论")
   (H2 "第II部分 一个刻画算法的语言")
   (H2. "引论")
   (H2. "函数式算法")
   (H2. "lambda演算")
   (H2. "SPARC语言")
   (H2 "第III部分 并发")
   (H2. "线程, 并发, 并行")
   (H2. "临界区块和互斥")
   (H2 "第IV部分 算法分析")
   (H2. "引论")
   (H2. "渐近")
   (H2. "代价模型")
   (H2. "递推")
   (H2 "第V部分 序列")
   (H2. "引论")
   (H3. "定义序列")
   (H2. "序列抽象数据类型")
   (H3. "抽象数据类型")
   (H3. "基本函数")
   (H3. "tabulate")
   (H3. "map和filter")
   (H3. "子序列")
   (H3. "append和flatten")
   (H3. "update和inject")
   (H3. "collect")
   (H3. "使用迭代进行聚合")
   (H3. "使用归约进行聚合")
   (H3. "使用扫描进行聚合")
   (H2. "数组序列")
   (H2. "序列的代价")
   (H2. "例子")
   (H2. "瞬态和单线程序列")
   (H2. "树序列")
   (H2 "第VI部分 算法设计和分析")
   (H2. "引论")
   (H2. "基本技术")
   (H3. "算法归约")
   (H3. "暴力")
   (H2. "分而治之")
   (H3. "分而治之")
   (H3. "归并排序")
   (H3. "序列扫描")
   (H3. "Euclid TSP")
   (H3. "使用reduce进行分而治之")
   (H2. "收缩")
   
   ))
#;
(define cmu15210.html
  (TmPrelude
   #:title "并行和顺序算法"
   #:css "styles.css"
   (H1 "并行和顺序算法")
   (H3 "第1章 引论")
   (P "本书意图呈现利用当今的计算机解决问题的技术, 包括顺序算法和并行算法. "
      "举个例子, 你或许想要寻找到咖啡馆的最短路径 (不限于固定的店家, "
      "追求的是路径最短). 我们关心的是正确性 (给出的路径的确是所有可能路径中最短的), "
      "效率 (消耗的能量相对较少), 以及性能 (用时尽可能短).")
   (P "本书涵盖了利用计算机解决问题的一些方面, 诸如"
      (Ul (Li "精确定义想要解决的问题,")
          (Li "解决问题的各种算法设计技巧,")
          (Li "设计抽象数据类型和用以实现它们的数据结构,")
          (Li "分析和比较各种算法和数据结构的代价.")))
   (P "我们既关心并行算法也关心顺序算法. 然而, 这两种算法并没有那么不同.")
   (H3 "第2章 并行")
   (P "术语" (Q "并行") "指的是同时运行多个计算或者说任务的能力. "
      "如今一切计算机系统都拥有并行性, 并以多种不同的层次呈现.")
   (H4 "第1节 并行硬件")
   (P (B "并行何以重要. ") "首先, 直接的理由是并行计算比顺序计算更快. "
      "速度一直是计算机科学及其应用的重要主题. 例如, 搜索引擎应该要以"
      (Q "交互速度") "完成任务, 一般来说是100毫秒以内. "
      "其次, 就能量使用而言, 并行计算的效率更高. 根据基本物理, "
      "主频达到原本的两倍的话, 功耗将是原本的八倍. "
      "但是, 通过并行, (理想情况下)我们可以在不消耗更多能量的情况下"
      "以更快的速度完成任务. 概括一下, 其实也就是性能问题和效率问题.")
   (P "假设我们有两台并行的电脑和一台顺序的电脑, 并且它们每台的速度和功耗相同. "
      "如果我们将一个任务划分成两个相当的子任务, 分别让这两台并行的"
      "电脑计算, 最终合并它们的结果. 那么, 最终我们可以用一台顺序电脑"
      "所消耗的时间的一半完成相同的任务, 但是总耗能没有发生改变.")
   (P "这完全是理论上的理想情况, 因为划分任务和合并结果都有开销. "
      "这将导致耗时和耗能的增加. 有的时候, 当并行规模增长时, "
      "这些开销可以变得渐渐能够忽略不计, 但并不总是如此.")
   (P "我们以做菜打比方, 例如若要准备三道菜, 可以一个人按顺序做三道, "
      "也可以三个人同时做, 每个人负责一道. 可能的开销是显然的 (例如需要分配谁做哪道菜), "
      "而且在某种意义上还需要更多的资源, 比如说三个人同时做需要三口锅.")
   (H4 "第2节 并行软件")
   (H4 "第3节 work, span, 并行时间")
   (P "本节描述了两种度量, work和span.")
   
   (H3 "第3章 描述, 问题, 和实现")
   (P "本章回顾了描述, 问题, 实现的基本概念.")
   (H4 "第1节 算法描述")
   ((definition #:n "3.1")
    "给定一个长度为" $n "的序列" $A ", 其元素取自于一个全序集, 并且其比较运算符为"
    $<= ", 返回一个序列" $B ", 其包含恰好相同的元素 (重复元素的个数当然也要相同), "
    "但是满足对于任意的" $i "和" $j " (" (&< (&<= $0 $i) $j $n)
    ") 都有" (&<= (vref $B $i) (vref $B $j)) ".")
   (H3 "第4章 基因测序 (一个例子)")
   (H2 "第I部分 背景")
   (H3 "第5章 集合和关系")
   (H3 "第6章 图论")
   (H2 "第II部分 描述算法的语言")
   (H3 "第7章 引论")
   (H3 "第8章 函数式算法")
   (H3 "第9章 lambda演算")
   (H3 "第10章 SPARC语言")
   (H2 "第III部分 并发")
   (H3 "第11章 线程, 并发, 和并行")
   
   ))