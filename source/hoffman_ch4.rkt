#lang racket
(provide div:hoffman_ch4)
(require SMathML "linear_algebra_utils.rkt")
(define div:hoffman_ch4
  (TmDiv
   (H2 "第4章 多项式")
   (H3 "第4.1节 代数")
   (P "本章的目的在于建立域上的多项式代数的一些基本性质. 如果我们先引入域上的"
      "线性代数的概念的话, 讨论会更加容易.")
   ((definition)
    "令" $F "是一个域, 域" $F "上的一个线性代数是一个" $F "上的向量空间" $V:fraktur
    ", 其带有一个额外的被称为向量的乘法的运算. 它将每对" $V:fraktur "中的向量" $alpha
    "和" $beta "联系以一个" $V:fraktur "中的向量" (&i* $alpha $beta) ", 其被称为"
    $alpha "和" $beta "的积, 满足"
    (Ol #:attr* '((type "a"))
        (Li "乘法是结合的,"
            (MB (assoc* $alpha $beta $gamma) ";"))
        (Li "乘法对于加法是分配的,"
            (MB (disR $alpha $beta $gamma) "且" (disL $alpha $beta $gamma) ";"))
        (Li "对于每个" $F "中的标量" $c ","
            (MB (&= (&i* $c (@i* $alpha $beta))
                    (&i* (@i* $c $alpha) $beta)
                    (&i* $alpha (@i* $c $beta))) ".")))
    "如果" $V:fraktur "中存在元素" $1 "满足" (&= (&i* $1 $alpha) (&i* $alpha $1) $alpha)
    "对于每个" $V:fraktur "中的" $alpha "均成立, 那么我们就称" $V:fraktur "是域" $F
    "上一个含幺元的线性代数, 并称" $1 "为" $V:fraktur "的幺元. 代数" $V:fraktur
    "被称为是交换的, 如果对于所有" $V:fraktur "中的" $alpha "和" $beta "有"
    (commute* $alpha $beta) ".")
   ((example #:n "1")
    "域" $F "上的" n*n "矩阵的集合, 在通常的运算下, 是一个含幺元的线性代数. 特别地, 域本身"
    "就是一个含幺元的线性代数. 这个代数在" (&>= $n $2) "时不交换, 域本身当然是交换的.")
   ((example #:n "2")
    "一个向量空间上的所有线性算子的空间, 以复合为积, 是一个含幺元的线性代数. 它是交换的"
    "当且仅当空间是一维的. [译注: 零维其实也是.]")
   (P "读者或许对于" $RR^3 "中的点积和叉积已经有了一些经验. 如果确是如此的话, 那么他应该观察到"
      "这两种积和上面的线性代数的定义中所描述的向量乘法均不是一种类型的运算. 点积是一种&quot;"
      "标量积&quot;, 也就是说, 它将一对向量联系以一个标量, 因此它当然不是我们现在所讨论的那种乘法. "
      "叉积的确联系每对" $RR^3 "中的向量以一个" $RR^3 "中的向量, 然而它不是一种结合运算.")
   (P "本节的剩余部分将致力于构造一种与之前的两个例子截然不同的代数. 令" $F "是一个域, " $S
      "是非负整数的集合. 根据第2章的例子3, 所有从" $S "到" $F "的函数构成了一个域" $F
      "上的向量空间. 我们将其记作" $F^inf ". 因此, " $F^inf "中的向量是" $F
      "中的标量" $f_i "的无穷序列" (&= $f (tu0 $f_0 $f_1 $f_2 $..h)) ". 如果"
      (&cm (&= $g (tu0 $g_0 $g_1 $g_2 $..h)) (&in $g_i $F)) "并且" $a "和" $b "是" $F
      "中的标量, 那么" (LC $a $f $b $g) "是由"
      (MB (&= (LC $a $f $b $g)
              (tu0 (LC $a $f_0 $b $g_0)
                   (LC $a $f_1 $b $g_1)
                   (LC $a $f_2 $b $g_2)
                   $..h)))
      "给出的无穷序列. 我们这样定义" $F^inf "中的积, 对于" $F^inf "中的向量" $f
      "和" $g ", 向量" (&i* $f $g) "由"
      (MB (&cm (&= (_ (@i* $f $g) $n)
                   (sum (&= $i $0) $n (&i* $f_i (_ $g (&- $n $i)))))
               (&= $n (&cm $0 $1 $2 $..h))))
      "给出, 因而"
      (MB (&= (&i* $f $g)
              (tu0 (&i* $f_0 $g_0)
                   (&+ (&i* $f_0 $g_1) (&i* $f_1 $g_0))
                   (&+ (&i* $f_0 $g_2) (&i* $f_1 $g_1) (&i* $f_2 $g_0))
                   $..h)))
      "并且因为对于" (&= $n (&cm $0 $1 $2 $..h)) "有"
      (MB (&= (_ (@i* $g $f) $n) (conv $i $n $g $f) (conv $i $n $f $g) (_ (@i* $f $g) $n)))
      "所以乘法是交换的 [译注: 这里用到了域的乘法的交换性质], 即" (commute* $f $g)
      ". 如果" $h "也属于" $F^inf ", 那么对于" (&= $n (&cm $0 $1 $2 $..h)) "我们有"
      (MB (deriv (_ (bra0 (&i* (@i* $f $g) $h)) $n)
                 (conv $i $n (@i* $f $g) $h)
                 (sum (&= $i $0) $n
                      (&i* (@conv $j $i $f $g) (_ $h (&- $n $i))))
                 (sum (&= $i $0) $n
                      (sum (&= $j $0) $i
                           (&i* $f_j (_ $g (&- $i $j)) (_ $h (&- $n $i)))))
                 (sum (&= $j $0) $n
                      (sum (&= $i $j) $n
                           (&i* $f_j (_ $g (&- $i $j)) (_ $h (&- $n $i)))))
                 (sum (&= $j $0) $n
                      (sum (&= $i $0) (&- $n $j)
                           (&i* $f_j $g_i (_ $h (&- $n $i $j)))))
                 (sum (&= $j $0) $n
                      (&i* $f_j (@conv $i (&- $n $j) $g $h)))
                 (conv $j $n $f (@i* $g $h))
                 (_ (bra0 (&i* $f (@i* $g $h))) $n)))
      "[译注: 以上的计算不单纯是指标体操, 还蕴含了&quot;按照两种方式数" (tu0 $i $j) "格点&quot;的想法.] 于是"
      (MB (assoc* $f $g $h) ".")
      "我们将验证该乘法满足上述线性代数定义中的b和c的工作留给读者, 并且读者还应该发现向量"
      (&= $1 (tu0 $1 $0 $0 $..h)) "充当了" $F^inf "的幺元. 因此, " $F^inf "在上述定义的运算下, "
      "构成了一个域" $F "上含幺元的交换线性代数.")
   (P "向量" (tu0 $0 $1 $0 $..h $0 $..h) "在接下来起到了突出的作用, 于是我们将一致地记其为"
      $x ". 在这整整一章里, " $x "从不会被用来表示域" $F "的元素. " $x "自乘" $n "次的结果被记为"
      $x^n ", 并且我们置" (&= $x^0 $1) ", 那么"
      (MB (&cm (&= $x^2 (tu0 $0 $0 $1 $0 $..h))
               (&= $x^3 (tu0 $0 $0 $0 $1 $0 $..h))))
      "而一般地, 对于每个整数" (&>= $k $0) ", " (&= (_ (@ $x^k) $k) $1) ", 对于所有非负整数"
      (&!= $n $k) ", 有" (&= (_ (@ $x^k) $n) $0) ". 本节我们以这样的观察结束, 由"
      (&cm $1 $x $x^2 $..h) "构成的集合是线性无关的且是无限的, 于是代数" $F^inf
      "不是有限维的.")
   (P "代数" $F^inf "有时也被称为域" $F "上的形式幂级数代数. 元素"
      (&= $f (tu0 $f_0 $f_1 $f_2 $..h)) "常被记为"
      (MB (&= $f (sum (&= $n $0) $inf (&i* $f_n $x^n))) ".")
      "这个记号对于处理代数运算而言是十分便利的. 然而在使用时, 必须要记住这是全然形式上的. "
      "代数中并不存在&quot;无限的和&quot;, 幂级数记号并不意图传达任何有关收敛性的想法, "
      "如果读者知道那是什么的话. 通过使用序列, 我们得以谨慎地定义了一个代数, 其行为与"
      "形式幂级数的加法和乘法一致, 但不会引起将其当作无穷和的困惑.")
   (H3 "第4.2节 多项式代数")
   (P "我们现在准备定义域" $F "上的多项式.")
   ((definition)
    "令" polyF "是由" (&cm $1 $x $x^2 $..h) "张成的" $F^inf
    "的子空间. " polyF "的元素被称为域" $F "上的多项式.")
   (P "既然" polyF "由" $x "及其幂的所有线性组合构成, 那么" $F^inf "中的非零向量" $f
      "是多项式当且仅当存在一个整数" (&>= $n $0) "使得" (&!= $f_n $0) "并且对于所有整数"
      (&> $k $n) "有" (&= $f_k $0) ". 这个整数显然是唯一的, 其被称为" $f "的次数 (degree). "
      "我们用" (&deg $f) "代表多项式" $f "的次数, 而" $0 "多项式的次数是没有定义的. 如果"
      $f "是一个次数为" $n "的非零多项式, 那么"
      (MB (&cm (&= $f (LC0 $f_0 $x^0 $f_1 $x^1 $f_2 $x^2 $f_n $x^n))
               (&!= $f_n $0)) ".")
      "标量" (&cm $f_0 $f_1 $..h $f_n) "有时也被称为" $f "的系数, 而且我们也可以说"
      $f "是一个系数在" $F "之中的多项式. 我们称具有形式" (&i* $c $x^0) "的多项式为标量多项式, 并且经常将"
      (&i* $c $x^0) "记作" $c ". 一个次数为" $n "的非零多项式" $f ", 如果" (&= $f_n $1)
      ", 那么就称其为首项系数为一 (monic) 的多项式.")
   (P "读者应该注意多项式和我们之前已经讨论甚多的" $F "上的多项式函数不是同一种对象. 如果" $F
      "包含无限的元素, 那么" polyF "和" $F "上的多项式函数的代数之间有一个自然的同构. "
      "我们将在下一节讨论这个事情. 现在让我们来验证" polyF "是一个代数.")
   ((theorem #:n "1")
    "令" $f "和" $g "是域" $F "上非零的多项式, 那么"
    (Ol #:attr* '((type "i"))
        (Li (&i* $f $g) "是一个非零的多项式;")
        (Li (&= (&deg (@i* $f $g)) (&+ (&deg $f) (&deg $g))) ";")
        (Li "如果" $f "和" $g "都是首项系数为一的多项式, 那么" (&i* $f $g)
            "也是首项系数为一的多项式;")
        (Li (&i* $f $g) "是标量多项式当且仅当" $f "和" $g "都是标量多项式;")
        (Li "如果" (&!= (&+ $f $g) $0) ", 那么"
            (MB (&<= (&deg (@+ $f $g)) (&max (&deg $f) (&deg $g))) "."))))
   ((proof)
    "设" $f "的次数为" $m ", " $g "的次数为" $n ". 如果" $k "是一个非负整数, 那么"
    (MB (&= (_ (@i* $f $g) (&+ $m $n $k)) (conv $i (&+ $m $n $k) $f $g)) ".")
    "为了使得" (&!= (&i* $f_i (_ $g (&- (&+ $m $n $k) $i))) $0) ", "
    (&<= $i $m) "且" (&<= (&- (&+ $m $n $k) $i) $n) "是必要的. 因此"
    (&<= (&+ $m $k) $i $m) "是必要的, 这推出了" (&= $k $0) "然后" (&= $i $m)
    ", 于是"
    (MB (&= (_ (@i* $f $g) (&+ $m $n)) (&i* $f_m $g_n)))
    "且"
    (MB (&cm (&= (_ (@i* $f $g) (&+ $m $n $k)) $0) (&> $k $0)) ".")
    "陈述i, ii, iii立即可由以上两个结果得到, 而iv是i和ii的推论. 我们将v的验证留给读者.")
   ((corollary #:n "1")
    "一个给定域" $F "上所有多项式的集合, 装备以上定义的线性组合和乘法运算后, 成为域"
    $F "上的一个含幺元的交换线性代数.")
   ((proof)
    "既然线性组合和乘法运算是对于" $F^inf "定义的而" polyF "是" $F^inf
    "的一个子空间, 那么只需证明两个多项式之积仍然是多项式就够了. 当其中一个因子是"
    $0 "时这是平凡的, 而剩下来的部分可从i得出.")
   ((corollary #:n "2")
    "设" (&cm $f $g $h) "是域" $F "上的多项式满足" (&!= $f $0) "且"
    (&= (&i* $f $g) (&i* $f $h)) ", 那么" (&= $g $h) ".")
   ((proof)
    "既然" (&= (&i* $f $g) (&i* $f $h)) ", 那么" (&= (&i* $f (@- $g $h)) $0)
    ". 鉴于" (&!= $f $0) ", 从i立即可以得到" (&= (&- $g $h) $0) ".")
   (P "特定的额外事实可由定理1的证明简单推得, 我们将总结其中一些.")
   (P "设"
      (MB (&= $f (sum (&= $i $0) $m (&i* $f_i $x^i)))
          "和" (&= $g (sum (&= $j $0) $n (&i* $g_j $x^j))))
      "那么从" (&cm (&= (_ (@i* $f $g) (&+ $m $n $k)) $0) (&> $k $0))
      "中我们可以得到"
      (MB (&= (&i* $f $g)
              (sum (&= $s $0) (&+ $m $n)
                   (&i* (@conv $r $s $f $g) $x^s))) ".")
      "读者应当验证, 在" (&cm (&= $f (&i* $c $x^m)) (&= $g (&i* $d $x^n)))
      "的特殊情形下, 其中" (&cm $c $d) "是" $F "中的标量, 上式可被规约为"
      (MB (&= (&i* (@i* $c $x^m) (@i* $d $x^n))
              (&i* $c $d (^ $x (&+ $m $n)))) ".")
      "据此, 以及" polyF "的分配律, 我们知道两多项式相乘的积也可由"
      (MB (sum (&cm $i $j) $ (&i* $f_i $g_j (^ $x (&+ $i $j)))))
      "给出, 该求和布于所有满足" (&<= $0 $i $m) "和" (&<= $0 $j $n)
      "的整数序对" (&cm $i $j) "之上.")
   ((definition)
    "令" $V:fraktur "是一个域" $F "上的含幺元的线性代数. 我们用" $1 "表示"
    $V:fraktur "的幺元, 并对于" $V:fraktur "的每个元素" $alpha "作出"
    (&= $alpha^0 $1) "的约定. 那么, 对于每个域" $F "上的多项式"
    (&= $f (sum (&= $i $0) $n (&i* $f_i $x^i))) "和" $V:fraktur
    "中的" $alpha ", 我们联系以一个" $V:fraktur "中的元素" (app $f $alpha)
    ", 由以下规则定义"
    (MB (&= (app $f $alpha) (sum (&= $i $0) $n (&i* $f_i $alpha^i)))))
   ((example #:n "3")
    "令" $CC "是复数域, 令" (&= $f (&+ $x^2 $2)) "."
    (Ol #:attr* '((type "a"))
        (Li "如果" (&= $V:fraktur $CC) "而" (&in $z $CC) ", 那么"
            (&= (app $f $z) (&+ $z^2 $2)) ". 特别地, " (&= (app $f $2) $6) "而"
            (MB (&= (ap $f (pare (~ (&+ $1 $i) (&- $1 $i)))) $1) "."))
        (Li "如果" (&= $V:fraktur (^ $CC (&c* $2 $2))) "且"
            (MB (&= $B (Mat ($1 $0) ($-1 $2))))
            "那么"
            (MB (&= (app $f $B)
                    (&+ (&i* $2 (Mat ($1 $0) ($0 $1)))
                        (^ (Mat ($1 $0) ($-1 $2)) $2))
                    (Mat ($3 $0) ($-3 $6))) "."))
        (Li "如果" $V:fraktur "是" $CC^3 "上的所有线性算子构成的代数, " $T "是由"
            (MB (&= (appl $T $c_1 $c_2 $c_3)
                    (tu0 (&i* $i (Msqrt $2) $c_1) $c_2
                         (&i* $i (Msqrt $2) $c_3))))
            "给定的" $V:fraktur "的元素, 那么" (app $f $T) "是由"
            (MB (&= (appl (app $f $T) $c_1 $c_2 $c_3)
                    (tu0 $0 (&i* $3 $c_2) $0)))
            "定义的" $CC^3 "上的线性算子.")
        (Li "如果" $V:fraktur "是所有" $CC "上的多项式的代数, 并且"
            (&= $g (&+ $x^4 (&i* $3 $i))) ", 那么" (app $f $g) "也是一个"
            $V:fraktur "中的多项式, 由"
            (MB (&= (app $f $g) (&+ $-7 (&i* $6 $i $x^4) $x^8)))
            "给定."))
    "机敏的读者可能会发现与这最后一个例子相关联的一个事实, 即如果" $f
    "是任意的域上的一个多项式而" $x "是多项式" (tu0 $0 $1 $0 $..h) ", 那么"
    (&= $f (app $f $x)) ", 不过我们建议他忘掉这个事实.")
   ((theorem #:n "2")
    "令" $F "是一个域, " $V:fraktur "是域" $F "上的一个含幺元的线性代数. 设"
    $f "和" $g "是域" $F "上的多项式, " $alpha "是" $V:fraktur "的一个元素, "
    $c "属于域" $F ", 那么"
    (Ol #:attr* '((type "i"))
        (Li (&= (app (@LC $c $f $g) $alpha)
                (LC $c (app $f $alpha) (app $g $alpha))) ";")
        (Li (&= (app (@i* $f $g) $alpha)
                (&i* (app $f $alpha) (app $g $alpha))) ".")))
   ((proof)
    "因为i的结果很容易建立, 我们将只证明ii. 设"
    (MB (&= $f (sum (&= $i $0) $m (&i* $f_i $x^i)))
        "和" (&= $g (sum (&= $j $0) $n (&i* $g_j $x^j))))
    "之前我们已经证明了"
    (MB (&= (&i* $f $g) (sum (&cm $i $j) $ (&i* $f_i $g_j (^ $x (&+ $i $j))))))
    "那么根据i,"
    (MB (deriv (app (@i* $f $g) $alpha)
               (sum (&cm $i $j) $ (&i* $f_i $g_j (^ $alpha (&+ $i $j))))
               (&i* (@sum (&= $i $0) $m (&i* $f_i $alpha^i))
                    (@sum (&= $j $0) $n (&i* $g_j $alpha^j)))
               (&i* (app $f $alpha) (app $g $alpha)))))
   ((exercise #:n "1")
    "令" $F "是复数域的子域, 令" $A "是如下" $F "上的" (&c* $2 $2) "矩阵"
    (MB (&= $A (Mat ($2 $1) ($-1 $3))) ".")
    "对于下列" $F "上的多项式" $f ", 计算" (app $f $A) "."
    (Ol #:attr* '((type "a"))
        (Li (&= $f (: $x^2 $- $x $+ $2)) ";")
        (Li (&= $f (&- $x^3 $1)) ";")
        (Li (&= $f (: $x^2 $- (&i* $5 $x) $+ $7)) ".")))
   ((exercise #:n "2")
    "令" $T "是" $RR^3 "上由"
    (MB (&= (appl $T $x_1 $x_2 $x_3)
            (tu0 $x_1 $x_3 (&- (&i* $-2 $x_2) $x_3))))
    "定义的线性算子. 令" $f "是" $RR "上的多项式, 由"
    (&= $f (&+ (&- $x^3) $2)) "定义. 找出" (app $f $T) ".")
   ((exercise #:n "3")
    "令" $A "是域" $F "上的一个" n*n "对角矩阵, 即对于" (&!= $i $j)
    "有" (&= Aij $0) "的矩阵. 令" $f "是" $F "上的多项式, 由"
    (MB (&= $f (&i* (@- $x (mref $A $1 $1)) $..c (@- $x (mref $A $n $n)))))
    "定义. 矩阵" (app $f $A) "是什么?")
   ((exercise #:n "4")
    "如果" $f "和" $g "是域" $F "上线性无关的多项式, " $h "是域" $F
    "上一个非零的多项式, 证明" (&i* $f $h) "和" (&i* $g $h) "是线性无关的.")
   ((exercise #:n "5")
    "如果" $F "是一个域, 证明" $F^inf "的两个非零元素之积仍然是非零的.")
   ((exercise #:n "6")
    "令" $S "是域" $F "上的某些非零多项式的集合. 如果" $S "中没有两个元素具有相同的次数, 证明"
    $S "在" polyF "中是一个线性无关的集合.")
   ((exercise #:n "7")
    "如果" $a "和" $b "是域" $F "的元素并且" (&!= $a $0) ", 证明多项式"
    (&cm $1 (LC $a $x $b) (^ (@LC $a $x $b) $2) (^ (@LC $a $x $b) $3) $..h)
    "构成了" polyF "的一个基.")
   ((exercise #:n "8")
    "如果" $F "是一个域, " $h "是" $F "上一个满足" (&>= (&deg $h) $1) "的多项式, 证明映射"
    (&\|-> $f (app $f $h)) "是" polyF "上的一个非奇异的线性算子. 证明这个算子是从" polyF
    "到自身的同构当且仅当" (&= (&deg $h) $1) ".")
   ((exercise #:n "9")
    "令" $F "是复数域的一个子域, 定义" polyF "上的变换" (&cm $T $D) "为"
    (MB (&= (ap $T (@sum (&= $i $0) $n (&i* $c_i $x^i)))
            (sum (&= $i $0) $n (&i* (~ $c_i (&+ $1 $i)) (^ $x (&+ $i $1))))))
    "和"
    (MB (&= (ap $D (@sum (&= $i $0) $n (&i* $c_i $x^i)))
            (sum (&= $i $1) $n (&i* $i $c_i (^ $x (&- $i $1))))) ".")
    (Ol #:attr* '((type "a"))
        (Li "证明" $T "是" polyF "上的非奇异线性算子, 并表明" $T "不是可逆的.")
        (Li "证明" $D "是" polyF "上满射的线性算子, 并找出其零空间.")
        (Li "证明" (&= (&i* $D $T) $I) "但是" (&!= (&i* $T $D) $I) ".")
        (Li "证明对于所有" polyF "中的" $f "和" $g "有"
            (&= (ap $T (bra0 (ap (@ap $T $f) $g)))
                (&- (ap (@ap $T $f) (@ap $T $g))
                    (ap $T (bra0 (app $f (ap $T $g)))))) ".")
        (Li "陈述并证明一条与d中为" $T "给出的类似的" $D "的规律.")
        (Li "设" $V "是" polyF "的一个非零的子空间, 其满足对于每个" (&in $f $V)
            ", " (&in (ap $T $f) $V) ". 证明" $V "不是有限维的.")
        (Li "设" $V "是" polyF "的一个有限维子空间. 证明存在整数" (&>= $m $0)
            "使得对于每个" (&in $f $V) "有" (&= (ap $D^m $f) $0) ".")))
   (H3 "第4.3节 Lagrange插值")
   (P "整节我们将默认" $F "是一个固定的域并且" (&cm $t_0 $t_1 $..h $t_n)
      "是" $F "的" (&+ $n $1) "个不同的元素. 令" $V "是" polyF "的子空间, 其由所有次数小于等于"
      $n "的多项式构成 (并包括" $0 "多项式). 令" $L_i "是由"
      (MB (&cm (&= (app $L_i $f) (app $f $t_i)) (&<= $0 $i $n)))
      "定义的从" $V "到" $F "的函数. 根据定理2的i, 每个" $L_i "都是" $V
      "上的线性泛函, 而我们想要证明的事实之一是由" (&cm $L_0 $L_1 $..h $L_n)
      "构成的集合是" V* "的一个基, " V* "即" $V "的对偶空间.")
   (P "当然为了达成这个目的, 实际上只需要说明 (参见第3章的定理15) "
      (setE $L_0 $L_1 $..h $L_n) "是某个" $V "的基" (setE $P_0 $P_1 $..h $P_n)
      "的对偶就足够了. 最多只存在一个这样的基, 而且若存在的话则其由"
      (MB (&= (app $L_j $P_i) (app $P_i $t_j) δij))
      "刻画. 多项式"
      (MB (deriv $P_i
                 (~ (&i* (@- $x $t_0) $..c (@- $x (_ $t (&- $i $1)))
                         (@- $x (_ $t (&+ $i $1))) $..c (@- $x $t_n))
                    (&i* (@- $t_i $t_0) $..c (@- $t_i (_ $t (&- $i $1)))
                         (@- $t_i (_ $t (&+ $i $1))) $..c (@- $t_i $t_n)))
                 (prod (&!= $j $i) $ (pare (~ (&- $x $t_j) (&- $t_i $t_j))))))
      "的次数均为" $n ", 因而属于" $V ". 根据定理2, 它们满足上述刻画.")
   (P "如果" (&= $f (sum $i $ (&i* $c_i $P_i))) ", 那么对于每个" $j "有"
      (MB (&= (app $f $t_j) (sum $i $ (&i* $c_i (app $P_i $t_j))) $c_j) ".")
      "既然" $0 "多项式有着对于每个" (&in $t $F) ", " (&= (app $0 $t) $0)
      "的性质, 于是多项式" (&cm $P_0 $P_1 $..h $P_n) "是线性无关的. 鉴于多项式"
      (&cm $1 $x $..h $x^n) "构成了" $V "的一个基, " $V "的维数是" (@+ $n $1)
      ". 因此, 线性无关集合" (setE $P_0 $P_1 $..h $P_n) "必然也是" $V
      "的一个基, 于是对于每个" (&in $f $V) "有"
      (MB (&= $f (sum (&= $i $0) $n (&i* (app $f $t_i) $P_i))) ".")
      "上述表达式被称为Lagrange插值公式, 置" (&= $f $x^j) "我们得到"
      (MB (&= $x^j (sum (&= $i $0) $n (&i* (^ (@ $t_i) $j) $P_i))) ".")
      "现在根据第2章的定理7, 我们知道矩阵"
      (MB (Mat ($1 $t_0 (_^ $t $0 $2) $..c (_^ $t $0 $n))
               ($1 $t_1 (_^ $t $1 $2) $..c (_^ $t $1 $n))
               ($..v $..v $..v $ $..v)
               ($1 $t_n (_^ $t $n $2) $..c (_^ $t $n $n))))
      "是可逆的. 该矩阵被称为Vandermonde矩阵. 直接证明这样的矩阵是可逆的或许是"
      "一个有趣的练习, 其中" (&cm $t_0 $t_1 $..h $t_n) "是" $F "的" (&+ $n $1)
      "个不同的元素.")
   (P "如果" $f "是域" $F "上任意的多项式, 在我们当下的讨论中, 我们将用" (&~ $f)
      "表示将每个" (&in $t $F) "映射到" (app $f $t) "的从" $F "到" $F
      "的多项式函数. 根据定义 (参见第2章的例子4), 每个多项式函数都以这样的方式"
      "产生. 然而, 对于两个多项式" $f "和" $g ", 即便" (&!= $f $g) ", 也可能出现"
      (&= (&~ $f) (&~ $g)) "的情况. 幸运的是, 我们将看到这种令人不快的情况只会在"
      $F "是有限域的时候发生. 为了精确地刻画多项式与多项式函数之间的关系, 我们需要"
      "定义两个多项式函数的积. 如果" $f "和" $g "是域" $F "上的多项式, " (&~ $f)
      "和" (&~ $g) "的积是从" $F "到" $F "的函数" (&i* (&~ $f) (&~ $g)) ", 由"
      (MB (&cm (&= (app (@i* (&~ $f) (&~ $g)) $t)
                   (&i* (app (&~ $f) $t) (app (&~ $g) $t)))
               (&in $t $F)))
      "给出. 根据定理2的ii, " (&= (app (@i* $f $g) $t) (&i* (app $f $t) (app $g $t)))
      ", 因而对于每个" (&in $t $F) "有"
      (MB (&= (app (&~ (@i* $f $g)) $t) (&i* (app (&~ $f) $t) (app (&~ $g) $t))) ".")
      "于是, " (&= (&i* (&~ $f) (&~ $g)) (&~ (@i* $f $g))) "是一个多项式函数. 此时, "
      "尽管是相当直接的, 我们将验证" $F "上的所有多项式函数构成的向量空间在上述定义的乘法下"
      "构成了一个域" $F "上的含幺元的交换线性代数的事情留给读者完成.")
   ((definition)
    "令" $F "是一个域, " $V:fraktur "和" (&~ $V:fraktur) "是" $F "上的线性代数. 称代数"
    $V:fraktur "和" (&~ $V:fraktur) "是同构的, 如果存在一个从" $V:fraktur "到"
    (&~ $V:fraktur) "的双射满足"
    (Ol #:attr* '((type "a"))
        (Li (&= (&~ (@LC $c $alpha $d $beta)) (LC $c (&~ $alpha) $d (&~ $beta))))
        (Li (&= (&~ (@i* $alpha $beta)) (&i* (&~ $alpha) (&~ $beta)))))
    "对于所有" (&in (&cm $alpha $beta) $V:fraktur) "和所有" (&in (&cm $c $d) $F)
    "成立. 映射" (&\|-> $alpha (&~ $alpha)) "被称为从" $V:fraktur "到"
    (&~ $V:fraktur) "的同构. 因此, 一个从" $V:fraktur "到" (&~ $V:fraktur)
    "的同构是一个&quot;保持&quot;乘积的向量空间的同构.")
   ((example #:n "4")
    "令" $V "是域" $F "上的一个" $n "维向量空间. 根据第3章的定理13及其之后的评注, 每个"
    $V "的有序基" $BBB "都确定了一个从" $V "上的线性算子的代数到域" $F "上的" n*n
    "矩阵的代数的同构" (&\|-> $T (coordm $T)) ". 设" $U "是" $V "上一个固定的线性算子, "
    "并给定多项式 [译注: 这个" $n "和" n*n "里的" $n "是两个毫不相关的数字]"
    (MB (&= $f (sum (&= $i $0) $n (&i* $c_i $x^i))))
    "其中系数" (&in $c_i $F) ", 那么"
    (MB (&= (app $f $U) (sum (&= $i $0) $n (&i* $c_i $U^i))))
    "既然" (&\|-> $T (coordm $T)) "是一个线性映射, 于是"
    (MB (&= (coordm (app $f $U))
            (sum (&= $i $0) $n (&i* $c_i (coordm $U^i)))) ".")
    "现在我们还知道"
    (MB (preserve coordm $T_1 &i* $T_2))
    "对于所有" (&in (&cm $T_1 $T_2) (&L $V $V)) "成立, 于是"
    (MB (&cm (&= (coordm $U^i) (^ (@ (coordm $U)) $i)) (&<= $2 $i $n)) ".")
    "这个关系对于" (&= $i (&cm $0 $1)) "也是成立的, 因而我们得到结果"
    (MB (&= (coordm (app $f $U)) (app $f (coordm $U))) ".")
    "用自然语言说, 如果" $U "是" $V "上的一个线性算子, 那么一个多项式应用于"
    $U "的结果的矩阵, 和该多项式应用于" $U "的矩阵的结果是相等的.")
   ((theorem #:n "3")
    "如果" $F "是一个无限域, 那么映射" (&\|-> $f (&~ $f)) "是从域" $F
    "上的多项式代数到域" $F "上的多项式函数代数的同构.")
   ((proof)
    "根据定义, 这个映射是一个满射. 如果" (&in (&cm $f $g) polyF)
    ", 对于所有的标量" $c "和" $d "显然有"
    (MB (&= (&~ (@LC $c $f $d $g)) (LC $c (&~ $f) $d (&~ $g))) ".")
    "之前我们已经说明了" (&= (&~ (@i* $f $g)) (&i* (&~ $f) (&~ $g)))
    ", 所以我们需要做的仅仅是证明该映射是一个单射. 根据线性性质, 实际上证明"
    (&= (&~ $f) $0) "能够推出" (&= $f $0) "就足够了. 设" $f "是一个次数小于等于"
    $n "的多项式 [译注: 实际上还包括零多项式] 并且满足" (&= (&~ $f) $0) ". 令"
    (&cm $t_0 $t_1 $..h $t_n) "是" $F "中" (&+ $n $1) "个不同的元素. 既然" (&= (&~ $f) $0)
    ", 那么对于" (&= $i (&cm $0 $1 $..h $n)) "有" (&= (app $f $t_i) $0)
    ", 根据Lagrange插值公式就立即得到" (&= $f $0) ".")
   (P "根据下一节的结果, 我们将得到该定理的一个完全不同的证明.")
   ((exercise #:n "1")
    "使用Lagrange插值公式找出这样一个实系数的多项式" $f ", 其次数小于等于" $3 ", 并且满足"
    (&cm (&= (app $f $-1) $-6) (&= (app $f $0) $2) (&= (app $f $1) $-2) (&= (app $f $2) $6)) ".")
   ((exercise #:n "2")
    "令" (&cm $alpha $beta $gamma $delta) "是实数. 我们问何时能够找到一个域" $RR "上的次数不高于"
    $2 "的多项式" $f "满足"
    (&cm (&= (app $f $-1) $alpha) (&= (app $f $1) $beta)
         (&= (app $f $3) $gamma) (&= (app $f $0) $delta))
    ". 证明当且仅当"
    (MB (&= (: (&i* $3 $alpha) $+ (&i* $6 $beta) $- $gamma $- (&i* $8 $delta)) $0))
    "的时候这是可能的.")
   ((exercise #:n "3")
    "令" $F "是实数域,"
    (MB (&cm (&= $A (Mat ($2 $0 $0 $0) ($0 $2 $0 $0) ($0 $0 $3 $0) ($0 $0 $0 $1)))
             (&= $p (&i* (@- $x $2) (@- $x $3) (@- $x $1)))) ".")
    (Ol #:attr* '((type "a"))
        (Li "证明" (&= (app $p $A) $0) ".")
        (Li "令" (&cm $P_1 $P_2 $P_3) "是对于" (&cm (&= $t_1 $2) (&= $t_2 $3) (&= $t_3 $1))
            "的Lagrange多项式, 计算" (&cm (&= $E_i (app $P_i $A)) (&= $i (&cm $1 $2 $3))) ".")
        (Li "证明" (&= (&+ $E_1 $E_2 $E_3) $I) "; 如果" (&!= $i $j) ", " (&= (&i* $E_i $E_j) $0)
            "; " (&= (_^ $E $i $2) $E_i) ".")
        (Li "证明" (&= $A (&+ (&i* $2 $E_1) (&i* $3 $E_2) $E_3)) ".")))
   ((exercise #:n "4")
    "令" (&= $p (&i* (@- $x $2) (@- $x $3) (@- $x $1))) ", 令" $T "是" $RR^4 "上任意的满足"
    (&= (app $p $T) $0) "的线性算子. 令" (&cm $P_1 $P_2 $P_3) "是练习3的Lagrange多项式. 令"
    (&cm (&= $E_i (app $P_i $T)) (&= $i (&cm $1 $2 $3))) ". 证明" (&= (&+ $E_1 $E_2 $E_3) $I)
    "; 如果" (&!= $i $j) ", " (&= (&i* $E_i $E_j) $0) "; " (&= (_^ $E $i $2) $E_i) "; "
    (&= $T (&+ (&i* $2 $E_1) (&i* $3 $E_2) $E_3)) ".")
   ((exercise #:n "5")
    "令" $n "是一个正整数, " $F "是一个域. 设" $A "是域" $F "上的一个" n*n "矩阵, " $P
    "是域" $F "上一个可逆的" n*n "矩阵. 如果" $f "是域" $F "上任意的多项式, 证明"
    (MB (&= (app $f (sim $A)) (sim (app $f $A))) "."))
   ((exercise #:n "6")
    "令" $F "是一个域. 我们已经考虑了由&quot;在" $t "处求值&quot;得到的"
    polyF "上的相当特殊的线性泛函:"
    (MB (&= (app $L $f) (app $f $t)) ".")
    "这样的线性泛函不仅是线性的, 还具有" (preserve* $L $f $g) "的性质. 证明如果" $L
    "是" polyF "上的线性泛函, 并且满足"
    (MB (preserve* $L $f $g))
    "对于所有的域" $F "上的多项式" $f "和" $g "成立, 那么要么" (&= $L $0) ", 要么存在"
    (&in $t $F) "使得对于每个多项式" $f "有" (&= (app $L $f) (app $f $t)) ".")
   (H3 "第4.4节 多项式理想")
   (P "本节我们关心主要依赖于域上的多项式代数的乘性结构的结果.")
   ((lemma)
    "设" $f "和" $d "是域" $F "上的非零多项式并且满足" (&<= (&deg $d) (&deg $f))
    ", 那么存在" (&in $g polyF) "使得"
    (MB (&= (&- $f (&i* $d $g)) $0)
        "或者" (&< (&deg (@- $f (&i* $d $g))) (&deg $f)) "."))
   ((proof)
    "设"
    (MB (&cm (&= $f (&+ (&i* $a_m $x^m)
                        (sum (&= $i $0) (&- $m $1) (&i* $a_i $x^i))))
             (&!= $a_m $0)))
    "以及"
    (MB (&cm (&= $d (&+ (&i* $b_n $x^n)
                        (sum (&= $i $0) (&- $n $1) (&i* $b_i $x^i))))
             (&!= $b_n $0)) ",")
    "那么" (&>= $m $n) ", 并且"
    (let ((expr (&- $f (&i* (pare (~ $a_m $b_n)) (^ $x (&- $m $n)) $d))))
      (MB (&= expr $0) "或者" (&< (&deg (brac expr)) (&deg $f)) "."))
    "因此, 我们可以取"
    (&= $g (&i* (pare (~ #:attr* '((displaystyle "true")) $a_m $b_n))
                (^ $x (&- $m $n)))) ".")
   (P "使用该引理我们可以表明众所周知的实或复系数多项式的&quot;长除&quot;"
      "过程在任意的域上都是可能的.")
   ((theorem #:n "4")
    "如果" $f "和" $d "是域" $F "上的多项式并且" (&!= $d $0) ", 那么存在"
    (&in (&cm $q $r) polyF) "满足"
    (Ol #:attr* '((type "i"))
        (Li (&= $f (&+ (&i* $d $q) $r)) ";")
        (Li "要么" (&= $r $0) "要么" (&< (&deg $r) (&deg $d)) "."))
    "满足i和ii的多项式" $q "和" $r "是唯一的.")
   ((proof)
    "如果" $f "是" $0 "或者" (&< (&deg $f) (&deg $d)) ", 那么取"
    (&= $q $0) "和" (&= $r $f) "即可. 在" (&!= $f $0) "并且"
    (&>= (&deg $f) (&deg $d)) "的情况下, 上述引理告诉我们存在多项式" $g
    "使得" (&= (&- $f (&i* $d $g)) $0) "或者"
    (&< (&deg (@- $f (&i* $d $g))) (&deg $f)) ". 如果"
    (&!= (&- $f (&i* $d $g)) $0) "并且"
    (&>= (&deg (@- $f (&i* $d $g))) (&deg $d)) ", 那么我们可以选择一个多项式"
    $h "使得" (&= (&- (@- $f (&i* $d $g)) (&i* $d $h)) $0) "或者"
    (MB (&< (&deg (bra0 (&- $f (&i* $d (@+ $g $h)))))
            (&deg (@- $f (&i* $d $g)))) ".")
    "若有必要则继续施行这个过程, 最终我们可以得到多项式" $q "和" $r "满足"
    (&= $r $0) "或者" (&< (&deg $r) (&deg $d)) ", 并且"
    (&= $f (&+ (&i* $d $q) $r)) ". 现在设我们也有"
    (&= $f (&+ (&i* $d $q_1) $r_1)) ", 其中" (&= $r_1 $0) "或者"
    (&< (&deg $r_1) (&deg $d)) ", 那么"
    (&= (&+ (&i* $d $q) $r) (&+ (&i* $d $q_1) $r_1)) ", 于是"
    (&= (&i* $d (@- $q $q_1)) (&- $r_1 $r)) ". 如果"
    (&!= (&- $q $q_1) $0) ", 那么" (&!= (&i* $d (@- $q $q_1)) $0) ", 并有"
    (MB (&= (&+ (&deg $d) (&deg (@- $q $q_1)))
            (&deg (@- $r_1 $r))) ".")
    "但是鉴于" (&- $r_1 $r) "的次数是小于" $d "的次数的, 这是不可能的. 因而"
    (&= (&- $q $q_1) $0) ", 随之亦有" (&= (&- $r_1 $r) $0) ".")
   ((definition)
    "令" $d "是域" $F "上的一个非零多项式. 如果" (&in $f polyF) ", 之前的定理告诉我们至多存在一个多项式"
    (&in $q polyF) "满足" (&= $f (&i* $d $q)) ". 如果这样的" $q "存在, 那么我们称" $d
    "整除" $f ", 或者" $f "被" $d "整除, 或者" $f "是" $d "的倍数, 并称" $q "是" $f "和" $d
    "的商. 我们也记" (&= $q (&/ $f $d)) ".")
   ((corollary #:n "1")
    "令" $f "是域" $F "上的一个多项式, 令" $c "是" $F "的一个元素, 那么" $f
    "被" (&- $x $c) "整除当且仅当" (&= (app $f $c) $0) ".")
   ((proof)
    "根据定理, " (&= $f (&+ (&i* (@- $x $c) $q) $r)) ", 其中" $r "是一个标量多项式. 又根据定理2,"
    (MB (&= (app $f $c) (&+ (&i* $0 (app $q $c)) (app $r $c)) (app $r $c)) ".")
    "于是, " (&= $r $0) "当且仅当" (&= (app $f $c) $0) ".")
   ((definition)
    "令" $F "是一个域, " (&in $c $F) "被称为是多项式" (&in $f polyF) "的根或者零点, 如果"
    (&= (app $f $c) $0) ".")
   ((corollary #:n "2")
    "域" $F "上的" $n "次多项式在" $F "中至多只有" $n "个根.")
   ((proof)
    "这个结果对于" $0 "次和" $1 "次多项式而言显然是真的. 我们假设其对于" (&- $n $1)
    "次的多项式而言是真的. 如果" $a "是" $n "次多项式" $f "的一个根, 那么"
    (&= $f (&i* (@- $x $a) $q)) ", 其中" $q "的次数是" (&- $n $1) ". 既然"
    (&= (app $f $b) $0) "当且仅当" (&= $a $b) "或者" (&= (app $q $b) $0)
    ", 根据归纳假设我们可以得到" $f "至多只有" $n "个根.")
   (P "读者应该观察到定理3的证明的主要步骤可由该推论立即得到. "
      "[译注: 原本的证明用的是Lagrange插值.]")
   (P "多项式的形式导数在讨论多重根的时候是很有用的. 多项式"
      (MB (&= $f (&+ $c_0 (&i* $c_1 $x) $..c (&i* $c_n $x^n))))
      "的导数是多项式"
      (MB (&= $f^ (&+ $c_1 (&i* $2 $c_2 $x) $..c (&i* $n $c_n (^ $x (&- $n $1))))) ".")
      "我们也使用记号" (&= (ap $D $f) $f^) ". [译注: 实际上, 形式导数由"
      (&= (_^ $f $n $prime) (&i* (@+ $n $1) (_ $f (&+ $n $1)))) "刻画.] "
      "微分是线性的, 也就是说, " $D "是" polyF "上的一个线性算子. 我们也有高阶形式导数"
      (&= (&Prime $f) (ap $D^2 $f)) ", " (&= (^ $f (@ $3)) (ap $D^3 $f)) ", 等等.")
   ((theorem #:n "5. Taylor公式")
    "令" $F "是一个特征为零的域, " $c "是" $F "的一个元素, " $n "是一个正整数. 如果"
    $f "是域" $F "上一个满足" (&<= (&deg $f) $n) "的多项式, 那么"
    (MB (&= $f (sum (&= $k $0) $n
                    (&i* (app (~ (@ap $D^k $f) (&fact $k)) $c)
                         (^ (@- $x $c) $k)))) "."))
   ((proof)
    "Taylor公式是二项式定理和算子" (&cm $D $D^2 $..h $D^n)
    "的线性性质的推论. 二项式定理很容易通过归纳证明, 并断言"
    (MB (&= (^ (@+ $a $b) $m)
            (sum (&= $k $0) $m
                 (&i* (comb $m $k) (^ $a (&- $m $k)) $b^k))))
    "其中"
    (MB (&= (comb $m $k)
            (~ (&fact $m) (&i* (&fact $k) (&fact (@- $m $k))))
            (~ (&i* $m (@- $m $1) $..c (@ $m $- $k $+ $1))
               (&d* $1 $2 $..c $k))))
    "是我们熟悉的二项式系数, 其给出了从" $m "个物品中一次取" $k "个的组合数. 根据二项式定理,"
    (MB (deriv $x^m
               (^ (bra0 (&+ $c (@- $x $c))) $m)
               (sum (&= $k $0) $m
                    (&i* (comb $m $k)
                         (^ $c (&- $m $k))
                         (^ (@- $x $c) $k)))
               (&+ $c^m (&i* $m (^ $c (&- $m $1)) (@- $x $c)) $..c (^ (@- $x $c) $m))))
    "而这就是在" (&= $f $x^m) "的情形下Taylor公式的陈述. 如果"
    (MB (&= $f (sum (&= $m $0) $n (&i* $a_m $x^m))))
    "那么"
    (MB (&= (app (@ap $D^k $f) $c)
            (sum (&= $m $0) $n
                 (&i* $a_m (app (@ap $D^k $x^m) $c)))))
    "因此"
    (MB (deriv (sum (&= $k $0) $n
                    (&i* (~ (app (@ap $D^k $f) $c) (&fact $k))
                         (^ (@- $x $c) $k)))
               (sum (&= $k $0) $n
                    (sum (&= $m $0) $n
                         (&i* $a_m (app (~ (@ap $D^k $x^m) (&fact $k)) $c)
                              (^ (@- $x $c) $k))))
               (sum (&= $m $0) $n
                    (&i* $a_m
                         (@sum (&= $k $0) $n
                               (&i* (app (~ (@ap $D^k $x^m) (&fact $k)) $c)
                                    (^ (@- $x $c) $k)))))
               (sum (&= $m $0) $n (&i* $a_m $x^m))
               $f)))
   (P "读者应该注意到, 因为多项式" (&cm $1 (@- $x $c) $..h (^ (@- $x $c) $n))
      "是线性无关的 (参见4.2节的练习7), 所以Taylor公式为" $f "写成多项式"
      (&cm (^ (@- $x $c) $k) (&<= $0 $k $n)) "唯一的线性组合提供了方法.")
   (P "尽管我们不会给出任何细节, 但是在这个点上或许值得提及Taylor公式的正当解释使得其"
      "也适用于非零特征域上的多项式. 如果域" $F "的特征不为零, 那么在" $F "中我们可以有"
      (&= (&fact $k) $0) ", 那么这就使得" (app (@ap $D^k $f) $c) "除以" (&fact $k)
      "毫无意义. 然而, 我们也可以赋予" (app (@ap $D^k $f) $c) "除以" (&fact $k)
      "一种意义, 因为" (ap $D^k $f) "的每个系数都是" $F "的一个元素乘上某个可以被"
      (&fact $k) "整除的整数. [译注: 不过, 在这种观点下, " (ap $D^k $f)
      "就是相当不同的对象了, 因为你不能仅从这个多项式对象本身还原出那些整数来, 还要考虑"
      (ap $D^k $f) "的内涵.] 如果这些话使你感到困惑, 那么我们建议读者把自己的注意力"
      "限制于特征为零的域, 或者复数域的子域.")
   (P "如果" $c "是非零多项式" $f "的一个根, 那么" $c "作为" $f "的根的重数是满足"
      (^ (@- $x $c) $r) "整除" $f "的最大正整数" $r ".")
   (P "一个根的重数显然小于等于" $f "的次数. 对于特征为零的域上的多项式而言, " $c
      "作为" $f "的根的重数与" $f "的高阶导数有关.")
   ((theorem #:n "6")
    "令" $F "是一个特征为零的域, 令" $f "是域" $F "上的一个多项式并且满足"
    (&<= (&deg $f) $n) ", 那么标量" $c "是" $f "的一个" $r "重根当且仅当"
    (MB (&cm (&= (app (@ap $D^k $f) $c) $0) (&<= $0 $k (&- $r $1)))
        "并且" (&!= (app (@ap $D^r $f) $c) $0) "."))
   ((proof)
    "设" $r "是" $c "作为" $f "的根的重数, 那么存在多项式" $g "满足"
    (&= $f (&i* (^ (@- $x $c) $r) $g)) "且" (&!= (app $g $c) $0) ". 如果"
    (&= (app $g $c) $0) ", 那么根据定理4的推论1, " $f "就会被"
    (^ (@- $x $c) (&+ $r $1)) "整除. 将Taylor公式应用于" $g ", 我们得到"
    (MB (deriv $f
               (&i* (^ (@- $x $c) $r)
                    (brac (sum (&= $m $0) (&- $n $r)
                               (&i* (app (~ (@ap $D^m $g) (&fact $m)) $c)
                                    (^ (@- $x $c) $m)))))
               (sum (&= $m $0) (&- $n $r)
                    (&i* (app (~ (@ap $D^m $g) (&fact $m)) $c)
                         (^ (@- $x $c) (&+ $r $m))))))
    "既然" $f "写成幂" (&cm (^ (@- $x $c) $k) (&<= $0 $k $n))
    "的线性组合的方式是唯一的, 于是"
    (MB (&= (~ (app (@ap $D^k $f) $c) (&fact $k))
            (Choice0
             ($0 ", 如果" (&<= $0 $k (&- $r $1)))
             ((~ (app (@ap (^ $D (&- $k $r)) $g) $c)
                 (&fact (@- $k $r)))
              ", 如果" (&<= $r $k $n)))))
    "因此, " (&cm (&= (app (@ap $D^k $f) $c) $0) (&<= $0 $k (&- $r $1))) "并且"
    (&!= (&= (app (@ap $D^r $f) $c) (&d* (&fact $r) (app $g $c))) $0)
    ". 反过来说, 如果这些条件被满足了, 那么根据Taylor公式就能立即得出存在多项式"
    $g "满足" (&= $f (&i* (^ (@- $x $c) $r) $g)) "并且" (&!= (app $g $c) $0)
    ". 现在设" $r "不是满足" (^ (@- $x $c) $r) "整除" $f "的最大正整数, 那么存在多项式"
    $h "满足" (&= $f (&i* (^ (@- $x $c) (&+ $r $1)) $h)) ". 然而, 根据定理1的推论2, 这将推出"
    (&= $g (&i* (@- $x $c) $h)) ", 于是" (&= (app $g $c) $0) ", 一个矛盾.")
   ((definition)
    "令" $F "是一个域. " polyF "中的一个理想是" polyF "的一个子空间" $M "满足对于每个"
    (&in $f polyF) "和" (&in $g $M) "有" (&in (&i* $f $g) $M) ".")
   ((example #:n "5")
    "如果" $F "是一个域, 并且" $d "是" $F "上的一个多项式, 那么集合" (&= $M (&i* $d polyF))
    "是一个理想, 其由所有" $d "乘上" polyF "中任意的" $f "得到的倍数" (&i* $d $f)
    "构成. 鉴于" $M "事实上包含" $d ", " $M "是非空的. 如果" (&in (&cm $f $g) polyF)
    "而" $c "是一个标量, 那么"
    (MB (&= (&- (&i* $c (@i* $d $f)) (&i* $d $g))
            (&i* $d (@- (&i* $c $f) $g))))
    "属于" $M ", 于是" $M "是一个子空间. 最后, " $M "也包含"
    (&= (&i* (@i* $d $f) $g) (&i* $d (@i* $f $g))) ". 理想" $M
    "被称为由" $d "生成的主理想.")
   ((example #:n "6")
    "令" (&cm $d_1 $..h $d_n) "是" $F "上有限多个多项式, 那么子空间" (&i* $d_i polyF)
    "之和" $M "也是一个理想. 这是因为若设" (&in $p $M) ", 那么存在" polyF "中的多项式"
    (&cm $f_1 $..h $f_n) "满足" (&= $p (LC0 $d_1 $f_1 $d_n $f_n))
    ". 如果" $g "是域" $F "上任意的多项式, 那么"
    (MB (&= (&i* $p $g) (LC0 $d_1 (@i* $f_1 $g) $d_n (@i* $f_n $g))))
    "于是" (&i* $p $g) "也属于" $M ", 因此" $M "是一个理想. 我们称" $M "为由多项式"
    (&cm $d_1 $..h $d_n) "生成的理想.")
   ((example #:n "7")
    "令" $F "是复数域的一个子域, 考虑理想"
    (MB (&= $M (LC (@+ $x $2) polyF (@+ $x^2 (&i* $8 $x) 16) polyF)) ".")
    "我们断言" (&= $M polyF) ". 这是因为" $M "包含"
    (MB (&= (&- (@+ $x^2 (&i* $8 $x) 16) (&i* $x (@+ $x $2))) (LC $6 $x 16)))
    "因而" $M "也包含" (&= (&- (@LC $6 $x 16) (&i* $6 (@+ $x $2))) $4)
    ", 于是标量多项式" (&in $1 $M) ", 那么其倍数自然是整个" polyF ".")
   ((theorem #:n "7")
    "如果" $F "是一个域, 并且" $M "是" polyF "任意的非零理想, 那么存在唯一的首项系数为一的多项式"
    (&in $d polyF) "使得" $M "是由" $d "生成的主理想.")
   ((proof)
    "根据假设, " $M "包含一个非零的多项式. " $M "所有的非零多项式中, 存在多项式" $d
    "具有最低的次数. [译注: 这依赖于自然数集的良序原理.] 我们不妨假设"
    $d "的首项系数为一, 因为不然的话我们可以给" $d
    "乘上一个标量使其变成首项系数为一的. 现在如果" (&in $f $M) ", 定理4表明"
    (&= $f (&+ (&i* $d $q) $r)) ", 其中" (&= $r $0) "或者" (&< (&deg $r) (&deg $d))
    ". 既然" (&in $d $M) ", 也有" (&in (&= (&- $f (&i* $d $q)) $r) $M) ". 因为"
    $d "是" $M "中具有最低次数的元素, 所以我们不可能有" (&< (&deg $r) (&deg $d))
    ", 于是" (&= $r $0) ", 因此" (&= $M (&i* $d polyF)) ". 如果" $g "是另一个满足"
    (&= $M (&i* $g polyF)) "的首项系数为一的多项式, 那么存在非零的多项式" $p
    "和" $q "满足" (&= $d (&i* $g $p)) "和" (&= $g (&i* $d $q)) ", 因而"
    (&= $d (&i* $d $p $q)) ", 然后"
    (MB (&= (&deg $d) (&+ (&deg $d) (&deg $p) (&deg $q))) ".")
    "于是, " (&= (&deg $p) (&deg $q) $0) ". 鉴于" $d "和" $g "的首项系数为一, "
    (&= $p $q $1) ", 即" (&= $d $g)
    ". [译注: 这段证明也表明多项式" $g "是某个非零理想的生成元当且仅当其为"
    "唯一的首项系数为一的生成元" $d "的非零标量倍数.]")
   (P "值得注意的是, 在刚才的证明中我们运用了一个更加一般且相当有用的事实的一种特殊情形, "
      "这个事实即如果" $p "是某个理想" $M "中的非零多项式而" (&in $f $M) "不被" $p
      "整除, 那么" (&= $f (&+ (&i* $p $q) $r)) ", 其中&quot;余项 (remainder)&quot;"
      (&in $r $M) ", 它异于" $0 ", 且次数比" $p "小. 我们已经在例子7中利用了这个"
      "事实来表明标量多项式" $1 "是那里考虑的理想的首项系数为一的生成元. 从原则上说, "
      "找出生成给定的非零理想的首项系数为一的多项式总是可能的. 这是因为人们通过有限步骤内的"
      "辗转相除最终可以得到理想中具有最低次数的多项式.")
   ((corollary)
    "如果" (&cm $p_1 $..h $p_n) "是域" $F "上的不全为零的多项式, 那么" polyF
    "中存在唯一的首项系数为一的多项式" $d "满足"
    (Ol #:attr* '((type "a"))
        (Li $d "在由" (&cm $p_1 $..h $p_n) "生成的理想之中;")
        (Li $d "整除每个多项式" $p_i ";"))
    "任何满足a和b的多项式也必然满足"
    (Ol #:attr* '((type "a") (start "3"))
        (Li "每个整除多项式" (&cm $p_1 $..h $p_n) "的多项式也整除" $d ".")))
   ((proof)
    "令" $d "是理想"
    (MB (LC0 $p_1 polyF $p_n polyF))
    "的首项系数为一的生成元. 每个该理想的成员都被" $d "整除, 因此每个多项式"
    $p_i "也被" $d "整除. 现在设" $f "是整除多项式" (&cm $p_1 $..h $p_n)
    "的多项式, 那么存在多项式" (&cm $g_1 $..h $g_n) "满足"
    (&cm (&= $p_i (&i* $f $g_i)) (&<= $1 $i $n)) ". 并且, 既然" $d "在理想"
    (MB (LC0 $p_1 polyF $p_n polyF))
    "之中, 那么存在多项式" (&in (&cm $q_1 $..h $q_n) polyF) "使得"
    (MB (&= $d (LC0 $p_1 $q_1 $p_n $q_n)))
    "于是"
    (MB (&= $d (&i* $f (@LC0 $g_1 $q_1 $g_n $q_n))) ".")
    "我们已经表明了" $d "是满足a, b, c的首项系数为一的多项式. 如果" $d^
    "是满足a和b的多项式, 根据a和" $d "的定义, 我们知道" $d^ "是" $d "的标量倍数, "
    "于是也满足c. [译注: 不太能理解这句话的推理过程和想法, 可能存在笔误.] "
    "最终, 当" $d^ "是首项系数为一的多项式时, 我们有" (&= $d^ $d) "." (Br)
    "[译注: 以上的证明似乎有些混乱. 实际上, 如果" $d "是满足a和b的多项式, "
    "那么它就是理想" (LC0 $p_1 polyF $p_n polyF) "的生成元. 在首项系数为一的"
    "情况下, 这个多项式至多只有一个. 很容易验证首项系数为一的生成元的确满足"
    "a和b. 另外, 条件a即可推出条件c, 不论首项系数是否为一.]")
   ((definition)
    "如果" (&cm $p_1 $..h $p_n) "是域" $F "上的不全为零的多项式, 那么理想"
    (MB (LC0 $p_1 polyF $p_n polyF))
    "唯一的首项系数为一的生成元被称为" (&cm $p_1 $..h $p_n) "的最大公因子 "
    "(greatest common divisor, g.c.d.). 这个术语可由之前的推论澄清. "
    "[译注: 实际上, 更像是由条件b和c澄清, 但是条件c和条件a是等价的. "
    "另外, 它也澄清了辗转相除法求最大公因子的原理.] "
    "我们称多项式" (&cm $p_1 $..h $p_n) "互素, 如果其最大公因子为"
    $1 ", 或者等价地, 它们生成的理想是整个" polyF ".")
   ((example #:n "8")
    "令" $F "是复数域" $CC ", 那么 [译注: 本书对于最大公因子所用的记号是" 'g.c.d.
    ", 但是我们将其改成现在更加通行的" $gcd ".]"
    (Ol #:attr* '((type "a"))
        (Li (&= (&gcd (&+ $x $2) (&+ $x^2 (&i* $8 $x) 16)) $1)
            " (见例子7);")
        (Li (&= (&gcd (&i* (^ (@- $x $2) $2) (@+ $x $i))
                      (&i* (@- $x $2) (@+ $x^2 $1)))
                (&i* (@- $x $2) (@+ $x $i)))
            ". 这是因为, 理想"
            (MB (LC (&i* (^ (@- $x $2) $2) (@+ $x $i)) polyF
                    (&i* (@- $x $2) (@+ $x^2 $1)) polyF))
            "包含"
            (MB (&= (&- (&i* (^ (@- $x $2) $2) (@+ $x $i))
                        (&i* (@- $x $2) (@+ $x^2 $1)))
                    (&i* (@- $x $2) (@+ $x $i) (@- $i $2))))
            "因而也包含" (&i* (@- $x $2) (@+ $x $i))
            ", 其首项系数为一, 且整除"
            (MB (&i* (^ (@- $x $2) $2) (@+ $x $i))
                "和" (&i* (@- $x $2) (@+ $x^2 $1)) "."))))
   ((example #:n "9")
    "令" $F "是有理数域, 并且在" polyF "中令" $M "是由"
    (MB (&cm (&i* (@- $x $1) (^ (@+ $x $2) $2))
             (&i* (^ (@+ $x $2) $2) (@- $x $3))
             (@- $x $3)))
    "生成的理想, 那么" $M "包含"
    (MB (&= (&i* 1/2 (^ (@+ $x $2) $2) (bra0 (&- (@- $x $1) (@- $x $3))))
            (^ (@+ $x $2) $2)))
    "并且既然"
    (MB (&= (^ (@+ $x $2) $2)
            (&+ (&i* (@- $x $3) (@+ $x $7)) 25)))
    "[译注: 原文是" (&- 17) "而不是" (&+ 25) ", 应该是笔误.] 那么" $M
    "包含标量多项式" $1 ", 于是" (&= $M polyF) "而多项式"
    (MB (&cm (&i* (@- $x $1) (^ (@+ $x $2) $2))
             (&i* (^ (@+ $x $2) $2) (@- $x $3))
             (@- $x $3)))
    "是互素的.")
   ((exercise #:n "1")
    "令" $QQ "是有理数域, 判断以下" (&poly $QQ)
    "的子集是否是理想. 若是理想, 则找出其首项系数为一的生成元."
    (Ol #:attr* '((type "a"))
        (Li "所有偶数次的" $f ";")
        (Li "所有次数大于等于" $5 "的" $f ";")
        (Li "所有满足" (&= (app $f $0) $0) "的" $f ";")
        (Li "所有满足" (&= (app $f $2) (app $f $4) $0)
            "的" $f ";")
        (Li "所有线性算子" $T "的像中的" $f ", 其中" $T "由"
            (MB (&= (ap $T (@sum (&= $i $0) $n (&i* $c_i $x^i)))
                    (sum (&= $i $0) $n
                         (&i* (~ $c_i (&+ $i $1))
                              (^ $x (&+ $i $1))))))
            "定义.")))
   ((exercise #:n "2")
    "找出以下每对多项式的最大公因子"
    (Ol #:attr* '((type "a"))
        (Li (&cm (&+ (&- (&i* $2 $x^5) $x^3 (&i* $3 $x^2) (&i* $6 $x)) $4)
                 (&+ $x^4 (&- $x^3 $x^2 (&i* $2 $x) $2))) ";")
        (Li (&cm (&- (LC 3 $x^4 8 $x^2) 3)
                 (&+ $x^3 (LC 2 $x^2 3 $x 6))) ";")
        (Li (&cm (&- $x^4 (&i* $2 $x^3) (&i* $2 $x^2) (&i* $2 $x) $3)
                 (&+ $x^3 (&i* $6 $x^2) (&i* $7 $x) $1)) ".")))
   ((exercise #:n "3")
    "令" $A "是域" $F "上的一个" n*n "矩阵. 证明所有满足" (&= (app $f $A) $0)
    "的多项式" (&in $f polyF) "构成了一个理想.")
   ((exercise #:n "4")
    "令" $F "是复数域的一个子域, 令"
    (MB (&= $A (Mat (1 -2) (0 3))) ".")
    "找出使得" (&= (app $f $A) $0) "的所有多项式" (&in $f polyF)
    "构成的理想的首项系数为一的生成元.")
   ((exercise #:n "5")
    "令" $F "是一个域, 证明" polyF "中任意数目的理想之交仍然是一个理想.")
   ((exercise #:n "6")
    "令" $F "是一个域, 证明由" (&in (&cm $f_1 $..h $f_n) polyF)
    "生成的理想是所有包含" (&cm $f_1 $..h $f_n) "的理想之交.")
   ((exercise #:n "7")
    "令" $K "是域" $F "的一个子域, 设多项式" (&in (&cm $f $g) (&poly $K))
    ". 令" $M_K "是" (&poly $K) "中由" $f "和" $g "生成的理想, " $M_F
    "是" polyF "中由" $f "和" $g "生成的理想. 证明" $M_K "和" $M_F
    "有着相同的首项系数为一的生成元.")
   (H3 "第4.5节 多项式的素因子分解")
   (P "本节我们将要证明每个域" $F "上的多项式都可以写成&quot;素&quot;"
      "多项式之积. 这种分解为我们提供了寻找有限多个多项式的最大公因子"
      "的有效工具, 并且特别地, 提供了判断多项式是否互素的有效手段.")
   ((definition)
    "令" $F "是一个域. 一个多项式" (&in $f polyF) "被称为在" $F
    "上可约, 如果存在多项式" (&in (&cm $g $h) polyF) ", 它们的次数大于等于"
    $1 ", 并且满足" (&= $f (&i* $g $h)) ". 在不存在的情况下, 我们称" $f
    "在" $F "上不可约. 域" $F "上不可约的非标量多项式被称为域" $F
    "上的素多项式 (prime polynomial over " $F "), 或者有时称其是"
    polyF "中的一个prime.")
   ((example #:n "10")
    "多项式" (&+ $x^2 $1) "在域" $CC "上是可约的, 因为"
    (MB (&= (&+ $x^2 $1) (&i* (@+ $x $i) (@- $x $i))))
    "而多项式" (&+ $x $i) "和" (&- $x $i) "属于" (&poly $CC) ". 另一方面, "
    (&+ $x^2 $1) "在域" $RR "上是不可约的, 因为如果"
    (MB (&= (&+ $x^2 $1) (&i* (@LC $a $x $b) (@LC $a^ $x $b^))))
    "其中" (&in (&cm $a $a^ $b $b^) $RR) ", 那么"
    (MB (&cm (&= (&i* $a $a^) $1)
             (&= (&+ (&i* $a $b^) (&i* $b $a^)) $0)
             (&= (&i* $b $b^) $1)) ".")
    "这些关系可以推出" (&= (&+ $a^2 $b^2) $0) ", 这对于实数是不可能的, 除非"
    (&= $a $b $0) ". [译注: 但是我们需要" (&!= $a $0) ".]")
   ((theorem #:n "8")
    "令" (&cm $p $f $g) "是域" $F "上的多项式, 设" $p "是素多项式, 并且" $p
    "整除" (&i* $f $g) ", 那么要么" $p "整除" $f ", 要么" $p "整除" $g ".")
   ((proof)
    "不失一般性, 假定" $p "是首项系数为一的素多项式. 那么, " $p "是素的就是在说"
    $p "仅有的首项系数为一的因子是" $1 "和" $p ". 令" $d "是" $f "和" $p
    "的最大公因子, 那么要么" (&= $d $1) ", 要么" (&= $d $p) ", 既然" $d
    "是整除" $p "的首项系数为一的多项式. 如果" (&= $d $p) ", 那么" $p "整除" $f
    ", 工作就结束了. 于是, 设" (&= $d $1) ", 即" $f "和" $p "是互素的. 我们将证明"
    $p "整除" $g ". 既然" (&= (&gcd $f $p) $1) ", 存在多项式" $f_0 "和" $p_0 "满足"
    (&= $1 (&+ (&i* $f_0 $f) (&i* $p_0 $p))) ". 两边乘上" $g ", 我们得到"
    (MB (deriv $g
               (&+ (&i* $f_0 $f $g) (&i* $p_0 $p $g))
               (&+ (&i* (@i* $f $g) $f_0) (&i* $p (@i* $p_0 $g)))))
    "既然" $p "整除" (&i* $f $g) ", 它也整除" (&i* (@i* $f $g) $f_0) ", 并且" $p
    "当然整除" (&i* $p (@i* $p_0 $g)) ", 因此" $p "整除" $g ".")
   ((corollary)
    "如果" $p "是素多项式并且整除" (&i* $f_1 $..c $f_n) ", 那么" $p
    "至少整除多项式" (&cm $f_1 $..h $f_n) "其中一个.")
   ((proof)
    "通过归纳进行证明. 当" (&= $n $2) "时, 该结果就是定理8. 设我们对于推论已经证明了"
    (&= $n $k) "的情形, 并设" $p "整除" (@+ $k $1) "个多项式之积" (&i* $f_1 $..c (_ $f (&+ $k $1)))
    ". 既然" $p "整除" (&i* (@i* $f_1 $..c $f_k) (_ $f (&+ $k $1))) ", 要么" $p "整除"
    (_ $f (&+ $k $1)) ", 要么" $p "整除" (&i* $f_1 $..c $f_k) ". 根据归纳假设, 如果"
    $p "整除" (&i* $f_1 $..c $f_k) ", 那么对于某个" (&cm $j (&<= $1 $j $k)) "有" $p
    "整除" $f_j ". 于是, 我们看到不论什么情况下必然都有对于某个" (&cm $j (&<= $1 $j (&+ $k $1)))
    ", " $p "整除" $f_j ".")
   ((theorem #:n "9")
    "如果" $F "是一个域, 那么" polyF "中的非标量首项系数为一多项式, 在不计顺序的情况下, "
    "有且仅有一种将其分解为" polyF "中的首项系数为一的素因子之积的方式.")
   ((proof)
    "设" $f "是域" $F "上的一个非标量首项系数为一多项式. 因为次数为一的多项式是不可约的, 因此在"
    (&= (&deg $f) $1) "的情况下没有什么好证明的东西. 设" $f "的次数" (&> $n $1) ". 根据归纳, "
    "我们可以假定该定理对于所有次数小于" $n "的非标量首项系数为一多项式均成立. 如果" $f
    "是不可约的, 那么它就已经被分解为首项系数为一的素因子之积了. 若" $f "可约, 则"
    (&= $f (&i* $g $h)) ", 其中" $g "和" $h "是次数小于" $n "的非标量首项系数为一多项式. 因此, "
    $g "和" $h "可以被分解为" polyF "中的首项系数为一的素因子之积, 于是" $f "也可以. 现在设"
    (MB (&= $f (&i* $p_1 $..c $p_m) (&i* $q_1 $..c $q_n)))
    "其中" (&cm $p_1 $..h $p_m) "和" (&cm $q_1 $..h $q_n) "是" polyF "中的首项系数为一的"
    "素多项式. 那么, " $p_m "整除" (&i* $q_1 $..c $q_n) ". 根据上述推论, " $p_m "必然整除某个"
    $q_i ". 鉴于" $q_i "和" $p_m "都是首项系数为一的素多项式, 这意味着"
    (MB (&= $q_i $p_m) ".")
    "从中我们看出, 如果" (&= $m $1) "或者" (&= $n $1) ", 那么" (&= $m $n $1) ", 因为"
    (MB (&= (&deg $f)
            (sum (&= $i $1) $m (&deg $p_i))
            (sum (&= $j $1) $n (&deg $q_j))) ".")
    "在" (&= $m $n $1) "的情况下没有什么好证明的东西, 所以我们不妨设" (&> $m $1) "且"
    (&> $n $1) ". 通过重排" $q "的下标, 我们可以假定" (&= $p_m $q_n) ", 并有"
    (MB (&= (&i* $p_1 $..c (_ $p (&- $m $1)) $p_m)
            (&i* $q_1 $..c (_ $q (&- $n $1)) $p_m)) ".")
    "根据定理1的推论2, 我们有"
    (MB (&= (&i* $p_1 $..c (_ $p (&- $m $1))) (&i* $q_1 $..c (_ $q (&- $n $1)))) ".")
    "因为多项式" (&i* $p_1 $..c (_ $p (&- $m $1))) "的次数小于" $n ", 可以应用归纳假设表明序列"
    (&cm $q_1 $..h (_ $q (&- $n $1))) "最多只是" (&cm $p_1 $..h (_ $p (&- $m $1)))
    "的重排. 这个事实和" (&= $p_m $q_n) "一起告诉我们" $f "作为首项系数为一的素因子之积的分解, "
    "在不计因子的顺序的情况下是唯一的." (Br)
    "[译注: 以上证明有一个小的混乱, 就是作为多项式" $f "的次数的" $n "和作为多项式序列"
    (&cm $q_1 $..h $q_n) "的长度的" $n "之间是毫无关系的.]")
   (P "在以上对于一个给定非标量首项系数为一的多项式" $f "的分解中, 某些首项系数为一的素因子"
      "是可以重复的. 如果" (&cm $p_1 $..h $p_r) "是对于这个" $f "的分解中所有不同的素因子, 那么"
      (MB (&= $f (&i* (_^ $p $1 $n_1) (_^ $p $2 $n_2) $..c (_^ $p $r $n_r))))
      "幂次" $n_i "是素因子" $p_i "在分解中出现的次数. 这样的分解显然也是唯一的, 其被称为" $f
      "的主分解 (primary decomposition). 很容易验证每个" $f "的首项系数为一的因子都具有"
      (MB (&cm (&i* (_^ $p $1 $m_1) (_^ $p $2 $m_2) $..c (_^ $p $r $m_r)) (&<= $0 $m_i $n_i)))
      "的形式. 这告诉我们有限数目的非标量首项系数为一多项式" (&cm $f_1 $..h $f_s)
      "的最大公因子可由联合所有那些同时出现在每个" (&cm $f_1 $..h $f_s) "的分解中的"
      "首项系数为一的素因子获得, 而其幂次取相应的幂能够整除每个" $f_i "的最大值. "
      "[译注: 这等价于取每个 " $f_i "与之对应的素因子的幂次的最小值.] "
      "若无素因子的(非平凡)幂次是每个" $f_i "的因子, 那么这些多项式是互素的. "
      "[译注: 这等价于若没有素因子出现在每个" $f_i "的分解中, 那么这些多项式是互素的.]")
   ((example #:n "11")
    "设" $F "是一个域, 令" (&cm $a $b $c) "是" $F "的不同元素, 那么多项式"
    (&cm (&- $x $a) (&- $x $b) (&- $x $c)) "是" polyF "中不同的首项系数为一的素多项式. 如果"
    (&cm $m $n $s) "是正整数, 那么" (^ (@- $x $c) $s) "是多项式"
    (MB (&i* (^ (@- $x $b) $n) (^ (@- $x $c) $s))
        "和" (&i* (^ (@- $x $a) $m) (^ (@- $x $c) $s)))
    "的最大公因子, 尽管这三个多项式"
    (MB (&cm (&i* (^ (@- $x $b) $n) (^ (@- $x $c) $s))
             (&i* (^ (@- $x $a) $m) (^ (@- $x $c) $s))
             (&i* (^ (@- $x $a) $m) (^ (@- $x $b) $n))))
    "是互素的.")
   ((theorem #:n "10")
    "令" $f "是域" $F "上的一个非标量首项系数为一多项式, 并且令"
    (MB (&= $f (&i* (_^ $p $1 $n_1) $..c (_^ $p $k $n_k))))
    "是" $f "的素因子分解. [译注: 按照上面的说法, 这里的prime factorization应该写成primary decomposition. "
    "当然了, 有基本理解能力的读者应该明白primary decompostion不过就是prime factorization的一种形式而已.] "
    "对于每个" (&cm $j (&<= $1 $j $k)) ", 令"
    (MB (&= $f_j (&/ $f (_^ $p $j $n_j)) (prod (&!= $i $j) $ (_^ $p $i $n_i))))
    "那么" (&cm $f_1 $..h $f_k) "是互素的. [译注: 这里需要定义多项式除法, 不过这是显然的.]")
   ((proof)
    "我们将这个(简单的)证明留给读者. 我们陈述这个定理很大程度上是因为"
    "我们想要在之后引用它. [译注: 第6章的定理12的证明引用了该定理.]")
   ((proof)
    "鉴于证明的确十分简单, 译者在此拟一个证明. 考虑刻画最大公因子定义的定理7的推论, 若首项系数为一的多项式"
    $d "满足条件b, 那么其仅可能为" $1 ". 但是, 既然这个刻画与非零理想存在且唯一的首项系数为一的生成元是等价的, "
    "所以说" $1 "就是" (&cm $f_1 $..h $f_k) "的最大公因子, 即" (&cm $f_1 $..h $f_k) "互素.")
   (Div
    #:attr* '((style "background: yellow"))
    (Em "注意: 此黄色背景标注内容将被删去.")
    ((theorem #:n "11")
     "令" $f "是一个域" $F "上的多项式, 其导数是" $f^ ", 那么" $f
     "是域" $F "上的不同的不可约多项式之积当且仅当" $f "和" $f^ "互素.")
    ((proof)
     "设域" $F "上对于" $f "的素因子分解中某个(非标量)素多项式" $p
     "是重复的 [译注: 原文之所以给非标量加上括号, 是因为素多项式按照定义本来就是非标量多项式], 那么"
     (&= $f (&i* $p^2 $h)) ", 其中" (&in $h polyF) ", 于是"
     (MB (&= $f^ (&+ (&i* $p^2 $h^) (&i* $2 $p $p^ $h))))
     "所以" $p "也是" $f^ "的一个因子, 因此" $f "和" $f^ "不是互素的." (Br)
     "现在设" (&= $f (&i* $p_1 $..c $p_k)) ", 其中" (&cm $p_1 $..h $p_k) "是域" $F
     "上不同的非标量不可约多项式. 令" (&= $f_j (&/ $f $p_j)) ", 那么"
     (MB (&= $f^ (LC0 (_^ $p $1 $prime) $f_1 (_^ $p $2 $prime) $f_2 (_^ $p $k $prime) $f_k)) ".")
     "令" $p "是一个整除" $f "和" $f^ "的素多项式, 那么对于某个" $i "有" (&= $p $p_i)
     ". 既然若" (&!= $j $i) ", 则" $p_i "整除" $f_j ", 并且" $p_i "也整除"
     (MB (&= $f^ (sum (&= $j $1) $k (&i* (_^ $p $j $prime) $f_j))))
     "我们看出来" $p_i "也必然整除" (&i* (_^ $p $i $prime) $f_i) ", 因而" $p_i
     "整除" $f_i "或" (_^ $p $i $prime) ". 但是, " $p_i "并不整除" $f_i
     ", 鉴于" (&cm $p_1 $..h $p_k) "都是不同的, 于是" $p_i "整除" (_^ $p $i $prime)
     ". 这是不可能的, 因为" (_^ $p $i $prime) "的次数比" $p_i "的次数少一. 我们总结一下, "
     "就是没有素多项式能够同时整除" $f "和" $f^ ", 即" $f "和" $f^ "是互素的.")
    (P "[译注: 定理11的陈述和证明都有些粗糙. 如果根据之前给出的定义稍加打磨一下, 定理11应该是&quot;"
       "令" $f "是域" $F "上的首项系数为一的多项式, 那么" $f "的素因子分解中每个因子仅出现一次"
       "当且仅当" $f "和" $f^ "互素&quot;. 其中" $1 "的素因子分解应该是&quot;空白&quot;, 因为"
       "&quot;空白&quot;的积定义为乘法的单位元 (也就是多项式" $1 ") 是很合理的. 至于证明, "
       "许多地方应该加上&quot;首项系数为一&quot;, 不然的话是不正确的. 另外, 这个证明中还用到了"
       "形式导数类似于导数的性质却没有另加证明, 尽管证明起来并不困难.]"))
   ((theorem #:n "11")
    "对于域" $F "上的一个首项系数为一的多项式" $f ", 设其素因子分解为"
    (&= $f (&..i* $p_1 $p_k)) ", 那么" (&..cm $p_1 $p_k) "互异当且仅当"
    $f "和" $f^ "互素.")
   ((proof)
    "设" (&..cm $p_1 $p_k) "互异. 若" $f "和" $f^ "不互素, 存在" $i
    "使得" $p_i "整除" $f "和" $f^ ". 令" (&= $f_j (&/ $f $p_j)) ", 那么"
    (MB (&= $f^ (LC0 (_^ $p $1 $prime) $f_1 (_^ $p $k $prime) $f_k)) ".")
    "对于" (&!= $j $i) ", 我们知道" $p_i "整除" $f_j ". 又因为" $p_i
    "整除" $f^ ", 所以" $p_i "整除" (&i* (_^ $p $i $prime) $f_i)
    ", 这等价于" $p_i "整除" (_^ $p $i $prime) "或" $f_i
    ". 但是, " $p_i "不可能整除" (_^ $p $i $prime) ", 鉴于"
    (_^ $p $i $prime) "的次数小于" $p_i "的次数. 而且, " $p_i
    "也不可能整除" $f_i ", 鉴于" (&..cm $p_1 $p_k)
    "是互异的. 这就推导出了一个矛盾, 于是" $f "和" $f^ "必然是互素的." (Br)
    "反过来, 设" $f "和" $f^ "互素. 若" $f "的素因子分解中出现重复的因子"
    $p ", 那么存在多项式" $h "使得" (&= $f (&i* $p^2 $h)) ", 于是"
    (MB (&= $f^ (&+ (&i* $p^2 $h^) (&i* $2 $p $p^ $h))
            (&i* $p (@+ (&i* $p $h^) (&i* $2 $p^ $h)))) ".")
    "因此, " $p "也整除" $f^ ", 但这与" $f "和" $f^ "矛盾. 换言之, "
    (&..cm $p_1 $p_k) "互异." (Br)
    "证明的最后, 我们想要澄清一下" (&= $f $1) "的极端情况. 此时, " $f
    "的素因子分解应该理解为&quot;空积&quot;, 因而互异的条件得到满足. 鉴于"
    (&= (&prime $1) $0) ", " (&= (&gcd $1 $0) $1) ", " $f "和" $f^
    "也是互素的. 我们看到, 即便是" (&= $f $1) ", 定理也是成立的.")
   ((tcomment)
    "刚才这个证明中用到了形式导数的性质而未加说明, 即对于多项式"
    (∈ $f $g polyF) ", 我们有"
    (MB (&= (&prime (@i* $f $g))
            (&+ (&i* $f^ $g) (&i* $f $g^))) ".")
    "并且, 使用归纳法, 我们很容易将其推广至任意多项的版本, "
    "而刚才的证明中也要用到. 鉴于其并非一眼即得的结果, "
    "我们将其表述为定理并进行证明.")
   ((theorem)
    "给定域" $F ", 对于任意的多项式" (∈ $f $g polyF)
    ", 其乘积的形式导数可以被表示为"
    (MB (&= (&prime (@i* $f $g))
            (&+ (&i* $f^ $g) (&i* $f $g^))) "."))
   ((proof)
    "显然, 此定理成立当且仅当对于每个自然数" (∈ $n $NN)
    ", 我们有"
    (MB (&= (_^ (@i* $f $g) $n $prime)
            (_ (@+ (&i* $f^ $g) (&i* $f $g^)) $n)) ".")
    "对于左边, 我们可知"
    (eqnderiv (_^ (@i* $f $g) $n $prime)
              (&i* (@+ $n $1) (_ (@i* $f $g) (&+ $n $1)))
              (&i* (@+ $n $1) (conv $k (&+ $n $1) $f $g)))
    "对于" (_ (@i* $f^ $g) $n) ", 我们可知"
    (eqnderiv (_ (@i* $f^ $g) $n)
              (sum (&= $k $0) $n
                   (&i* (_^ $f $k $prime)
                        (_ $g (&- $n $k))))
              (sum (&= $k $0) $n
                   (&i* (@+ $k $1)
                        (_ $f (&+ $k $1))
                        (_ $g (&- $n $k))))
              (sum (&= $k $1) (&+ $n $1)
                   (&i* $k $f_k
                        (_ $g (: $n $+ $1 $- $k))))
              (sum (&= $k $0) (&+ $n $1)
                   (&i* $k $f_k
                        (_ $g (: $n $+ $1 $- $k)))))
    "对于" (_ (@i* $f $g^) $n) ", 我们可知"
    (eqnderiv (_ (@i* $f $g^) $n)
              (sum (&= $k $0) $n
                   (&i* $f_k (_^ $g (&- $n $k) $prime)))
              (sum (&= $k $0) $n
                   (&i* (@ $n $+ $1 $- $k)
                        $f_k (_ $g (: $n $+ $1 $- $k))))
              (&+ (&i* (@+ $n $1)
                       (sum (&= $k $0) $n
                            (&i* $f_k (_ $g (: $n $+ $1 $- $k)))))
                  (sum (&= $k $0) $n
                       (&i* (@- $k)
                            $f_k (_ $g (: $n $+ $1 $- $k))))))
    "因此, 我们得到"
    (eqnderiv (_ (@+ (&i* $f^ $g) (&i* $f $g^)) $n)
              (&+ (_ (@i* $f^ $g) $n) (_ (@i* $f $g^) $n))
              (&+ (sum (&= $k $0) (&+ $n $1)
                       (&i* $k $f_k
                            (_ $g (: $n $+ $1 $- $k))))
                  (&i* (@+ $n $1)
                       (sum (&= $k $0) $n
                            (&i* $f_k (_ $g (: $n $+ $1 $- $k)))))
                  (sum (&= $k $0) $n
                       (&i* (@- $k)
                            $f_k (_ $g (: $n $+ $1 $- $k)))))
              (&+ (&i* (@+ $n $1)
                       (sum (&= $k $0) $n
                            (&i* $f_k (_ $g (: $n $+ $1 $- $k)))))
                  (&i* (@+ $n $1) (_ $f (&+ $n $1)) $g_0))
              (&i* (@+ $n $1) (conv $k (&+ $n $1) $f $g))
              (_^ (@i* $f $g) $n $prime))
    "证明也就结束了. 这个证明的优点在于其可以直接被推广至"
    "形式幂级数的情形而无需修改.")
   ((corollary)
    "给定域" $F ", 对于任意的多项式" (∈ $f_1 $f_2 $..h $f_n polyF)
    ", 其乘积的形式导数可以被表示为"
    (MB (&= (&prime (@i* $f_1 $f_2 $..c $f_n))
            (&+ (&i* (_^ $f $1 $prime) $f_2 $..c $f_n)
                (&i* $f_1 (_^ $f $2 $prime) $..c $f_n) $..c
                (&i* $f_1 $..c (_ $f (&- $n $1)) (_^ $f $n $prime)))) "."))
   ((definition)
    "域" $F "被称为代数封闭的 (algebraically closed), 如果每个域" $F
    "上的素多项式的次数都是" $1 ".")
   (P "称" $F "是代数封闭的意味着每个" $F "上的非标量不可约的首项系数为一多项式均具有"
      (@- $x $c) "的形式. 我们已经观察到每个这样的多项式对于任意的" $F "都是不可约的. "
      "据此, 代数闭域的一个等价定义是" polyF "中的每个非标量多项式" $f "都可以被表达为"
      (MB (&= $f (&i* $c (^ (@- $x $c_1) $n_1) $..c (^ (@- $x $c_k) $n_k))))
      "的形式, 其中" $c "是一个标量, " (&cm $c_1 $..h $c_k) "是" $F "的不同元素, "
      (&cm $n_1 $..h $n_k) "是正整数. 另一种对于代数闭域的刻画是如果" $f "是域"
      $F "上的非标量多项式, 那么存在" (&in $c $F) "使得" (&= (app $f $c) $0) ".")
   (P "实数域" $RR "不是代数封闭的, 因为多项式" (@+ $x^2 $1) "在" $RR "上是不可约的且次数不为"
      $1 ", 或是因为不存在实数" $c "满足" (&= (&+ $c^2 $1) $0) ". 所谓的代数基本定理陈述了复数域"
      $CC "是代数闭域的事实. 我们将不会证明这个定理, 尽管我们之后将在本书中稍微使用一下它. 省略这个定理的证明的"
      "一部分原因在于时间的限制, 一部分原因在于此证明依赖于实数系的一个&quot;非代数&quot;性质. "
      "至于一种可能的证明, 感兴趣的读者可以阅读参考文献中Schreier和Sperner所写的书.")
   (P "代数基本定理也使得实系数多项式的素因子分解的可能性明晰化. 如果" $f "是一个实系数多项式而"
      $c "是" $f "的一个复根, 那么其复共轭" (OverBar $c) "也是" $f "的一个根. 因此, 那些非实的复根必然以"
      "共轭对偶的形式出现, 而整个根的集合具有"
      (setE $t_1 $..h $t_k $c_1 (_ (OverBar $c) $1) $..h $c_r (_ (OverBar $c) $r))
      "的形式, 其中" (&cm $t_1 $..h $t_k) "是实数而" (&cm $c_1 $..h $c_r) "是非实的复数, 因此" $f "可以被分解为"
      (MB (&= $f (&i* $c (@- $x $t_1) $..c (@- $x $t_k) $p_1 $..c $p_r)))
      "其中" $p_i "是二次多项式"
      (MB (&= $p_i (&i* (@- $x $c_i) (@- $x (_ (OverBar $c) $i)))) ".")
      "这些多项式" $p_i "具有实系数. 我们总结一下, 实数域上的每个非标量不可约多项式的次数都是" $1 "或" $2
      ". " $RR "上的每个非标量多项式都是特定的线性因子 (从" $f "的实根中得到) 和特定的不可约二次多项式"
      "之积 [译注: 还要考虑一下最后再乘上一个系数].")
   ((exercise #:n "1")
    "令" $p "是域" $F "上一个首项系数为一的多项式. 令" $f "和" $g "是域" $F "上互素的多项式. 证明"
    (&i* $p $f) "和" (&i* $p $g) "的最大公因子是" $p ".")
   ((exercise #:n "2")
    "默认代数基本定理成立, 证明以下事实. 如果" $f "和" $g "是复数域上的多项式, 那么"
    (&= (&gcd $f $g) $1) "当且仅当" $f "和" $g "没有共同的根.")
   ((exercise #:n "3")
    "令" $D "是" (&poly $CC) "上的微分算子. 令" $f "是复数域上的首项系数为一多项式. 证明"
    (MB (&= $f (&i* (@- $x $c_1) $..c (@- $x $c_k))))
    "其中" (&cm $c_1 $..h $c_k) "是不同的复数, 当且仅当" $f "和" (ap $D $f) "互素. 换言之, " $f
    "没有重复的根当且仅当" $f "和" (ap $D $f) "没有相同的根. (默认代数基本定理成立.)")
   ((exercise #:n "4")
    "证明以下Taylor公式的推广. 令" (&cm $f $g $h) "是某个复数域的子域上的多项式, 并且"
    (&<= (&deg $f) $n) ", 那么"
    (MB (&= (app $f $g) (sum (&= $k $0) $n
                             (&i* (~ $1 (&fact $k))
                                  (app (^ $f (@ $k)) $h)
                                  (^ (@- $g $h) $k)))) ".")
    "(这里" (app $f $g) "代表&quot;应用" $f "于" $g "&quot;.)")
   (P "对于剩余的练习, 我们需要如下定义. 如果" (&cm $f $g $p) "是域" $F "上的多项式并且"
      (&!= $p $0) ", 那么我们称模" $p "下" $f "和" $g "同余, 如果" (@- $f $g) "被" $p
      "整除. 如果模" $p "下" $f "同余于" $g ", 那么我们记"
      (MB (equivmod $f $g) "."))
   ((exercise #:n "5")
    "对于任意的非零多项式" $p ", 证明模" $p "同余是一个等价关系."
    (Ol #:attr* '((type "a"))
        (Li "自反: " (equivmod $f $f) ".")
        (Li "对称: 如果" (equivmod $f $g) ", 那么" (equivmod $g $f) ".")
        (Li "传递: 如果" (equivmod $f $g) "并且" (equivmod $g $h)
            ", 那么" (equivmod $f $h) ".")))
   ((exercise #:n "6")
    "设" (equivmod $f $g) "且" (equivmod $f_1 $g_1) "."
    (Ol #:attr* '((type "a"))
        (Li "证明" (equivmod (&+ $f $f_1) (&+ $g $g_1)) ".")
        (Li "证明" (equivmod (&i* $f $f_1) (&i* $g $g_1)) ".")))
   ((exercise #:n "7")
    "使用练习6证明以下结果. 如果" (&cm $f $g $h $p) "是域" $F "上的多项式而" (&!= $p $0)
    ", 若" (equivmod $f $g) ", 则" (equivmod (app $h $f) (app $h $g))
    ". [译注: 原文是练习7, 应该是练习6. 或许其他地方这样的编号引用错误还有很多, 因为我没有一一检查.]")
   ((exercise #:n "8")
    "如果" $p "是一个 [译注: 非标量] 不可约多项式而" (equivmod (&i* $f $g) $0) ", 那么" (equivmod $f $0)
    "或者" (equivmod $g $0) ". 给出反例说明在" $p "可约的情况下这是错误的.")
   ))