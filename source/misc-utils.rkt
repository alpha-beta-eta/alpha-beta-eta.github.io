#lang racket
(provide (all-defined-out))
(require SMathML)
(define $gcd (Mi "gcd"))
(define (&gcd a b)
  (appl $gcd a b))
(define $vert0 (Mo "&vert;" #:attr* '((lspace "0") (rspace "0"))))
(define (div a b)
  (: a $vert0 b))
(define $*0 (Mo "&#8270;" #:attr* '((lspace "0") (rspace "0"))))
(define i.<= (Mi "&le;"))
(define (&d x y)
  (appl $d x y))
(define $img (Mi "img"))
(define (&img f)
  (app $img f))
(define $exp (Mi "exp"))
(define (&exp x)
  (app $exp x))
(define $sup0 (Mi "sup"))
(define (&sup0 X)
  (ap $sup0 X))
(define (insert-before-last x lst)
  (let r ((a (car lst)) (d (cdr lst)))
    (if (null? (cdr d))
        (cons a (cons x d))
        (cons a (r (car d) (cdr d))))))
(define (..lize &)
  (lambda arg*
    (apply & (insert-before-last $..c arg*))))
(define &..i* (..lize &i*))
(define (&..cm . arg*)
  (apply &cm (insert-before-last $..h arg*)))
(define LC0
  (case-lambda
    ((k u) (&+ $..c (&i* k u)))
    ((k u . arg*) (&+ (&i* k u) (apply LC0 arg*)))))
(define (_@ A x)
  (_ (@ A) x))