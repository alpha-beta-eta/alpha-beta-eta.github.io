#lang racket
(provide tspl4.html)
(require SMathML)
(define (_cm A . x*)
  (_ A (apply &cm x*)))
(define $log (Mi "log"))
(define &log
  (case-lambda
    ((x) (ap $log x))
    ((b x) (ap (_ $log b) x))))
(define-@lized-op*
  (@/ &/))
(define tspl4.html
  (TnTmPrelude
   #:title "Scheme编程语言"
   #:css "styles.css"
   (H1. "Scheme编程语言")
   (P "在某种意义上, 我的确没有时间翻译这本书. "
      "不过, 鉴于Scheme是我学习编程的起点, "
      "我总是感到翻译TSPL4对于我个人而言具有特别的意义.")
   (H2. "前言" #:auto? #f)
   (H2. "引论")
   (H2. "开始")
   (H2. "深入")
   (H2. "过程和变量绑定")
   (H2. "控制操作")
   (H3. "过程应用")
   (H3. "顺序 (sequencing)")
   (H3. "条件式 (conditionals)")
   (H3. "递归和迭代")
   (H3. "map和fold操作")
   (H3. "延续 (continuations)")
   (H3. "延迟求值")
   (H3. "多值")
   (H3. "eval")
   (H2. "对象上的操作")
   (H2. "输入和输出")
   (H2. "句法扩展")
   (H3. "关键词绑定")
   (H3. "syntax-rules转换器")
   (H3. "syntax-case转换器")
   (H3. "例子")
   (H2. "记录")
   (H2. "库和顶层程序")
   (H3. "标准库")
   (H3. "定义新库")
   (H3. "顶层程序")
   (H3. "例子")
   (H2. "异常和条件")
   (H2. "扩展例子")
   (H3. "矩阵和向量乘法")
   (P "这个示例程序牵涉最为基本的编程技术. "
      "其刻画了简单算术和向量操作, 使用"
      (Code "do") "句法形式的循环, "
      "基于对象类型的分派, 以及引起异常.")
   (P "标量和标量, 标量和矩阵, 或者矩阵和矩阵的乘法, "
      "都是由一个被称为" (Code "mul") "的单一"
      (Em "通用(generic)") "过程所执行的. "
      (Code "mul") "被调用以两个参数, "
      "而其根据参数的类型来决定应该执行的操作. "
      "鉴于标量操作使用了Scheme的乘法过程"
      (Code "*") ", " (Code "mul")
      "的标量可以是任意内置的数值类型 "
      "(精确或非精确的复数, 实数, 有理数, 或整数).")
   (P "一个" (&c* $m $n) "的矩阵" $A "和一个"
      (&c* $n $p) "的矩阵" $B "之积是"
      (&c* $m $p) "的矩阵" $C
      ", 其元素由以下公式定义:"
      (MB (&= (_cm $C $i $j)
              (sum (&= $k $0)
                   (&- $n $1)
                   (&i* (_cm $A $i $k)
                        (_cm $B $k $j)))) ".")
      "一个标量" $x "和一个" (&c* $m $n)
      "的矩阵" $A "之积是" (&c* $m $n)
      "的矩阵" $C ", 其元素由以下等式定义:"
      (MB (&= (_cm $C $i $j)
              (&i* $x (_cm $A $i $j))) ".")
      "也就是说, " $C "的每个元素都是" $x
      "和" $A "的相应元素之积. "
      )
   (H3. "排序")
   (H3. "一个集合构造器")
   (H3. "词频统计")
   (H3. "Scheme打印器")
   (H3. "格式化输出")
   (H3. "一个Scheme的元循环解释器")
   (H3. "定义抽象对象")
   (H3. "快速Fourier变换")
   (P "本节所描述的过程利用了Scheme的复数算术来计算一个值的序列的"
      (Em "离散Fourier变换(DFT)")
      ". 离散Fourier变换在诸如模式识别, 带宽压缩, 雷达目标探测, "
      "天气监视等广阔的数字电子应用中被用来分析和处理采样的信号序列.")
   (P "一个由" $N "个输入值构成的序列"
      (MB (_^ (setE (app $x $n)) (&= $n $0) (&- $N $1)))
      "的DFT是由" $N "个输出值构成的序列"
      (MB (_^ (setE (app $X $m)) (&= $m $0) (&- $N $1)))
      "而这每一项由以下等式定义:"
      (MB (&= (app $X $m)
              (sum (&= $n $0) (&- $N $1)
                   (&i* (app $x $n)
                        (^ $e (&i* (&- $i)
                                   (~ (&i* $2 $pi $m $n)
                                      $N)))))))
      "一般而言(对于给定的" $N ")抽象出常量是方便的, 即"
      (MB (&= $W_N (^ $e (&i* (&- $i) (~ (&i* $2 $pi) $N)))))
      "这让我们得到了更加简明但是等价的等式"
      (MB (&= (app $X $m)
              (sum (&= $n $0) (&- $N $1)
                   (&i* (app $x $n)
                        (_^ $W $N (&i* $m $n))))))
      "直接将" $N "个输出值每个计算为" $N
      "个中间值之和的话, 需要阶为" $N^2
      "的操作量. 若使用" (Em "快速")
      "Fourier变换 (FFT), 其可应用于" $N
      "为" $2 "的幂次的情形, 那么就仅需阶为"
      (&i* $N (&log $2 $N))
      "的操作量. 尽管其通常被呈现为一个复杂的迭代算法, "
      "快速Fourier变换以递归算法表达最为简明和优雅.")
   (P "这个递归算法应该归功于Sam Daniel, "
      "其可由按以下方式操作前缀和 (preceding summation) "
      "推导出来. 我们首先将求和分为两半, "
      "然后将其重新组合为一个从" $0 "到"
      (&- (&/ $N $2) $1) "的求和."
      (MB (deriv (app $X $m)
                 (&+ (sum (&= $n $0) (&- (&/ $N $2) $1)
                          (&i* (app $x $n)
                               (_^ $W $N (&i* $m $n))))
                     (sum (&= $n (&/ $N $2)) (&- $N $1)
                          (&i* (app $x $n)
                               (_^ $W $N (&i* $m $n)))))
                 (sum (&= $n $0) (&- (&/ $N $2) $1)
                      (bra0
                       (&+ (&i* (app $x $n)
                                (_^ $W $N (&i* $m $n)))
                           (&i* (app $x (&+ $n (&/ $N $2)))
                                (_^ $W $N (&i* $m (@+ $n (&/ $N $2))))))))))
      "然后, 我们可以将共同的因子" (_^ $W $N (&i* $m $n))
      "提取出来, 即"
      (MB (&= (app $X $m)
              (sum (&= $n $0) (&- (&/ $N $2) $1)
                   (&i* (bra0
                         (&+ (app $x $n)
                             (&i* (app $x (&+ $n (&/ $N $2)))
                                  (_^ $W $N (&i* $m (@/ $N $2))))))
                        (_^ $W $N (&i* $m $n))))))
      "我们可以在" $m "为偶数时将" (_^ $W $N (&i* $m (@/ $N $2)))
      "规约为" $1 ", 而在" $m "为奇数时规约为" $-1 ", 因为"
      (MB (&= (_^ $W $N (&i* $m (@/ $N $2)))
              (_^ $W $2 $m)
              (^ $e (&- (&i* $i $pi $m)))
              (Choice0
               ($1 $cm $m "为偶数")
               ($-1 $cm $m "为奇数"))))
      "这允许我们分别对于偶数和奇数的情形特化求和. 对于"
      (&<= $0 $k (&- (&/ $N $2) $1)) ", 我们有"
      (eqn* ((app $X (&i* $2 $k))
             $=
             (sum (&= $n $0) (&- (&/ $N $2) $1)
                  (&i* (bra0
                        (&+ (app $x $n)
                            (app $x (&+ $n (&/ $N $2)))))
                       (_^ $W $N (&i* $2 $k $n)))))
            ($
             $=
             (sum (&= $n $0) (&- (&/ $N $2) $1)
                  (&i* (bra0
                        (&+ (app $x $n)
                            (app $x (&+ $n (&/ $N $2)))))
                       (_^ $W (&/ $N $2) (&i* $k $n)))))
            ((app $X (&+ (&i* $2 $k) $1))
             $=
             (sum (&= $n $0) (&- (&/ $N $2) $1)
                  (&i* (bra0
                        (&- (app $x $n)
                            (app $x (&+ $n (&/ $N $2)))))
                       (_^ $W $N (&i* (@+ (&i* $2 $k) $1) $n)))))
            ($
             $=
             (sum (&= $n $0) (&- (&/ $N $2) $1)
                  (&i* (bra0
                        (&- (app $x $n)
                            (app $x (&+ $n (&/ $N $2)))))
                       (_^ $W $N $n)
                       (_^ $W (&/ $N $2) (&i* $k $n))))))
      "作为结果的求和分别是具有" (&/ $N $2) "个元素的序列"
      (MB (_^ (setE (&+ (app $x $n)
                        (app $x (&+ $n (&/ $N $2)))))
              (&= $n $0) (&- (&/ $N $2) $1)))
      "和"
      (MB (_^ (setE (&i* (bra0
                          (&- (app $x $n)
                              (app $x (&+ $n (&/ $N $2)))))
                         (_^ $W $N $n)))
              (&= $n $0) (&- (&/ $N $2) $1)))
      "的DFT的第" $k "项. 因此, 一个具有" $N
      "个元素的序列的DFT可以被递归地计算为两个具有"
      (&/ $N $2) "个元素的序列的DFT的交织. "
      "如果我们将具有" $2 "个元素的序列作为基本情形, "
      "那么我们就可以按照以下方式描述一个递归的FFT算法 (RFFT). "
      "对于" (&= $N $2) "的情形, 我们有"
      (MB (deriv (ap 'RFFT (_^ (setE (app $x $n)) (&= $n $0) $1))
                 (_^ (setE (app $X $m)) (&= $m $0) $1)
                 (setE (&+ (app $x $0) (app $x $1))
                       (&i* (bra0 (&- (app $x $0) (app $x $1)))
                            (_^ $W $2 $0)))
                 (setE (&+ (app $x $0) (app $x $1))
                       (&- (app $x $0) (app $x $1)))))
      "鉴于" (&= $N $1) "时的DFT是恒等变换, 以及"
      (&= (_^ $W $2 $0) $e^0 $1) ". "
      )
   (H3. "一个合一算法")
   (P "合一是一种模式匹配的技术, 用于自动定理证明, 类型推导系统, "
      "计算机代数, 以及逻辑编程 (例如Prolog).")
   
   (H3. "使用engine的多任务")
   ))