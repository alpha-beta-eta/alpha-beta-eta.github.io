#lang racket
(provide mop.html)
(require SMathML)
(define (LP x . x*)
  (apply P (B x ". ") x*))
(define mop.html
  (TmPrelude
   #:title "元对象协议艺术"
   #:css "styles.css"
   (H1 "元对象协议艺术")
   (H3 "引论")
   (P "现代编程语言设计存在于两个看似相互冲突的需求之间的张力中. "
      "一方面, 诸如Scheme, Prolog和ML等高级语言在优雅性和表达能力方面取得了重大进展. "
      "另一方面, 许多工业程序员发现这些语言过于" (Q "理论化")
      "或不切实际, 难以在日常使用中应用, 而且效率低下. "
      "因此, 这些语言往往只在学术和研究环境中使用, "
      "而世界上大多数主流编程是用C和C++等语言进行的, 这些语言因其效率和适应性而著称.")
   (P "本书介绍了一种编程语言设计的新方法, 在这种方法中, "
      "优雅性和效率这两个需求被视为相容的, 而非冲突的. "
      "我们的目标是开发出既像最纯粹的理论设计一样简洁, "
      "又在性能或实现控制上不做任何妥协的语言.")
   (P "我们实现优雅性和效率相结合的方式是将语言设计建立在" (Em "元对象协议")
      "的基础上. 元对象协议是语言的接口, 它使用户能够增量式地修改语言的行为和实现, "
      "并能够在语言内部编写程序.")
   (P "采用元对象协议的语言模糊了语言设计者和语言用户之间的界限. "
      "传统上, 设计者被期望制造具有良定义的"
      "固定行为 (或者说" (Q "语义") ") 的语言. "
      "用户被期望将这些语言视为不可变的黑盒抽象, "
      "并从构建在其之上的结构中获得所需的灵活性或能力. "
      "这种明确的分工被认为构成了适当的劳动分工. "
      "编程语言设计被视为一门困难的, 高度专业化的艺术, 不适合普通用户参与. "
      "同时也常常假设语言设计必须是刚性的, "
      "以支持可移植的实现, 高效的编译器等等.")
   (P "相比之下, 元对象协议方法基于这样的理念: "
      "人们可以而且应该" (Q "开放语言")
      ", 允许用户调整设计和实现以适应他们的特定需求. "
      "换句话说, 鼓励用户参与语言设计过程. "
      "如果处理得当, 开放语言设计不必损害程序的可移植性或实现效率.")
   
   (H2 "第I部分 元对象协议的设计和实现")
   (H3 "第1章 CLOS是如何实现的")
   (H4 "第1.1节 CLOS的一个子集")
   (P "出于教学和(相对)简明的旨趣, 我们选择与CLOS的一个简化子集打交道. "
      "完整CLOS的所有基本特征都有囊括: "
      (Em "类(class)") ", 其从一个类或者多个类继承了结构和行为; "
      "类的" (Em "实例(instance)") ", 其可以被创建, 初始化, 和操纵; "
      (Em "通用函数(generic function)") ", 其行为依赖于供给它们的参数的类; "
      (Em "方法(method)") ", 其定义了通用函数特定于类的行为和操作. "
      "我们简化了的方言的主要限制包括:")
   (LP "没有类重定义"
       
       )
   (LP "没有方法重定义"
       
       )
   (LP "没有前向引用的超类"
       
       )
   (LP "显式的通用函数定义"
       
       )
   (LP "只有标准的方法组合"
       
       )
   (LP (Span "没有" (Code "eql") "特化子")
       
       )
   (LP (Span "没有带有" (Code ":class") "分配的槽")
       
       )
   (LP "类型和类并未完全继承"
       
       )
   (LP "最小的句法糖"
       
       )
   (H4 "第1.2节 基本的台面下数据结构")
   (P "就其最简单的语言而言, 一个CLOS程序由"
      (Code "defclass") ", " (Code "defgeneric") ", " (Code "defmethod")
      "形式以及与其交织的更为传统的Common Lisp形式构成. "
      "执行这些形式定义了程序的类, 通用函数, 方法.")
   (P "在台面下, 这些形式的执行创建了对于类, 通用函数, 方法的内部表示, "
      "记录了其定义中所提供的信息. "
      "实现使用存储于类的内部表示的信息来创建类的实例以及访问(实例的)槽. "
      "存储于通用函数及其方法的内部表示中的信息则用以调用通用函数.")
   (P "为了使事情具体化, 考虑以下的示例CLOS程序:"
      (CodeB "(defclass rectangle ()
  ((height :initform 0.0 :initarg :height)
   (width  :initform 0.0 :initarg :width)))

(defclass color-mixin ()
  ((cyan    :initform 0.0 :initarg :cyan)
   (magenta :initform 0.0 :initarg :magenta)
   (yellow  :initform 0.0 :initarg :yellow)))

(defclass color-rectangle (color-mixin rectangle)
  ((clearp :initform (y-or-n-p &quot;But is it transparent?&quot;)
           :initarg :clearp :accessor clearp)))

(defgeneric paint (x))

(defmethod paint ((x rectangle)) ;Method #1
  (vertical-stroke (slot-value x 'height)
                   (slot-value x 'width)))")
      )
   (H4 "第1.3节 表示类")
   (H4 "第1.4节 打印对象")
   (H4 "第1.5节 表示实例的结构")
   (H4 "第1.6节 表示通用函数")
   (H4 "第1.7节 表示方法")
   (H4 "第1.8节 调用通用函数")
   (H4 "第1.9节 关于性能的一些话")
   (H4 "第1.10节 总结")
   (H3 "第2章 自省与分析")
   (H3 "第3章 扩展语言")
   (H3 "第4章 协议设计")
   (H2 "第II部分 CLOS的一个元对象协议")
   (H3 "第5章 概念")
   (H3 "第6章 Generic Functions and Methods")
   (H3 "附录A CLOS简介")
   (H3 "附录B 部分习题解答")
   ))