<html><head><meta charset="utf-8"/><title>数据结构和算法笔记</title><link href="styles.css" rel="stylesheet"/></head><body><h1>数据结构和算法笔记</h1><p>我完全不懂数据结构和算法. 另外, 这里是一些关于数据结构和算法的笔记. 当我认为我懂了之后, 或许会写一本书.</p><h2>什么是数据结构?</h2><p>以下内容翻译自Purely Functional Data Structures.</p><p>任何对于数据结构的讨论都充斥着误解的潜在可能, 因为术语<em>数据结构</em>至少具有四个不同但相互关联的含义.<ul><li><em>一个抽象数据类型 (即一个类型和一集该类型上的函数). </em>我们将会称其为一个<em>抽象</em>.</li><li><em>一个抽象数据类型的一个具体实现. </em>我们将会称其为一个<em>实现</em>, 但是注意一个实现未必要被具体化为代码&mdash;&mdash;一个具体的设计就足够了.</li><li><em>一个数据类型的一个实例, 例如一个特定的列表或树. </em>我们将会称这样的一个实例为一个<em>对象</em>或者一个<em>版本</em>. 然而, 特定的数据类型可能有着它们自己的命名法. 例如, 我们将会直接称栈或队列对象为栈或队列.</li><li><em>一个在更新下保持不变的独特身份(identity). </em>例如, 在一个基于栈的解释器里, 我们经常非正式地说<q>栈 (the stack)</q>, 就好像只存在一个栈似的, 而不是不同的时间有着不同的版本. 我们将会称这个身份为一个<em>可持久化身份</em>. 这个事项主要出现在可持久化数据结构的上下文中; 当我们言及相同数据结构的不同版本时, 我们的意思是这些不同版本共享着一个相同的可持久化身份.</li></ul>大致说来, 抽象对应于Standard ML的签名, 实现对应于结构或函子, 对象或版本对应于值. 至于可持久化身份, Standard ML中没有贴切的对应概念 (good analogue).</p><h2>IOI 1994 The Triangle</h2><p>算是简单的动态规划问题.</p><pre><code>(define ref
  (case-lambda
    ((v i) (vector-ref v i))
    ((v i . j*) (apply ref (vector-ref v i) j*))))
(define (solve-IOI94P1 T)
  (define N (vector-length T))
  (define S (make-vector N))
  (let iter ((i 0))
    (cond
      ((= i N) (apply max (vector->list S)))
      (else
       (let iter ((j i))
         (cond
           ((= j 0)
            (vector-set! S 0 (+ (ref T i 0) (ref S 0))))
           (else
            (vector-set! S j (+ (ref T i j)
                                (max (ref S (- j 1)) (ref S j))))
            (iter (- j 1)))))
       (iter (+ i 1))))))</code></pre><pre><code>> (solve-IOI94P1
   '#(#(7)
      #(3 8)
      #(8 1 0)
      #(2 7 4 4)
      #(4 5 2 6 5)))
30</code></pre><p>题解网上很容易找到, 也没有必要再写什么. 注意<code>make-vector</code>默认将每个元素置为<code>0</code>.</p><h2>辅助过程</h2><pre><code>(define (vector-swap! v i j)
  (define t (vector-ref v i))
  (vector-set! v i (vector-ref v j))
  (vector-set! v j t))</code></pre><h2>插入排序</h2><p>插入排序相当简单 (但实际上对于没有接触过的人而言又不那么简单), 但也相当重要. 在数组长度比较短的时候, 插入排序往往是效率最高的.</p><pre><code>(define (insertion-sort! v)
  (define l (vector-length v))
  (unless (&lt; l 2)
    (let iter ((i 1))
      (unless (= i l)
        (insert! v i)
        (iter (+ i 1))))))
(define (insert! v i)
  (define x (vector-ref v i))
  (let iter ((j (- i 1)))
    (cond
      ((= j -1) (vector-set! v 0 x))
      ((> (vector-ref v j) x)
       (vector-set!
        v (+ j 1) (vector-ref v j))
       (iter (- j 1)))
      (else
       (vector-set! v (+ j 1) x)))))</code></pre><p>插入排序的时间复杂度估计非常简单, 每次插入最坏的情况就是移动到开头, 并且插入次数大致上是<math><mi>n</mi></math>, 故上界为<math><mrow><mi>O</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow></mrow></math>.</p><h2>归并排序</h2><p>注意一下, <code>(merge-sort! v lo hi)</code>排序的是<code>v</code>从<code>lo</code>到<code>hi</code>的部分, 包含<code>lo</code>但不包含<code>hi</code>.</p><pre><code>(define (merge-sort! v lo hi)
  (unless (&lt;= (- hi lo) 1)
    (define mi (quotient (+ lo hi) 2))
    (merge-sort! v lo mi)
    (merge-sort! v mi hi)
    (merge! v lo mi hi)))
(define (merge! v lo mi hi)
  (define l (vector-copy v lo mi))
  (define r (vector-copy v mi hi))
  (define a (- mi lo))
  (define b (- hi mi))
  (let iter ((k lo) (i 0) (j 0))
    (cond
      ((and (&lt; i a) (&lt; j b))
       (cond
         ((&lt; (vector-ref l i)
             (vector-ref r j))
          (vector-set! v k (vector-ref l i))
          (iter (+ k 1) (+ i 1) j))
         (else
          (vector-set! v k (vector-ref r j))
          (iter (+ k 1) i (+ j 1)))))
      ((= i a)
       (let iter ((k k) (j j))
         (unless (= k hi)
           (vector-set! v k (vector-ref r j))
           (iter (+ k 1) (+ j 1)))))
      ((= j b)
       (let iter ((k k) (i i))
         (unless (= k hi)
           (vector-set! v k (vector-ref l i))
           (iter (+ k 1) (+ i 1))))))))</code></pre><p>归并排序的时间复杂度估计不难理解, 大致上每个层次归并所用的时间是<math><mrow><mi>O</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow></math>, 而大约有<math><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow></math>层, 故上界估计为<math><mrow><mi>O</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>&it;</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>.</p><h2>冒泡排序</h2><p>不知道为什么, 编写冒泡排序是一件很有压力的事情, 而实际上我的确也写了很长时间. 在编写冒泡排序的时候, 我的脑子里的所思所想是这样的: 后段已排序, 后段的每个元素都大于等于前段的所有元素, 每轮交换可以将前段的最大元素移至最后的位置, 如果在一轮中没有发生交换, 则说明整个数组是已排序好了的. 当然, 也可以从逆序归约的角度思考问题.</p><pre><code>(define (bubble-sort! v)
  (define l (vector-length v))
  (let loop ((i 1))
    (unless (>= i l)
      (let iter ((j 0) (flag #f))
        (cond
          ((= j (- l i))
           (when flag
             (loop (+ i 1))))
          ((> (vector-ref v j)
              (vector-ref v (+ j 1)))
           (vector-swap! v j (+ j 1))
           (iter (+ j 1) #t))
          (else
           (iter (+ j 1) flag)))))))</code></pre><h2>快速排序</h2><p>这里的约定和归并排序那里一致. 主元的选取是任意的, 我只是选取了第一个元素.</p><pre><code>(define (quick-sort! v lo hi)
  (unless (&lt;= (- hi lo) 1)
    (define p (partition! v lo hi))
    (quick-sort! v lo p)
    (quick-sort! v (+ p 1) hi)))
(define (partition! v lo hi)
  (define pivot (vector-ref v lo))
  (let iter ((left (+ lo 1)) (right hi))
    (cond ((= left right)
           (vector-swap! v lo (- left 1))
           (- left 1))
          ((> (vector-ref v left) pivot)
           (vector-swap! v left (- right 1))
           (iter left (- right 1)))
          (else
           (iter (+ left 1) right)))))</code></pre><p>根据原地 (in-place) 的定义的不同, 快速排序可以是原地的, 也可以不是原地的, 因为它的确要消耗栈的空间.</p><h2>二分搜索</h2><p>据说二分搜索很少有人能够书写正确, 即便是算法研究者也不例外. 这里仍然遵循着左闭右开的原则, 以后不再赘述.</p><pre><code>(define (binary-search x v lo hi)
  (if (>= lo hi)
      #f
      (let ((mi (quotient (+ lo hi) 2)))
        (cond
          ((= (vector-ref v mi) x) mi)
          ((> (vector-ref v mi) x)
           (binary-search x v lo mi))
          (else
           (binary-search x v (+ mi 1) hi))))))</code></pre><h2>杂凑 (哈希)</h2><h2>3SUM问题</h2><p><code>3SUM</code>的前条件是<code>v</code>已从小到达排序且元素互异.</p><pre><code>(define (3SUM v)
  (define l (vector-length v))
  (let loop ((i 0) (result '()))
    (cond ((= i l) result)
          ((>= (vector-ref v i) 0) result)
          (else
           (let iter ((j (+ i 1)) (k (- l 1)) (r '()))
             (if (&lt; j k)
                 (let* ((a (vector-ref v i))
                        (b (vector-ref v j))
                        (c (vector-ref v k))
                        (s (+ a b c)))
                   (cond
                     ((= s 0) (iter (+ j 1)
                                    (- k 1)
                                    (cons (list a b c) r)))
                     ((&lt; s 0) (iter (+ j 1) k r))
                     (else (iter j (- k 1) r))))
                 (loop (+ i 1) (append r result))))))))</code></pre><h2>parallel和concurrent的区别</h2><p>parallel指的是一种同时运行多个任务的实际能力, 而concurrent是一种编程抽象, 它维护了一种同时运行多个任务的illusion. concurrent的程序可能的确以parallel的方式运行, 但也可能只是以顺序运行的方式来模拟parallelism.</p><p>以上是一种实用的表面说法, 在某种意义上其实有点似是而非. concurrency的本质在于一种<q>不确定性</q>, 我们无法控制事件发生的时间和顺序, 但仍然企图获得对于这样的物理本性的一种(可复合的)控制. parallelism和concurrency不同的地方在于, 它强调的同时运行的能力可以从一开始得到控制, 而且我们从一开始的企图就是从中获得效率和性能. 当然, 或许我需要说明的是, 并行不是自然或者天生就是可控的, 而是我们希望去控制而可以控制, 因而这里重要的事情是确定子计算的依赖关系.</p><h2>zipper</h2><p>zipper可以有多种理解, 但是从具体的数据结构来说, zipper可以理解为附加了<q>历史记录</q>的各种各样的数据结构. 这个历史记录描述了我们是以何种方式进入相应的数据结构的. 通过历史(和现在), 我们也可以还原本来数据结构的面貌.</p><h2>关于<math><mi>d</mi></math>叉树的基本事实</h2><p>若以数组存储<math><mi>d</mi></math>叉树 (且根结点的下标为<math><mn>1</mn></math>), 那么下标为<math><mi>k</mi></math>的结点的子结点的下标范围是<math display="block"><mrow><mo stretchy="false">[</mo><mrow><mrow><mi>d</mi><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mn>2</mn></mrow><mo>,</mo><mrow><mrow><mi>d</mi><mo>&it;</mo><mi>k</mi></mrow><mo>+</mo><mn>2</mn></mrow><mo stretchy="false">)</mo></mrow><mtext>,</mtext></math>而下标为<math><mi>k</mi></math> (其中<math><mrow><mi>k</mi><mo>></mo><mn>1</mn></mrow></math>) 的结点的父结点的下标为<math display="block"><mrow><mo>&lfloor;</mo><mfrac><mrow><mi>k</mi><mo>+</mo><mrow><mi>d</mi><mo>&minus;</mo><mn>2</mn></mrow></mrow><mi>d</mi></mfrac><mo>&rfloor;</mo></mrow><mtext>.</mtext></math>具有<math><mi>n</mi></math>层的满<math><mi>d</mi></math>叉树的元素总数为<math display="block"><mrow><mrow><msup><mi>d</mi><mn>0</mn></msup><mo>+</mo><msup><mi>d</mi><mn>1</mn></msup><mo>+</mo><mo>&ctdot;</mo><mo>+</mo><msup><mi>d</mi><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow><mo>=</mo><mfrac><mrow><msup><mi>d</mi><mi>n</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><mrow><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow></mfrac></mrow><mtext>.</mtext></math>具有<math><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></math>层 (即高度为<math><mi>n</mi></math>) 的完全<math><mi>d</mi></math>叉树的元素数目范围是<math display="block"><mrow><mo stretchy="false">[</mo><mrow><mfrac><mrow><msup><mi>d</mi><mi>n</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><mrow><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow></mfrac><mo>+</mo><mn>1</mn></mrow><mo>,</mo><mfrac><mrow><msup><mi>d</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>&minus;</mo><mn>1</mn></mrow><mrow><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow></mfrac><mo stretchy="false">]</mo></mrow><mtext>或者写成</mtext><mrow><mo stretchy="false">[</mo><mfrac><mrow><msup><mi>d</mi><mi>n</mi></msup><mo>+</mo><mrow><mi>d</mi><mo>&minus;</mo><mn>2</mn></mrow></mrow><mrow><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow></mfrac><mo>,</mo><mfrac><mrow><msup><mi>d</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>+</mo><mrow><mi>d</mi><mo>&minus;</mo><mn>2</mn></mrow></mrow><mrow><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow></mfrac><mo stretchy="false">)</mo></mrow><mtext>.</mtext></math>给这闭区间的左右范围乘上<math><mrow><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow></math>, 那么可以得到<math display="block"><mrow><mrow><mo stretchy="false">[</mo><mrow><msup><mi>d</mi><mi>n</mi></msup><mo>+</mo><mrow><mi>d</mi><mo>&minus;</mo><mn>2</mn></mrow></mrow><mo>,</mo><mrow><msup><mi>d</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>&minus;</mo><mn>1</mn></mrow><mo stretchy="false">]</mo></mrow><mo>&sube;</mo><mrow><mo stretchy="false">[</mo><msup><mi>d</mi><mi>n</mi></msup><mo>,</mo><msup><mi>d</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo></mrow></mrow><mtext>,</mtext></math>这暗示了具有<math><mi>k</mi></math>个元素的完全<math><mi>d</mi></math>叉树的高度可以表示为<math display="block"><mrow><mo>&lfloor;</mo><mrow><msub><mi>log</mi><mi>d</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mi>k</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&rfloor;</mo></mrow><mtext>.</mtext></math></p><h2>堆排序</h2><p>堆排序分为两个阶段, 第一阶段自底而上建最大堆, 第二阶段不断地将最大元素和未排序部分的最后一个元素交换 (相当于取出最大元素放在堆的后面), 并仍然需要维护堆的性质.</p><p>自底而上建堆可以被称为Floyd的技巧, 它比起逐个将数组元素加入堆中具有显然的性能优势. 当然了, 另外一个可以被称为Floyd技巧的东西出现在取出堆的优先元素时, 其需要将堆的最后元素放到堆顶, 然后通过下沉维护堆的性质. 既然最后的元素可以想见优先级非常低, 所以说一般而言其会沉到相当深的位置. Floyd的想法是, 不如先将其沉到底部, 然后再上浮, 如此可以减少比较次数. 若比较代价很大, 那么性能提升会比较明显. 不过, 我没有在这里的堆排序里实现后一个Floyd技巧.</p><pre><code>(define (left-child lo k)
  (- (+ (* 2 k) 1) lo))
(define (heap-sort! v lo hi)
  (unless (&lt;= (- hi lo) 1)
    (let iter ((i (quotient (+ lo hi -1) 2)))
      (unless (&lt; i lo)
        (sink! v lo hi i)
        (iter (- i 1))))
    (let iter ((i (- hi 1)))
      (unless (&lt; i lo)
        (vector-swap! v lo i)
        (sink! v lo i lo)
        (iter (- i 1))))))
(define (sink! v lo hi i)
  (let iter ((i i))
    (define l (left-child lo i))
    (unless (>= l hi)
      (define j
        (cond ((>= (+ l 1) hi) l)
              ((&lt; (vector-ref v l)
                  (vector-ref v (+ l 1)))
               (+ l 1))
              (else l)))
      (unless (>= (vector-ref v i)
                  (vector-ref v j))
        (vector-swap! v i j)
        (iter j)))))</code></pre><p>自底而上建堆时, 无需从最后一个元素开始, 因为它们都是叶子, 第一个不是叶子的位置是<code>(quotient (+ lo hi -1) 2)</code>.</p><p>对于<code>(sink! v lo hi i)</code>而言, <code>lo</code>主要是为了确定后继的位置, 而<code>hi</code>当然是为了划定堆的范围.</p><h2>minimax</h2><p>对于两人回合制完美信息零和游戏而言, 形容minimax的最简明扼要的语言大概是<em>事后诸葛</em>. 假设现在我们拥有一个终局评估函数, 其给出了一局游戏的结果, 以数值表示. 例如, 对于<math><mi>A</mi></math>和<math><mi>B</mi></math>参与的一局游戏, 或许<math><mn>0</mn></math>表示<math><mi>B</mi></math>赢, <math><mn>1</mn></math>表示<math><mi>A</mi></math>赢 (假设这种游戏没有平局或者其他终局情况). 那么, 以正常人的角度来看, <math><mi>A</mi></math>肯定是希望最大化终局函数的值, <math><mi>B</mi></math>肯定是希望最小化终局函数的值. 如果我们扩展整个游戏树, 包含所有可能的对局情况, 那么倒着看游戏, 就很容易理解<math><mi>A</mi></math>或者<math><mi>B</mi></math>该采取什么样的策略. 也就是说, 它们都应该采取对于自己最有利的策略. 再换句话说, 假设每个人都下最优的步骤且当前局面下所有步骤的未来结果已知 (也就是一个终局函数的值), 那么<math><mi>A</mi></math>只需要选择最大的一步就行, 而<math><mi>B</mi></math>则需要选择最小的一步. 以这种方式, 我们可以自后往前地构建出对于<math><mi>A</mi></math>和<math><mi>B</mi></math>而言的任何局面下的最佳步骤.</p><h2>红黑树</h2><p>以下是关于红黑树的高度和其元素数目之间关系的实验, 代码可能写得很糟糕, 但是不用在意这种细节问题.</p><pre><code>#lang racket
(require &quot;match.rkt&quot;)
;&lt;rbt> ::= E
;       |  (R &lt;rbt> &lt;val> &lt;rbt>)
;       |  (B &lt;rbt> &lt;val> &lt;rbt>)
(define E 'E)
(define (R a x b) `(R ,a ,x ,b))
(define (B a x b) `(B ,a ,x ,b))
(define (balance s)
  (match s
    ((B (R (R ,a ,x ,b) ,y ,c) ,z ,d)
     (R (B a x b) y (B c z d)))
    ((B (R ,a ,x (R ,b ,y ,c)) ,z ,d)
     (R (B a x b) y (B c z d)))
    ((B ,a ,x (R (R ,b ,y ,c) ,z ,d))
     (R (B a x b) y (B c z d)))
    ((B ,a ,x (R ,b ,y (R ,c ,z ,d)))
     (R (B a x b) y (B c z d)))
    (,else s)))
(define (blacken s)
  (match s
    ((R ,a ,x ,b) (B a x b))
    (,else s)))
(define (insert x s)
  (define (ins s)
    (match s
      ((,c ,a ,y ,b)
       (cond ((&lt; x y)
              (balance `(,c ,(ins a) ,y ,b)))
             ((= x y) s)
             ((> x y)
              (balance `(,c ,a ,y ,(ins b))))))
      (,else (R E x E))))
  (blacken (ins s)))
(define (insert-random s)
  (insert (random) s))
(define (height s)
  (match s
    ((,c ,a ,x ,b)
     (add1 (max (height a) (height b))))
    (,else 0)))
(define (repeated f n)
  (cond ((= n 0) identity)
        ((= n 1) f)
        (else (compose f (repeated f (- n 1))))))
(define (experiment-average thunk n)
  (let iter ((rest n) (sum 0))
    (if (= rest 0)
        (/ sum n)
        (iter (- rest 1) (+ sum (thunk))))))
(define (ex-on-n n)
  (let ((f (repeated insert-random n)))
    (experiment-average
     (lambda ()
       (height (f E)))
     1000.0)))
(define (enum a b)
  (if (> a b)
      '()
      (cons a (enum (+ a 1) b))))
(map (lambda (n)
       (list n (ex-on-n n)))
     (enum 7 63))</code></pre><p>实验结果:</p><pre><code>'((7 3.648)
  (8 4.0)
  (9 4.0)
  (10 4.158)
  (11 4.419)
  (12 4.645)
  (13 4.811)
  (14 4.93)
  (15 5.04)
  (16 5.119)
  (17 5.202)
  (18 5.293)
  (19 5.398)
  (20 5.515)
  (21 5.581)
  (22 5.714)
  (23 5.819)
  (24 5.899)
  (25 5.975)
  (26 6.042)
  (27 6.111)
  (28 6.177)
  (29 6.228)
  (30 6.294)
  (31 6.368)
  (32 6.468)
  (33 6.517)
  (34 6.614)
  (35 6.661)
  (36 6.675)
  (37 6.751)
  (38 6.824)
  (39 6.87)
  (40 6.896)
  (41 6.949)
  (42 6.999)
  (43 7.031)
  (44 7.076)
  (45 7.104)
  (46 7.151)
  (47 7.187)
  (48 7.22)
  (49 7.246)
  (50 7.273)
  (51 7.299)
  (52 7.368)
  (53 7.361)
  (54 7.42)
  (55 7.457)
  (56 7.46)
  (57 7.512)
  (58 7.543)
  (59 7.617)
  (60 7.648)
  (61 7.683)
  (62 7.719)
  (63 7.776))</code></pre><h2>(算法性)图论</h2><p>图论是一个很大的主题, 算法性的图论也是一个很大的主题. 我几乎完全不懂图论, 但是又经常被偶尔用到的图论里的微妙定义折磨. 据我观察, 很少有涉及图论的书能给出完全正确(且一致)的定义.</p><h3>第1节 无向图</h3><p>一个图<math><mi>G</mi></math>是由一个顶点的集合<math><mi>V</mi></math>和一个边的集合<math><mi>E</mi></math>构成的. 对于每条边<math><mrow><mi>e</mi><mo>&in;</mo><mi>E</mi></mrow></math>, 都存在两个(相互之间没有顺序的)顶点<math><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow></math>与之对应. 从直觉上说, 这条边<math><mi>e</mi></math>连接了<math><mi>x</mi></math>和<math><mi>y</mi></math>. 我们并不排除<math><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow></math>的情况, 此时<math><mi>e</mi></math>被称为一个自环 (loop). 一个顶点是孤立的, 如果不存在能够连接到该顶点的边. 一个图是简单的, 如果它没有自环, 也没有两条不同但是却连接了相同顶点的边. 两条非自环的不同边如果连接了相同的顶点, 那么我们就称这两条边是平行的. 非简单的图有时被称为多图 (multigraph). 如果一个图的顶点集合和边集合均为有限的, 那么我们就称这个图是有限的. 基本上我们总是关心有限的图而已.</p><p>顶点之间的连通关系是由边导出的连接关系所生成的等价关系. 连通关系下的等价类被称为连通分量. </p></body></html>