<html><head><meta charset="utf-8"/><title>元对象协议艺术</title><link href="styles.css" rel="stylesheet"/></head><body><h1>元对象协议艺术</h1><h3>引论</h3><p>现代编程语言设计存在于两个看似相互冲突的需求之间的张力中. 一方面, 诸如Scheme, Prolog和ML等高级语言在优雅性和表达能力方面取得了重大进展. 另一方面, 许多工业程序员发现这些语言过于<q>理论化</q>或不切实际, 难以在日常使用中应用, 而且效率低下. 因此, 这些语言往往只在学术和研究环境中使用, 而世界上大多数主流编程是用C和C++等语言进行的, 这些语言因其效率和适应性而著称.</p><p>本书介绍了一种编程语言设计的新方法, 在这种方法中, 优雅性和效率这两个需求被视为相容的, 而非冲突的. 我们的目标是开发出既像最纯粹的理论设计一样简洁, 又在性能或实现控制上不做任何妥协的语言.</p><p>我们实现优雅性和效率相结合的方式是将语言设计建立在<em>元对象协议</em>的基础上. 元对象协议是语言的接口, 它使用户能够增量式地修改语言的行为和实现, 并能够在语言内部编写程序.</p><p>采用元对象协议的语言模糊了语言设计者和语言用户之间的界限. 传统上, 设计者被期望制造具有良定义的固定行为 (或者说<q>语义</q>) 的语言. 用户被期望将这些语言视为不可变的黑盒抽象, 并从构建在其之上的结构中获得所需的灵活性或能力. 这种明确的分工被认为构成了适当的劳动分工. 编程语言设计被视为一门困难的, 高度专业化的艺术, 不适合普通用户参与. 同时也常常假设语言设计必须是刚性的, 以支持可移植的实现, 高效的编译器等等.</p><p>相比之下, 元对象协议方法基于这样的理念: 人们可以而且应该<q>开放语言</q>, 允许用户调整设计和实现以适应他们的特定需求. 换句话说, 鼓励用户参与语言设计过程. 如果处理得当, 开放语言设计不必损害程序的可移植性或实现效率.</p><h2>第I部分 元对象协议的设计和实现</h2><h3>第1章 CLOS是如何实现的</h3><h4>第1.1节 CLOS的一个子集</h4><p>出于教学和(相对)简明的旨趣, 我们选择与CLOS的一个简化子集打交道. 完整CLOS的所有基本特征都有囊括: <em>类(class)</em>, 其从一个类或者多个类继承了结构和行为; 类的<em>实例(instance)</em>, 其可以被创建, 初始化, 和操纵; <em>通用函数(generic function)</em>, 其行为依赖于供给它们的参数的类; <em>方法(method)</em>, 其定义了通用函数特定于类的行为和操作. 我们简化了的方言的主要限制包括:</p><p><b>没有类重定义. </b></p><p><b>没有方法重定义. </b></p><p><b>没有前向引用的超类. </b></p><p><b>显式的通用函数定义. </b></p><p><b>只有标准的方法组合. </b></p><p><b><span>没有<code>eql</code>特化子</span>. </b></p><p><b><span>没有带有<code>:class</code>分配的槽</span>. </b></p><p><b>类型和类并未完全继承. </b></p><p><b>最小的句法糖. </b></p><h4>第1.2节 基本的台面下数据结构</h4><p>就其最简单的语言而言, 一个CLOS程序由<code>defclass</code>, <code>defgeneric</code>, <code>defmethod</code>形式以及与其交织的更为传统的Common Lisp形式构成. 执行这些形式定义了程序的类, 通用函数, 方法.</p><p>在台面下, 这些形式的执行创建了对于类, 通用函数, 方法的内部表示, 记录了其定义中所提供的信息. 实现使用存储于类的内部表示的信息来创建类的实例以及访问(实例的)槽. 存储于通用函数及其方法的内部表示中的信息则用以调用通用函数.</p><p>为了使事情具体化, 考虑以下的示例CLOS程序:<pre><code>(defclass rectangle ()
  ((height :initform 0.0 :initarg :height)
   (width  :initform 0.0 :initarg :width)))

(defclass color-mixin ()
  ((cyan    :initform 0.0 :initarg :cyan)
   (magenta :initform 0.0 :initarg :magenta)
   (yellow  :initform 0.0 :initarg :yellow)))

(defclass color-rectangle (color-mixin rectangle)
  ((clearp :initform (y-or-n-p &quot;But is it transparent?&quot;)
           :initarg :clearp :accessor clearp)))

(defgeneric paint (x))

(defmethod paint ((x rectangle)) ;Method #1
  (vertical-stroke (slot-value x 'height)
                   (slot-value x 'width)))</code></pre></p><h4>第1.3节 表示类</h4><h4>第1.4节 打印对象</h4><h4>第1.5节 表示实例的结构</h4><h4>第1.6节 表示通用函数</h4><h4>第1.7节 表示方法</h4><h4>第1.8节 调用通用函数</h4><h4>第1.9节 关于性能的一些话</h4><h4>第1.10节 总结</h4><h3>第2章 自省与分析</h3><h3>第3章 扩展语言</h3><h3>第4章 协议设计</h3><h2>第II部分 CLOS的一个元对象协议</h2><h3>第5章 概念</h3><h3>第6章 Generic Functions and Methods</h3><h3>附录A CLOS简介</h3><h3>附录B 部分习题解答</h3></body></html>