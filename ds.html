<html><head><meta charset="utf-8"/><title>指称语义学</title><link href="styles.css" rel="stylesheet"/></head><body><h1>指称语义学: 编程语言理论的Scott-Strachey方法</h1><p>本书或许是我人生中接触到的第一本严肃编程语言教科书. 那时我还在读SICP, 已经是2019年的事情了. 虽然我当时迫切想要阅读这本书, 但是完全读不明白, 缺乏动机. 或许现在才是学习这本书籍的好时机, 毕竟和那时比起来, 我已经学了点格论和指称语义了. 这也不是我第一次尝试翻译这本书, 不过先前都浅尝辄止了.</p><h2>前言 (Dana S. Scott所写)</h2><p><b>对于Christopher Strachey和其工作致敬</b></p><p>我们都希望Christopher能够为本书写下这些引言. 他于1975年5月在58岁时英年早逝, 在其亲人, 同事, 学生以及诸多(学术和非学术的)朋友的生活之中留下了永恒的缺憾. 在他于牛津工作的十年间, 自1971年起他拥有个人讲席, 他所在的领域经历了显著的增长和变化, 很大程度上这要归功于他个人的许多原创性想法和他对于别人工作的影响. 出于对于他的工作的认可, 英国计算机协会于1972年授予他成为首批杰出会士之一. {译注: 首批实际上只有两个人, 另外一个是Dijkstra.}</p><p>然而, Strachey自己的发表是不多的, 尽管这并不总是他的问题. </p><p>不论如何, 就我个人而言, Strachey他自己能否写出令人满意的开篇文字也是值得怀疑的. 他的讲课风格时而简洁明快, 时而杂乱无章; 有时晦涩难懂, 有时妙趣横生; 既令人愉悦, 又令人抓狂; 带着讽刺意味, 而且始终高度即兴, 但 (对于那些愿意倾听的人们而言) 一直具有强烈的启发性. 他所能做的, 并且的确在一些场合是这么做的, 是产生一些更短的碎片, 这些碎片极其清晰, 提出了什么是基本的想法和重要的问题, 因为他的独特经历赋予了他特殊的洞察力. </p><h2>第1章 引论</h2><h3>第1.1节 引用透明性</h3><h3>第1.2节 形式语义的目的</h3><h3>第1.3节 句法和语义</h3><h2>第2章 指称语义</h2><h3>第2.1节 形式语义的方法</h3><h4>第2.1.1小节 操作性方法</h4><h4>第2.1.2小节 指称性方法</h4><h4>第2.1.3小节 公理性方法</h4><h3>第2.2节 两种方法的例子</h3><h3>第2.3节 操作性方法的评注</h3><h3>第2.4节 公理性方法的评注</h3><h3>第2.5节 我们的方法的评注</h3><h2>第3章 二进制数码</h2><h3>第3.1节 句法</h3><h3>第3.2节 语义</h3><h3>第3.3节 数码 vs. 数字</h3><h3>第3.4节 良好记号的价值</h3><h3>第3.5节 实现的问题: 加法</h3><h2>第4章 第一级函数</h2><h3>第4.1节 第一级对象和第二级对象</h3><h3>第4.2节 例子: Curry化了的函数</h3><h3>第4.3节 实现</h3><h3>第4.4节 函数, 算法和近似</h3><h2>第5章 <math><mi>&lambda;</mi></math>演算</h2><h3>第5.1节 <math><mi>&lambda;</mi></math>演算</h3><h3>第5.2节 递归定义</h3><h2>第6章 格与domain</h2><p>前一章末的讨论已经指出若要使得我们对于<math><mi>&lambda;</mi></math>演算的语义理论的搜索成功, 那么我们必须找到方法来限制我们所能够考虑的函数类. 否则的话, 函数就会太多, 以至于我们无法找到任何带有同构函数空间的非平凡空间.</p><p>逻辑学家的通常解法是压根不与函数打交道, 转而与函数的表示打交道. 简而言之, 他们取G&ouml;del配数. 他们通常处理整数上的函数, 在这种情况下G&ouml;del配数的运算将可用有限长度算法表达的函数 (其构成了一个可数集) 映射为整数. 当他们想要考虑一个以另外一个函数<math><mi>B</mi></math>作为一个参数的函数<math><mi>A</mi></math>时, 那么他们可以形式化地给<math><mi>A</mi></math>提供<math><mi>B</mi></math>的G&ouml;del配数.</p><p>这种方法在牵涉可判定性的论证中的使用是令人满意的. 这些论证通常具有以下形式: <q>设你声明你有一个可以判定停机问题的函数<math><mi>X</mi></math>; 那么我们可以找到另外一个函数<math><mi>W</mi></math>使得<math><mi>X</mi></math>不能成立.</q></p><h3>第6.1节 近似序</h3><p>我们不使用算法的G&ouml;del配数, 转而采取另外一种方法, 其更关心函数 (或者说映射) 本身. 让我们试着通过检视我们的问题的另一方面 (多不动点问题) 来汲取一点灵感. 考虑递归定义:<pre><code>f = λx. if x = 0 then 1
        else if x = 1 then f(3)
        else f(x-2)</code></pre>我们看出我们是在寻找<pre><code>λf.λx. if x = 0 then 1
       else if x = 1 then f(3)
       else f(x-2)</code></pre>的一个不动点. 我们对于利用递归函数进行计算的实际经验或许会将我们引向以下的解<math display="block"><mrow><mrow><msup><mi>f</mi><mo>&prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mn>1</mn></mtd><mtd columnalign="left"><mo>,</mo><mi>x</mi><mtext>为偶数</mtext></mtd></mtr><mtr><mtd><mi>undefined</mi></mtd><mtd columnalign="left"><mo>,</mo><mi>x</mi><mtext>为奇数</mtext></mtd></mtr></mtable></mrow></mrow></math>但是另外一个解为<math display="block"><mrow><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mn>1</mn></mrow><mtext>, 对于所有的</mtext><mi>x</mi></math>而且以下也是解<math display="block"><mrow><mrow><msub><mi>f</mi><mi>a</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mn>1</mn></mtd><mtd columnalign="left"><mo>,</mo><mi>x</mi><mtext>为偶数</mtext></mtd></mtr><mtr><mtd><mi>a</mi></mtd><mtd columnalign="left"><mo>,</mo><mi>x</mi><mtext>为奇数</mtext></mtd></mtr></mtable></mrow></mrow></math>其中<math><mi>a</mi></math>是一个任意的常量. 为什么<math><msup><mi>f</mi><mo>&prime;</mo></msup></math>是一个计算机实现实际会提供的函数呢?</p><p>答案在于其他的解都包含任意的信息 (即<math><mi>a</mi></math>的值), 这是我们不希望实现所决定的. </p><h3>第6.2节 偏序集</h3><h3>第6.3节 完备格</h3><h3>第6.4节 格上的函数</h3><h3>第6.5节 一个不动点算子</h3><h2>第7章 自反domain</h2><h2>第8章 <math><mi>&lambda;</mi></math>演算的形式语义</h2><h2>第9章 一个简单的流程图语言</h2><h2>第10章 环境和其他扩展</h2><h2>第11章 跳跃和延续</h2><h2>第12章 赋值和存储</h2></body></html>