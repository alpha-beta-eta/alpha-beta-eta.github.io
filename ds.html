<html><head><meta charset="utf-8"/><title>指称语义学</title><link href="styles.css" rel="stylesheet"/></head><body><h1>指称语义学</h1><h2>第1章 引论</h2><h2>第2章 指称语义学</h2><h2>第3章 二进制数码</h2><h2>第4章 第一级函数</h2><h2>第5章 <math><mi>&lambda;</mi></math>演算</h2><h3>第5.1节 <math><mi>&lambda;</mi></math>演算</h3><h3>第5.2节 递归定义</h3><h2>第6章 格与域</h2><p>前一章最后的讨论已经指出如果我们想要成功地找到一个<math><mi>&lambda;</mi></math>演算的语义理论, 那么我们就必须找出一种限制我们能够考虑的函数类的方法. 否则的话, 就太多了而不能找到任何具有同构函数空间的非平凡的空间.</p><p>逻辑学家的通常解决方案是压根不与函数打交道, 换而与函数的表示打交道. 简而言之, 他们用哥德尔配数. 他们通常处理整数上的函数, 在这种情况下哥德尔配数操作将可用有限长度的算法表达的函数 (构成了一个可数集) 映射至整数. 当他们想要考虑以函数<math><mi>B</mi></math>作为参数的函数<math><mi>A</mi></math>时, 他们可以形式化地给<math><mi>A</mi></math>提供<math><mi>B</mi></math>的哥德尔配数.</p><p></p><h3>第6.1节 近似序</h3><p>不使用算法的哥德尔配数, 那么我们将采用另一种方式, 这种方式更加关注于函数或者说映射本身. 让我们通过观察我们的问题的另一方面来获得一点直觉, 即多重不动点的麻烦. 考虑递归函数:<math display="block"><mtable><mtr><mtd><mrow><mi>f</mi><mo>=</mo><mi>&lambda;</mi><mi>x</mi><mo lspace="0" rspace="0">.</mo></mrow></mtd><mtd columnalign="left"><mrow><mtext mathvariant="monospace">if&nbsp;</mtext><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><mtext mathvariant="monospace">&nbsp;then&nbsp;</mtext><mn>1</mn></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd columnalign="left"><mrow><mtext mathvariant="monospace">else if&nbsp;</mtext><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><mtext mathvariant="monospace">&nbsp;then&nbsp;</mtext><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd columnalign="left"><mrow><mtext mathvariant="monospace">else&nbsp;</mtext><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>&minus;</mo><mn>2</mn></mrow><mo stretchy="false">)</mo></mrow></mrow><mtext mathvariant="monospace">.</mtext></mrow></mtd></mtr></mtable></math>我们知道我们在寻找<math display="block"><mtable><mtr><mtd><mrow><mi>&lambda;</mi><mi>f</mi><mo lspace="0" rspace="0">.</mo><mi>&lambda;</mi><mi>x</mi><mo lspace="0" rspace="0">.</mo></mrow></mtd><mtd columnalign="left"><mrow><mtext mathvariant="monospace">if&nbsp;</mtext><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><mtext mathvariant="monospace">&nbsp;then&nbsp;</mtext><mn>1</mn></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd columnalign="left"><mrow><mtext mathvariant="monospace">else if&nbsp;</mtext><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><mtext mathvariant="monospace">&nbsp;then&nbsp;</mtext><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd columnalign="left"><mrow><mtext mathvariant="monospace">else&nbsp;</mtext><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>&minus;</mo><mn>2</mn></mrow><mo stretchy="false">)</mo></mrow></mrow><mtext mathvariant="monospace">.</mtext></mrow></mtd></mtr></mtable></math>的不动点. 我们对于递归函数的实际经验或许会将我们引向解<math display="block"><mrow><mrow><msup><mi>f</mi><mo>&prime;</mo></msup><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mn>1</mn></mtd><mtd columnalign="left"><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mtext mathvariant="monospace">&nbsp;even</mtext></mrow><mo stretchy="false">)</mo></mrow></mtd></mtr><mtr><mtd><mtext mathvariant="monospace">undefined</mtext></mtd><mtd columnalign="left"><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mtext mathvariant="monospace">&nbsp;odd</mtext></mrow><mo stretchy="false">)</mo></mrow></mtd></mtr></mtable></mrow></mrow></math>但是<math display="block"><mrow><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mn>1</mn></mrow></math>或者更一般的<math display="block"><mrow><mrow><msub><mi>f</mi><mi>a</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mn>1</mn></mtd><mtd columnalign="left"><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mtext mathvariant="monospace">&nbsp;even</mtext></mrow><mo stretchy="false">)</mo></mrow></mtd></mtr><mtr><mtd><mi>a</mi></mtd><mtd columnalign="left"><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mtext mathvariant="monospace">&nbsp;odd</mtext></mrow><mo stretchy="false">)</mo></mrow></mtd></mtr></mtable></mrow></mrow></math>也是解, 其中<math><mi>a</mi></math>是任意的常数. 那么为什么<math><msup><mi>f</mi><mo>&prime;</mo></msup></math>是实践中的计算机实现会提供的函数呢?</p><p>答案在于其他的解都包含了我们不希望实现去决定的任意的信息 (<math><mi>a</mi></math>的值). 另一方面, <math><msup><mi>f</mi><mo>&prime;</mo></msup></math>仅包含递归定义实际传达的信息. 它是我们所需要的最小的解, 即包含最少信息量的解. 让我们现在来形式化这个根据信息量对于值进行排序的想法.</p><p>为了看明白这个序是如何运作的, 让我们先来看看一个比函数更简单的值的集合. 考虑一种对于实数进行近似的可能方式, 即闭区间, 记作<math><mrow><mo stretchy="false">[</mo><mrow><munder><mi>x</mi><mo>&UnderBar;</mo></munder><mo>,</mo><mover><mi>x</mi><mo>&OverBar;</mo></mover></mrow><mo stretchy="false">]</mo></mrow></math>其中<math><munder><mi>x</mi><mo>&UnderBar;</mo></munder></math>和<math><mover><mi>x</mi><mo>&OverBar;</mo></mover></math>是实数, 并且<math><mrow><munder><mi>x</mi><mo>&UnderBar;</mo></munder><mo>&le;</mo><mover><mi>x</mi><mo>&OverBar;</mo></mover></mrow></math>. 想法在于绝对精确的值介于这两值之间.</p><p>令<math><mrow><mi>x</mi><mo>=</mo><mrow><mo stretchy="false">[</mo><mrow><munder><mi>x</mi><mo>&UnderBar;</mo></munder><mo>,</mo><mover><mi>x</mi><mo>&OverBar;</mo></mover></mrow><mo stretchy="false">]</mo></mrow></mrow></math>而<math><mrow><mi>y</mi><mo>=</mo><mrow><mo stretchy="false">[</mo><mrow><munder><mi>y</mi><mo>&UnderBar;</mo></munder><mo>,</mo><mover><mi>y</mi><mo>&OverBar;</mo></mover></mrow><mo stretchy="false">]</mo></mrow></mrow></math>. 如果<math><mrow><munder><mi>y</mi><mo>&UnderBar;</mo></munder><mo>&le;</mo><munder><mi>x</mi><mo>&UnderBar;</mo></munder></mrow></math>且<math><mrow><mover><mi>x</mi><mo>&OverBar;</mo></mover><mo>&le;</mo><mover><mi>y</mi><mo>&OverBar;</mo></mover></mrow></math>, 那么<math><mi>x</mi></math>与<math><mi>y</mi></math>一致, 但是更加精确. 我们或许可以将其记作<math><mrow><mi>y</mi><mo>&sqsube;</mo><mi>x</mi></mrow></math>, 意思在于<math><mi>x</mi></math>比<math><mi>y</mi></math>更精确 (或者说至少不更不精确), <math><mi>x</mi></math>比<math><mi>y</mi></math>包含更多 (或者相等) 的信息, 但是<math><mi>x</mi></math>中没有任何会与<math><mi>y</mi></math>相冲突的信息.<svg width="640" height="270" stroke="black" style="display: block; margin: auto;"><defs><marker id="arrow" viewbox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 2 L 6 5 L 0 8 z"/></marker></defs><line x1="260" y1="90" x2="380" y2="90" marker-end="url(#arrow)" marker-start="url(#arrow)" stroke-width="1.2px"/><line x1="140" y1="120" x2="380" y2="120" marker-end="url(#arrow)" marker-start="url(#arrow)" stroke-width="1.2px"/><line x1="260" y1="150" x2="500" y2="150" marker-end="url(#arrow)" marker-start="url(#arrow)" stroke-width="1.2px"/><foreignObject x="236" y="81" width="100" height="30"><math><mi>z</mi></math></foreignObject><foreignObject x="116" y="111" width="100" height="30"><math><mi>y</mi></math></foreignObject><foreignObject x="236" y="141" width="100" height="30"><math><mi>x</mi></math></foreignObject><line x1="260" y1="60" x2="260" y2="180" stroke-width="1.2px" stroke-dasharray="8 4"/><line x1="380" y1="60" x2="380" y2="180" stroke-width="1.2px" stroke-dasharray="8 4"/><line x1="30" y1="210" x2="610" y2="210" stroke-width="1.2px"/><foreignObject x="23" y="216" width="100" height="30"><math><mrow><mo>&minus;</mo><mi>&infin;</mi></mrow></math></foreignObject><foreignObject x="603" y="216" width="100" height="30"><math><mrow><mo>+</mo><mi>&infin;</mi></mrow></math></foreignObject></svg>我们看到在以上图片中, 有<math><mrow><mi>x</mi><mo>&sqsube;</mo><mi>z</mi></mrow></math>和<math><mrow><mi>y</mi><mo>&sqsube;</mo><mi>z</mi></mrow></math>, 但是<math><mi>x</mi></math>和<math><mi>y</mi></math>是不可比较的. 实际上, <math><mi>z</mi></math>是将<math><mi>y</mi></math>和<math><mi>z</mi></math>的所有信息合并了: 我们称<math><mi>z</mi></math>是<math><mi>x</mi></math>和<math><mi>y</mi></math>的最小上界, 记作<math><mrow><mi>z</mi><mo>=</mo><mrow><mi>y</mi><mo>&sqcup;</mo><mi>z</mi></mrow></mrow></math>.</p><p>存在一些特殊的情形. 一种是区间<math><mrow><mo stretchy="false">[</mo><mrow><mrow><mo>&minus;</mo><mi>&infin;</mi></mrow><mo>,</mo><mi>&infin;</mi></mrow><mo stretchy="false">]</mo></mrow></math>, 整个实轴. (?或许应该称为扩展实轴) 这压根就没有给出任何信息, 它比任何其他可能给出的信息都要弱, 我们称其为<math><mi>&bottom;</mi></math>. 另一种特别的情况是包含不一致的信息, 例如<math><mrow><mrow><mo stretchy="false">[</mo><mrow><mn>0</mn><mo>,</mo><mn>1</mn></mrow><mo stretchy="false">]</mo></mrow><mo>&sqcup;</mo><mrow><mo stretchy="false">[</mo><mrow><mn>2</mn><mo>,</mo><mn>3</mn></mrow><mo stretchy="false">]</mo></mrow></mrow></math>, 我们称其为<math><mi>&top;</mi></math>. 因此, <math><mi>&bottom;</mi></math>代表信息的缺失, 而<math><mi>&top;</mi></math>代表信息太多, 以至于产生了矛盾的地步. 其他某些值集可能更容易根据信息进行排序. 例如, 两个真值之间是无法比较的, 于是如果我们添加<math><mi>&bottom;</mi></math>和<math><mi>&top;</mi></math>以代表欠定和过定的真值, 那么我们就得到了下图所呈现的内容.<svg width="640" height="270" stroke="black" style="display: block; margin: auto;"><defs><marker id="arrow" viewbox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 2 L 6 5 L 0 8 z"/></marker></defs><line x1="320" y1="30" x2="200" y2="135" stroke-width="1.2px"/><line x1="320" y1="30" x2="440" y2="135" stroke-width="1.2px"/><line x1="320" y1="240" x2="200" y2="135" stroke-width="1.2px"/><line x1="320" y1="240" x2="440" y2="135" stroke-width="1.2px"/><circle cx="320" cy="30" r="4"/><circle cx="200" cy="135" r="4"/><circle cx="440" cy="135" r="4"/><circle cx="320" cy="240" r="4"/><foreignObject x="313" y="7" width="100" height="30"><math><mi>&top;</mi></math></foreignObject><foreignObject x="150" y="126" width="100" height="30"><math><mtext mathvariant="monospace">false</mtext></math></foreignObject><foreignObject x="448" y="126" width="100" height="30"><math><mtext mathvariant="monospace">true</mtext></math></foreignObject><foreignObject x="313" y="246" width="100" height="30"><math><mi>&bottom;</mi></math></foreignObject></svg></p><h3>第6.2节 偏序集</h3><div class="definition"><b>定义.</b> 一个集合<math><mi>P</mi></math>是在<math><mo>&sqsube;</mo></math>下的偏序集, 如果对于每个<math><mrow><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi></mrow><mo>&in;</mo><mi>P</mi></mrow></math>, 以下性质成立:<ol><li>(自反性) <math><mrow><mi>x</mi><mo>&sqsube;</mo><mi>x</mi></mrow></math>.</li><li>(反对称) <math><mrow><mi>x</mi><mo>&sqsube;</mo><mi>y</mi></mrow></math>且<math><mrow><mi>y</mi><mo>&sqsube;</mo><mi>x</mi></mrow></math>可以推出<math><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow></math>.</li><li>(传递性) <math><mrow><mi>x</mi><mo>&sqsube;</mo><mi>y</mi></mrow></math>且<math><mrow><mi>y</mi><mo>&sqsube;</mo><mi>z</mi></mrow></math>可以推出<math><mrow><mi>x</mi><mo>&sqsube;</mo><mi>z</mi></mrow></math>.</li></ol></div><p>下图呈现了一些例子.<svg width="640" height="270" stroke="black" style="display: block; margin: auto;"><defs><marker id="arrow" viewbox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 2 L 6 5 L 0 8 z"/></marker></defs><circle cx="50" cy="135" r="4"/><foreignObject x="26" y="126" width="100" height="30"><math><mn>0</mn></math></foreignObject><circle cx="50" cy="110" r="4"/><foreignObject x="26" y="101" width="100" height="30"><math><mn>1</mn></math></foreignObject><circle cx="50" cy="85" r="4"/><foreignObject x="26" y="76" width="100" height="30"><math><mn>2</mn></math></foreignObject><circle cx="50" cy="60" r="4"/><foreignObject x="26" y="51" width="100" height="30"><math><mn>3</mn></math></foreignObject><foreignObject x="48" y="27" width="100" height="30"><math><mo>&vellip;</mo></math></foreignObject><circle cx="50" cy="160" r="4"/><foreignObject x="14" y="151" width="100" height="30"><math><mrow><mo>&minus;</mo><mn>1</mn></mrow></math></foreignObject><circle cx="50" cy="185" r="4"/><foreignObject x="14" y="176" width="100" height="30"><math><mrow><mo>&minus;</mo><mn>2</mn></mrow></math></foreignObject><circle cx="50" cy="210" r="4"/><foreignObject x="14" y="201" width="100" height="30"><math><mrow><mo>&minus;</mo><mn>3</mn></mrow></math></foreignObject><foreignObject x="48" y="224" width="100" height="30"><math><mo>&vellip;</mo></math></foreignObject><line x1="50" y1="60" x2="50" y2="210" stroke-width="1.2px"/><foreignObject x="40" y="245" width="100" height="30">(1)</foreignObject><circle cx="100" cy="135" r="4"/><foreignObject x="76" y="126" width="100" height="30"><math><mn>3</mn></math></foreignObject><circle cx="100" cy="110" r="4"/><foreignObject x="76" y="101" width="100" height="30"><math><mn>4</mn></math></foreignObject><circle cx="100" cy="85" r="4"/><foreignObject x="76" y="76" width="100" height="30"><math><mn>5</mn></math></foreignObject><circle cx="100" cy="60" r="4"/><foreignObject x="76" y="51" width="100" height="30"><math><mn>6</mn></math></foreignObject><foreignObject x="98" y="27" width="100" height="30"><math><mo>&vellip;</mo></math></foreignObject><circle cx="100" cy="160" r="4"/><foreignObject x="76" y="151" width="100" height="30"><math><mn>2</mn></math></foreignObject><circle cx="100" cy="185" r="4"/><foreignObject x="76" y="176" width="100" height="30"><math><mn>1</mn></math></foreignObject><circle cx="100" cy="210" r="4"/><foreignObject x="76" y="201" width="100" height="30"><math><mn>0</mn></math></foreignObject><line x1="100" y1="60" x2="100" y2="210" stroke-width="1.2px"/><foreignObject x="90" y="245" width="100" height="30">(2)</foreignObject><circle cx="240" cy="60" r="4"/><circle cx="180" cy="85" r="4"/><circle cx="300" cy="85" r="4"/><circle cx="180" cy="185" r="4"/><circle cx="300" cy="185" r="4"/><circle cx="240" cy="210" r="4"/><line x1="240" y1="60" x2="180" y2="85" stroke-width="1.2px"/><line x1="240" y1="60" x2="300" y2="85" stroke-width="1.2px"/><line x1="180" y1="85" x2="180" y2="185" stroke-width="1.2px"/><line x1="300" y1="85" x2="300" y2="185" stroke-width="1.2px"/><line x1="240" y1="210" x2="180" y2="185" stroke-width="1.2px"/><line x1="240" y1="210" x2="300" y2="185" stroke-width="1.2px"/><line x1="180" y1="85" x2="300" y2="185" stroke-width="1.2px"/><foreignObject x="236" y="216" width="100" height="30"><math><mn>1</mn></math></foreignObject><foreignObject x="162" y="176" width="100" height="30"><math><mn>3</mn></math></foreignObject><foreignObject x="308" y="176" width="100" height="30"><math><mn>2</mn></math></foreignObject><foreignObject x="162" y="76" width="100" height="30"><math><mn>6</mn></math></foreignObject><foreignObject x="308" y="76" width="100" height="30"><math><mn>4</mn></math></foreignObject><foreignObject x="231" y="37" width="100" height="30"><math><mn>12</mn></math></foreignObject><foreignObject x="230" y="245" width="100" height="30">(3)</foreignObject><circle cx="480" cy="60" r="4"/><circle cx="400" cy="100" r="4"/><circle cx="480" cy="100" r="4"/><circle cx="560" cy="100" r="4"/><circle cx="400" cy="185" r="4"/><circle cx="480" cy="185" r="4"/><circle cx="560" cy="185" r="4"/><circle cx="480" cy="225" r="4"/><line x1="480" y1="225" x2="400" y2="185" stroke-width="1.2px"/><line x1="480" y1="225" x2="480" y2="185" stroke-width="1.2px"/><line x1="480" y1="225" x2="560" y2="185" stroke-width="1.2px"/><line x1="400" y1="185" x2="480" y2="100" stroke-width="1.2px"/><line x1="400" y1="185" x2="560" y2="100" stroke-width="1.2px"/><line x1="480" y1="185" x2="400" y2="100" stroke-width="1.2px"/><line x1="480" y1="185" x2="560" y2="100" stroke-width="1.2px"/><line x1="560" y1="185" x2="400" y2="100" stroke-width="1.2px"/><line x1="560" y1="185" x2="480" y2="100" stroke-width="1.2px"/><line x1="400" y1="100" x2="480" y2="60" stroke-width="1.2px"/><line x1="480" y1="100" x2="480" y2="60" stroke-width="1.2px"/><line x1="560" y1="100" x2="480" y2="60" stroke-width="1.2px"/><foreignObject x="453" y="37" width="100" height="30"><math><mrow><mo stretchy="false">{</mo><mrow><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi></mrow><mo stretchy="false">}</mo></mrow></math></foreignObject><foreignObject x="472" y="231" width="100" height="30"><math><mrow><mo stretchy="false">{</mo><mrow/><mo stretchy="false">}</mo></mrow></math></foreignObject><foreignObject x="366" y="176" width="100" height="30"><math><mrow><mo stretchy="false">{</mo><mi>a</mi><mo stretchy="false">}</mo></mrow></math></foreignObject><foreignObject x="568" y="176" width="100" height="30"><math><mrow><mo stretchy="false">{</mo><mi>c</mi><mo stretchy="false">}</mo></mrow></math></foreignObject><foreignObject x="446" y="176" width="100" height="30"><math><mrow><mo stretchy="false">{</mo><mi>b</mi><mo stretchy="false">}</mo></mrow></math></foreignObject><foreignObject x="354" y="91" width="100" height="30"><math><mrow><mo stretchy="false">{</mo><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow><mo stretchy="false">}</mo></mrow></math></foreignObject><foreignObject x="488" y="91" width="100" height="30"><math><mrow><mo stretchy="false">{</mo><mrow><mi>a</mi><mo>,</mo><mi>c</mi></mrow><mo stretchy="false">}</mo></mrow></math></foreignObject><foreignObject x="568" y="91" width="100" height="30"><math><mrow><mo stretchy="false">{</mo><mrow><mi>a</mi><mo>,</mo><mi>b</mi></mrow><mo stretchy="false">}</mo></mrow></math></foreignObject><foreignObject x="470" y="248" width="100" height="30">(4)</foreignObject></svg><ol><li>整数集, 序为<math><mo>&le;</mo></math>.</li><li>非负整数集, 序为<math><mo>&le;</mo></math>.</li><li><math><mn>12</mn></math>的因子集, 以整除性排序.</li><li>三元素集的幂集, 序为<math><mo>&sube;</mo></math>.</li></ol></p><div class="definition"><b>定义.</b> 对于偏序集<math><mi>P</mi></math>而言, 称其为链, 如果对于任意的<math><mrow><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo>&in;</mo><mi>P</mi></mrow></math>, <math><mrow><mi>x</mi><mo>&sqsube;</mo><mi>y</mi></mrow></math>或者<math><mrow><mi>y</mi><mo>&sqsube;</mo><mi>x</mi></mrow></math>.</div><div class="corollary"><b>推论.</b> 链的每个子集都是链.</div><div class="theorem"><b>定理.</b> 每个非空的有限链<math><mi>P</mi></math>都可以写成<math><mrow><mo stretchy="false">{</mo><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>,</mo><msub><mi>p</mi><mn>2</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>p</mi><mi>n</mi></msub></mrow><mo stretchy="false">}</mo></mrow></math>的形式, 其中当<math><mrow><mi>i</mi><mo>&le;</mo><mi>j</mi></mrow></math>时有<math><mrow><msub><mi>p</mi><mi>i</mi></msub><mo>&sqsube;</mo><msub><mi>p</mi><mi>j</mi></msub></mrow></math>.</div><div class="notation"><b>记号.</b> </div><div class="theorem"><b>定理.</b> 对于任意的<math><mrow><mi>X</mi><mo>&sube;</mo><mi>P</mi></mrow></math>, 至多存在一个<math><mrow><mi>a</mi><mo>&in;</mo><mi>P</mi></mrow></math>使得对于每个<math><mrow><mi>p</mi><mo>&in;</mo><mi>P</mi></mrow></math>, <math><mrow><mi>a</mi><mo>&sqsube;</mo><mi>p</mi></mrow></math>当且仅当<math><mrow><mi>X</mi><mo>&sqsube;</mo><mi>p</mi></mrow></math>. <math><mi>a</mi></math>若存在, 其被称为<math><mi>X</mi></math>的最小上界.</div><h3>第6.3节 完全格</h3><h3>第6.4节 格上的函数</h3><h3>第6.5节 一个不动点算子</h3><h2>第7章 自反域</h2><h2>第8章 <math><mi>&lambda;</mi></math>演算的形式语义</h2></body></html>