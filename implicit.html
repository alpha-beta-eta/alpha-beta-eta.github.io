<html><head><meta charset="utf-8"/><title>隐函数定理</title><link href="styles.css" rel="stylesheet"/></head><body><h1>隐函数定理</h1><h2>第1章 隐函数定理引论</h2><h3>第1.1节 隐函数</h3><p>对于微积分的初学者而言, 函数由诸如<math display="block"><mtable columnalign="left center right" width="100%"><mtr><mtd><mphantom><mtext>(1.1)</mtext></mphantom></mtd><mtd><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mrow><mn>2</mn><mo>&it;</mo><msup><mi>x</mi><mn>2</mn></msup></mrow></mrow><mo>&minus;</mo><mi>x</mi><mo>&minus;</mo><mn>3</mn></mrow></mrow></mtd><mtd><mtext>(1.1)</mtext></mtd></mtr></mtable></math><math display="block"><mtable columnalign="left center right" width="100%"><mtr><mtd><mphantom><mtext>(1.2)</mtext></mphantom></mtd><mtd><mrow><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><msqrt><mrow><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow></msqrt></mrow></mtd><mtd><mtext>(1.2)</mtext></mtd></mtr></mtable></math><math display="block"><mtable columnalign="left center right" width="100%"><mtr><mtd><mphantom><mtext>(1.3)</mtext></mphantom></mtd><mtd><mrow><mrow><mi>h</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>cos</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mn>2</mn><mo>&it;</mo><mi>&pi;</mi><mo>&it;</mo><mi>t</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd><mtext>(1.3)</mtext></mtd></mtr></mtable></math>这样的解析表达式给出. 实际上, 250年前这是L&eacute;onard Euler (1707-1783) 所采取的方法 (见Euler [EB88]):<blockquote>A function of a variable quantity is an analytic expression composed in any way whatsoever of the variable quantity and numbers or constant quantities.</blockquote></p><p>几乎是在同一时间, 有人发现<q>由公式给出函数</q>这一概念对于微积分的目的而言太过具有限制性了. 例如,<math display="block"><mtable columnalign="left center right" width="100%"><mtr><mtd><mphantom><mtext>(1.4)</mtext></mphantom></mtd><mtd><msup><mi>y</mi><mn>5</mn></msup><mo>+</mo><mrow><mn>16</mn><mo>&it;</mo><mi>y</mi></mrow><mo>&minus;</mo><mrow><mn>32</mn><mo>&it;</mo><msup><mi>x</mi><mn>3</mn></msup></mrow><mo>+</mo><mrow><mn>32</mn><mo>&it;</mo><mi>x</mi></mrow><mo>=</mo><mn>0</mn></mtd><mtd><mtext>(1.4)</mtext></mtd></mtr></mtable></math><svg width="320" height="160" stroke="black" style="display: block; margin: auto;"><path x="0" y="0" d="M 0 0 h 320 v 160 h -320 z" fill="none"/><text x="130" y="80">欠一张图</text></svg>的轨迹定义了一个很好的<math><msup><mi>&Ropf;</mi><mn>2</mn></msup></math>的子集, 草绘于图1.1之中. 这个图片 (figure) 让我们怀疑这个轨迹是不是<math><mi>y</mi></math>作为<math><mi>x</mi></math>的函数的图 (graph). 但是, 并没有可以用来描述这个函数的公式存在.</p><p>与将函数当作公式的朴素定义相比, 函数的现代的集合论式的定义基于函数的图 (graph) 陈述. 精确地说, 定义域为<math><mi>X</mi></math>而陪域为<math><mi>Y</mi></math>的一个函数<math><mi>f</mi></math>是笛卡尔积<math display="block"><mrow><mrow><mi>X</mi><mo>&times;</mo><mi>Y</mi></mrow><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow><mo stretchy="false">|</mo><mrow><mrow><mi>x</mi><mo>&in;</mo><mi>X</mi></mrow><mo>,</mo><mrow><mi>y</mi><mo>&in;</mo><mi>Y</mi></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>的一个子集, 其具有性质(i)对于每个<math><mrow><mi>x</mi><mo>&in;</mo><mi>X</mi></mrow></math>, 存在一个元素<math><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi>f</mi></mrow></math>; (ii)如果<math><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi>f</mi></mrow></math>且<math><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mover><mi>y</mi><mo>~</mo></mover></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi>f</mi></mrow></math>, 那么<math><mrow><mi>y</mi><mo>=</mo><mover><mi>y</mi><mo>~</mo></mover></mrow></math>. 在这两个性质成立的情况下, <math><mrow><mi>x</mi><mo>&in;</mo><mi>X</mi></mrow></math>的选择确定了唯一使得<math><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi>f</mi></mrow></math>的<math><mi>y</mi></math>; 藉着唯一性, 我们发现简记<math display="block"><mrow><mi>y</mi><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>以表达<math><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi>f</mi></mrow></math>比较方便.</p><div class="example"><b>例子1.1.1. </b>由(1.4)所定义的轨迹具有这样的性质, 对于<math><mrow><mi>x</mi><mo>&in;</mo><mi>&Ropf;</mi></mrow></math>的每个选择, 都存在唯一的<math><mrow><mi>y</mi><mo>&in;</mo><mi>&Ropf;</mi></mrow></math>使得序对<math><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></math>满足该等式. 因此, 存在一个函数<math><mi>f</mi></math>, 现代意义上的函数, 使得其图<math><mrow><mi>y</mi><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>是(1.4)的轨迹.</div><h3>第1.2节 隐函数定理的一个非正式版本</h3><p>启发式地进行思考, 人们通常期望一个变元的一个方程<math display="block"><mrow><mrow><mi>F</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>c</mi></mrow></math>足够用来确定<math><mi>x</mi></math>的值, 其中<math><mi>c</mi></math>是一个常数 (尽管如此, 存在多于一个但有限多个解也是令人毫不意外的). 当存在两个变元时, 人们期望需要通过两个同时的 (或者说联立的) 方程<math display="block"><mtable columnalign="right center left" displaystyle="true"><mtr><mtd><mrow><mi>F</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mi>c</mi></mtd></mtr><mtr><mtd><mrow><mi>G</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mi>d</mi></mtd></mtr></mtable></math>来确定<math><mi>x</mi></math>和<math><mi>y</mi></math>的值, 其中<math><mi>c</mi></math>和<math><mi>d</mi></math>是常数. 一般情况下, 人们期望着具有<math><mi>m</mi></math>个变元的由<math><mi>m</mi></math>个方程构成的一个方程组<math display="block"><mtable columnalign="left center right" width="100%"><mtr><mtd><mphantom><mtext>(1.6)</mtext></mphantom></mtd><mtd><mtable><mtr><mtd><mrow><msub><mi>F</mi><mn>1</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>x</mi><mi>m</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><msub><mi>c</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd><mrow><msub><mi>F</mi><mn>2</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>x</mi><mi>m</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><msub><mi>c</mi><mn>2</mn></msub></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>&vellip;</mo></mtd><mtd><mrow/></mtd></mtr><mtr><mtd><mrow><msub><mi>F</mi><mi>m</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>x</mi><mi>m</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><msub><mi>c</mi><mi>m</mi></msub></mtd></mtr></mtable></mtd><mtd><mtext>(1.6)</mtext></mtd></mtr></mtable></math>恰好就具有用于确定这些变元的值的合适方程数目, 其中<math><mrow><msub><mi>c</mi><mn>1</mn></msub><mo>,</mo><msub><mi>c</mi><mn>2</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>c</mi><mi>m</mi></msub></mrow></math>是常数. 但是当然了, 我们必须意识到这些方程之间可能存在着冗余. 也就是说, 我们必须验证这个方程组 (或者说系统) 是非退化的&mdash;&mdash;意即一个特定的行列式非零 (does not vanish).</p><p>在(1.6)里的方程均为线性方程的情况下, 我们可以诉诸于线性代数来使得我们的启发式思考精确化 (见任意一本线性代数教科书): 保证(1.6)对于所有常量<math><msub><mi>c</mi><mi>i</mi></msub></math>的值都存在唯一解的充分必要条件是线性方程组的系数矩阵秩为<math><mi>m</mi></math>. {译注: 说白了就是可逆.}</p><p>我们继续启发式地思考: 如果变量的数目比方程的数目多, 即<math display="block"><mtable columnalign="left center right" width="100%"><mtr><mtd><mphantom><mtext>(1.7)</mtext></mphantom></mtd><mtd><mtable><mtr><mtd><mrow><msub><mi>F</mi><mn>1</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><msub><mi>c</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd><mrow><msub><mi>F</mi><mn>2</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><msub><mi>c</mi><mn>2</mn></msub></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>&vellip;</mo></mtd><mtd><mrow/></mtd></mtr><mtr><mtd><mrow><msub><mi>F</mi><mi>m</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><msub><mi>c</mi><mi>m</mi></msub></mtd></mtr></mtable></mtd><mtd><mtext>(1.7)</mtext></mtd></mtr></mtable></math>其中<math><msub><mi>c</mi><mi>i</mi></msub></math>仍然是常量而<math><mrow><mi>n</mi><mo>></mo><mi>m</mi></mrow></math>, 那么我们希望将<math><mrow><mi>n</mi><mo>&minus;</mo><mi>m</mi></mrow></math>个额外变量视为参数. 在线性方程组的情况下, 这又是被理解透彻的: 如果系数矩阵的秩为<math><mi>m</mi></math>, 那么就可以将某<math><mi>m</mi></math>个变量表达为其余<math><mrow><mi>n</mi><mo>&minus;</mo><mi>m</mi></mrow></math>个变量的函数. {译注: 从某种意义上说, 这是通过将自由变元移至等式右侧完成的, 那么此时又变回了之前的良好情形.} 而且, 对于系数矩阵的任意<math><mi>m</mi></math>个独立 (线性无关) 列, 相对应的<math><mi>m</mi></math>个变元可以被表达为其余变元的函数. {译注: 仍然可以这么思考, 将其余变量移至右侧后, 又变回了之前的良好情形. 当然了, 这些线性无关列的选择一般的确是不唯一的.}</p><p>在一般情形下, 与线性情形相对的是, (1.7)这个方程组定义了一个全然任意的<math><msup><mi>&Ropf;</mi><mi>n</mi></msup></math>子集 (如果这些函数都是连续函数, 那么这是一个任意的闭子集). 只有在特殊条件下(1.7)才会定义一个隐函数, 其中<math><mi>m</mi></math>个变量由其余<math><mrow><mi>n</mi><mo>&minus;</mo><mi>m</mi></mrow></math>个变量确定. 隐函数定理的意图在于为我们提供一个强大的方法, 或者一组强大的方法, 用以确保我们之前的启发式想法能够成立.</p><p>隐函数定理根植于微分演算, 而微分演算的基岩是线性近似. 据此, 我们在一个点<math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>,</mo><msub><mi>p</mi><mn>2</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>p</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></math>的一个邻域内工作, 其中(1.7)在点<math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>,</mo><msub><mi>p</mi><mn>2</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>p</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></math>处得到满足, 而(1.7)中的诸函数可以由它们的微分 (differential) 进行线性近似. 我们现在就要以非形式化的语言陈述应函数定理 (之后也会给出更为形式化的说明):<blockquote><b>(Informal) Implicit Function Theorem</b><br/>令(1.7)中的诸函数都是连续可微的. 如果(1.7)在<math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>,</mo><msub><mi>p</mi><mn>2</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>p</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></math>处成立, 并且如果当(1.7)的诸函数被替换为其线性近似时特定的<math><mi>m</mi></math>个变量可以表达为其余<math><mrow><mi>n</mi><mo>&minus;</mo><mi>m</mi></mrow></math>个变量的函数, 那么对于(1.7)本身而言, 在<math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>,</mo><msub><mi>p</mi><mn>2</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>p</mi><mi>n</mi></msub></mrow><mo stretchy="false">)</mo></mrow></math>的一个邻域内, 相同的这<math><mi>m</mi></math>个变量可以定义为其余<math><mrow><mi>n</mi><mo>&minus;</mo><mi>m</mi></mrow></math>个变量的隐函数. 并且, 作为结果的隐函数是连续可微的, 且其导数可以藉由隐式微分进行计算.</blockquote></p><p>让我们来看一个非常简单的例子, 其只有两个变元和一个方程.</p><div class="example"><b>例子1.2.1. </b>考虑<math display="block"><mtable columnalign="left center right" width="100%"><mtr><mtd><mphantom><mtext>(1.8)</mtext></mphantom></mtd><mtd><mrow><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow><mo>=</mo><mn>1</mn></mrow></mtd><mtd><mtext>(1.8)</mtext></mtd></mtr></mtable></math>由(1.8)所定义的轨迹是以原点为中心的半径为<math><mn>1</mn></math>的圆. 对于任意满足(1.8)且<math><mrow><mi>q</mi><mo>&ne;</mo><mn>0</mn></mrow></math>的点<math><mrow><mi>P</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mi>p</mi><mo>,</mo><mi>q</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>, 在其一个合适的邻域内, 我们都可以解这个方程以将<math><mi>y</mi></math>显式表达为<math display="block"><mrow><mi>y</mi><mo>=</mo><mrow><mo>&plusmn;</mo><msqrt><mrow><mn>1</mn><mo>&minus;</mo><msup><mi>x</mi><mn>2</mn></msup></mrow></msqrt></mrow></mrow></math>其中正负号的选取依赖于<math><mi>q</mi></math>是为正还是为负. (类似地, 在<math><mrow><mi>p</mi><mo>&ne;</mo><mn>0</mn></mrow></math>的情况下, 我们可以解这个方程以将<math><mi>x</mi></math>表达为关于<math><mi>y</mi></math>的显式函数.)<br/>隐函数定理的有用性在于我们可以避免显式解出方程. 为采取隐函数定理的观念, 我们对于(1.8)的左侧进行线性近似. 在一个点<math><mrow><mo stretchy="false">(</mo><mrow><mi>p</mi><mo>,</mo><mi>q</mi></mrow><mo stretchy="false">)</mo></mrow></math>的一个邻域内, 一个连续线性可微函数<math><mrow><mi>F</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>由<math display="block"><mrow><mrow><mi>a</mi><mo>&it;</mo><mrow><mi mathvariant="normal">&Delta;</mi><mo>&af;</mo><mi>x</mi></mrow></mrow><mo>+</mo><mrow><mi>b</mi><mo>&it;</mo><mrow><mi mathvariant="normal">&Delta;</mi><mo>&af;</mo><mi>y</mi></mrow></mrow><mo>+</mo><mi>c</mi></mrow></math>所线性近似, 其中<math><mi>a</mi></math>是<math><mrow><mrow><mi>&part;</mi><mo>&af;</mo><mi>F</mi></mrow><mo lspace="0" rspace="0">/</mo><mrow><mi>&part;</mi><mo>&af;</mo><mi>x</mi></mrow></mrow></math>在<math><mi>P</mi></math>处求得的值, <math><mrow><mi mathvariant="normal">&Delta;</mi><mo>&af;</mo><mi>x</mi></mrow></math>是<math><mi>x</mi></math>从<math><mrow><mi>P</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mi>p</mi><mo>,</mo><mi>q</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>到点<math><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></math>的过程中所发生的改变, <math><mi>b</mi></math>是<math><mrow><mrow><mi>&part;</mi><mo>&af;</mo><mi>F</mi></mrow><mo lspace="0" rspace="0">/</mo><mrow><mi>&part;</mi><mo>&af;</mo><mi>y</mi></mrow></mrow></math>在<math><mi>P</mi></math>处求得的值, <math><mrow><mi mathvariant="normal">&Delta;</mi><mo>&af;</mo><mi>y</mi></mrow></math>是<math><mi>y</mi></math>从<math><mrow><mi>P</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mi>p</mi><mo>,</mo><mi>q</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>到点<math><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></math>的过程中所发生的改变, <math><mi>c</mi></math>是<math><mi>F</mi></math>在<math><mi>P</mi></math>处的值. 在这个例子里, <math><mrow><mrow><mi>F</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow></mrow></math>, 即(1.8)的左侧.<br/>我们计算<math display="block"><mrow><mrow><mrow><mfrac><mi>&part;</mi><mrow><mi>&part;</mi><mo>&af;</mo><mi>x</mi></mrow></mfrac><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow><mo stretchy="false">)</mo></mrow></mrow><msub><mo>|</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mi>p</mi><mo>,</mo><mi>q</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></msub></mrow><mo>=</mo><mrow><mn>2</mn><mo>&it;</mo><mi>p</mi></mrow></mrow></math>以及<math display="block"><mrow><mrow><mrow><mfrac><mi>&part;</mi><mrow><mi>&part;</mi><mo>&af;</mo><mi>y</mi></mrow></mfrac><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow><mo stretchy="false">)</mo></mrow></mrow><msub><mo>|</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mi>p</mi><mo>,</mo><mi>q</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></msub></mrow><mo>=</mo><mrow><mn>2</mn><mo>&it;</mo><mi>q</mi></mrow></mrow></math>因此, 在满足(1.8)的点<math><mrow><mi>P</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>的一个邻域内, (1.8)的左侧由<math display="block"><mrow><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mn>2</mn><mo>&it;</mo><mi>p</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>&minus;</mo><mi>p</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mn>2</mn><mo>&it;</mo><mi>q</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>y</mi><mo>&minus;</mo><mi>q</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mn>1</mn></mrow><mo>=</mo><mrow><mrow><mrow><mn>2</mn><mo>&it;</mo><mi>p</mi><mo>&it;</mo><mi>x</mi></mrow><mo>+</mo><mrow><mn>2</mn><mo>&it;</mo><mi>q</mi><mo>&it;</mo><mi>y</mi></mrow></mrow><mo>&minus;</mo><mn>1</mn></mrow></mrow></math>所线性近似. 当我们将(1.8)的左侧替换以其线性近似并进行化简时, 我们就得到了<math display="block"><mtable columnalign="left center right" width="100%"><mtr><mtd><mphantom><mtext>(1.9)</mtext></mphantom></mtd><mtd><mrow><mrow><mrow><mi>p</mi><mo>&it;</mo><mi>x</mi></mrow><mo>+</mo><mrow><mi>q</mi><mo>&it;</mo><mi>y</mi></mrow></mrow><mo>=</mo><mn>1</mn></mrow></mtd><mtd><mtext>(1.9)</mtext></mtd></mtr></mtable></math>其当然是圆在点<math><mi>P</mi></math>处的切线方程.<br/>隐函数定理告诉我们, 每当我们可以对于近似线性方程(1.9)将<math><mi>y</mi></math>解为<math><mi>x</mi></math>的一个函数时, 那么原本的方程(1.8)就定义了<math><mi>y</mi></math>为<math><mi>x</mi></math>的一个隐函数. 显然, 恰当<math><mrow><mi>q</mi><mo>&ne;</mo><mn>0</mn></mrow></math>时我们可以将<math><mi>y</mi></math>作为<math><mi>x</mi></math>的函数解出. </div><h3>第1.3节 隐函数定理范式</h3><h2>第2章 历史</h2><h3>第2.1节 历史性引论</h3><h3>第2.2节 Newton</h3><h2>第3章 基本想法</h2><h2>第4章 应用</h2><h2>第5章 变种和推广</h2></body></html>